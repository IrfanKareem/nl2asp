{
    "name": "NL2CNL Dataset",
    "pairs": [
        {
            "Category": "Definition Const/Compound",
            "CNL": " layer 0 have a width to layer 2.",
            "NL": "There is a width between layers 0 and 2."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": " There is a Init with id A.",
            "NL": "It is possible to find an Init with the id A."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": " There is a layer with value equal to 2. ",
            "NL": "There is a layer with a value of 2."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": " There is a sign with id M. ",
            "NL": "There is a sign with the identifier M."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": " There is a vertex with id A.",
            "NL": "The vertex with the id A is present in the graph."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "1 is start.",
            "NL": "There is a start with the number 1."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "1 is start.",
            "NL": "The first number represents the start."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "10 is maxweight.",
            "NL": "There is a maxweight with the number 10."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "2 is bound.",
            "NL": "There is a bound with the number 2."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "3 is Bound.",
            "NL": "There is a bound for number 3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "3 is vtxbound.",
            "NL": "There is a vtxbound to 3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "4 is bound.",
            "NL": "There is a bound with the number 4."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "4 is edgebound.",
            "NL": "The edgebound is number 4."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A blue is colour.",
            "NL": "The node colour is blue."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A color is one of green, red, yellow.",
            "NL": "The available colors are green, red and yellow."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A color is one of red, green, blue.",
            "NL": "The available colors are red, green and blue."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A cyan is colour. ",
            "NL": "The node colour is colour."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A green is colour.",
            "NL": "The node colour is green."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A levels goes from 1 to 3.",
            "NL": "Assume that there are three levels in a cluster."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a list nil have an Acnt to list 0.",
            "NL": "There is an Acnt with the value Nil, and with a value 0."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A node goes from 1 to 3.",
            "NL": "Assume that there are three nodes in a graph."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A node goes from 1 to 4.",
            "NL": "Assume that there are four vertex in a path."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A node goes from 1 to 6.",
            "NL": "Assume that there are six nodes in a graph."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A node goes from 1 to 6.",
            "NL": "Assume that there are six nodes in a clique."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a obs 0 has an obs_elabel to obs 1 and obs P.",
            "NL": "An obs 0 has an obs_elabel associated with obs 1 and obs P."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a obs 0 has an obs_elabel to obs 4 and obs M.",
            "NL": "An obs 0 has an obs_elabel associated with obs 4 and obs M."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a obs 0 have an obs_elabel to obs 3 and obs M.",
            "NL": "An obs 0 has an obs_elabel associated with obs 3 and obs M."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a obs 1 has an obs_elabel to obs 2 and obs P.",
            "NL": "An obs 1 has an obs_elabel associated with obs 2 and obs P."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a obs 1 has an obs_vlabel to obs P.",
            "NL": "An obs 1 has an obs_vlabel associated with obs P."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a obs 1 have an obs_elabel to obs 0 and obs P.",
            "NL": "An obs 1 has an obs_elabel associated with obs 0 and obs P."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a obs 2 has an obs_elabel to obs 4 and obs M.",
            "NL": "An obs 2 has an obs_elabel associated with obs 4 and obs M."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a obs 3 has an obs_elabel to obs 1 and obs P.",
            "NL": "An obs 3 has an obs_elabel associated with obs 1 and obs P."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a obs 3 has an obs_vlabel to obs P.",
            "NL": "An obs 3 has an obs_vlabel associated with obs P."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a obs 3 have an obs_elabel to obs 2 and obs P.",
            "NL": "An obs 3 has an obs_elabel associated with obs 2 and obs P."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a obs 3 have an obs_elabel to obs 4 and obs P.",
            "NL": "An obs 3 has an obs_elabel associated with obs 4 and obs P."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A parts goes from 1 to 3.",
            "NL": "Assume that there are three parts."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A red is colour. ",
            "NL": "The node colour is red."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A vertex 0 have an edge to vertex X, where X is one of 1, 3, 4.",
            "NL": "There is an edge from vertex 0 to vertex X, where X is either 1, 3, or 4."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a vertex 1 has an edge to vertex X, where X is one of 0, 2.",
            "NL": "There is an edge from vertex 1 to vertex X, where X is either 0 and 2."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a vertex 2 have an edge to vertex 4.",
            "NL": "There is an edge from vertex 2 to vertex 4."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a vertex 3 has an edge to vertex X, where X is one of 1, 2, 4.",
            "NL": "There is an edge from vertex 3 to vertex X, where X is either 1, 2, or 4."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a vertex A has an edge to vertex B.",
            "NL": "There is an edge between a vertex A and a vertex B."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a vertex A has an edge to vertex E.",
            "NL": "There is an edge between a vertex A and a vertex E."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a vertex B has an edge to vertex C.",
            "NL": "There is an edge between a vertex B and a vertex C."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a vertex C has an edge to vertex D.",
            "NL": "There is an edge between a vertex C and a vertex D."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a vertex C have an edge to vertex E.",
            "NL": "There is an edge between a vertex C and a vertex E."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a vertex D has an edge to vertex A.",
            "NL": "There is an edge between a vertex D and a vertex A."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a vertex D have an edge to vertex E.",
            "NL": "There is an edge between a vertex D and a vertex E."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a vertex E has an edge to vertex A.",
            "NL": "There is an edge between a vertex E and a vertex A."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A vertex goes from 1 to 4.",
            "NL": "Assume that there are four vertex in a graph."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A vertex goes from 1 to 4. ",
            "NL": "Assume that there are four vertex in a ham path."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A Vtx goes from 1 to 4. ",
            "NL": "Assume that there are four vertex in a cycle."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A Vtx goes from 1 to 8.",
            "NL": "Assume that there are eight vertex in a set."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A Vtx goes from 1 to 8. ",
            "NL": "Assume that there are eight vertex in a cluster."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A Vtx goes from 1 to 8. ",
            "NL": "Assume that there are eight vertex in a partition."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A yellow is colour.",
            "NL": "The node colour is yellow."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "anna is female.",
            "NL": "The name of the female is Anna."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "female anna has a womanAssignsScore to male john and male luca.",
            "NL": "There is a womanAssignsScore for female Anna that is assigned to male John and male Luca."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "female mary has a womanAssignsScore to male john and male luca.",
            "NL": "There is a womanAssignsScore for female Mary that is assigned to male John and male Luca."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "john is jailed.",
            "NL": "John has been jailed."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "john is male. ",
            "NL": "The name of the male is John."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "layer 0 has an in_layer to layer n1.",
            "NL": "There is an in_layer between layer 0 and layer n1."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "layer 0 have an in_layer to layer n2.",
            "NL": "There is an in_layer between layer 0 and layer n2."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "layer 1 has a width to layer n1.",
            "NL": "There is a width between layers 1 and 1."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "layer 1 have an in_layer to layer n3.",
            "NL": "There is an in_layer between layer 1 and layer n3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "layer n1 have an edge to layer n3.",
            "NL": "There is an in_layer between layer n1 and layer n3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "layer n2 has an edge to layer n3.",
            "NL": "There is an in_layer between layer n2 and layer n3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "luca is jailed.",
            "NL": "Luca has been jailed."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "luca is male.",
            "NL": "The name of the male is Luca."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "male john have an manAssignsScore to female mary and female anna.",
            "NL": "There is a manAssignsScore for male John that is assigned to female mary and female anna."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "male luca have an manAssignsScore to female mary and female anna.",
            "NL": "There is a manAssignsScore for male Luca that is assigned to female mary and female anna."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "mary is female.",
            "NL": "The name of the female is Mary."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 1 edge to node X, where X is one of 2, 5.",
            "NL": "There is an edge from node 1 to node X, where X has one of the values 2, or 5."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 1 has a link to node 2.",
            "NL": "There is a link between node 1 and node 2."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 1 has an edge to node X, where X is one of 2, 5.",
            "NL": "There is an edge between node 1 and node X, where X can be either 2, or 5."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 1 have an edge node X, where X is one of 2, 5.",
            "NL": "There is node 1 has an edge to node X, where X is one of the numbers 2 or 5."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 1 have link Node U, where U is one of 2, 3.",
            "NL": "There is node 1 has a link to node U, where U is one of the numbers 2 or 3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 1 is adjacent to node X, where X is one of 2, 5.",
            "NL": "There is node 1 adjacent to node X, where X is one of the numbers 2 or 5."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 1 is link to Node U, where U is one of 2, 3.",
            "NL": "There is node 1 has link to node X, where X is one of the numbers 2 or 3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 10 have an link to node 11.",
            "NL": "There is a link between node 10 and node 11."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 11 has a link to node 12.",
            "NL": "There is a link between node 11 and node 12."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 12 have an link to node 13.",
            "NL": "There is a link between node 12 and node 13."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 13 has a link to node 14.",
            "NL": "There is a link between node 13 and node 14."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 14 have an link to node 15.",
            "NL": "There is a link between node 14 and node 15."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 15 have an link to node 16.",
            "NL": "There is a link between node 15 and node 16."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 2 edge to node X, where X is one of 3, 5.",
            "NL": "There is an edge from node 2 to node X, where X has one of the values 3, or 5."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 2 has a link to node 3.",
            "NL": "There is a link between node 2 and node 3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 2 have an edge node X, where X is one of 3, 5.",
            "NL": "There is node 2 has an edge to node X, where X is one of the numbers 3 or 5."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 2 have an edge to node X, where X is one of 3, 5.",
            "NL": "There is an edge between node 2 and node X, where X can be either 3, or 5."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 2 have link Node U, where U is one of 1, 3.",
            "NL": "There is node 2 has a link to node U, where U is one of the numbers 1 or 3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 2 is adjacent to node X, where X is one of 3, 5.",
            "NL": "There is node 2 adjacent to node X, where X is one of the numbers 3 or 5."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 2 is link to Node U, where U is one of 1, 3.",
            "NL": "There is node 2 has link to node X, where X is one of the numbers 1 or 3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 3 edge to node 4.",
            "NL": "There is an edge from node 3 to node 4."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 3 has an edge Node 4.",
            "NL": "There is node 3 has an edge to node 4."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 3 has an edge to node 4.",
            "NL": "There is an edge between node 1 and node 4."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 3 have an link to node 4.",
            "NL": "There is a link between node 3 and node 4."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 3 have link Node U, where U is one of 1, 2.",
            "NL": "There is node 3 has a link to node U, where U is one of the numbers 1 or 2."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 3 is adjacent to Node 4.",
            "NL": "There is node 2 adjacent to node 4."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 3 is link to Node U, where U is one of 1, 2.",
            "NL": "There is node 3 has link to node X, where X is one of the numbers 1 or 2."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 4 edge to node X, where X is one of 5, 6.",
            "NL": "There is an edge from node 4 to node X, where X has one of the values 5, or 6."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 4 has a link to node 5.",
            "NL": "There is a link between node 4 and node 5."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 4 has an edge Node 5.",
            "NL": "There is node 4 has an edge to node 5."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 4 have an edge Node 6.",
            "NL": "There is node 4 has an edge to node 6."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 4 have an edge to node X, where X is one of 5, 6.",
            "NL": "There is an edge between node 1 and node X, where X can be either 5, or 6."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 4 is adjacent to Node 5.",
            "NL": "There is node 4 adjacent to node 5."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 5 has a link to node 6.",
            "NL": "There is a link between node 5 and node 6."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 6 has a link to node 8.",
            "NL": "There is a link between node 6 and node 8."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 6 is adjacent to Node 4.",
            "NL": "There is node 6 adjacent to node 4."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 8 has a link to node 9.",
            "NL": "There is a link between node 8 and node 9."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 9 has a link to node 10.",
            "NL": "There is a link between node 9 and node 10."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "There is a sign with id P.",
            "NL": "There is a sign with the identifier P."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "There is a vertex with id B.",
            "NL": "The vertex with the id B is present in the graph."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "There is a vertex with id C.",
            "NL": "The vertex with the id C is present in the graph."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "There is a vertex with id D.",
            "NL": "The vertex with the id D is present in the graph."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "There is a vertex with id E.",
            "NL": "The vertex with the id E is present in the graph."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "There is a weight with value equal to 1.",
            "NL": "There is a weight with a value of 1."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "visit 1 has a road to visit 2.",
            "NL": "There is a road connecting visit 1 with visit 2."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "visit 1 have a start. ",
            "NL": "There is a start with the visit 1."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "visit 2 has a road to visit 3.",
            "NL": "There is a road connecting visit 2 with visit 3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "visit 3 has a road to visit 4.",
            "NL": "There is a road connecting visit 3 with visit 4."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "visit 4 has a road to visit 1.",
            "NL": "There is a road connecting visit 4 with visit 1."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 1 has an edge to Vtx 5.",
            "NL": "There is a vertex 1 has an edge to vertex 5."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 1 has an edgewt to Vtx 4 and weight 3.",
            "NL": "There is an edgewt between vertex 1 and vertex 4 having a weight of 3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 1 have an edge to Vtx 2 and weight 2.",
            "NL": "There is an edge between vertex 1 and vertex 2 with a weight of 2."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 1 have an edge to Vtx X, where X is one of 2, 4, 5.",
            "NL": "There is an edge between vertex 1 and vertex 2, as well as the other vertices 4 and 5."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 1 have an edge to Vtx X, where X is one of 2, 4.",
            "NL": "There is an edge between vertex 1 and vertex X, where X can be either one of 2, 4. "
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 1 have an edgewt to Vtx 2 and weight 2.",
            "NL": "There is an edgewt between vertex 1 and vertex 2 having a weight of 2."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 2 has an edge to Vtx 3 and weight 3.",
            "NL": "There is an edge between vertex 2 and vertex 2 with a weight of 3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 2 has an edge to Vtx 8.",
            "NL": "There is a vertex 2 has an edge to vertex 8."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 2 have an edge to Vtx X, where X is one of 3, 5.",
            "NL": "There is an edge between vertex 2 and vertex 3 as well as vertex 5."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 2 have an edgewt to Vtx 1 and weight 2.",
            "NL": "There is an edgewt between vertex 2 and vertex 1 having a weight of 2."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 2 have an edgewt to Vtx 3 and weight 3.",
            "NL": "There is an edgewt between vertex 2 and vertex 3 having a weight of 3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 3 has an edge to Vtx 1.",
            "NL": "There is an edge between vertex 3 and vertex 1."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 3 has an edge to Vtx X, where X is one of 1, 4, 5, 7.",
            "NL": "There is a vertex 3 has an edge to vertex X, where X is one of numbers 1, 4, 5 and 7."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 3 has an edge to Vtx X, where X is one of 5, 1.",
            "NL": "Vertex 3 has an edge over vertex X, where X is one of the number 5 and 1."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 3 have an edge to Vtx 2.",
            "NL": "There is an edge between vertex 3 and vertex 2. "
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 3 have an edge to Vtx 4 and weight 1.",
            "NL": "There is an edge between vertex 3 and vertex 2 with a weight of 1."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 3 have an edgewt to Vtx 2 and weight 3.",
            "NL": "There is an edgewt between vertex 3 and vertex 2 having a weight of 3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 3 have an edgewt to Vtx 4 and weight 1.",
            "NL": "There is an edgewt between vertex 3 and vertex 4 having a weight of 1."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 4 has an edge to Vtx 1 and weight 3.",
            "NL": "There is an edge between vertex 4 and vertex 2 with a weight of 3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 4 has an edge to Vtx 3.",
            "NL": "There is an edge between vertex 4 and vertex 3. "
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 4 has an edge to Vtx X, where X is one of 2, 3, 5.",
            "NL": "There is an edge between vertex 4 and vertex 2, as well as the other vertices 3 and 5."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 4 has an edgewt to Vtx 1 and weight 3.",
            "NL": "There is an edgewt between vertex 4 and vertex 1 having a weight of 3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 4 have an edge to Vtx 2.",
            "NL": "There is a vertex 4 has an edge to vertex 2."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 4 have an edgewt to Vtx 3 and weight 1.",
            "NL": "There is an edgewt between vertex 4 and vertex 3 having a weight of 1."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 5 has an edge to Vtx X, where X is one of 2, 4.",
            "NL": "There is a vertex 5 has an edge to vertex X, where X is one of numbers 2 or 4."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 5 have an edge to Vtx 3.",
            "NL": "There is an edge between vertex 5 and vertex 3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 5 have an edge to Vtx X, where X is one of 2, 1.",
            "NL": "Vertex 5 has an edge over vertex X, where X is one of the number 2 and 1."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 6 has an edge to Vtx X, where X is one of 5, 1.",
            "NL": "Vertex 6 has an edge over vertex X, where X is one of the number 5 and 1."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 6 have an edge to Vtx X, where X is one of 1, 2, 4, 7.",
            "NL": "There is a vertex 6 has an edge to vertex X, where X is one of numbers 1, 2, 4 and 7."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 7 has an edge to Vtx X, where X is one of 1, 4, 5.",
            "NL": "There is a vertex 7 has an edge to vertex X, where X is one of numbers 1, 2, and 5."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 7 has an edge to Vtx X, where X is one of 6, 5, 4.",
            "NL": "Vertex 7 has an edge over vertex X, where vertex X is one of the following: 6, 5, or 4."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 8 has an edge to Vtx X, where X is one of 1, 4, 5, 7.",
            "NL": "There is a vertex 8 has an edge to vertex X, where X is one of numbers 1, 2, 5 and 7."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 8 has an edge to Vtx X, where X is one of 1, 5, 6.",
            "NL": "Vertex 8 has an edge over vertex X, where vertex X is one of the following: 1, 5, or 6."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": " layer 0 have a width to layer 2.",
            "NL": "There is a width separating layers 0 and 2."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": " layer 0 have a width to layer 2.",
            "NL": "A width exists between layer 0 and layer 2."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": " layer 0 have a width to layer 2.",
            "NL": "Layer 0 and layer 2 are separated by a certain width."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": " layer 0 have a width to layer 2.",
            "NL": "A certain width is maintained between layers 0 and 2."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": " layer 0 have a width to layer 2.",
            "NL": "The distance, or width, between layers 0 and 2 is defined."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": " There is a Init with id A.",
            "NL": "It is possible to locate an Init with the identifier A."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": " There is a Init with id A.",
            "NL": "It is feasible to locate an Init having the identification A."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": " There is a Init with id A.",
            "NL": "It is possible to locate an Initial with the designation A."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": " There is a Init with id A.",
            "NL": "It is feasible to locate an Init that has the identification A."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": " There is a Init with id A.",
            "NL": "It is possible to locate an Init with the identification of A."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": " There is a layer with value equal to 2. ",
            "NL": "A layer having a value of 2 exists."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": " There is a layer with value equal to 2. ",
            "NL": "A value of 2 is present in a layer."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": " There is a layer with value equal to 2. ",
            "NL": "There is a layer having a value of 2."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": " There is a layer with value equal to 2. ",
            "NL": "A layer possessing a value of 2 exists."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": " There is a layer with value equal to 2. ",
            "NL": "A layer of value 2 exists."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": " There is a sign with id M. ",
            "NL": "A sign with the label M is present."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": " There is a sign with id M. ",
            "NL": "A sign with M is present."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": " There is a sign with id M. ",
            "NL": "A sign bearing the label M is present."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": " There is a sign with id M. ",
            "NL": "A sign bearing the identifier M is present."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": " There is a sign with id M. ",
            "NL": "A sign bearing the label M can be found."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": " There is a vertex with id A.",
            "NL": "The graph contains the vertex with the id A."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": " There is a vertex with id A.",
            "NL": "The graph contains a vertex with the id A."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": " There is a vertex with id A.",
            "NL": "There is a vertex in the graph labelled A."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": " There is a vertex with id A.",
            "NL": "The graph contains the vertex identified as A."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": " There is a vertex with id A.",
            "NL": "There is a vertex in the graph labeled A."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "1 is start.",
            "NL": "The number 1 is the beginning."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "1 is start.",
            "NL": "The number 1 marks the beginning."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "1 is start.",
            "NL": "Beginning with the number 1, there is a start."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "1 is start.",
            "NL": "The number 1 is the starting point."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "1 is start.",
            "NL": "The beginning is numbered 1."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "1 is start.",
            "NL": "The beginning is indicated by the first number."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "1 is start.",
            "NL": "The initial number indicates the beginning."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "1 is start.",
            "NL": "The initial figure indicates the beginning."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "1 is start.",
            "NL": "The initial figure signifies the beginning."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "1 is start.",
            "NL": "The initial number denotes the beginning."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "10 is maxweight.",
            "NL": "There is a maxweight set to the number 10."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "10 is maxweight.",
            "NL": "The maximum weight is given by the number 10."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "10 is maxweight.",
            "NL": "There exists a maximum weight of 10."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "10 is maxweight.",
            "NL": "The number 10 represents the maximum weight."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "10 is maxweight.",
            "NL": "A maximum weight has been assigned the number 10."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "2 is bound.",
            "NL": "There is a limit of two."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "2 is bound.",
            "NL": "There is a limit to the number 2."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "2 is bound.",
            "NL": "A limit exists on the number 2."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "2 is bound.",
            "NL": "There is a limit of 2."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "2 is bound.",
            "NL": "A limit exists for the number 2."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "3 is Bound.",
            "NL": "There is a limit for number 3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "3 is Bound.",
            "NL": "The number 3 has a limit."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "3 is Bound.",
            "NL": "A limit exists for number 3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "3 is Bound.",
            "NL": "There is a limit to number 3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "3 is Bound.",
            "NL": "A limit has been set for number 3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "3 is vtxbound.",
            "NL": "The limit is set at 3 for the vtxbound."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "3 is vtxbound.",
            "NL": "The limit for the vtx is set at 3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "3 is vtxbound.",
            "NL": "A limit of 3 is imposed on the vtx."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "3 is vtxbound.",
            "NL": "A limit of 3 is set for the vtx."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "3 is vtxbound.",
            "NL": "5 A limit of 3.5 is imposed on the vtx."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "4 is bound.",
            "NL": "There is a limit of 4."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "4 is bound.",
            "NL": "A limit exists for the number 4."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "4 is bound.",
            "NL": "The number 4 has a limit."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "4 is bound.",
            "NL": "The number 4 is a limit."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "4 is bound.",
            "NL": "A limit is set by the number 4."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "4 is edgebound.",
            "NL": "Edgebound is the fourth one."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "4 is edgebound.",
            "NL": "The number four is the edgebound."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "4 is edgebound.",
            "NL": "The number 4 is edgebound."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "4 is edgebound.",
            "NL": "The number four is the limit of the boundary."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "4 is edgebound.",
            "NL": "Edgebound is fourth in line."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "4 is id7.",
            "NL": "Number 4 has an ID7."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "4 is id7.",
            "NL": "Number 4 has an ID of 7."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "4 is id7.",
            "NL": "Number 4 has an identification number of 7."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "4 is id7.",
            "NL": "The number 4 has an id7."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "4 is id7.",
            "NL": "The number 4 has an ID of 7."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A blue is colour.",
            "NL": "Blue is the color of the node."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A blue is colour.",
            "NL": "The color of this node is blue."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A blue is colour.",
            "NL": "Blue is the designated color of the node."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A blue is colour.",
            "NL": "The node bears a blue color."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A blue is colour.",
            "NL": "The node has been colored blue."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A color is one of green, red, yellow.",
            "NL": "The colors that are available are green, red, and yellow."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A color is one of green, red, yellow.",
            "NL": "The colors on offer are green, red and yellow."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A color is one of green, red, yellow.",
            "NL": "The colors on offer are green, red, and yellow."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A color is one of green, red, yellow.",
            "NL": "The colors that are offered are green, red, and yellow."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A color is one of green, red, yellow.",
            "NL": "The colors offered are green, red, and yellow."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A color is one of red, green, blue.",
            "NL": "The colors that can be chosen are red, green, and blue."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A color is one of red, green, blue.",
            "NL": "The colors that can be chosen are red, green and blue."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A color is one of red, green, blue.",
            "NL": "The colors that are on offer are red, green and blue."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A color is one of red, green, blue.",
            "NL": "The colors on offer are red, green and blue."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A color is one of red, green, blue.",
            "NL": "The colors on offer are red, green, and blue."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A cyan is colour. ",
            "NL": "The color of the node is the same as its hue."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A cyan is colour. ",
            "NL": "The colour of the node is a colour."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A cyan is colour. ",
            "NL": "The colour of the node is a hue."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A cyan is colour. ",
            "NL": "The hue of the node is tinted."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A cyan is colour. ",
            "NL": "The hue of the node is a colour."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A green is colour.",
            "NL": "Green is the color of the node."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A green is colour.",
            "NL": "The color of the node is green."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A green is colour.",
            "NL": "The node exhibits a green color."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A green is colour.",
            "NL": "Green is the assigned color of the node."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A green is colour.",
            "NL": "The node is colored in green."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A levels goes from 1 to 3.",
            "NL": "Assume that there exist three levels within a cluster."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A levels goes from 1 to 3.",
            "NL": "It is assumed that the cluster has three levels."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A levels goes from 1 to 3.",
            "NL": "The presence of three levels can be assumed within the cluster."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A levels goes from 1 to 3.",
            "NL": "Let us consider a cluster with three levels."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A levels goes from 1 to 3.",
            "NL": "Consider a scenario where a cluster comprises three levels."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a list nil has an Acnt to list 0.",
            "NL": "There is an Account with no value and one with a value of 0."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a list nil has an Acnt to list 0.",
            "NL": "There is an Acnt with no value and another with a value of zero."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a list nil has an Acnt to list 0.",
            "NL": "There is an Account that has no value and another with a value of zero."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a list nil has an Acnt to list 0.",
            "NL": "There is an Acnt with no value and another with a value of 0."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a list nil has an Acnt to list 0.",
            "NL": "There is an Account with no value and one with a value of zero."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A node goes from 1 to 3.",
            "NL": "It is assumed that there are three nodes in the graph."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A node goes from 1 to 3.",
            "NL": "Suppose there are three nodes in a graph."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A node goes from 1 to 3.",
            "NL": "Let's suppose there are three nodes in a graph."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A node goes from 1 to 3.",
            "NL": "It is assumed that there are three points in the graph."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A node goes from 1 to 3.",
            "NL": "It is assumed that there are three nodes present in the graph."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A node goes from 1 to 4.",
            "NL": "It is assumed that there are four points along a path."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A node goes from 1 to 4.",
            "NL": "It is assumed that there are four vertices in a path."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A node goes from 1 to 4.",
            "NL": "There are four vertices in a path."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A node goes from 1 to 4.",
            "NL": "It is assumed that there are four points along the path."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A node goes from 1 to 4.",
            "NL": "If there are four vertices in a path,"
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A node goes from 1 to 6.",
            "NL": "It is assumed that the graph contains six nodes."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A node goes from 1 to 6.",
            "NL": "It is assumed that the graph has six nodes."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A node goes from 1 to 6.",
            "NL": "It is assumed that there are six points in the graph."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A node goes from 1 to 6.",
            "NL": "It is assumed that there are six nodes in the graph."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A node goes from 1 to 6.",
            "NL": "Suppose there are six nodes in a graph."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A node goes from 1 to 6.",
            "NL": "It is assumed that there are six members in a clique."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A node goes from 1 to 6.",
            "NL": "It is presumed that there are six members in a clique."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A node goes from 1 to 6.",
            "NL": "It is assumed that there are six members in the clique."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A node goes from 1 to 6.",
            "NL": "It is assumed that the clique consists of six nodes."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A node goes from 1 to 6.",
            "NL": "It is assumed that a clique has six nodes."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a obs 0 has an obs_elabel to obs 4 and obs M.",
            "NL": "Obs 0 has an associated obs_elabel for obs 4 and obs M."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a obs 0 has an obs_elabel to obs 4 and obs M.",
            "NL": "Obs 0 has an obs_elabel associated with obs 4 and obs M."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a obs 0 has an obs_elabel to obs 4 and obs M.",
            "NL": "There is an obs_elabel associated with obs 0, 4, and M."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a obs 0 has an obs_elabel to obs 4 and obs M.",
            "NL": "Obs 0 has an obs_elabel associated with obs 4 and another obs_elabel associated with obs M."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a obs 0 has an obs_elabel to obs 4 and obs M.",
            "NL": "Obs 0 has an obs_elabel associated with obs 4 and another obs_elabel for obs M."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a obs 0 have an obs_elabel to obs 1 and obs P.",
            "NL": "Obs 0 has an obs_elabel linked to obs 1 and another obs P."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a obs 0 have an obs_elabel to obs 1 and obs P.",
            "NL": "Obs 0 has an associated obs_elabel for both obs 1 and obs P."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a obs 0 have an obs_elabel to obs 1 and obs P.",
            "NL": "An observation 0 has an observation label associated with observation 1 and observation P."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a obs 0 have an obs_elabel to obs 1 and obs P.",
            "NL": "Obs 0 has an obs_elabel linked to obs 1 and obs P."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a obs 0 have an obs_elabel to obs 1 and obs P.",
            "NL": "Obs 0 has an obs_elabel connected to obs 1 and obs P."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a obs 0 have an obs_elabel to obs 3 and obs M.",
            "NL": "For obs 0, there is an obs_elabel associated with obs 3 and obs M."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a obs 0 have an obs_elabel to obs 3 and obs M.",
            "NL": "Obs 3 and Obs M have an associated obs_elabel with an Obs 0."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a obs 0 have an obs_elabel to obs 3 and obs M.",
            "NL": "Obs 0 has an obs_elabel associated with obs 3 and obs M."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a obs 0 have an obs_elabel to obs 3 and obs M.",
            "NL": "Obs 0 has an obs_elabel linked to obs 3 and obs M."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a obs 0 have an obs_elabel to obs 3 and obs M.",
            "NL": "Obs 3 and Obs M have Obs 0 associated with them, which has an Obs_elabel."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a obs 1 have an obs_elabel to obs 0 and obs P.",
            "NL": "Obs 0 and Obs P both have an Obs_elabel associated with Obs 1."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a obs 1 have an obs_elabel to obs 0 and obs P.",
            "NL": "Obs 0 and Obs P have an Obs_elabel associated with them that is shared by Obs 1."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a obs 1 have an obs_elabel to obs 0 and obs P.",
            "NL": "Obs 0 and Obs P have an associated obs_elabel with them that belongs to Obs 1."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a obs 1 have an obs_elabel to obs 0 and obs P.",
            "NL": "Obs 0 and Obs P have an Obs_elabel associated with them both by Obs 1."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a obs 1 have an obs_elabel to obs 0 and obs P.",
            "NL": "Obs 0 and Obs P have an Obs_elabel associated with them for Obs 1."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a obs 1 have an obs_elabel to obs 2 and obs P.",
            "NL": "Obs 1 has an obs_elabel linked to both Obs 2 and Obs P."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a obs 1 have an obs_elabel to obs 2 and obs P.",
            "NL": "Obs 1 has an obs_elabel associated with both Obs 2 and Obs P."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a obs 1 have an obs_elabel to obs 2 and obs P.",
            "NL": "Obs 1 has an observation label associated with obs 2 and a different label associated with obs P."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a obs 1 have an obs_elabel to obs 2 and obs P.",
            "NL": "Obs 1 has an associated obs_elabel with obs 2 and another obs_elabel for obs P."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a obs 1 have an obs_elabel to obs 2 and obs P.",
            "NL": "Obs 1 has an associated obs_elabel for both Obs 2 and Obs P."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a obs 1 have an obs_vlabel to obs P.",
            "NL": "Observation 1 has a label associated with it known as Observation P."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a obs 1 have an obs_vlabel to obs P.",
            "NL": "An observation 1 has an observation value label linked to observation P."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a obs 1 have an obs_vlabel to obs P.",
            "NL": "There is an obs_vlabel linked to obs P belonging to obs 1."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a obs 1 have an obs_vlabel to obs P.",
            "NL": "There is an obs_vlabel associated with obs P that belongs to obs 1."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a obs 1 have an obs_vlabel to obs P.",
            "NL": "An observation 1 has a corresponding observation label associated with it."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a obs 2 have an obs_elabel to obs 4 and obs M.",
            "NL": "Obs 2 has an obs_elabel associated with obs 4 and another obs_elabel associated with obs M."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a obs 2 have an obs_elabel to obs 4 and obs M.",
            "NL": "Obs 2 has an obs_elabel connected to obs 4 and obs M."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a obs 2 have an obs_elabel to obs 4 and obs M.",
            "NL": "Obs 2 has an obs_elabel that is associated with both obs 4 and obs M."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a obs 2 have an obs_elabel to obs 4 and obs M.",
            "NL": "Obs 4 and Obs M have an associated observation label with Obs 2."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a obs 2 have an obs_elabel to obs 4 and obs M.",
            "NL": "Obs 2 has an obs_elabel linked to obs 4 and obs M."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a obs 3 has an obs_elabel to obs 1 and obs P.",
            "NL": "An observation label is associated with observation 1 and observation P for observation 3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a obs 3 has an obs_elabel to obs 1 and obs P.",
            "NL": "Obs 3 has an obs_elabel associated with obs 1 and another obs P."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a obs 3 has an obs_elabel to obs 1 and obs P.",
            "NL": "Obs 3 has an obs_elabel associated with both Obs 1 and Obs P."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a obs 3 has an obs_elabel to obs 1 and obs P.",
            "NL": "Obs 3 has an obs_elabel associated with it and with both Obs 1 and Obs P."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a obs 3 has an obs_elabel to obs 1 and obs P.",
            "NL": "Obs 3 has a label associated with both Obs 1 and Obs P."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a obs 3 has an obs_elabel to obs 4 and obs P.",
            "NL": "Obs 3 has an associated obs_elabel with obs 4 and Obs P."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a obs 3 has an obs_elabel to obs 4 and obs P.",
            "NL": "Obs 3 has an obs_elabel connected to obs 4 and obs P."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a obs 3 has an obs_elabel to obs 4 and obs P.",
            "NL": "Obs 3 is linked to Obs 4 and Obs P, both having an obs_elabel associated with them."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a obs 3 has an obs_elabel to obs 4 and obs P.",
            "NL": "Obs 3 has an obs_elabel associated with obs 4 and another obs_elabel connected to obs P."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a obs 3 has an obs_elabel to obs 4 and obs P.",
            "NL": "Obs 3 has an obs_elabel associated with both obs 4 and obs P."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a obs 3 have an obs_elabel to obs 2 and obs P.",
            "NL": "Obs 3 has an obs_elabel linked to obs 2 and obs P."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a obs 3 have an obs_elabel to obs 2 and obs P.",
            "NL": "Obs 3 has an obs_elabel associated with both Obs 2 and Obs P."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a obs 3 have an obs_elabel to obs 2 and obs P.",
            "NL": "Obs 3 has an observation label associated with obs 2 and obs P."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a obs 3 have an obs_elabel to obs 2 and obs P.",
            "NL": "Obs 3 has a corresponding obs_elabel linked to obs 2 and obs P."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a obs 3 have an obs_elabel to obs 2 and obs P.",
            "NL": "Obs 3 has an obs_elabel associated with it and obs 2 and obs P."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a obs 3 have an obs_vlabel to obs P.",
            "NL": "Observation 3 is associated with Observation P through an Observation Vlabel."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a obs 3 have an obs_vlabel to obs P.",
            "NL": "There is a obs_vlabel linked to obs P for an obs 3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a obs 3 have an obs_vlabel to obs P.",
            "NL": "An obs 3 has a label associated with obs P known as an obs_vlabel."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a obs 3 have an obs_vlabel to obs P.",
            "NL": "There is an obs_vlabel linked to obs P that belongs to an obs 3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a obs 3 have an obs_vlabel to obs P.",
            "NL": "An observation 3 has a corresponding observation value label associated with observation point P."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A parts goes from 1 to 3.",
            "NL": "Assuming there are three parts,"
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A parts goes from 1 to 3.",
            "NL": "Assuming there are three parts, let's look at them."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A parts goes from 1 to 3.",
            "NL": "Assuming there are three components,"
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A parts goes from 1 to 3.",
            "NL": "Assuming that there are three components,"
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A parts goes from 1 to 3.",
            "NL": "Assuming there are three parts, let's go over them one by one."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A red is colour. ",
            "NL": "A red color is assigned to the node."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A red is colour. ",
            "NL": "The color of the node is red."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A red is colour. ",
            "NL": "Red is the color of the node."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A red is colour. ",
            "NL": "The node is colored red."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A red is colour. ",
            "NL": "The node displays a red color."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A vertex 0 have an edge to vertex X, where X is one of 1, 3, 4.",
            "NL": "Vertex 0 has an edge that leads to either vertex 1, 3, or 4."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A vertex 0 have an edge to vertex X, where X is one of 1, 3, 4.",
            "NL": "Vertex 0 has a connection to either vertex 1, 3, or 4."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A vertex 0 have an edge to vertex X, where X is one of 1, 3, 4.",
            "NL": "Vertex 0 is connected to vertices 1, 3, or 4 through an edge."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A vertex 0 have an edge to vertex X, where X is one of 1, 3, 4.",
            "NL": "Vertex 0 has an edge to one of the vertices 1, 3, or 4."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A vertex 0 have an edge to vertex X, where X is one of 1, 3, 4.",
            "NL": "Vertex 0 is connected to either vertex 1, 3, or 4 by an edge."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a vertex 1 has an edge to vertex X, where X is one of 0, 2.",
            "NL": "Vertex 1 is connected to either Vertex 0 or Vertex 2."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a vertex 1 has an edge to vertex X, where X is one of 0, 2.",
            "NL": "Vertex 1 has an edge to either vertex 0 or vertex 2."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a vertex 1 has an edge to vertex X, where X is one of 0, 2.",
            "NL": "Vertex 1 has an edge connecting it to either vertex 0 or vertex 2."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a vertex 1 has an edge to vertex X, where X is one of 0, 2.",
            "NL": "There is a connection between vertex 1 and either vertex 0 or vertex 2."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a vertex 1 has an edge to vertex X, where X is one of 0, 2.",
            "NL": "Vertex 1 has an edge that leads to either vertex 0 or vertex 2."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a vertex 2 has an edge to vertex 4.",
            "NL": "Vertex 2 is connected to vertex 4 by an edge."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a vertex 2 has an edge to vertex 4.",
            "NL": "Vertex 2 has an edge connecting to vertex 4."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a vertex 2 has an edge to vertex 4.",
            "NL": "Vertex 2 has an edge leading to vertex 4."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a vertex 2 has an edge to vertex 4.",
            "NL": "Vertex 2 has an edge that leads to vertex 4."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a vertex 2 has an edge to vertex 4.",
            "NL": "Vertex 2 has a path leading to vertex 4."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a vertex 3 has an edge to vertex X, where X is one of 1, 2, 4.",
            "NL": "Vertex 3 has an edge to either vertex 1, 2, or 4."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a vertex 3 has an edge to vertex X, where X is one of 1, 2, 4.",
            "NL": "Vertex 3 has an edge leading to either vertex 1, 2, or 4."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a vertex 3 has an edge to vertex X, where X is one of 1, 2, 4.",
            "NL": "Vertex 3 has an edge that leads to one of the vertices 1, 2, or 4."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a vertex 3 has an edge to vertex X, where X is one of 1, 2, 4.",
            "NL": "Vertex 3 has an edge connecting to one of the vertices 1, 2, or 4."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a vertex 3 has an edge to vertex X, where X is one of 1, 2, 4.",
            "NL": "Vertex 3 has an edge leading to one of the vertices 1, 2, or 4."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a vertex A has an edge to vertex B.",
            "NL": "A vertex A and a vertex B are connected by an edge."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a vertex A has an edge to vertex B.",
            "NL": "There is a connection between vertex A and vertex B."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a vertex A has an edge to vertex B.",
            "NL": "A vertex A and a vertex B have an edge between them."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a vertex A has an edge to vertex B.",
            "NL": "A connection exists between vertex A and vertex B."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a vertex A has an edge to vertex B.",
            "NL": "Vertex A and Vertex B have an edge between them."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a vertex A has an edge to vertex E.",
            "NL": "There is an edge connecting a vertex A to a vertex E."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a vertex A has an edge to vertex E.",
            "NL": "An edge connects vertex A and vertex E."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a vertex A has an edge to vertex E.",
            "NL": "Vertex A and vertex E are linked via an edge."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a vertex A has an edge to vertex E.",
            "NL": "Vertex A is connected to vertex E by an edge."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a vertex A has an edge to vertex E.",
            "NL": "Vertex A shares an edge with vertex E."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a vertex B has an edge to vertex C.",
            "NL": "There is an edge connecting a vertex B and a vertex C."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a vertex B has an edge to vertex C.",
            "NL": "An edge exists connecting vertex B and vertex C."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a vertex B has an edge to vertex C.",
            "NL": "Vertex B and vertex C are connected via an edge."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a vertex B has an edge to vertex C.",
            "NL": "Vertex B is linked to vertex C by an edge."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a vertex B has an edge to vertex C.",
            "NL": "An edge is present between vertex B and vertex C."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a vertex C have an edge to vertex D.",
            "NL": "A connection exists between vertex C and vertex D."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a vertex C have an edge to vertex D.",
            "NL": "A vertex C and a vertex D are connected by an edge."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a vertex C have an edge to vertex D.",
            "NL": "There is a connection between vertex C and vertex D."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a vertex C have an edge to vertex D.",
            "NL": "A vertex C and a vertex D have a shared edge."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a vertex C have an edge to vertex D.",
            "NL": "A vertex C and a vertex D have an edge between them."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a vertex C have an edge to vertex E.",
            "NL": "A connection exists between vertex C and vertex E."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a vertex C have an edge to vertex E.",
            "NL": "There is a connection between vertex C and vertex E."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a vertex C have an edge to vertex E.",
            "NL": "A vertex C and a vertex E are connected by an edge."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a vertex C have an edge to vertex E.",
            "NL": "A vertex C and a vertex E have an edge connecting them."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a vertex C have an edge to vertex E.",
            "NL": "A vertex C and a vertex E have an edge between them."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a vertex D has an edge to vertex A.",
            "NL": "A vertex D and a vertex A have an edge between them."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a vertex D has an edge to vertex A.",
            "NL": "A vertex D and a vertex A are connected by an edge."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a vertex D has an edge to vertex A.",
            "NL": "There is a connection between vertex D and vertex A."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a vertex D has an edge to vertex A.",
            "NL": "The vertices A and D are connected by an edge."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a vertex D has an edge to vertex A.",
            "NL": "A vertex D and a vertex A have an edge connecting them."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a vertex D has an edge to vertex E.",
            "NL": "There is an edge connecting a vertex D to a vertex E."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a vertex D has an edge to vertex E.",
            "NL": "Vertex D and vertex E share an edge."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a vertex D has an edge to vertex E.",
            "NL": "An edge exists between vertex D and vertex E."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a vertex D has an edge to vertex E.",
            "NL": "Vertex D is connected to vertex E through an edge."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a vertex D has an edge to vertex E.",
            "NL": "Vertex D has an edge to vertex E."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a vertex E has an edge to vertex A.",
            "NL": "A vertex E and a vertex A have an edge between them."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a vertex E has an edge to vertex A.",
            "NL": "There is a connection between vertex E and vertex A."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a vertex E has an edge to vertex A.",
            "NL": "A vertex E and a vertex A are connected by an edge."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a vertex E has an edge to vertex A.",
            "NL": "A connection exists between vertex E and vertex A."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "a vertex E has an edge to vertex A.",
            "NL": "A vertex E is connected to a vertex A by an edge."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A vertex goes from 1 to 4.",
            "NL": "It is assumed that there are four vertices in a graph."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A vertex goes from 1 to 4.",
            "NL": "There are four vertices in a graph."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A vertex goes from 1 to 4.",
            "NL": "It is assumed that there are four vertices in the graph."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A vertex goes from 1 to 4.",
            "NL": "There are four vertices in the graph."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A vertex goes from 1 to 4.",
            "NL": "It can be assumed that there are four vertices in a graph."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A vertex goes from 1 to 4. ",
            "NL": "Suppose there are four vertices in a hamiltonian path."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A vertex goes from 1 to 4. ",
            "NL": "It is assumed that there are four vertices in a hamiltonian path."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A vertex goes from 1 to 4. ",
            "NL": "Assuming there are four vertices in a hamiltonian path."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A vertex goes from 1 to 4. ",
            "NL": "Let us suppose that there are four vertices in a hamiltonian path."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A vertex goes from 1 to 4. ",
            "NL": "Let's suppose that there are four points in a hamiltonian cycle."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A Vtx goes from 1 to 4. ",
            "NL": "It is assumed that a cycle has four vertices."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A Vtx goes from 1 to 4. ",
            "NL": "It is assumed that there are four vertices in a cycle."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A Vtx goes from 1 to 4. ",
            "NL": "Assuming there are four vertices in a cycle."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A Vtx goes from 1 to 4. ",
            "NL": "It can be assumed that there are four corners in a circular shape."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A Vtx goes from 1 to 4. ",
            "NL": "It can be assumed that there are four corners in a cycle."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A Vtx goes from 1 to 8.",
            "NL": "It is assumed that there are eight vertices in the set."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A Vtx goes from 1 to 8.",
            "NL": "There are eight vertices in the set."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A Vtx goes from 1 to 8.",
            "NL": "It is assumed that the set has eight vertices."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A Vtx goes from 1 to 8.",
            "NL": "It is assumed that there are eight vertices in a set."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A Vtx goes from 1 to 8.",
            "NL": "It is assumed that the set contains eight vertices."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A Vtx goes from 1 to 8. ",
            "NL": "Let's assume there are eight vertices in a cluster."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A Vtx goes from 1 to 8. ",
            "NL": "It is assumed that the partition has eight vertices."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A Vtx goes from 1 to 8. ",
            "NL": "It is assumed that there are eight vertices in a partition."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A Vtx goes from 1 to 8. ",
            "NL": "It is assumed that there are eight vertices in a division."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A Vtx goes from 1 to 8. ",
            "NL": "Assuming there are eight vertices in a partition."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A Vtx goes from 1 to 8. ",
            "NL": "It is assumed that there are eight vertices in a section."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A Vtx goes from 1 to 8. ",
            "NL": "Suppose a cluster has eight vertices."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A Vtx goes from 1 to 8. ",
            "NL": "The assumption is that there are eight vertices in one cluster."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A Vtx goes from 1 to 8. ",
            "NL": "Let's consider that a cluster is made up of eight vertices."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A Vtx goes from 1 to 8. ",
            "NL": "It's presumed that there are eight vertices within a cluster."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A yellow is colour.",
            "NL": "The node color remains yellow."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A yellow is colour.",
            "NL": "The color of the node is yellow."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A yellow is colour.",
            "NL": "Yellow is the node's color."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A yellow is colour.",
            "NL": "The node exhibits a yellow color."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A yellow is colour.",
            "NL": "The yellow color is attributed to the node."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "anna is female.",
            "NL": "The female's name is Anna."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "anna is female.",
            "NL": "The woman is called Anna."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "anna is female.",
            "NL": "Anna is the name of the female."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "anna is female.",
            "NL": "The lady's name is Anna."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "anna is female.",
            "NL": "The female individual is named Anna."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "edge7 31 have Weighted to edge7 Y, where Y is one of 1, 2, 14, 28.",
            "NL": "The edge7 31 has been assigned a Weight to edge7 Y, with Y being one of the numbers 1, 2, 14, or 28."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "edge7 31 have Weighted to edge7 Y, where Y is one of 1, 2, 14, 28.",
            "NL": "A Weight of 31 is assigned to edge7 Y, which can take on values of 1, 2, 14, or 28."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "edge7 31 have Weighted to edge7 Y, where Y is one of 1, 2, 14, 28.",
            "NL": "The weight of edge7 31 has been assigned to edge7 Y, with Y being one of 1, 2, 14, or 28."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "edge7 31 have Weighted to edge7 Y, where Y is one of 1, 2, 14, 28.",
            "NL": "The edge7 31 has been assigned a Weighted value to edge7 Y, which can be one of the numbers 1, 2, 14, or 28."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "edge7 31 have Weighted to edge7 Y, where Y is one of 1, 2, 14, 28.",
            "NL": "The weight of edge7 31 is assigned to edge7 Y, where Y is one of the numbers 1, 2, 14, or 28."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "female anna has a womanAssignsScore to male john and male luca.",
            "NL": "A Score is assigned to female Anna which is shared between male John and male Luca."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "female anna has a womanAssignsScore to male john and male luca.",
            "NL": "A Score has been assigned to female Anna that is meant for both male John and male Luca."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "female anna has a womanAssignsScore to male john and male luca.",
            "NL": "A Score has been assigned to Anna, a female, for John and Luca, both males."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "female anna has a womanAssignsScore to male john and male luca.",
            "NL": "Anna has a score assigned to her that is also assigned to both John and Luca."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "female anna has a womanAssignsScore to male john and male luca.",
            "NL": "A Score is assigned to Anna, a female, which is also assigned to both John and Luca, males."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "female mary have an womanAssignsScore to male john and male luca.",
            "NL": "A Score has been assigned to Mary, a female, that is meant for both John and Luca, two males."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "female mary have an womanAssignsScore to male john and male luca.",
            "NL": "A score has been assigned to Mary, a female, that is also assigned to John and Luca, both males."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "female mary have an womanAssignsScore to male john and male luca.",
            "NL": "A score has been assigned to Mary, a female, for John and Luca, both males."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "female mary have an womanAssignsScore to male john and male luca.",
            "NL": "A score has been assigned to Mary, a female, and allocated to both John and Luca, males."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "female mary have an womanAssignsScore to male john and male luca.",
            "NL": "John and Luca have both been assigned a Score by a female named Mary."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "field6 5 have Parent field6 34.",
            "NL": "Field6 5 has a parent of field6 34."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "field6 5 have Parent field6 34.",
            "NL": "The Parent of field6 5 is field6 34."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "field6 5 have Parent field6 34.",
            "NL": "Field 6 5 has a parent field of 6 34."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "field6 5 have Parent field6 34.",
            "NL": "Field6 5 has a parent field6 34."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "field6 5 have Parent field6 34.",
            "NL": "Field6 5 is the parent of field6 34."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "john is jailed.",
            "NL": "John has been put in prison."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "john is jailed.",
            "NL": "John is in jail."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "john is jailed.",
            "NL": "John has been incarcerated."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "john is jailed.",
            "NL": "John has been imprisoned."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "john is jailed.",
            "NL": "John is in prison."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "john is male. ",
            "NL": "The name John belongs to the male."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "john is male. ",
            "NL": "The man's name is John."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "john is male. ",
            "NL": "John is the name of the man."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "john is male. ",
            "NL": "The gentleman is named John."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "john is male. ",
            "NL": "The male in question is called John."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "key5 9 have Couple to key5 7. ",
            "NL": "There is a relationship between key5 9 and key5 7."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "key5 9 have Couple to key5 7. ",
            "NL": "There is a connection between key5 9 and key5 7."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "key5 9 have Couple to key5 7. ",
            "NL": "A connection exists between key5 9 and key5 7."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "key5 9 have Couple to key5 7. ",
            "NL": "The relationship between key5 9 and key5 7 is a pair."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "key5 9 have Couple to key5 7. ",
            "NL": "A relationship exists between key5 9 and key5 7."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "layer 0 has an in_layer to layer n2.",
            "NL": "There is also an in_layer positioned between layer 0 and layer n2."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "layer 0 has an in_layer to layer n2.",
            "NL": "An in_layer exists between layer 0 and layer n2."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "layer 0 has an in_layer to layer n2.",
            "NL": "Layer 0 and layer n2 have an in_layer between them."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "layer 0 has an in_layer to layer n2.",
            "NL": "An in_layer is present between layer 0 and layer n2."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "layer 0 has an in_layer to layer n2.",
            "NL": "There's a designated in_layer situated between layer 0 and layer n2."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "layer 0 have an in_layer to layer n1.",
            "NL": "There is an intervening layer between layer 0 and layer n1."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "layer 0 have an in_layer to layer n1.",
            "NL": "There is an intermediary layer between layer 0 and layer n1."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "layer 0 have an in_layer to layer n1.",
            "NL": "There is an interlayer between layer 0 and layer n1."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "layer 0 have an in_layer to layer n1.",
            "NL": "There is an intermediate layer between layer 0 and layer n1."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "layer 0 have an in_layer to layer n1.",
            "NL": "A barrier exists between layer 0 and layer n1."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "layer 1 has an in_layer to layer n3.",
            "NL": "There is an intervening layer between Layer 1 and Layer n3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "layer 1 has an in_layer to layer n3.",
            "NL": "There is an intermediate layer between Layer 1 and Layer n3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "layer 1 has an in_layer to layer n3.",
            "NL": "There is an intermediary layer between Layer 1 and Layer n3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "layer 1 has an in_layer to layer n3.",
            "NL": "A layer of insulation exists between layer 1 and layer n3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "layer 1 has an in_layer to layer n3.",
            "NL": "There is a layer in between Layer 1 and Layer n3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "layer 1 have a width to layer n1.",
            "NL": "There is a gap between layers 1 and 2."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "layer 1 have a width to layer n1.",
            "NL": "The gap between layers 1 and 1 is wide."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "layer 1 have a width to layer n1.",
            "NL": "There is a spacing between layers 1 and 2."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "layer 1 have a width to layer n1.",
            "NL": "5 There is a gap between layers 1 and 1.5."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "layer 1 have a width to layer n1.",
            "NL": "The space between layers 1 and 1 is wide."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "layer n1 have an edge to layer n3.",
            "NL": "There is an in_layer linking layer n1 and layer n3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "layer n1 have an edge to layer n3.",
            "NL": "An in_layer is situated between layer n1 and layer n3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "layer n1 have an edge to layer n3.",
            "NL": "Layer n1 and layer n3 have an in_layer in between."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "layer n1 have an edge to layer n3.",
            "NL": "There's an in_layer that separates layer n1 from layer n3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "layer n1 have an edge to layer n3.",
            "NL": "Layer n1 and layer n3 are divided by an in_layer."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "layer n2 have an edge to layer n3.",
            "NL": "There is an in_layer connecting layer n2 and layer n3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "layer n2 have an edge to layer n3.",
            "NL": "An in_layer exists between layer n2 and layer n3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "layer n2 have an edge to layer n3.",
            "NL": "Layer n2 and layer n3 have an in_layer between them."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "layer n2 have an edge to layer n3.",
            "NL": "There's an in_layer separating layer n2 from layer n3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "layer n2 have an edge to layer n3.",
            "NL": "An in_layer is present between layer n2 and layer n3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "luca is jailed.",
            "NL": "Luca has been put in prison."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "luca is jailed.",
            "NL": "Luca has been imprisoned."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "luca is jailed.",
            "NL": "Luca has been put in jail."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "luca is jailed.",
            "NL": "Luca is in jail."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "luca is jailed.",
            "NL": "Luca has been incarcerated."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "luca is male.",
            "NL": "Luca is the name of the male."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "luca is male.",
            "NL": "Luca is the man's name."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "luca is male.",
            "NL": "The name given to the male is Luca."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "luca is male.",
            "NL": "The gentleman is referred to as Luca."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "luca is male.",
            "NL": "The man is called Luca."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "M edge3 has a Diameter to O key2 and O value3.",
            "NL": "The Diameter of M edge3 is assigned to the O key2 and O value3 pair."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "M edge3 has a Diameter to O key2 and O value3.",
            "NL": "The M edge3 has a Diameter that is assigned to the O key2 and O value3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "M edge3 has a Diameter to O key2 and O value3.",
            "NL": "The Diameter of M edge3 is assigned to both the O key2 and O value3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "M edge3 has a Diameter to O key2 and O value3.",
            "NL": "The M edge3 has a Diameter assigned to it with a O key2 and O value3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "M edge3 has a Diameter to O key2 and O value3.",
            "NL": "The Diameter of M edge3 is assigned to both O key2 and O value3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "male john has a manAssignsScore to female mary and female anna.",
            "NL": "John has been assigned a score that is specifically for males and is shared between Mary and Anna."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "male john has a manAssignsScore to female mary and female anna.",
            "NL": "A score has been assigned to male John that is shared by both female Mary and Anna."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "male john has a manAssignsScore to female mary and female anna.",
            "NL": "John has been assigned a score for Mary and Anna, both of whom are female."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "male john has a manAssignsScore to female mary and female anna.",
            "NL": "John has been assigned a score for male that Mary and Anna both share."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "male john has a manAssignsScore to female mary and female anna.",
            "NL": "John has been assigned a score for Mary and Anna, both female."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "male luca has a manAssignsScore to female mary and female anna.",
            "NL": "Luca, a male, has been assigned ScoreAssigns to Mary and Anna, both females."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "male luca has a manAssignsScore to female mary and female anna.",
            "NL": "Luca has been assigned a score for Mary and Anna, both of whom are female."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "male luca has a manAssignsScore to female mary and female anna.",
            "NL": "Luca has been assigned a score by a man which is shared between Mary and Anna."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "male luca has a manAssignsScore to female mary and female anna.",
            "NL": "Luca has been assigned a score by a man which is applicable to both Mary and Anna."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "male luca has a manAssignsScore to female mary and female anna.",
            "NL": "Luca has been assigned a score by a man for Mary and Anna, both female."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "mary is female.",
            "NL": "The female's name is Mary."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "mary is female.",
            "NL": "The woman's name is Mary."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "mary is female.",
            "NL": "The female individual goes by the name Mary."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "mary is female.",
            "NL": "The name assigned to the female is Mary."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "mary is female.",
            "NL": "The lady is known as Mary."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 1 edge to node X, where X is one of 2, 5.",
            "NL": "Node 1 has an edge to either node 2 or node 5."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 1 edge to node X, where X is one of 2, 5.",
            "NL": "Node 1 has an edge that leads to either node 2 or node 5."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 1 edge to node X, where X is one of 2, 5.",
            "NL": "Node 1 has an edge leading to either node 2 or node 5."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 1 edge to node X, where X is one of 2, 5.",
            "NL": "A connection exists from node 1 to either node 2 or node 5."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 1 edge to node X, where X is one of 2, 5.",
            "NL": "Node 1 is connected to either node 2 or node 5."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 1 has an edge node X, where X is one of 2, 5.",
            "NL": "Node 1 has an edge to either node 2 or node 5."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 1 has an edge node X, where X is one of 2, 5.",
            "NL": "Node 1 is connected to either node 2 or node 5."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 1 has an edge node X, where X is one of 2, 5.",
            "NL": "Node 1 has a connection to either node 2 or node 5."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 1 has an edge node X, where X is one of 2, 5.",
            "NL": "Node 1 has an edge connected to either node 2 or node 5."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 1 has an edge node X, where X is one of 2, 5.",
            "NL": "Node 1 has an edge that connects it to either node 2 or node 5."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 1 have an edge to node X, where X is one of 2, 5.",
            "NL": "Node 1 has an edge to either node 2 or node 5."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 1 have an edge to node X, where X is one of 2, 5.",
            "NL": "Node 1 has a connection to either node 2 or node 5."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 1 have an edge to node X, where X is one of 2, 5.",
            "NL": "A connection exists between node 1 and either node 2 or node 5."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 1 have an edge to node X, where X is one of 2, 5.",
            "NL": "Node 1 has an edge that connects it to either node 2 or node 5."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 1 have an edge to node X, where X is one of 2, 5.",
            "NL": "Node 1 is connected to either node 2 or node 5 at the edge."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 1 have an link to node 2.",
            "NL": "A connection exists between node 1 and node 2."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 1 have an link to node 2.",
            "NL": "Node 1 is connected to Node 2."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 1 have an link to node 2.",
            "NL": "There is an association between node 1 and node 2."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 1 have an link to node 2.",
            "NL": "Node 1 and node 2 are connected."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 1 have an link to node 2.",
            "NL": "There is a connection between node 1 and node 2."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 1 have link Node U, where U is one of 2, 3.",
            "NL": "Node 1 has a connection to either node 2 or node 3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 1 have link Node U, where U is one of 2, 3.",
            "NL": "Node 1 is connected to either node 2 or node 3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 1 have link Node U, where U is one of 2, 3.",
            "NL": "Node 1 has a link to either node 2 or node 3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 1 have link Node U, where U is one of 2, 3.",
            "NL": "Node 1 is connected to either node 2 or 3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 1 have link Node U, where U is one of 2, 3.",
            "NL": "Node 1 is linked to either node 2 or node 3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 1 is adjacent to node X, where X is one of 2, 5.",
            "NL": "Node X is adjacent to node 1, where X is either 2 or 5."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 1 is adjacent to node X, where X is one of 2, 5.",
            "NL": "Node X, which can be either 2 or 5, has node 1 as its neighbor."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 1 is adjacent to node X, where X is one of 2, 5.",
            "NL": "Node X is adjacent to node 1, with X being either 2 or 5."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 1 is adjacent to node X, where X is one of 2, 5.",
            "NL": "Node X, which can be either 2 or 5, has a node 1 adjacent to it."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 1 is adjacent to node X, where X is one of 2, 5.",
            "NL": "Node X, which is either 2 or 5, is adjacent to node 1."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 1 is link to Node U, where U is one of 2, 3.",
            "NL": "There is node 1 with a link to either node 2 or node 3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 1 is link to Node U, where U is one of 2, 3.",
            "NL": "Node 1 is linked to Node X, where X can be either 2 or 3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 1 is link to Node U, where U is one of 2, 3.",
            "NL": "There exists a link from Node 1 to Node X, where X is 2 or 3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 1 is link to Node U, where U is one of 2, 3.",
            "NL": "A link connects Node 1 to Node X, where X represents 2 or 3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 1 is link to Node U, where U is one of 2, 3.",
            "NL": "Node 1 has a connection to Node X, where X can be defined as either 2 or 3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 10 has a link to node 11.",
            "NL": "There is a connection established between node 10 and node 11."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 10 has a link to node 11.",
            "NL": "A connection exists between node 10 and node 11."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 10 has a link to node 11.",
            "NL": "Node 10 and node 11 share a link."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 10 has a link to node 11.",
            "NL": "Node 10 is linked with node 11."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 10 has a link to node 11.",
            "NL": "There's a link connecting node 10 and node 11."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 11 has a link to node 12.",
            "NL": "A link is established between node 11 and node 12."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 11 has a link to node 12.",
            "NL": "Node 11 and node 12 are connected via a link."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 11 has a link to node 12.",
            "NL": "A link connects node 11 and node 12."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 11 has a link to node 12.",
            "NL": "Node 11 is linked to node 12."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 11 has a link to node 12.",
            "NL": "Node 11 has a link to node 12."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 12 has a link to node 13.",
            "NL": "Node 12 is connected to node 13."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 12 has a link to node 13.",
            "NL": "A connection exists between node 12 and node 13."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 12 has a link to node 13.",
            "NL": "Node 12 has a connection to Node 13."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 12 has a link to node 13.",
            "NL": "There is a connection between node 12 and node 13."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 12 has a link to node 13.",
            "NL": "Node 12 and node 13 are connected."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 13 has a link to node 14.",
            "NL": "A link is established between node 13 and node 14."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 13 has a link to node 14.",
            "NL": "A link connects node 13 and node 14."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 13 has a link to node 14.",
            "NL": "There's a connection between node 13 and node 14."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 13 has a link to node 14.",
            "NL": "Node 13 and node 14 share a link."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 13 has a link to node 14.",
            "NL": "Node 13 has a link to node 14."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 14 has a link to node 15.",
            "NL": "Node 14 and node 15 are connected."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 14 has a link to node 15.",
            "NL": "A connection exists between node 14 and node 15."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 14 has a link to node 15.",
            "NL": "Node 14 is connected to node 15."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 14 has a link to node 15.",
            "NL": "There is a connection between node 14 and node 15."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 14 has a link to node 15.",
            "NL": "Node 14 and node 15 have a connection."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 15 has a link to node 16.",
            "NL": "There is a link connecting node 15 and node 16."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 15 has a link to node 16.",
            "NL": "A link exists between node 15 and node 16."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 15 has a link to node 16.",
            "NL": "Node 15 and node 16 are connected by a link."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 15 has a link to node 16.",
            "NL": "Node 15 has a link to node 16."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 15 has a link to node 16.",
            "NL": "There's a connection from node 15 to node 16"
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 2 edge to node X, where X is one of 3, 5.",
            "NL": "Node 2 has an edge that leads to either node 3 or node 5."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 2 edge to node X, where X is one of 3, 5.",
            "NL": "Node 2 has an edge to either node 3 or node 5."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 2 edge to node X, where X is one of 3, 5.",
            "NL": "Node 2 is connected to either node 3 or node 5."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 2 edge to node X, where X is one of 3, 5.",
            "NL": "A connection exists from node 2 to either node 3 or node 5."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 2 edge to node X, where X is one of 3, 5.",
            "NL": "Node X can be connected to node 2 with an edge, and X can be either 3 or 5."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 2 has a link to node 3.",
            "NL": "A link is established between node 2 and node 3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 2 has a link to node 3.",
            "NL": "A link exists between node 2 and node 3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 2 has a link to node 3.",
            "NL": "There's a connection from node 2 to node 3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 2 has a link to node 3.",
            "NL": "Node 2 and node 3 are connected by a link."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 2 has a link to node 3.",
            "NL": "Node 2 has a link to node 3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 2 have an edge node X, where X is one of 3, 5.",
            "NL": "Node 2 has an edge to either node 3 or node 5."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 2 have an edge node X, where X is one of 3, 5.",
            "NL": "Node 2 has an edge connecting it to either node 3 or node 5."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 2 have an edge node X, where X is one of 3, 5.",
            "NL": "Node 2 has an edge that connects it to either node 3 or node 5."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 2 have an edge node X, where X is one of 3, 5.",
            "NL": "Node 2 is connected to either node 3 or node 5."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 2 have an edge node X, where X is one of 3, 5.",
            "NL": "Node 2 has an edge that connects to either node 3 or node 5."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 2 have an edge to node X, where X is one of 3, 5.",
            "NL": "Node 2 has an edge to either node 3 or node 5."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 2 have an edge to node X, where X is one of 3, 5.",
            "NL": "A connection exists between node 2 and either node 3 or node 5."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 2 have an edge to node X, where X is one of 3, 5.",
            "NL": "Node 2 has a connection to either node 3 or node 5."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 2 have an edge to node X, where X is one of 3, 5.",
            "NL": "Node 2 is connected to either node 3 or node 5."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 2 have an edge to node X, where X is one of 3, 5.",
            "NL": "Node 2 has an edge connecting it to either node 3 or node 5."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 2 have link Node U, where U is one of 1, 3.",
            "NL": "Node 2 has a connection to either node 1 or node 3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 2 have link Node U, where U is one of 1, 3.",
            "NL": "Node 2 is connected to either node 1 or node 3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 2 have link Node U, where U is one of 1, 3.",
            "NL": "Node 2 is linked to either node 1 or node 3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 2 have link Node U, where U is one of 1, 3.",
            "NL": "Node U, which is either 1 or 3, is linked to node 2."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 2 have link Node U, where U is one of 1, 3.",
            "NL": "Node U, being one of the numbers 1 or 3, is linked to node 2."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 2 is adjacent to node X, where X is one of 3, 5.",
            "NL": "Node X, either 3 or 5, has a neighboring node 2."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 2 is adjacent to node X, where X is one of 3, 5.",
            "NL": "Node X, one of either 3 or 5, has a neighboring node 2."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 2 is adjacent to node X, where X is one of 3, 5.",
            "NL": "Node X, which is either 3 or 5, has node 2 adjacent to it."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 2 is adjacent to node X, where X is one of 3, 5.",
            "NL": "Node X, either 3 or 5, has a node 2 next to it."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 2 is adjacent to node X, where X is one of 3, 5.",
            "NL": "Node X has node 2 next to it, with X being either 3 or 5."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 2 is link to Node U, where U is one of 1, 3.",
            "NL": "Node 2 is connected to either node 1 or node 3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 2 is link to Node U, where U is one of 1, 3.",
            "NL": "Node 2 has a connection to either node 1 or node 3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 2 is link to Node U, where U is one of 1, 3.",
            "NL": "Node 2 has a link to either node 1 or node 3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 2 is link to Node U, where U is one of 1, 3.",
            "NL": "Node X, which can be either 1 or 3, is connected to node 2."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 2 is link to Node U, where U is one of 1, 3.",
            "NL": "Node 2 is linked to either node 1 or node 3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 3 edge to node 4.",
            "NL": "There is a connection from node 3 to node 4."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 3 edge to node 4.",
            "NL": "Node 3 has an edge leading to node 4."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 3 edge to node 4.",
            "NL": "A connection exists between node 3 and node 4."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 3 edge to node 4.",
            "NL": "Node 3 has a connection to Node 4."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 3 edge to node 4.",
            "NL": "Node 3 has an edge to Node 4."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 3 has an edge Node 4.",
            "NL": "Node 3 has a connection to node 4."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 3 has an edge Node 4.",
            "NL": "Node 3 has an edge connecting to node 4."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 3 has an edge Node 4.",
            "NL": "Node 3 is connected to node 4."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 3 has an edge Node 4.",
            "NL": "There is an edge connecting node 3 to node 4."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 3 has an edge Node 4.",
            "NL": "Node 3 has an edge connecting it to node 4."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 3 have an edge to node 4.",
            "NL": "A connection exists between node 1 and node 4."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 3 have an edge to node 4.",
            "NL": "Node 1 and node 4 are connected by an edge."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 3 have an edge to node 4.",
            "NL": "Node 1 and node 4 have an edge between them."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 3 have an edge to node 4.",
            "NL": "There is a connection between node 1 and node 4."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 3 have an edge to node 4.",
            "NL": "Node 1 and node 4 have a connection."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 3 have an link to node 4.",
            "NL": "There is also a link connecting node 3 and node 4."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 3 have an link to node 4.",
            "NL": "There's a connection between node 3 and node 4."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 3 have an link to node 4.",
            "NL": "A link connects node 3 and node 4."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 3 have an link to node 4.",
            "NL": "Node 3 has a link with node 4."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 3 have an link to node 4.",
            "NL": "Node 3 is connected to node 4 through a link."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 3 have link Node U, where U is one of 1, 2.",
            "NL": "Node 3 is connected to either node 1 or node 2."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 3 have link Node U, where U is one of 1, 2.",
            "NL": "Node 3 has a connection to either node 1 or node 2."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 3 have link Node U, where U is one of 1, 2.",
            "NL": "Node 3 has a link to either node 1 or node 2."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 3 have link Node U, where U is one of 1, 2.",
            "NL": "Node 3 has a connection with either node 1 or node 2."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 3 have link Node U, where U is one of 1, 2.",
            "NL": "Node 3 is linked to either node 1 or node 2."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 3 is adjacent to Node 4.",
            "NL": "Node 4 is adjacent to node 2."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 3 is adjacent to Node 4.",
            "NL": "Node 4 is next to node 2."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 3 is adjacent to Node 4.",
            "NL": "Node 4 has an adjacent node 2."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 3 is adjacent to Node 4.",
            "NL": "Node 4 has a neighbor which is node 2."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 3 is adjacent to Node 4.",
            "NL": "Node 4 has a neighbor, which is node 2."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 3 is link to Node U, where U is one of 1, 2.",
            "NL": "Given node 3, there will be a link to node X, where X is one of the numbers 1 or 2."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 3 is link to Node U, where U is one of 1, 2.",
            "NL": "Node 3 is linked to Node X, with X being either the number 1 or 2."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 3 is link to Node U, where U is one of 1, 2.",
            "NL": "Node 3 possesses a link to Node X, where X can be either 1 or 2."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 3 is link to Node U, where U is one of 1, 2.",
            "NL": "A connection exists between Node 3 and Node X, with X representing either 1 or 2."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 3 is link to Node U, where U is one of 1, 2.",
            "NL": "Node 3 has a connection to Node X, where X can be defined as 1 or 2."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 4 edge to node X, where X is one of 5, 6.",
            "NL": "Node 4 has an edge that leads to either node 5 or node 6."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 4 edge to node X, where X is one of 5, 6.",
            "NL": "Node 4 has an edge leading to either node 5 or node 6."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 4 edge to node X, where X is one of 5, 6.",
            "NL": "Node 4 has an edge to either node 5 or 6."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 4 edge to node X, where X is one of 5, 6.",
            "NL": "Node 4 has an edge to either node 5 or node 6."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 4 edge to node X, where X is one of 5, 6.",
            "NL": "Node 4 is connected to either node 5 or node 6."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 4 has an edge to node X, where X is one of 5, 6.",
            "NL": "The nodes 1 and either 5 or 6 are connected by an edge."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 4 has an edge to node X, where X is one of 5, 6.",
            "NL": "Node 1 has an edge that connects to either node 5 or node 6."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 4 has an edge to node X, where X is one of 5, 6.",
            "NL": "The connection between node 1 and either node 5 or 6 is defined by an edge."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 4 has an edge to node X, where X is one of 5, 6.",
            "NL": "Node 1 has an edge to either node 5 or node 6."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 4 has an edge to node X, where X is one of 5, 6.",
            "NL": "The connection between node 1 and either node 5 or node 6 exists."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 4 have an edge Node 5.",
            "NL": "Node 4 has an edge connecting it to node 5."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 4 have an edge Node 5.",
            "NL": "Node 4 is connected to Node 5 through an edge."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 4 have an edge Node 5.",
            "NL": "Node 4 shares an edge with Node 5."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 4 have an edge Node 5.",
            "NL": "An edge exists between Node 4 and Node 5"
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 4 have an edge Node 5.",
            "NL": "An edge links Node 4 and Node 5."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 4 have an edge Node 6.",
            "NL": "Node 4 has a connection to node 6."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 4 have an edge Node 6.",
            "NL": "Node 4 has a connection with node 6."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 4 have an edge Node 6.",
            "NL": "Node 4 is connected to node 6."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 4 have an edge Node 6.",
            "NL": "Node 4 has an edge connecting it to node 6."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 4 have an edge Node 6.",
            "NL": "Node 4 has an edge connecting to node 6."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 4 have an link to node 5.",
            "NL": "Node 4 is connected to Node 5."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 4 have an link to node 5.",
            "NL": "A connection exists between node 4 and node 5."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 4 have an link to node 5.",
            "NL": "Node 4 and node 5 are connected."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 4 have an link to node 5.",
            "NL": "There is a connection between node 4 and node 5."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 4 have an link to node 5.",
            "NL": "Node 4 and node 5 are linked."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 4 is adjacent to Node 5.",
            "NL": "There is a node 4 that is neighboring node 5."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 4 is adjacent to Node 5.",
            "NL": "Node 4 is next to node 5."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 4 is adjacent to Node 5.",
            "NL": "Node 5 is adjacent to node 4."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 4 is adjacent to Node 5.",
            "NL": "Node 4 is located next to node 5."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 4 is adjacent to Node 5.",
            "NL": "Node 4 lies next to node 5."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 5 has a link to node 6.",
            "NL": "A link is established between node 5 and node 6."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 5 has a link to node 6.",
            "NL": "Node 5 and node 6 share a link."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 5 has a link to node 6.",
            "NL": "A link exists connecting node 5 and node 6."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 5 has a link to node 6.",
            "NL": "There's a connection from node 5 to node 6."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 5 has a link to node 6.",
            "NL": "Node 5 is linked to node 6."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 6 have an link to node 8.",
            "NL": "There is a connection between node 6 and node 8."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 6 have an link to node 8.",
            "NL": "A connection exists between node 6 and node 8."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 6 have an link to node 8.",
            "NL": "Node 6 and node 8 are connected."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 6 have an link to node 8.",
            "NL": "An association exists between node 6 and node 8."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 6 have an link to node 8.",
            "NL": "Node 6 is connected to node 8."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 6 is adjacent to Node 4.",
            "NL": "Node 4 is next to node 6."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 6 is adjacent to Node 4.",
            "NL": "Node 4 has node 6 next to it."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 6 is adjacent to Node 4.",
            "NL": "Node 4 has node 6 adjacent to it."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 6 is adjacent to Node 4.",
            "NL": "Node 4 has a neighbor, node 6."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Node 6 is adjacent to Node 4.",
            "NL": "Node 4 has a neighbor node 6."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 8 have an link to node 9.",
            "NL": "There is a connection between node 8 and node 9."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 8 have an link to node 9.",
            "NL": "A connection exists between node 8 and node 9."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 8 have an link to node 9.",
            "NL": "Node 8 and Node 9 are connected."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 8 have an link to node 9.",
            "NL": "Node 8 and node 9 are linked."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 8 have an link to node 9.",
            "NL": "Node 8 is connected to Node 9."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 9 has a link to node 10.",
            "NL": "There is a link connecting node 9 and node 10."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 9 has a link to node 10.",
            "NL": "A link exists between node 9 and node 10."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 9 has a link to node 10.",
            "NL": "Node 9 and node 10 are connected via a link."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 9 has a link to node 10.",
            "NL": "There's a connection linking node 9 and node 10."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "node 9 has a link to node 10.",
            "NL": "Node 9 has a link to node 10."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "There is a sign with id P.",
            "NL": "A sign with the label P is present."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "There is a sign with id P.",
            "NL": "A sign bearing the label P is present."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "There is a sign with id P.",
            "NL": "A sign is labeled with the identifier P."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "There is a sign with id P.",
            "NL": "A sign bearing the designation P is present."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "There is a sign with id P.",
            "NL": "A sign bearing the identifier P is present."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "There is a vertex with id B.",
            "NL": "There is a vertex in the graph that has the id B."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "There is a vertex with id B.",
            "NL": "The graph contains the vertex with the id B."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "There is a vertex with id B.",
            "NL": "The graph contains the vertex identified as B."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "There is a vertex with id B.",
            "NL": "The graph contains a vertex with the id B."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "There is a vertex with id B.",
            "NL": "The graph contains the vertex labeled B."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "There is a vertex with id C.",
            "NL": "The graph contains the vertex with the id C."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "There is a vertex with id C.",
            "NL": "The graph contains a vertex with the id C."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "There is a vertex with id C.",
            "NL": "A vertex labeled C is included in the graph."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "There is a vertex with id C.",
            "NL": "There is a vertex in the graph with the id C."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "There is a vertex with id C.",
            "NL": "There is a vertex in the graph that has the id C."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "There is a vertex with id D.",
            "NL": "The graph contains a vertex identified as D."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "There is a vertex with id D.",
            "NL": "The graph contains a vertex with the id D."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "There is a vertex with id D.",
            "NL": "The graph contains the vertex identified as D."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "There is a vertex with id D.",
            "NL": "The graph contains a vertex with the identifier D."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "There is a vertex with id D.",
            "NL": "The graph contains the vertex with the id D."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "There is a vertex with id E.",
            "NL": "The graph contains the vertex with an id of E."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "There is a vertex with id E.",
            "NL": "The graph contains a vertex identified as E."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "There is a vertex with id E.",
            "NL": "The graph contains a vertex with the id E."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "There is a vertex with id E.",
            "NL": "The graph contains the vertex with the id E."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "There is a vertex with id E.",
            "NL": "There is a vertex labeled E in the graph."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "There is a weight with value equal to 1.",
            "NL": "The weight has a value of 1."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "There is a weight with value equal to 1.",
            "NL": "The weight has a magnitude of 1."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "There is a weight with value equal to 1.",
            "NL": "A weight has a value of 1."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "There is a weight with value equal to 1.",
            "NL": "A weight with a value of 1 exists."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "There is a weight with value equal to 1.",
            "NL": "A weight of 1 is present."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "value4 J have NonInitial to value4 J and id 37.",
            "NL": "The id of 10 belongs to NonInitial located between value4 37 and value4 25."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "value4 J have NonInitial to value4 J and id 37.",
            "NL": "The id 10 belongs to a NonInitial value between value4 37 and value4 25."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "value4 J have NonInitial to value4 J and id 37.",
            "NL": "The id 10 is associated with a NonInitial value between value4 37 and value4 25."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "value4 J have NonInitial to value4 J and id 37.",
            "NL": "The id of 10 belongs to the NonInitial located between value4 37 and value4 25."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "value4 J have NonInitial to value4 J and id 37.",
            "NL": "The id 10 is assigned to the NonInitial between value4 37 and value4 25."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "visit 1 has a start. ",
            "NL": "The visit is beginning."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "visit 1 has a start. ",
            "NL": "The visit has begun."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "visit 1 has a start. ",
            "NL": "Beginning the visit is the first step."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "visit 1 has a start. ",
            "NL": "The visit is starting."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "visit 1 has a start. ",
            "NL": "The visit begins here."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "visit 1 have a road to visit 2.",
            "NL": "A road links visit 1 to visit 2."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "visit 1 have a road to visit 2.",
            "NL": "A road links visit 1 and visit 2."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "visit 1 have a road to visit 2.",
            "NL": "There is a road linking visit 1 and visit 2."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "visit 1 have a road to visit 2.",
            "NL": "There is a road linking visit 1 to visit 2."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "visit 1 have a road to visit 2.",
            "NL": "A road links visit 1 with visit 2."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "visit 2 have a road to visit 3.",
            "NL": "There is a road linking visit 2 and visit 3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "visit 2 have a road to visit 3.",
            "NL": "A road links visit 2 to visit 3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "visit 2 have a road to visit 3.",
            "NL": "A road links visit 2 with visit 3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "visit 2 have a road to visit 3.",
            "NL": "There is a road linking visit 2 to visit 3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "visit 2 have a road to visit 3.",
            "NL": "There is a road that links visit 2 to visit 3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "visit 3 has a road to visit 4.",
            "NL": "A road links visit 3 to visit 4."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "visit 3 has a road to visit 4.",
            "NL": "A route links visit 3 to visit 4."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "visit 3 has a road to visit 4.",
            "NL": "There is a road linking visit 3 and visit 4."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "visit 3 has a road to visit 4.",
            "NL": "There is a road linking visit 3 to visit 4."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "visit 3 has a road to visit 4.",
            "NL": "A road links visit 3 with visit 4."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "visit 4 has a road to visit 1.",
            "NL": "A road links visit 4 to visit 1."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "visit 4 has a road to visit 1.",
            "NL": "There is a road linking visit 4 to visit 1."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "visit 4 has a road to visit 1.",
            "NL": "A route exists linking visit 4 to visit 1."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "visit 4 has a road to visit 1.",
            "NL": "A road links visit 1 to visit 4."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "visit 4 has a road to visit 1.",
            "NL": "There is a road linking visit 1 and visit 4."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 1 has an edge to Vtx X, where X is one of 2, 4.",
            "NL": "Vertex 1 has a connection to either vertex 2 or vertex 4."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 1 has an edge to Vtx X, where X is one of 2, 4.",
            "NL": "Vertex 1 is connected to either vertex 2 or vertex 4 by an edge."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 1 has an edge to Vtx X, where X is one of 2, 4.",
            "NL": "Vertex 1 has an edge to either vertex 2 or vertex 4."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 1 has an edge to Vtx X, where X is one of 2, 4.",
            "NL": "There is a connection between vertex 1 and either vertex 2 or vertex 4."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 1 has an edge to Vtx X, where X is one of 2, 4.",
            "NL": "A connection exists from vertex 1 to either vertex 2 or vertex 4."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 1 has an edgewt to Vtx 2 and weight 2.",
            "NL": "A weight of 2 exists on the edge connecting vertex 1 and vertex 2."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 1 has an edgewt to Vtx 2 and weight 2.",
            "NL": "The edge connecting vertex 1 and vertex 2 has a weight of 2."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 1 has an edgewt to Vtx 2 and weight 2.",
            "NL": "A connection of weight 2 exists between vertex 1 and vertex 2."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 1 has an edgewt to Vtx 2 and weight 2.",
            "NL": "The connection between vertex 1 and vertex 2 has a weight of 2."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 1 has an edgewt to Vtx 2 and weight 2.",
            "NL": "The weight of 2 exists between vertex 1 and vertex 2 at the edge."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 1 has an edgewt to Vtx 4 and weight 3.",
            "NL": "The edge connecting vertex 1 to vertex 4 has a weight of 3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 1 has an edgewt to Vtx 4 and weight 3.",
            "NL": "The edge between vertex 1 and vertex 4 has a weight of 3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 1 has an edgewt to Vtx 4 and weight 3.",
            "NL": "The edge connecting vertex 1 and vertex 4 has a weight of 3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 1 has an edgewt to Vtx 4 and weight 3.",
            "NL": "There is a connection of weight 3 between vertex 1 and vertex 4."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 1 has an edgewt to Vtx 4 and weight 3.",
            "NL": "There is an edge connecting vertex 1 and vertex 4 with a weight of 3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 1 have an edge to Vtx 2 and weight 2.",
            "NL": "Vertex 1 and vertex 2 have an edge of weight 2."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 1 have an edge to Vtx 2 and weight 2.",
            "NL": "The weight of the edge connecting vertex 1 and vertex 2 is 2."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 1 have an edge to Vtx 2 and weight 2.",
            "NL": "Vertex 1 and Vertex 2 are connected by an edge with a weight of 2."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 1 have an edge to Vtx 2 and weight 2.",
            "NL": "Vertex 1 and vertex 2 have an edge with a weight of 2."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 1 have an edge to Vtx 2 and weight 2.",
            "NL": "The edge connecting vertex 1 and vertex 2 has a weight of 2."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 1 have an edge to Vtx 5.",
            "NL": "Vertex 1 has an edge connecting to vertex 5."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 1 have an edge to Vtx 5.",
            "NL": "Vertex 1 is connected to vertex 5 by an edge."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 1 have an edge to Vtx 5.",
            "NL": "Vertex 1 has an edge that connects to vertex 5."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 1 have an edge to Vtx 5.",
            "NL": "Vertex 1 has an edge connecting it to vertex 5."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 1 have an edge to Vtx 5.",
            "NL": "Vertex 1 has a connection to vertex 5."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 1 have an edge to Vtx X, where X is one of 2, 4, 5.",
            "NL": "Vertex 1 and 2 have an edge between them, as well as vertices 4 and 5."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 1 have an edge to Vtx X, where X is one of 2, 4, 5.",
            "NL": "A connection exists between vertex 1 and vertex 2, and also between vertices 4 and 5."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 1 have an edge to Vtx X, where X is one of 2, 4, 5.",
            "NL": "Vertex 1 and vertex 2, as well as vertices 4 and 5, are connected by an edge."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 1 have an edge to Vtx X, where X is one of 2, 4, 5.",
            "NL": "There is a link between vertices 1 and 2, as well as between vertices 4 and 5."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 1 have an edge to Vtx X, where X is one of 2, 4, 5.",
            "NL": "There is a connection between vertex 1 and vertex 2, as well as vertices 4 and 5."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 2 has an edge to Vtx X, where X is one of 3, 5.",
            "NL": "Vertex 2 and vertex 3, as well as vertex 5, have an edge between them."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 2 has an edge to Vtx X, where X is one of 3, 5.",
            "NL": "Vertex 2 and vertex 3, as well as vertex 5, are connected by an edge."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 2 has an edge to Vtx X, where X is one of 3, 5.",
            "NL": "Vertex 2 is connected to both vertex 3 and vertex 5."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 2 has an edge to Vtx X, where X is one of 3, 5.",
            "NL": "Vertex 2 and vertex 3, as well as vertex 5, share an edge."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 2 has an edge to Vtx X, where X is one of 3, 5.",
            "NL": "Vertex 2 and vertex 3, as well as vertex 5, have an adjoining edge."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 2 has an edgewt to Vtx 1 and weight 2.",
            "NL": "The edge connecting vertex 2 and vertex 1 has a weight of 2."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 2 has an edgewt to Vtx 1 and weight 2.",
            "NL": "A weight of 2 exists between vertex 1 and vertex 2 on the edge."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 2 has an edgewt to Vtx 1 and weight 2.",
            "NL": "The edge connecting vertex 2 to vertex 1 has a weight of 2."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 2 has an edgewt to Vtx 1 and weight 2.",
            "NL": "There is an edge connecting vertex 2 and vertex 1 with a weight of 2."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 2 has an edgewt to Vtx 1 and weight 2.",
            "NL": "The edge connecting vertex 1 and vertex 2 has a weight of 2."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 2 have an edge to Vtx 3 and weight 3.",
            "NL": "Vertex 2 and vertex 2 have an edge of weight 3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 2 have an edge to Vtx 3 and weight 3.",
            "NL": "Vertex 2 and vertex 2 have an edge with a weight of 3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 2 have an edge to Vtx 3 and weight 3.",
            "NL": "Vertex 2 and vertex 2 are connected by an edge with a weight of 3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 2 have an edge to Vtx 3 and weight 3.",
            "NL": "The edge between vertex 2 and vertex 2 has a weight of 3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 2 have an edge to Vtx 3 and weight 3.",
            "NL": "Vertex 2 has an edge to vertex 2 with a weight of 3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 2 have an edge to Vtx 8.",
            "NL": "Vertex 2 has an edge connecting it to vertex 8."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 2 have an edge to Vtx 8.",
            "NL": "Vertex 2 is connected to vertex 8 by an edge."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 2 have an edge to Vtx 8.",
            "NL": "Vertex 2 has an edge connected to vertex 8."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 2 have an edge to Vtx 8.",
            "NL": "Vertex 2 has an edge that connects to vertex 8."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 2 have an edge to Vtx 8.",
            "NL": "Vertex 2 has a connection to vertex 8."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 2 have an edgewt to Vtx 3 and weight 3.",
            "NL": "A weight of 3 exists on the edge connecting vertex 2 and vertex 3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 2 have an edgewt to Vtx 3 and weight 3.",
            "NL": "A weight of 3 exists between vertex 2 and vertex 3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 2 have an edgewt to Vtx 3 and weight 3.",
            "NL": "The edge connecting vertex 2 and vertex 3 has a weight of 3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 2 have an edgewt to Vtx 3 and weight 3.",
            "NL": "There is an edge connecting vertex 2 and vertex 3 with a weight of 3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 2 have an edgewt to Vtx 3 and weight 3.",
            "NL": "The edge connecting vertex 2 to vertex 3 has a weight of 3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 3 has an edge to Vtx 2.",
            "NL": "Vertex 3 and vertex 2 have an edge between them."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 3 has an edge to Vtx 2.",
            "NL": "Vertex 3 and vertex 2 are connected by an edge."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 3 has an edge to Vtx 2.",
            "NL": "Vertex 3 and vertex 2 have an edge connecting them."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 3 has an edge to Vtx 2.",
            "NL": "A connection exists between vertex 3 and vertex 2."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 3 has an edge to Vtx 2.",
            "NL": "Vertex 3 and vertex 2 have an adjoining edge."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 3 has an edge to Vtx 4 and weight 1.",
            "NL": "Vertex 3 and vertex 2 have an edge connecting them with a weight of 1."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 3 has an edge to Vtx 4 and weight 1.",
            "NL": "The edge connecting vertex 3 and vertex 2 has a weight of 1."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 3 has an edge to Vtx 4 and weight 1.",
            "NL": "Vertex 3 and vertex 2 are connected by an edge with a weight of 1."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 3 has an edge to Vtx 4 and weight 1.",
            "NL": "The edge between vertex 3 and vertex 2 has a weight of 1."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 3 has an edge to Vtx 4 and weight 1.",
            "NL": "There is a connection of weight 1 between vertex 3 and vertex 2."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 3 has an edge to Vtx X, where X is one of 1, 4, 5, 7.",
            "NL": "Vertex 3 has an edge that connects to one of the vertices numbered 1, 4, 5, or 7."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 3 has an edge to Vtx X, where X is one of 1, 4, 5, 7.",
            "NL": "Vertex 3 has an edge to one of the vertices 1, 4, 5, and 7."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 3 has an edge to Vtx X, where X is one of 1, 4, 5, 7.",
            "NL": "Vertex 3 is connected to vertex X, which can be any of the numbers 1, 4, 5, or 7."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 3 has an edge to Vtx X, where X is one of 1, 4, 5, 7.",
            "NL": "Vertex 3 has an edge connecting it to one of the vertices 1, 4, 5, or 7."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 3 has an edge to Vtx X, where X is one of 1, 4, 5, 7.",
            "NL": "Vertex 3 has an edge connecting it to one of the vertices numbered 1, 4, 5, and 7."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 3 has an edgewt to Vtx 2 and weight 3.",
            "NL": "The edge connecting vertex 3 and vertex 2 has a weight of 3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 3 has an edgewt to Vtx 2 and weight 3.",
            "NL": "There is a link of weight 3 connecting vertex 3 and vertex 2."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 3 has an edgewt to Vtx 2 and weight 3.",
            "NL": "There exists an edge connecting vertex 3 and vertex 2 with a weight of 3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 3 has an edgewt to Vtx 2 and weight 3.",
            "NL": "A connection of weight 3 exists between vertex 3 and vertex 2."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 3 has an edgewt to Vtx 2 and weight 3.",
            "NL": "There is a connection between vertex 3 and vertex 2 with a weight of 3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 3 has an edgewt to Vtx 4 and weight 1.",
            "NL": "The edge connecting vertex 3 to vertex 4 has a weight of 1."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 3 has an edgewt to Vtx 4 and weight 1.",
            "NL": "The edge connecting vertex 3 and vertex 4 has a weight of 1."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 3 has an edgewt to Vtx 4 and weight 1.",
            "NL": "The connection between vertex 3 and vertex 4 has a weight of 1."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 3 has an edgewt to Vtx 4 and weight 1.",
            "NL": "There is an edge connecting vertex 3 and vertex 4 with a weight of 1."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 3 has an edgewt to Vtx 4 and weight 1.",
            "NL": "The weight of 1 exists between vertex 3 and vertex 4."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 3 have an edge to Vtx 1.",
            "NL": "Vertex 3 and vertex 1 share an edge."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 3 have an edge to Vtx 1.",
            "NL": "Vertex 3 and vertex 1 have an edge between them."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 3 have an edge to Vtx 1.",
            "NL": "Vertex 3 and vertex 1 are connected by an edge."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 3 have an edge to Vtx 1.",
            "NL": "A connection exists between vertex 3 and vertex 1."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 3 have an edge to Vtx 1.",
            "NL": "Vertex 3 and vertex 1 have a shared edge."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 3 have an edge to Vtx X, where X is one of 5, 1.",
            "NL": "Vertex 3 has an advantage compared to either vertex 5 or vertex 1."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 3 have an edge to Vtx X, where X is one of 5, 1.",
            "NL": "Vertex 3 has an advantage over either vertex 5 or vertex 1."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 3 have an edge to Vtx X, where X is one of 5, 1.",
            "NL": "Vertex 3 has an advantage over vertex 5 or 1."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 3 have an edge to Vtx X, where X is one of 5, 1.",
            "NL": "Vertex 3 has an advantage compared to vertex X, which can be either 5 or 1."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 3 have an edge to Vtx X, where X is one of 5, 1.",
            "NL": "Vertex 3 has an advantage compared to vertex X, which is either 5 or 1."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 4 has an edge to Vtx 1 and weight 3.",
            "NL": "The edge connecting vertex 4 and vertex 2 has a weight of 3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 4 has an edge to Vtx 1 and weight 3.",
            "NL": "Vertex 4 and vertex 2 have an edge of weight 3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 4 has an edge to Vtx 1 and weight 3.",
            "NL": "Vertex 4 and vertex 2 have an edge with a weight of 3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 4 has an edge to Vtx 1 and weight 3.",
            "NL": "Vertex 4 and vertex 2 are connected by an edge with a weight of 3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 4 has an edge to Vtx 1 and weight 3.",
            "NL": "The edge connecting vertex 4 to vertex 2 has a weight of 3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 4 has an edge to Vtx 2.",
            "NL": "Vertex 4 has an edge that connects to vertex 2."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 4 has an edge to Vtx 2.",
            "NL": "Vertex 4 has an edge connecting it to vertex 2."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 4 has an edge to Vtx 2.",
            "NL": "Vertex 4 is connected to vertex 2 by an edge."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 4 has an edge to Vtx 2.",
            "NL": "Vertex 4 has an edge connected to vertex 2."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 4 has an edge to Vtx 2.",
            "NL": "Vertex 4 has an edge connecting to vertex 2."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 4 has an edge to Vtx 3.",
            "NL": "Vertex 4 and vertex 3 are connected by an edge."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 4 has an edge to Vtx 3.",
            "NL": "Vertex 4 and vertex 3 have an edge between them."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 4 has an edge to Vtx 3.",
            "NL": "Vertex 4 and vertex 3 have an edge connecting them."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 4 has an edge to Vtx 3.",
            "NL": "A connection exists between vertex 4 and vertex 3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 4 has an edge to Vtx 3.",
            "NL": "Vertex 4 and vertex 3 share an edge."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 4 has an edgewt to Vtx 1 and weight 3.",
            "NL": "The edge connecting vertex 4 and vertex 1 has a weight of 3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 4 has an edgewt to Vtx 1 and weight 3.",
            "NL": "The edge connecting vertex 4 to vertex 1 has a weight of 3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 4 has an edgewt to Vtx 1 and weight 3.",
            "NL": "A weight of 3 exists between vertex 4 and vertex 1."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 4 has an edgewt to Vtx 1 and weight 3.",
            "NL": "There is a connection of weight 3 between vertex 4 and vertex 1."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 4 has an edgewt to Vtx 1 and weight 3.",
            "NL": "The edge between vertex 4 and vertex 1 has a weight of 3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 4 have an edge to Vtx X, where X is one of 2, 3, 5.",
            "NL": "Vertex 4 is connected to vertex 2, and vertices 3 and 5 are also connected."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 4 have an edge to Vtx X, where X is one of 2, 3, 5.",
            "NL": "Vertex 4 has an edge to vertex 2, as well as to vertices 3 and 5."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 4 have an edge to Vtx X, where X is one of 2, 3, 5.",
            "NL": "Vertex 4 has an edge connecting it to vertex 2, as well as to vertices 3 and 5."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 4 have an edge to Vtx X, where X is one of 2, 3, 5.",
            "NL": "There is an edge connecting vertex 4 to vertex 2, in addition to the edges connecting vertices 3 and 5."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 4 have an edge to Vtx X, where X is one of 2, 3, 5.",
            "NL": "Vertex 4 is connected to vertex 2, as well as vertices 3 and 5."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 4 have an edgewt to Vtx 3 and weight 1.",
            "NL": "The edge connecting vertex 4 and vertex 3 has a weight of 1."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 4 have an edgewt to Vtx 3 and weight 1.",
            "NL": "A weight of 1 exists between vertex 4 and vertex 3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 4 have an edgewt to Vtx 3 and weight 1.",
            "NL": "There is a connection with a weight of 1 between vertex 4 and vertex 3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 4 have an edgewt to Vtx 3 and weight 1.",
            "NL": "The edge connecting vertex 4 to vertex 3 has a weight of 1."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 4 have an edgewt to Vtx 3 and weight 1.",
            "NL": "There is a connection of weight 1 between vertex 4 and vertex 3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 5 has an edge to Vtx 3.",
            "NL": "Vertex 5 and vertex 3 have an edge between them."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 5 has an edge to Vtx 3.",
            "NL": "Vertex 5 and vertex 3 are connected by an edge."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 5 has an edge to Vtx 3.",
            "NL": "A line exists connecting vertex 5 and vertex 3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 5 has an edge to Vtx 3.",
            "NL": "A connection exists between vertex 5 and vertex 3."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 5 has an edge to Vtx 3.",
            "NL": "Vertex 5 and vertex 3 have an edge connecting them."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 5 has an edge to Vtx X, where X is one of 2, 1.",
            "NL": "Vertex 5 has an advantage compared to either vertex 2 or vertex 1."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 5 has an edge to Vtx X, where X is one of 2, 1.",
            "NL": "Vertex 5 has an advantage over vertex 2 or 1."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 5 has an edge to Vtx X, where X is one of 2, 1.",
            "NL": "Vertex 5 has an advantage over vertex X, which can be either 2 or 1."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 5 has an edge to Vtx X, where X is one of 2, 1.",
            "NL": "Vertex 5 has an advantage over either vertex 2 or vertex 1."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 5 has an edge to Vtx X, where X is one of 2, 1.",
            "NL": "Vertex 5 has an advantage over vertexes 2 and 1."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 5 has an edge to Vtx X, where X is one of 2, 4.",
            "NL": "Vertex 5 has an edge to either vertex 2 or vertex 4."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 5 has an edge to Vtx X, where X is one of 2, 4.",
            "NL": "Vertex 5 has an edge that connects it to either vertex 2 or vertex 4."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 5 has an edge to Vtx X, where X is one of 2, 4.",
            "NL": "Vertex 5 has an edge connecting it to either vertex 2 or vertex 4."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 5 has an edge to Vtx X, where X is one of 2, 4.",
            "NL": "Vertex 5 is connected to either vertex 2 or vertex 4."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 5 has an edge to Vtx X, where X is one of 2, 4.",
            "NL": "Vertex 5 has an edge that connects to either vertex 2 or vertex 4."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 6 has an edge to Vtx X, where X is one of 5, 1.",
            "NL": "Vertex 6 has an advantage compared to either vertex 5 or vertex 1."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 6 has an edge to Vtx X, where X is one of 5, 1.",
            "NL": "Vertex 6 has an advantage over either vertex 5 or vertex 1."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 6 has an edge to Vtx X, where X is one of 5, 1.",
            "NL": "Vertex 6 has the advantage over either vertex 5 or vertex 1."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 6 has an edge to Vtx X, where X is one of 5, 1.",
            "NL": "Vertex 6 has an advantage compared to either vertex 5 or 1."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 6 has an edge to Vtx X, where X is one of 5, 1.",
            "NL": "Vertex 6 has an advantage over vertex 5 or 1."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 6 have an edge to Vtx X, where X is one of 1, 2, 4, 7.",
            "NL": "Vertex 6 has an edge connecting it to one of the vertices numbered 1, 2, 4, or 7."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 6 have an edge to Vtx X, where X is one of 1, 2, 4, 7.",
            "NL": "Vertex 6 has an edge connecting it to one of the vertices numbered 1, 2, 4 or 7."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 6 have an edge to Vtx X, where X is one of 1, 2, 4, 7.",
            "NL": "Vertex 6 has an edge that connects to one of the vertices numbered 1, 2, 4, or 7."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 6 have an edge to Vtx X, where X is one of 1, 2, 4, 7.",
            "NL": "Vertex 6 has an edge that connects to one of the vertices 1, 2, 4, or 7."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 6 have an edge to Vtx X, where X is one of 1, 2, 4, 7.",
            "NL": "Vertex 6 has a connection to one of the vertices 1, 2, 4, and 7."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 7 has an edge to Vtx X, where X is one of 6, 5, 4.",
            "NL": "Vertex 7 has an advantage over any of the vertices 6, 5, or 4."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 7 has an edge to Vtx X, where X is one of 6, 5, 4.",
            "NL": "Vertex 7 has an advantage over vertex X, which could be 6, 5, or 4."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 7 has an edge to Vtx X, where X is one of 6, 5, 4.",
            "NL": "Vertex 7 has an advantage compared to any of the vertices 6, 5, or 4."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 7 has an edge to Vtx X, where X is one of 6, 5, 4.",
            "NL": "Vertex 7 has an advantage over any of the following vertices: 6, 5, or 4."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 7 has an edge to Vtx X, where X is one of 6, 5, 4.",
            "NL": "Vertex 7 has an advantage compared to vertices 6, 5, or 4."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 7 have an edge to Vtx X, where X is one of 1, 4, 5.",
            "NL": "Vertex 7 has an edge that connects to one of the vertices 1, 2, or 5."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 7 have an edge to Vtx X, where X is one of 1, 4, 5.",
            "NL": "Vertex 7 has an edge connecting it to one of the vertices numbered 1, 2, or 5."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 7 have an edge to Vtx X, where X is one of 1, 4, 5.",
            "NL": "Vertex 7 has an edge connecting it to vertices 1, 2, and 5."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 7 have an edge to Vtx X, where X is one of 1, 4, 5.",
            "NL": "Vertex 7 has an edge that connects it to one of the vertices 1, 2, or 5."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 7 have an edge to Vtx X, where X is one of 1, 4, 5.",
            "NL": "Vertex 7 has an edge connecting it to one of the vertices 1, 2, or 5."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 8 has an edge to Vtx X, where X is one of 1, 4, 5, 7.",
            "NL": "Vertex 8 has an edge connecting it to one of the vertices 1, 2, 5, or 7."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 8 has an edge to Vtx X, where X is one of 1, 4, 5, 7.",
            "NL": "Vertex 8 has an edge connecting it to one of the vertices numbered 1, 2, 5, or 7."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 8 has an edge to Vtx X, where X is one of 1, 4, 5, 7.",
            "NL": "Vertex 8 has an edge to vertex X, where X is one of the numbers 1, 2, 5, or 7."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 8 has an edge to Vtx X, where X is one of 1, 4, 5, 7.",
            "NL": "Vertex 8 has an edge that connects to one of the vertices numbered 1, 2, 5, and 7."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 8 has an edge to Vtx X, where X is one of 1, 4, 5, 7.",
            "NL": "Vertex 8 has an edge to one of the vertices 1, 2, 5 and 7."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 8 have an edge to Vtx X, where X is one of 1, 5, 6.",
            "NL": "Vertex 8 has an advantage compared to the vertices 1, 5, or 6."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 8 have an edge to Vtx X, where X is one of 1, 5, 6.",
            "NL": "Vertex 8 has an advantage compared to vertices 1, 5, or 6."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 8 have an edge to Vtx X, where X is one of 1, 5, 6.",
            "NL": "Vertex 8 has an advantage over any of the vertices 1, 5, or 6."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 8 have an edge to Vtx X, where X is one of 1, 5, 6.",
            "NL": "Vertex 8 has an advantage compared to any of the vertices 1, 5, or 6."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "Vtx 8 have an edge to Vtx X, where X is one of 1, 5, 6.",
            "NL": "Vertex 8 has an advantage over vertices 1, 5, and 6."
        },
        {
            "Category": "Definition When",
            "CNL": "edge8 U have Inorder edge8 N when edge8 U is Lone edge8 E and also edge8 E Lone edge8 N.",
            "NL": "When edge8 U is Inorder edge8 E, and also edge8 N is Inorder edge8 N, then edge8 U does Lone edge8 N. "
        },
        {
            "Category": "Definition When",
            "CNL": "id1 P is Unpaired when id1 V is Unpaired and also id1 V has a Twosome id1 P.",
            "NL": "A id1 P is Unpaired when a id1 P has been Unpaired, and a id1 P has a Twosome to a id1 P."
        },
        {
            "Category": "Definition When",
            "CNL": "id2 D is Out when id2 D is NonGrouping and also id2 A is not Label and also id2 D is not Unmatch.",
            "NL": "A Out id2 D is one that is a NonGrouping with id2 D, not an Label with id2 D, and not a Unmatch with id2 D."
        },
        {
            "Category": "Definition When",
            "CNL": "id4 X Dominating_Set id4 L and id4 V when id4 X has an Offspring id4 M and id4 J and also id4 X Dominating_Set id4 M and id4 J and also id4 L Tree id4 V.",
            "NL": "A id4 X will Dominating_Set id4 L and id4 V when id4 X has an Offspring id4 M and a id4 J, and id4 X will also Dominating_Set id4 M and id4 J and id4 L will Tree id4 V."
        },
        {
            "Category": "Definition When",
            "CNL": "id7 X Trapped id7 I when id7 X is Following id7 I and also if O is Trapped is I and also id7 O is Face id7 X and id7 I.",
            "NL": "When id7 X is Following id7 I, id7 O is Trapped id7 I, id7 O is Face id7 X and id7 I, then id7 X has Trapped id7 I. "
        },
        {
            "Category": "Definition When",
            "CNL": "key10 I is Depth_Vertex key10 O and key10 U when key10 Q is Flow_Network and also key10 Q is Index key10 I and also key10 Q is Depth_Vertex key10 O and node9 U, where I is different from O.",
            "NL": "Essentially, key10 I corresponds to Depth_Vertex key10 O and key10 U when key10 Q is Flow_Network, and also key10 Q corresponds to Index key10 I and also key10 Q corresponds to Depth_Vertex key10 O and node9 U, where I is different from O."
        },
        {
            "Category": "Definition When",
            "CNL": "key2 15 is Dominating_Set when key2 A is Position and also key2 A is Superior.",
            "NL": "The key2 15 is a Dominating_Set when the key2 A is Position, as well as the Superior key2 A."
        },
        {
            "Category": "Definition When",
            "CNL": "key7 H has a Shaded to key7 W when key7 C has an Arrived key7 H and also key7 C has an Arrived key7 W and also list N is Check, where N is less than Z and Z is less than Y.",
            "NL": "There is an Shaded between key7 H and key7 W when key7 C has an Arrived key7 H, and key7 C also has an Arrived list Z, and list N is Check, where N is less than Z and Z is less than Y. "
        },
        {
            "Category": "Definition When",
            "CNL": "key7 J is Next when key7 J is Major and also key7 J is not Auxiliary and also key7 J is not Symbol and also key7 J is Commence key7 V and also key7 J is Commence key7 W and also key7 R is Spanning_Tree and also key7 J is Spanning_Tree key7 R.",
            "NL": "When key7 J is Major, key7 J is not Auxiliary, key7 J is Symbol, key7 J is not Commence key7 V, key7 J is not Commence key7 W, and key7 J is NonForemost key7 R, then key7 J has Next."
        },
        {
            "Category": "Definition When",
            "CNL": "key7 P is Comprises key7 V when key7 P Perfect_Graph key7 V and key7 R and also key7 P has Linked key7 K and also key7 V is not Enumeration and also key7 V is not Unconnected and also key7 P have Load key7 V and key7 Q and also key7 V is Linked key7 K.",
            "NL": "When key7 P is Perfect_Graph key7 V, key7 R, key7 P is Linked key7 K, key7 V is not Unconnected, key7 P is Load key7 V and key7 Q, key7 V is Linked key7 K, then key7 P has Comprises key7 V."
        },
        {
            "Category": "Definition When",
            "CNL": "node M is Hamiltonian_Graph node F when node M Attained node F and node B and also node M has Compartment node Z and also node F is not Inpath and also node F is not Minimum_Cut and also node M have Euler_Trail node F and node Q and also node F is Compartment node Z.",
            "NL": "When node M is Attained node F, node B, node M is Compartment node Z, node F is not Minimum_Cut, node M is Euler_Trail node F and node Q, node F is Compartment node Z, then node M has Hamiltonian_Graph node F."
        },
        {
            "Category": "Definition When",
            "CNL": "node T has a Subsequently to node G when node T is Radius and also node G is Radius and also node G have an Secondary to T.",
            "NL": "A Subsequently exists between node T and node G when node T is Radius, as well as an Secondary between node T and node G when node T is Radius."
        },
        {
            "Category": "Definition When",
            "CNL": "value10 H is Load when value10 H have an Distinct value10 M and also value10 M is Label, where Z is less than H.",
            "NL": "It is considered an Load when value10 H is part of an Distinct value10 M, and also if value10 M is part of an Label, where Z is less than H."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx3 V is Selected_Color when vtx3 V is Module vtx3 L. ",
            "NL": "The vtx3 V is Selected_Color when vtx3 V Module the vtx3 L."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx9 Q have a Edge_Paired vtx9 V when vtx9 V Nonclique vtx9 I and also vtx9 Q Edge_Paired vtx9 I and also vtx9 V Longest_Path vtx9 Q.",
            "NL": "The vtx9 Q Edge_Paired vtx9 V when vtx9 V has a Nonclique vtx9 I and there is an Edge_Paired with vtx9 Q and vtx9 I also there is a Longest_Path between vtx9 V and vtx9 Q. "
        },
        {
            "Category": "Definition When",
            "CNL": " id U is diff id1 V when id U have an edge id1 V and also id U obs_elabel id1 V and id3 P and also id U obs_elabel id1 V and id3 M and also id U have obs_vlabel id1 S and also id V is obs_vlabel id1 T, where S is different from T.",
            "NL": "When id U has an edge id V, and there are obs_elabel with id U, id1 V and id2 P, and there is no obs_elabel with id U, id1 V and id2 M, and there is also obs_vlabel with id U and id1 S and also obs_vlabel with id V and id1 T, where S is not equal to T, then we has a diff between id U and id1 V."
        },
        {
            "Category": "Definition When",
            "CNL": " id U is vlabel id S when id U is edge id V and also id U is obs_vlabel id S and also id V is not trivial and also id V is not Input.",
            "NL": "When id U is on the edge of id V, id V is not input, id V is not trivial, id U is obs_vlabel id S, then id U has vlabel id S."
        },
        {
            "Category": "Definition When",
            "CNL": " id V is trivial when id V is vertex and also id V is not Input and also id V is not nonTriv.",
            "NL": "A trivial id V is one that is a vertex with id V, not an input with id V, and not a nontrivial with id V."
        },
        {
            "Category": "Definition When",
            "CNL": " list X is outgroup when list X has an asgn list outgroup and also list N is Atomcnt, where N is less than X.",
            "NL": "It is considered an outgroup when list X is part of an ASGN list outgroup, and also if list N is part of an atomcnt, where N is less than X."
        },
        {
            "Category": "Definition When",
            "CNL": " node C okin node X when node C has an in node X and also node X have an ok and also node C have an pair node X.",
            "NL": "When node C has an in node X and node X has an ok and also node C has a pair node X, then node C is okin with node X."
        },
        {
            "Category": "Definition When",
            "CNL": " node X oktr node C1 and node Y1 when field1 X has a triple field2 C1 and field3 Y1 and also node C1 okin node Y1 and also field1 X not succ field2 C1 and field3 Y1. ",
            "NL": "The node X oks the node C1 and the node Y1 when field1 X has a triple field2 C1 and field3 Y1 and node C1 okin the node Y1 and also field1 X does not success in field2 C1 and field3 Y1."
        },
        {
            "Category": "Definition When",
            "CNL": " node X oktr node C1 and node Y1 when node X have an triple node C1 and node Y1 and also node C1 okin node Y1 and also node X not succ node C1 and node Y1.",
            "NL": "As long as node X has a triple node C1 and node Y1, and as well as node C1 oktin node Y1, and also not success node C1 and node Y1, assuming node X oktr node C1 and node Y1."
        },
        {
            "Category": "Definition When",
            "CNL": "edge X has an inPath to edge Y when node X is reached and also node X has an edge to Y and also edge X have not outPath edge Y.",
            "NL": "There is an inpath from edge X to edge Y when node X is reached, and there is also an edge from X to edge Y, but there is not an outpath from edge X to edge Y."
        },
        {
            "Category": "Definition When",
            "CNL": "edge X has an inPath to edge Y when node X is start and also node X have an edge to Y and also edge X have not outpath edge Y.",
            "NL": "There is an inpath from edge X to edge Y when node X is started, and there is also an edge from X to edge Y, but there is not an outpath from edge X to edge Y."
        },
        {
            "Category": "Definition When",
            "CNL": "edge X has an outPath to edge Y when node X is reached and also node X have an edge to Y and also edge X have not inpath edge Y. ",
            "NL": "There is an outpath from edge X to edge Y when node X is reached, and there is also an edge from X to edge Y, but there is not an inpath from edge X to edge Y."
        },
        {
            "Category": "Definition When",
            "CNL": "edge X has an outPath to edge Y when node X is start and also node X have an edge to Y and also edge X have not inpath edge Y.",
            "NL": "There is an outpath from edge X to edge Y when node X is started, and there is also an edge from X to edge Y, but there is not an inpath from edge X to edge Y."
        },
        {
            "Category": "Definition When",
            "CNL": "id 1 is singleton when id V is active and also id V is trivial.",
            "NL": "The id 1 is a singleton when the id V is active, as well as the trivial id V."
        },
        {
            "Category": "Definition When",
            "CNL": "id M has a match id W when id M have a manAssignsScore id Fv1 and id Fv2 and also id W has a womanAssignsScore id Fv3 and id Fv4 and also id M not nonMatch id W. ",
            "NL": "It is possible for id M to have a match id W if it has a manAssignsScore id Fv1 and id Fv2, and also if it has a womanAssignsScore id Fv3 and id Fv4, not if it has a nonMatch id M and id W."
        },
        {
            "Category": "Definition When",
            "CNL": "id M have a nonMatch id W when id M have a manAssignsScore id FV1 and id FV2 and also id W have a womanAssignsScore id FV3 and id FV4 and also id M not Match id W.",
            "NL": "It is possible for id M to have a nonmatch id M if it has a manAssignsScore id Fv1 and id Fv2, and also id W has a womanAssignsScore id Fv3 and id Fv4, not if it has a nonMatch id M and id W."
        },
        {
            "Category": "Definition When",
            "CNL": "id M is jailed when id M is match id Fv1.",
            "NL": "The id M is jailed when id M matches the id Fv1."
        },
        {
            "Category": "Definition When",
            "CNL": "id U is coppo id V when id U is oppo id V and also id U is first id V.",
            "NL": "When id U is oppo of id V, id U is first id V, then id U coppo id V. "
        },
        {
            "Category": "Definition When",
            "CNL": "id U is coppo id V when id U is oppo id V and also if W is coppo is V and also id W is ntedge id U and id V.",
            "NL": "When id U is oppo id V, id W is coppo id V, id W is ntedge id U and id V, then id U has coppo id V."
        },
        {
            "Category": "Definition When",
            "CNL": "id U is diff id1 V when id U have an edge id1 V and also id U obs_vlabel id1 S and also id V obs_vlabel id1 S and also id U have obs_elabel id1 V and id2 M and also id U is obs_elabel id1 V and id2 P.",
            "NL": "When id U has an edge id V, and there are obs_elabel with id U, id1 V and id2 M, and there is no obs_elabel with id U, id1 V and id2 P, and there is also obs_vlabel with id1 U and id2 S and also obs_vlabel with id1 V and id2 S, then we has a difference between id U and id1 V. "
        },
        {
            "Category": "Definition When",
            "CNL": "id U is first id V when id V is vertex and also id V is not Input and also id V is not trivial id V and also id U is edge id V and also id U is not nfirst id V. ",
            "NL": "As long as id V is vertex and not input, and id U is edge id V and not trivial id V, and id U is not nfirst id V, then id V is first id V."
        },
        {
            "Category": "Definition When",
            "CNL": "id U is last id V when id V is vertex and also id V is not Input and also id V is not trivial id V and also id U is edge id V and also id U is not nlast id V.",
            "NL": "As long as id V is vertex and not input, and id U is edge id V, and not trivial id V, and id U is not nlast id V, then id U is last id V."
        },
        {
            "Category": "Definition When",
            "CNL": "id U is llabel id V and id S when id U is edge id V and also id U is obs_elabel id V and id S and also id V is not trivial and also id V is not Input.",
            "NL": "When id U is on the edge of id V, id V is not input, id V is not trivial, id U is obs_elabel id V and id S, then id U has llabel id V and id S."
        },
        {
            "Category": "Definition When",
            "CNL": "id U is nfirst id V when id W ntedge id U and id V. ",
            "NL": "When id W is ntedge id U and id V, then there is id U nfirst id V."
        },
        {
            "Category": "Definition When",
            "CNL": "id U is oppo id V when id U llabel id V and id M and also id U has vlabel id S and also id V is not trivial and also id V is not Input and also id U have obs_elabel id V and id P and also id V is vlabel id S. ",
            "NL": "When id U is llabel id V, id M, id U is vlabel id S, id V is not input, id U is obs_elabel id V and id P, id V is vlabel id S, then id U has oppo id V."
        },
        {
            "Category": "Definition When",
            "CNL": "id U is oppo id V when id U llabel id V and id P and also id U has vlabel id S and also id V is not trivial and also id V is not Input and also id U have obs_elabel id V and id M and also id V is vlabel id T, where S is different from T.",
            "NL": "When id U is llabel id V, id P, id U is vlabel id S, id V is not trivial, id V is not input, id U is obs_elabel id V and id M, id V is vlabel id T, then id U has oppo id V."
        },
        {
            "Category": "Definition When",
            "CNL": "id U is reach id V when id U is edge id V and also id V is active and also id V is not trivial.",
            "NL": "When id U is on the edge of id V, id V is active, and id V is not trivial then id U reaches id V."
        },
        {
            "Category": "Definition When",
            "CNL": "id U is reach id W when id U is edge id V and also id V is active and also id V is not trivial and also id U is reach id W and also id W is vertex and also id U is obs_vlabel id P and also id U is obs_vlabel id M. ",
            "NL": "When id U is on the edge of id V, id V is active, id V is not trivial, id U reaches id W, id W is a vertex and id U is not obs_vlabel id P, and id U is not obs_vlabel id M, then id V reaches id W."
        },
        {
            "Category": "Definition When",
            "CNL": "id U is reach id W when id U is edge id V and also id V is active and also id V is not trivial and also id V is reach id W and also id W is vertex.",
            "NL": "When id U is on the edge of id V, id V is active, id V is not trivial, id V is reach id W, and id W is vertex, then id U reaches id W."
        },
        {
            "Category": "Definition When",
            "CNL": "id U llabel id V and id S when id 1 is bot and also id U is edge id V and also id S is sign and also id V is not trivial and also id V is not Input and also id U is obs_elabel id V and id P and also id U is ebs_elabel id V and id M.",
            "NL": "When id 1 is bot, id U is edge id V, id S signs, id V is not trivial, id V is not input, id U is not obs_elabel id V and id P, id U is not obs_elabel id V and id M then id U is llabel id V, and id S."
        },
        {
            "Category": "Definition When",
            "CNL": "id V is active when id V is vertex and also id V is not Input and also id V is not Inactive.",
            "NL": "As long as id V is a vertex and not input, and not an inactive id V, then id V is active."
        },
        {
            "Category": "Definition When",
            "CNL": "id V is aedge when id V is vertex and also id V is not Input and also id V is not trivial and also id V is obs_vlabel id P and also id V is obs_vlabel id M and also id W is active and also id V is edge id W. ",
            "NL": "When id V is vertex, id V is not input, id V is trivial, id V is not obs_vlabel id P, id V is not obs_vlabel id M, and id V is edge id W, then id V has aedge."
        },
        {
            "Category": "Definition When",
            "CNL": "id V is diff id1 V when id V has edge id1 V1 and also id V have obs_elabel id1 V1 and id2 M and also id V have obs_elabel id1 V1 and id2 P.",
            "NL": "When id V has an edge id V, and there are obs_elabel with id V, id1 V and id2 M, and also there is no obs_elabel with id V, id1 V and id2 P, then we has a difference with id V and id1 V."
        },
        {
            "Category": "Definition When",
            "CNL": "id V is Inactive when id V is vertex and also id V is not Input and also id V is not active.",
            "NL": "As long as id V is a vertex and not input, and not an active id V, then id V is inactive."
        },
        {
            "Category": "Definition When",
            "CNL": "id V is Inactive when id V is vertex and also id V is not Input and also id W is active and also id W is trivial, where V is different from W.",
            "NL": "As long as id V is a vertex and not input, id W is active, and trivial id W, and id V is not equal to W, then id V is inactive."
        },
        {
            "Category": "Definition When",
            "CNL": "id V is nontriv when id V is vertex and also id V is not Input and also id U is edge id1 V and also id U is not diff id1 V.",
            "NL": "As long as id V is vertex and not input, and id U is edge id1 V and not diff id1 V, then id V is nontrivial."
        },
        {
            "Category": "Definition When",
            "CNL": "id V is reach id U when id U is edge id V and also id V is active and also id V is not trivial and also id U is obs_vlabel id P and also id U is obs_vlabel id M. ",
            "NL": "When id U is on the edge of id V, id V is active, id V is not trivial, id U is not obs_vlabel id P, and id U is not obs_vlabel id M, then id V reaches id U"
        },
        {
            "Category": "Definition When",
            "CNL": "id V is vlabel id S when id V is vertex and also id V is obs_vlabel id S and also id V is not trivial and also id V is not Input. ",
            "NL": "When id V is vertex, id V is not input, id V is not trivial, id V is obs_vlabel id S, then id V has vlabel id S."
        },
        {
            "Category": "Definition When",
            "CNL": "id V vlabel id S when id 1 is bot and also id U is edge id V and also id S is sign and also id V is not trivial and also id V is not Input and also id U is obs_vlabel id P and also id U is obs_vlabel id M.",
            "NL": "When id 1 is bot, id U is edge id V, id S signs, id V is not trivial, id V is not input, id U is obs_vlabel id P, id U is not obs_vlabel id M then id U is vlabel is S."
        },
        {
            "Category": "Definition When",
            "CNL": "id V vlabel id S when id 1 is bot and also id V is vertex and also id S is sign and also id V is not trivial and also id V is not Input and also id V is obs_vlabel id P and also id V is obs_vlabel id M.",
            "NL": "When id 1 is bot, id V is vertex, id S signs, id V is not trivial, id V is not input, id V is not obs_vlabel id P, id V is not obs_vlabel id M then id V is vlabel is S."
        },
        {
            "Category": "Definition When",
            "CNL": "id W is btedge id U and id V when id V is vertex and also id V is not Input and also id V is not Trivial id V and also id W is edge id V and also id U edge id V and also id Z edge id V, where W is less than Z and Z is less than U. ",
            "NL": "When id V is vertex, id W is edge id V, id V is not input, id V is not trivial, id U is edge id V, where Z is greater than W and less than U then we has a btedge with id W, id1 U, and id2 V."
        },
        {
            "Category": "Definition When",
            "CNL": "id W is nlast id V when id W ntedge id U and id V.",
            "NL": "When id W is ntedge id U and id V, then there is id W nlast id V."
        },
        {
            "Category": "Definition When",
            "CNL": "id W is ntedge id U and id V when id V is vertex and also id V is not Input and also id V is not trivial and also id W is edge id V and also id U edge id V and also id W is not btedge id U and id V, where W is less than U.",
            "NL": "When id V is vertex, id W is edge id V, id V is not input, id V is not trivial, id U is edge id V, where Z is less than U then we has a ntedge with id W, id1 U, and id2 V."
        },
        {
            "Category": "Definition When",
            "CNL": "id W mvlabel id U and id M when id U is edge id V and also id W is active and also id V is not trivial and also id W is not trivial and also id V is active and also id V is reach id W and also id W is reach id V and also id W is mvlabel id U and id P, where W is different from V.",
            "NL": "When id U is edge id V, id W is active, id V is not trivial, id W is not trivial, id V is active, id V is reach id W, id W is reach id V, where id W is not equal to id V, and id W is not mvlabel id V and id P then id W is mvlabel id U, and id M."
        },
        {
            "Category": "Definition When",
            "CNL": "id W mvlabel id U and id P when id U is edge id V and also id W is active and also id V is not trivial and also id W is not trivial and also id V is active and also id V is reach id W and also id W is reach id V and also id W is mvlabel id U and id M, where W is different from V.",
            "NL": "When id U is edge id V, id W is active, id V is not trivial, id W is not trivial, id V is active, id V is reach id W, id W is reach id V, where id W is not equal to id V, and id W is not mvlabel id V and id M then id W is mvlabel id U, and id P."
        },
        {
            "Category": "Definition When",
            "CNL": "id W mvlabel id U and id S when id U is obs_vlabel id S and also id U edge id V and also id W is vertex and also id V is not trivial and also id W is not trivial and also id V is not Input and also id W is not Input, where W is different from V.",
            "NL": "When id V is obs_vlabel id S, id U is edge id V, id W is vertex, id V is not trivial, id W is not trivial, id V is not input, id W is input where id W is not equal to id V, then id W is mvlabel id U, and id S."
        },
        {
            "Category": "Definition When",
            "CNL": "id W mvlabel id V and id M when id W is active and also id V is not trivial and also id W is not trivial and also id V is active and also id W is reach id V and also id V is reach id W and also id W is mvlabel id V and id P, where W is different from V. ",
            "NL": "When id W is active, id V is not trivial, id W is not trivial, id V is active, id V is reach id W, id W is reach id V, where id W is not equal to id V, and id W is mvlabel id V and id P then id W is mvlabel id V, and id M."
        },
        {
            "Category": "Definition When",
            "CNL": "id W mvlabel id V and id P when id W is active and also id V is not trivial and also id W is not trivial and also id V is active and also id W is reach id V and also id V is reach id W and also id W is mvlabel id V and id M, where W is different from V. ",
            "NL": "When id W is active, id V is not trivial, id W is not trivial, id V is active, id V is reach id W, id W is reach id V, where id W is not equal to id V, and id W is not mvlabel id V and id M, then id W is mvlabel id V, and id P."
        },
        {
            "Category": "Definition When",
            "CNL": "id W mvlabel id V and id S when id V is obs_vlabel id S and also id W is vertex and also id V is not trivial and also id W is not trivial and also id V is not Input and also id W is not Input, where W is different from V.",
            "NL": "When id V is obs_vlabel id S, id W is vertex, id V is not trivial, id W is not trivial, id V is not input, where id W is not equal to id V, then id W is mvlabel id V, and id S."
        },
        {
            "Category": "Definition When",
            "CNL": "list 1 has an asgn to list A when list A is fstatom.",
            "NL": "There is an asgn between list 1 and list A when list A is fstatom."
        },
        {
            "Category": "Definition When",
            "CNL": "list 2N-1 is node when list N is Atomcnt.",
            "NL": "A node is a list 2N-1 if a list N is an Atomcnt."
        },
        {
            "Category": "Definition When",
            "CNL": "list E is proj when list E has a member to E, and L.",
            "NL": "A list E is a project if it has a member from both E and L."
        },
        {
            "Category": "Definition When",
            "CNL": "list L is assigned when list X has an asgn list L and also list L is comp.",
            "NL": "List L is assigned when list X has an asgn list L and list L is also a comp list."
        },
        {
            "Category": "Definition When",
            "CNL": "list L is sublist list1 L when list L is comp.",
            "NL": "When list L is a comp, list L is a sublist of list1 L."
        },
        {
            "Category": "Definition When",
            "CNL": "list N-1 has an asgn to list B when list N has an asgn list A and also list A have a nxtatom list B.",
            "NL": "When list N has an asgn list A and list A has a nxtatom list B, list N-1 has an asgn to list B."
        },
        {
            "Category": "Definition When",
            "CNL": "list N-1 is node when list N is node, where N is greater than 1.",
            "NL": "There is a node in the list N-1 when N is greater than 1, where N is the number of nodes."
        },
        {
            "Category": "Definition When",
            "CNL": "list X has a denied list L when list X has an edge list L and also list L have a comp and also list Y have a reach list L.",
            "NL": "There is a denied list X in list L when list X has an edge list Y, and list L has a complete as well as a reach list Y in list L."
        },
        {
            "Category": "Definition When",
            "CNL": "list X has a pair to list Y when list X is node and also list Y is node and also list N is Atomcnt, where X is greater than Y and X is greater than N.",
            "NL": "There is a pair between list X and list Y when list X is a node and list Y is a node and list N is an Atomcnt, where X is greater than Y and X is greater than N."
        },
        {
            "Category": "Definition When",
            "CNL": "list X has a reach list A when list X have a asgn list A.",
            "NL": "There is a reach list X on list A when there is an asgn list X on list A."
        },
        {
            "Category": "Definition When",
            "CNL": "list X has a reach list A when list Y has a reach list A and also list X has an edge list Y.",
            "NL": "There is a reach list X in list A when list Y has a reach list A, as well as an edge list X in list Y."
        },
        {
            "Category": "Definition When",
            "CNL": "list X has a transs to list Y when list X has a transs list Z and also list Z has an edge list Y.",
            "NL": "When list X has a trans to list Z, and also list Z has an edge to list Y, then list X has a trans to list Y."
        },
        {
            "Category": "Definition When",
            "CNL": "list X have a next list A when list A have member list L and also list X have an edge list Y and also list Y have an asgn list A.",
            "NL": "List X has a next list A when list A has a member list L and list X has an edge list Y when list Y has an asgn list A."
        },
        {
            "Category": "Definition When",
            "CNL": "list X have a transs to list Y when list X have an edge list Y and also list X is node. ",
            "NL": "There is a trans between list X and list Y when list X has an edge over list Y and also has nodes in list X+1."
        },
        {
            "Category": "Definition When",
            "CNL": "list X have an asgn to list L when list X has a haschild and also list L has a comp and also list X have not denied list L. ",
            "NL": "When list X has a haschild and list L has a comp and list X has not denied list L, an asgn is made between list X and list L."
        },
        {
            "Category": "Definition When",
            "CNL": "list X is Acnt list 1 when list X is Atom.",
            "NL": "When list X is Atom, list X is Acnt list 1."
        },
        {
            "Category": "Definition When",
            "CNL": "list X is Atom when list X is proj and also list X is not comp.",
            "NL": "List X is Atom when it is a project and also when it is not a component."
        },
        {
            "Category": "Definition When",
            "CNL": "list X is outgroup when list Y has an asgn list outgroup and also list X has an edge list Y.",
            "NL": "When list Y has an asgn list outgroup and list X has an edge list Y, then list X is an outgroup."
        },
        {
            "Category": "Definition When",
            "CNL": "list Y have a order to list Z when list X have an edge list Y and also list X have a edge list Z and also list N is Atomcnt, where N is less than Z and Z is less than Y.",
            "NL": "There is an order between list Y and list Z when list X has an edge list Y, and list X also has an edge list Z, and list N is Atomcnt, where N is less than Z and Z is less than Y."
        },
        {
            "Category": "Definition When",
            "CNL": "node C okin node X when node C have not in node X and also node C pair node X. ",
            "NL": "It is evident that node C pairs with node X when node C does not have IN node X, as well as when node C does not have Okin node X."
        },
        {
            "Category": "Definition When",
            "CNL": "node C1 cex node C2 when node X has a member node X and node C1 and also node C2 is clique and also node X not member node X and node C2. ",
            "NL": "Node C1 CEX node C2 when node X has a member with node C1, and node C2 is also a clique and node X, not a member with node C2."
        },
        {
            "Category": "Definition When",
            "CNL": "node C1 rest node X and node C2 when node X has a member node C1 and also node C2 has a subeq node C1 and also node C1 have an cliquesize node S and also node C2 have an cliquesize node S-1, where S is greater than 1.",
            "NL": "Node C1 rests on node X and node C2, if node X has a member node C1 and node C2 has a subeq node C1 and node C1 has a cliquesize node S and node C2 has a cliquesize node S-1, where S is greater than 1."
        },
        {
            "Category": "Definition When",
            "CNL": "node C1 subseq node C2 when node C1 is clique and also node C2 is clique and also node C1 is not cex node C2.",
            "NL": "There is a subsequence between node C1 and node C2 when node C1 is a clique and node C2 is a clique and node C1 is not a CEX node C2."
        },
        {
            "Category": "Definition When",
            "CNL": "node P diffpen node X when node C has an in node X and also node C penalty node X and node P and also node P not minpen node X. ",
            "NL": "Node P has a diffpen node X when node C has an IN node X as well as node C is penalty node X and node P does not has a minpen node X."
        },
        {
            "Category": "Definition When",
            "CNL": "node P1 diffpen node X when node P2 diffpen node X and also node P1 nextpen node P2 and node X and also node P1 not minpen node X.",
            "NL": "Node P1 diffpen node X when node P2 diffpen node X, and also node P1 nextpen node P2, and node X, and also node P1 is not the minpen node X."
        },
        {
            "Category": "Definition When",
            "CNL": "node R aux node Y when node C have an aux node Y and also node C rest node Z and node R and also node R not cliquesize node 1.",
            "NL": "Node R has an aux node Y when node C does not has an aux node Y and also node C rests under node Z and node R is not cliqued to node 1."
        },
        {
            "Category": "Definition When",
            "CNL": "node R aux node Y when node R has an in node Y and also node R not cliquesize node 1.",
            "NL": "The node R aux the node Y if node R has an IN node Y, not if node R is the cliquesize node 1."
        },
        {
            "Category": "Definition When",
            "CNL": "node X is ok when node X have an oktr node C and node Y and also field1 X not pred field2 C and field3 Y.",
            "NL": "In this case, node X is OK if it has an oktr node C and node Y and field1 X, but not a predicted field2 C and field3 Y."
        },
        {
            "Category": "Definition When",
            "CNL": "node X is reached when node X has a start.",
            "NL": "The node X is reached when the node X has started."
        },
        {
            "Category": "Definition When",
            "CNL": "node X is reached when node Y is reached and also node Y has an inPath node X.",
            "NL": "A node X is reached when node Y is reached, and also node Y has an inPath to node X."
        },
        {
            "Category": "Definition When",
            "CNL": "Node X is uconnected to Node Y when node X is adjacent to node Y, where X is less than Y. ",
            "NL": "There is a condition in which node X is unconnected from node Y when node X is adjacent to node Y, and X is less than Y."
        },
        {
            "Category": "Definition When",
            "CNL": "Node X is uedge Node Y when node X has an edge node Y, where X is less than Y. ",
            "NL": "There is a condition in which node X is uedge from node Y when node X is edge to node Y, and X is less than Y."
        },
        {
            "Category": "Definition When",
            "CNL": "node X oktr node C2 and node Y2 when node X has a next node C1 and node Y1 and also node X oktr node C1 and node Y1 and also node C2 okin node Y2.",
            "NL": "A node X will oktr node C2 and node Y2 when node X has a next node C1 and a node Y1, and node X will also oktr node C1 and node Y1 and node C2 will okin node Y2."
        },
        {
            "Category": "Definition When",
            "CNL": "Node Y is uconnected to Node X when node X is adjacent to node Y, where Y is less than X. ",
            "NL": "There is a condition in which node Y is unconnected from node X when node X is adjacent to node Y, and Y is less than X."
        },
        {
            "Category": "Definition When",
            "CNL": "Node Y is uedge Node X when node X have an edge node Y, where Y is less than X. ",
            "NL": "There is a condition in which node Y is uedge from node X when node X is edge to node Y, and Y is less than X."
        },
        {
            "Category": "Definition When",
            "CNL": "point Y is visit when point X is road point Y and also point X is start.",
            "NL": "Point Y is visited when point X is the road to point Y and point X is the starting point."
        },
        {
            "Category": "Definition When",
            "CNL": "point Y is visit when point X is road point Y and also point X is visit.",
            "NL": "Point Y is visited when point X is the road to point Y and point X is the visiting point."
        },
        {
            "Category": "Definition When",
            "CNL": "tree X is haschild when tree X has an edge to Y.",
            "NL": "A tree X is said to be a haschild when it has an edge over another tree Y."
        },
        {
            "Category": "Definition When",
            "CNL": "tree X is hasparent when tree Y has an edge to X.",
            "NL": "When tree Y has an edge to tree X, tree X is hasparent."
        },
        {
            "Category": "Definition When",
            "CNL": "value C1 have an index value 1 when value C1 is colour and also value C1 is not later.",
            "NL": "A value C1 has an index value 1 when the value C1 is a colour, as well as when the value C1 is not later."
        },
        {
            "Category": "Definition When",
            "CNL": "value C1 have colourss value C2 when value C1 is colourss and also value C2 is colourss, where C1 is less than C2.",
            "NL": "The value C1 has the colours value C2, if value C1 colours, and if value C2 colours, where C1 is less than C2."
        },
        {
            "Category": "Definition When",
            "CNL": "value C1 have next value C2 when value C1 is colourss value C2 and also value C1 have not notnext value C2.",
            "NL": "When value C1 is colour value C2, and also value C1 is not notnext value C2, then value C1 does have next value C2."
        },
        {
            "Category": "Definition When",
            "CNL": "value C1 have notnext value C3 when value C1 is colourss value C2 and also value C2 is colourss value C3.",
            "NL": "When value C1 is colour value C2, and also value C2 is colour value C3, then value C1 does not next value C3."
        },
        {
            "Category": "Definition When",
            "CNL": "value C2 is later when value C1 have a next value C2.",
            "NL": "A value C2 is later when a value C1 has a next value C2."
        },
        {
            "Category": "Definition When",
            "CNL": "value N is chosenColour value C when value N is node and also value C is index value I and also value N is not notChosenColour value C, where I is less than or equal to N.",
            "NL": "When value N is a node, value C is an index value I, and value N is not notChosenColour value C, where I is less than or equal to N, value N is chosenColour value C."
        },
        {
            "Category": "Definition When",
            "CNL": "value N is colored when value N has chosencolour value C.",
            "NL": "When value N has chosencolor value C, value N is colored."
        },
        {
            "Category": "Definition When",
            "CNL": "value N is notChosenColour value C when value N is chosenColour value CC and also value C is index value I, where I is less than or equal to N and C is different from CC.",
            "NL": "The value N is notchosenColor value C when the value N is chosenColor value CC, and the value C is also an index value I, where I is less than or equal to N and C is not equal to CC."
        },
        {
            "Category": "Definition When",
            "CNL": "value N is notChosenColour value C when value NN is chosencolour value C and also value NN is link value N, where NN is less than N.",
            "NL": "When value NN is chosencolour value C, and also when value NN is link value N, where NN is less than N, value N is notChosenColour value C."
        },
        {
            "Category": "Definition When",
            "CNL": "value N1 is inorder value N2 when value N1 has a compare value N2 and also value L have a gt value N2 and value P and also value L have a not gt value N1 and value P.",
            "NL": "When value N1 has a compare value N2 and value L has a gt value N2 and value P and also value L has a not gt value N1 and value P, value N1 is inorder value N2."
        },
        {
            "Category": "Definition When",
            "CNL": "value N2 is compare value N4 when value N2 has a edge_paired value N4, where N2 is less than N4.",
            "NL": "When value N2 has an edge_paired value N4, and N2 is less than N4, value N2 is compared to value N4."
        },
        {
            "Category": "Definition When",
            "CNL": "value N4 is compare value N2 when value N2 has an edge_paired value N4, where N4 is less than N2.",
            "NL": "When value N2 has an edge_paired value N4, and N4 is less than N2, value N4 is compared to value N2."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex B is bucket vertex Z when vertex B is bucket vertex Y and also vertex Z is not Abss and also vertex Y is edge vertex Z. ",
            "NL": "The vertex B is bucket vertex Z when the vertex B is bucket vertex Y, as well as the vertex Z is not Abss and the vertex Y is the edge vertex Z."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex B is bucket vertex Z when vertex B is bucket vertex Y and also vertex Z is not Abss and also vertex Z is edge vertex Y.",
            "NL": "The vertex B is bucket vertex Z when the vertex B is bucket vertex Y, as well as the vertex Z is not Abss and the vertex Z is the edge vertex Y."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex V is No_In vertex V2 when vertex V is In vertex V1 and also vertex V2 is vertex, where V1 is different from V2.",
            "NL": "If vertex V is in vertex V1 and vertex V2 is vertex, where V1 differs from V2, then vertex V is No_In vertex V2."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex V is no_reached when vertex V is vertex and also vertex V is not reached.",
            "NL": "A vertex V is no_reached when vertex V is vertex, as well as when vertex V is not reached."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex V2 is No_In vertex V when vertex V1 is In vertex V and also vertex V2 is vertex, where V1 is different from V2.",
            "NL": "If vertex V1 is in vertex V and vertex V2 is vertex, where V1 differs from V2, then vertex V2 is No_In vertex V."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex V2 is reached when vertex V1 is Init and also vertex V1 is In vertex V2.",
            "NL": "A vertex V2 is reached when vertex V1 is init, as well as when vertex V1 is IN a vertex V2."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex V2 is reached when vertex V1 is reached and also vertex V1 is In vertex V2.",
            "NL": "A vertex V2 is reached when vertex V1 is reached, as well as when vertex V1 is IN a vertex V2."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex W is r vertex V and id W when vertex V is In and also vertex V is edge vertex W and also vertex W is In.",
            "NL": "The vertex W is the r vertex V and the id W when the vertex V is in, as well as the vertex V is the edge vertex W when the vertex W is in."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex X is bucket id X when vertex X is edge vertex _ and also vertex X is not Abss.",
            "NL": "There is a bucket id X associated with vertex X when it is edge vertex next, as well as when vertex X is not Abss."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex X is clique when vertex X is node and also vertex X is not nonClique.",
            "NL": "When vertex X is a node and also vertex X is not nonClique, then vertex X is a clique."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex X is In when vertex V is In and also vertex V is edge vertex W and also vertex W is In.",
            "NL": "Vertex X is IN when vertex X is not Abs and vertex X is P."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex X is nonclique when vertex X is node and also vertex X is not Clique.",
            "NL": "When vertex X is a node and also vertex X is not Clique, then vertex X is a nonclique."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex X is parent vertex Y when vertex X is not Abss and also vertex Y is not Abss and also vertex X is edge vertex Y and also vertex Y is not parent vertex X.",
            "NL": "Vertex X is a parent vertex Y when both vertex X and vertex Y are not Abss and when vertex X is an edge vertex Y and vertex Y is not a parent vertex X."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex X is r vertex V and vertex W when vertex Y is In and also vertex Y is edge vertex X and also vertex Y is r vertex V and id W, where X is different from V.",
            "NL": "Essentially, vertex X corresponds to r vertex V and vertex W when vertex Y is in, and also vertex Y corresponds to edge vertex X and also vertex Y corresponds to r vertex V and id W, where X is different from V."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex X is r vertex V and vertex W when vertex Y is In and also vertex Y is edge vertex X and also vertex Y is r vertex V and id W, where Y is different from W.",
            "NL": "Essentially, vertex X corresponds to r vertex V and vertex W when vertex Y is in, and also vertex Y corresponds to edge vertex X and also vertex Y corresponds to r vertex V and id W, where Y is different from W."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex X is r vertex Y when vertex X is parent vertex Y.",
            "NL": "When vertex X is parent vertex Y, then vertex X is the r vertex Y."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex X is r vertex Y when vertex X is r vertex Z and also vertex Z is parent vertex Y.",
            "NL": "Vertex X is an r vertex Y when vertex X is an r vertex Z and also when vertex Z is the parent vertex Y."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx C is clique when vtx C pair vtx X.",
            "NL": "A clique C exists when vertex C pairs with vertex X."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx C pair vtx X when vtx C have an penalty to X, and P.",
            "NL": "The vertex C pairs with the vertex X when the vertex C has a penalty to X and P."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx K has a reach vtx U when vtx U has a partition vtx K and also vtx U have a not existslesss vtx K.",
            "NL": "There is a reach between vertex U and vertex K when vertex U has a partition with vertex K, as well as a not existsless vertex U and vertex K."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx K has a reach vtx V when vtx U uedge vtx V and also vtx K reach vtx U and also vtx V partition vtx K.",
            "NL": "The vertex K reaches vertex V when vertex U has an uedge vertex V and there is a reach with vertex K and vertex U also there is a partition between vertex V and vertex K."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx K has a reach vtx V when vtx V uedge vtx U and also vtx K reach vtx U and also vtx V partition vtx K.",
            "NL": "The vertex K reaches vertex V when vertex V has an uedge vertex U and there is a reach with vertex K and vertex U also there is a partition between vertex V and vertex K."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx U has a reach vtx V when vtx U has an used_edge vtx V.",
            "NL": "The vertex U has a reach vertex V when the vertex U has an used_edge vertex V."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx U has a reach vtx V when vtx U have a used_edge vtx U and also vtx Z has a reach vtx V, where U is different from V.",
            "NL": "Vertex U has a reach vertex V when vertex U has an used_edge vertex Z, and vertex Z has a reach vertex V when U differs from V."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx U has an u_edge vtx V and vtx W when vtx U have uedge vtx V and also vtx U have weight_wtedge vtx V and vtx W.",
            "NL": "Vertex U has an uedge vertex V and weight W when vertex U has an uedge vertex V and also vertex U has a weight_wtedge vertex V and weight W."
        },
        {
            "Category": "Definition When",
            "CNL": "Vtx U has an uedge to Vtx V when Vtx U has an edge to V, where U is less than V. ",
            "NL": "There is a condition in which node U is uedge from node V when node U is edge to node V, and U is less than V."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx U have a existslesss vtx K when vtx U has a partition vtx K and also vtx V has a partition vtx K and also vtx V is Vtx, where V is less than U.",
            "NL": "A vertex U has an existless vertex K when it has a partition vertex K, and also vertex V has a partition vertex K, and also vertex V is Vtx, where V is less than U."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx U have a u_edge vtx V and vtx W when vtx U have uedge vtx V and also vtx V have weight_wtedge vtx U and vtx W.",
            "NL": "Vertex U has an uedge vertex V and weight W when vertex U has an uedge vertex V and also vertex V has a weight_wtedge vertex U and weight W."
        },
        {
            "Category": "Definition When",
            "CNL": "Vtx U have an uedge to Vtx V when Vtx V has an edge to U, where U is less than V. ",
            "NL": "There is a condition in which node U is uedge from node V when node V is edge to node U, and U is less than V."
        },
        {
            "Category": "Definition When",
            "CNL": "Vtx U have an used_edge to Vtx V when Vtx U is dom and also Vtx V is dom and also Vtx U has an uedge to V.",
            "NL": "A used_edge exists between vertex U and vertex V when vertex U is dominant, as well as an uedge between vertex U and vertex V when vertex U is dominant."
        },
        {
            "Category": "Definition When",
            "CNL": "Vtx U have an used_edge to Vtx V when Vtx U is dom and also Vtx V is dom and also Vtx V have an uedge to U.",
            "NL": "A used_edge exists between vertex U and vertex V when vertex U is dominant, as well as an uedge between vertex V and vertex U when vertex U is dominant."
        },
        {
            "Category": "Definition When",
            "CNL": "Vtx U reach Vtx V when Vtx U has an used_edge to Z and also Vtx Z reach Vtx V, where U is different from V.",
            "NL": "The vertex U reaches a vertex V when a vertex U has an used_edge to Z and a vertex Z reaches a vertex V when U is not equal to V."
        },
        {
            "Category": "Definition When",
            "CNL": "Vtx U reach Vtx V when Vtx U have an used_edge to V.",
            "NL": "The vertex U reaches the vertex V when the vertex U has an used_edge to the vertex V."
        },
        {
            "Category": "Definition When",
            "CNL": "Vtx V is considered when Vtx U has an uedge to V and also Vtx U is dom.",
            "NL": "A vertex V is considered when vertex U has an uedge to vertex V, and if vertex U is dominating."
        },
        {
            "Category": "Definition When",
            "CNL": "Vtx V is considered when Vtx V has an uedge to U and also Vtx U is dom.",
            "NL": "A vertex V is considered when vertex V has an uedge to vertex U, and if vertex U is dominating."
        },
        {
            "Category": "Definition When",
            "CNL": "Vtx V is considered when Vtx V is dom.",
            "NL": "Vertex V gets considered when it dominates."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx V is reached when vtx U has a reach vtx V.",
            "NL": "The vertex V is reached when the vertex U reaches the vertex V."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx V is reached when vtx U is reached and also vtx U have a link vtx V.",
            "NL": "A vertex V is reached when a vertex U has been reached, and a vertex U has a link to a vertex V."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx V is reached when vtx U is reached and also vtx V have a link vtx U.",
            "NL": "A vertex V is reached when a vertex U has been reached, and a vertex V has a link to a vertex U."
        },
        {
            "Category": "Definition When",
            "CNL": "Vtx V is reached when Vtx U reach Vtx V.",
            "NL": "The vertex V is reached when the vertex U reaches the vertex V."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx X have a hc vtx Y when vtx X have a in_hm vtx Y and also vtx X has an edge vtx Y.",
            "NL": "The vertex X has a HC vertex Y when the vertex X has an in_hm vertex Y and also when the vertex X has an edge vertex Y."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx X have a hc vtx Y when vtx Y have a in_hm vtx X and also vtx X have a edge vtx Y.",
            "NL": "The vertex X has a HC vertex Y when the vertex Y has an in_hm vertex X and also when the vertex X has an edge vertex Y."
        },
        {
            "Category": "Definition When",
            "CNL": "Vtx X have an arc to Vtx Y when Vtx X has an edge to Y.",
            "NL": "The vertex X has an arc to the vertex Y while the vertex X has an edge to the vertex Y."
        },
        {
            "Category": "Definition When",
            "CNL": "Vtx X is reached when Vtx Dummy has an inpath vtx X.",
            "NL": "The vertex X is reached when the vertex Dummy has an inpath to the vertex X."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx X is var when vtx C pair vtx X.",
            "NL": "A variable C exists when vertex C pairs with vertex X."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx X triple vtx C and vtx Y when vtx C have an pair vtx Y and also vtx X have an member vtx C and also vtx X is var, where Y is different from X.",
            "NL": "The vertex X has a triple vertex C and vertex Y when vertex C has a pair vertex Y whereas vertex X has a member vertex C and vertex X is variable, where Y is different from X."
        },
        {
            "Category": "Definition When",
            "CNL": "Vtx Y has an arc to Vtx X when Vtx X has an edge to Y.",
            "NL": "The vertex Y has an arc to the vertex X while the vertex X has an edge to the vertex Y."
        },
        {
            "Category": "Definition When",
            "CNL": " id U is diff id1 V when id U has an edge id1 V and also id U obs_elabel id1 V and id3 P and also id U obs_elabel id1 V and id3 M and also id U have obs_vlabel id1 S and also id V is obs_vlabel id1 T, where S is different from T.",
            "NL": "If there is an edge between id U and id V, and there is an obs_elabel with id U, id1 V and id2 P, but not with id U, id1 V and id2 M, and there is an obs_vlabel with id U and id1 S as well as an obs_vlabel with id V and id1 T, where S is not equal to T, then we can observe a difference between id U and id1 V."
        },
        {
            "Category": "Definition When",
            "CNL": " id U is diff id1 V when id U has an edge id1 V and also id U obs_elabel id1 V and id3 P and also id U obs_elabel id1 V and id3 M and also id U have obs_vlabel id1 S and also id V is obs_vlabel id1 T, where S is different from T.",
            "NL": "If id U has an edge id V, and there is an obs_elabel with id U, id1 V and id2 P, but no obs_elabel with id U, id1 V and id2 M, and there are also obs_vlabel with id U and id1 S and with id V and id1 T, where S is not equal to T, then we can see a difference between id U and id1 V."
        },
        {
            "Category": "Definition When",
            "CNL": " id U is diff id1 V when id U has an edge id1 V and also id U obs_elabel id1 V and id3 P and also id U obs_elabel id1 V and id3 M and also id U have obs_vlabel id1 S and also id V is obs_vlabel id1 T, where S is different from T.",
            "NL": "If there is an edge between nodes U and V, and there is an observation of type obs_elabel with nodes U, V and P, but no observation of type obs_elabel with nodes U, V and M, and there are observations of type obs_vlabel with nodes U and S, and observations of type obs_vlabel with nodes V and T, where S is not equal to T, then there is a difference between nodes U and V."
        },
        {
            "Category": "Definition When",
            "CNL": " id U is diff id1 V when id U has an edge id1 V and also id U obs_elabel id1 V and id3 P and also id U obs_elabel id1 V and id3 M and also id U have obs_vlabel id1 S and also id V is obs_vlabel id1 T, where S is different from T.",
            "NL": "If the edge between id U and id V exists, there is an obs_elabel with id U, id1 V and id2 P but not with id U, id1 V and id2 M, and there are two distinct obs_vlabel for id U and id1 S and id V and id1 T, then there is a difference between id U and id V."
        },
        {
            "Category": "Definition When",
            "CNL": " id U is diff id1 V when id U has an edge id1 V and also id U obs_elabel id1 V and id3 P and also id U obs_elabel id1 V and id3 M and also id U have obs_vlabel id1 S and also id V is obs_vlabel id1 T, where S is different from T.",
            "NL": "If id U has an edge id V, and there are obs_elabel with id U, id1 V and id2 P, but no obs_elabel with id U, id1 V and id2 M, and there are also obs_vlabel with id U and id1 S and obs_vlabel with id V and id1 T, where S is not equal to T, then there is a difference between id U and id1 V."
        },
        {
            "Category": "Definition When",
            "CNL": " id U is vlabel id S when id U is edge id V and also id U is obs_vlabel id S and also id V is not trivial and also id V is not Input.",
            "NL": "If U is at the brink of V, which is not trivial and not input, U has the label S."
        },
        {
            "Category": "Definition When",
            "CNL": " id U is vlabel id S when id U is edge id V and also id U is obs_vlabel id S and also id V is not trivial and also id V is not Input.",
            "NL": "If id U is on the brink of id V, which is not straightforward and not insignificant, then id U is observed to have vlabel id S."
        },
        {
            "Category": "Definition When",
            "CNL": " id U is vlabel id S when id U is edge id V and also id U is obs_vlabel id S and also id V is not trivial and also id V is not Input.",
            "NL": "When id U is on the brink of id V, which is neither input nor trivial, then id U has been assigned the vlabel of id S."
        },
        {
            "Category": "Definition When",
            "CNL": " id U is vlabel id S when id U is edge id V and also id U is obs_vlabel id S and also id V is not trivial and also id V is not Input.",
            "NL": "If id U is on the brink of id V, which is neither input nor trivial, then id U is given the vlabel id S."
        },
        {
            "Category": "Definition When",
            "CNL": " id U is vlabel id S when id U is edge id V and also id U is obs_vlabel id S and also id V is not trivial and also id V is not Input.",
            "NL": "If id U is at the brink of id V, where id V is not straightforward and requires input, then id U has the vlabel id S."
        },
        {
            "Category": "Definition When",
            "CNL": " id V is trivial when id V is vertex and also id V is not Input and also id V is not nonTriv.",
            "NL": "A trivial vertex with id V is one that is not an input with id V, nor a nontrivial one with the same identifier."
        },
        {
            "Category": "Definition When",
            "CNL": " id V is trivial when id V is vertex and also id V is not Input and also id V is not nonTriv.",
            "NL": "A trivial vertex with id V is one that is not an input or a nontrivial one with the same id."
        },
        {
            "Category": "Definition When",
            "CNL": " id V is trivial when id V is vertex and also id V is not Input and also id V is not nonTriv.",
            "NL": "A trivial vertex with ID V is one that is not an input or a nontrivial vertex with the same ID."
        },
        {
            "Category": "Definition When",
            "CNL": " id V is trivial when id V is vertex and also id V is not Input and also id V is not nonTriv.",
            "NL": "A trivial vertex with id V is one that is not an input with id V or a nontrivial with id V."
        },
        {
            "Category": "Definition When",
            "CNL": " id V is trivial when id V is vertex and also id V is not Input and also id V is not nonTriv.",
            "NL": "A trivial vertex with ID V is one that is not an input or a nontrivial one with that same ID."
        },
        {
            "Category": "Definition When",
            "CNL": " list X is outgroup when list X have an asgn list outgroup and also list N is Atomcnt, where N is less than X.",
            "NL": "If list X is part of an ASGN list outgroup and list N is part of an atomcnt, where N is less than X, then X is considered an outgroup."
        },
        {
            "Category": "Definition When",
            "CNL": " list X is outgroup when list X have an asgn list outgroup and also list N is Atomcnt, where N is less than X.",
            "NL": "If list X is part of an ASGN list outgroup and list N, with N being less than X, is part of an atomcnt, then it is considered an outgroup."
        },
        {
            "Category": "Definition When",
            "CNL": " list X is outgroup when list X have an asgn list outgroup and also list N is Atomcnt, where N is less than X.",
            "NL": "If list X is part of an ASGN list outgroup and list N is part of an atomcnt, with N being less than X, then it is seen as an outgroup."
        },
        {
            "Category": "Definition When",
            "CNL": " list X is outgroup when list X have an asgn list outgroup and also list N is Atomcnt, where N is less than X.",
            "NL": "If list X is part of an ASGN list outgroup and list N, which is less than X, is part of an atomcnt, then it is considered an outgroup."
        },
        {
            "Category": "Definition When",
            "CNL": " list X is outgroup when list X have an asgn list outgroup and also list N is Atomcnt, where N is less than X.",
            "NL": "If list X is part of an ASGN list outgroup and list N is part of an atomcnt, with N being smaller than X, then it is seen as an outgroup."
        },
        {
            "Category": "Definition When",
            "CNL": " node C okin node X when node C has an in node X and also node X have an ok and also node C have an pair node X.",
            "NL": "If node C has an in node X and node X is ok, and node C also has a pair node X, then node C is compatible with node X."
        },
        {
            "Category": "Definition When",
            "CNL": " node C okin node X when node C has an in node X and also node X have an ok and also node C have an pair node X.",
            "NL": "If node C has a connection to node X and node X is functioning properly, then node C is compatible with node X."
        },
        {
            "Category": "Definition When",
            "CNL": " node C okin node X when node C has an in node X and also node X have an ok and also node C have an pair node X.",
            "NL": "If node C is connected to node X and node X is functioning properly, then node C is compatible with node X."
        },
        {
            "Category": "Definition When",
            "CNL": " node C okin node X when node C has an in node X and also node X have an ok and also node C have an pair node X.",
            "NL": "If node C is connected to node X, and node X is in a good state, and node C is paired with node X, then node C is in agreement with node X."
        },
        {
            "Category": "Definition When",
            "CNL": " node C okin node X when node C has an in node X and also node X have an ok and also node C have an pair node X.",
            "NL": "If node C is connected to node X, and node X is functioning properly, then node C is compatible with node X."
        },
        {
            "Category": "Definition When",
            "CNL": " node X oktr node C1 and node Y1 when field1 X have an triple field2 C1 and field3 Y1 and also node C1 okin node Y1 and also field1 X not succ field2 C1 and field3 Y1. ",
            "NL": "When field1 X has a triple field2 C1 and field3 Y1, the node X okays both the node C1 and node Y1, but if field1 X fails in field2 C1 and field3 Y1, node C1 will not be able to okay node Y1."
        },
        {
            "Category": "Definition When",
            "CNL": " node X oktr node C1 and node Y1 when field1 X have an triple field2 C1 and field3 Y1 and also node C1 okin node Y1 and also field1 X not succ field2 C1 and field3 Y1. ",
            "NL": "Node X attempts to approve both node C1 and node Y1 when field1 X has a triple field2 C1 and field3 Y1, and node C1 approves node Y1; however, field1 X does not succeed in field2 C1 and field3 Y1."
        },
        {
            "Category": "Definition When",
            "CNL": " node X oktr node C1 and node Y1 when field1 X have an triple field2 C1 and field3 Y1 and also node C1 okin node Y1 and also field1 X not succ field2 C1 and field3 Y1. ",
            "NL": "When node X attempts to approve both node C1 and node Y1, but fails to do so due to field1 X not having a triple field2 C1 and field3 Y1, node C1 still manages to approve node Y1."
        },
        {
            "Category": "Definition When",
            "CNL": " node X oktr node C1 and node Y1 when field1 X have an triple field2 C1 and field3 Y1 and also node C1 okin node Y1 and also field1 X not succ field2 C1 and field3 Y1. ",
            "NL": "When field1 X has a triple field2 C1 and field3 Y1, the node X approves the node C1 and the node Y1. However, node C1 and node Y1 do not succeed in field1 X, field2 C1, and field3 Y1."
        },
        {
            "Category": "Definition When",
            "CNL": " node X oktr node C1 and node Y1 when field1 X have an triple field2 C1 and field3 Y1 and also node C1 okin node Y1 and also field1 X not succ field2 C1 and field3 Y1. ",
            "NL": "When field1 X has a triple of field2 C1 and field3 Y1, the node X approves the node C1 and the node Y1; however, if field1 X does not succeed in field2 C1 and field3 Y1, the node C1 will not be able to approve the node Y1."
        },
        {
            "Category": "Definition When",
            "CNL": " node X oktr node C1 and node Y1 when node X has a triple node C1 and node Y1 and also node C1 okin node Y1 and also node X not succ node C1 and node Y1.",
            "NL": "Assuming node X has a triple connection between nodes C1 and Y1, and provided that the connection between C1 and Y1 is not successful, node X should attempt to connect C1 and Y1."
        },
        {
            "Category": "Definition When",
            "CNL": " node X oktr node C1 and node Y1 when node X has a triple node C1 and node Y1 and also node C1 okin node Y1 and also node X not succ node C1 and node Y1.",
            "NL": "Assuming node X has a triple between nodes C1 and Y1 and is unsuccessful in connecting nodes C1 and Y1, node X will attempt to connect them."
        },
        {
            "Category": "Definition When",
            "CNL": " node X oktr node C1 and node Y1 when node X has a triple node C1 and node Y1 and also node C1 okin node Y1 and also node X not succ node C1 and node Y1.",
            "NL": "Assuming node X has triple node C1 and node Y1, and node C1 is connected to node Y1, but node C1 and node Y1 are not successful, node X must connect node C1 and node Y1."
        },
        {
            "Category": "Definition When",
            "CNL": " node X oktr node C1 and node Y1 when node X has a triple node C1 and node Y1 and also node C1 okin node Y1 and also node X not succ node C1 and node Y1.",
            "NL": "Assuming node X has a triple of nodes C1, Y1, and C2, if node C1 is not successful in connecting to node Y1, then node X should attempt to connect node C1 to node Y1."
        },
        {
            "Category": "Definition When",
            "CNL": " node X oktr node C1 and node Y1 when node X has a triple node C1 and node Y1 and also node C1 okin node Y1 and also node X not succ node C1 and node Y1.",
            "NL": "Assuming node X has a triple connection between node C1 and node Y1, and node C1 and node Y1 are not successful, node X will attempt to connect node C1 and node Y1."
        },
        {
            "Category": "Definition When",
            "CNL": " value7 P is Breadth id5 P when value7 is OutDegree key9 P and also id5 P is not LessThanExists. ",
            "NL": "When the OutDegree vertex is next and value7 P is not LessThanExists, there is a Breadth id5 P associated with it."
        },
        {
            "Category": "Definition When",
            "CNL": " value7 P is Breadth id5 P when value7 is OutDegree key9 P and also id5 P is not LessThanExists. ",
            "NL": "When OutDegree vertex is next and value7 P is not LessThanExists, there is a Breadth id5 P associated with value7 P."
        },
        {
            "Category": "Definition When",
            "CNL": " value7 P is Breadth id5 P when value7 is OutDegree key9 P and also id5 P is not LessThanExists. ",
            "NL": "When the OutDegree vertex is next and value7 P is not LessThanExists, a Breadth id5 P is associated with value7 P."
        },
        {
            "Category": "Definition When",
            "CNL": " value7 P is Breadth id5 P when value7 is OutDegree key9 P and also id5 P is not LessThanExists. ",
            "NL": "When the OutDegree vertex is next and value7 P is not LessThanExists, there is a Breadth id5 P associated with value7 P."
        },
        {
            "Category": "Definition When",
            "CNL": " value7 P is Breadth id5 P when value7 is OutDegree key9 P and also id5 P is not LessThanExists. ",
            "NL": "When the OutDegree vertex is next, there is an associated Breadth id5 P with value7 P, and when value7 P is not LessThanExists."
        },
        {
            "Category": "Definition When",
            "CNL": "edge U is Source_Data edge D when edge U is Source_Data edge F and also edge D is not Ending and also edge F is Oriented edge D.",
            "NL": "When edge U is Source_Data edge F, edge D is not the Ending, however, edge D is the Oriented edge when edge U is Source_Data edge D, and edge F is the Oriented edge."
        },
        {
            "Category": "Definition When",
            "CNL": "edge U is Source_Data edge D when edge U is Source_Data edge F and also edge D is not Ending and also edge F is Oriented edge D.",
            "NL": "When the edge U is Source_Data edge F, edge D is not the Ending edge, but the Oriented edge D is."
        },
        {
            "Category": "Definition When",
            "CNL": "edge U is Source_Data edge D when edge U is Source_Data edge F and also edge D is not Ending and also edge F is Oriented edge D.",
            "NL": "When the edge U is Source_Data edge F, the edge D is not Ending, but the edge U is Source_Data edge D and the edge F is the Oriented edge D."
        },
        {
            "Category": "Definition When",
            "CNL": "edge U is Source_Data edge D when edge U is Source_Data edge F and also edge D is not Ending and also edge F is Oriented edge D.",
            "NL": "When the edge U is Source_Data edge F, the edge D is not the Ending, but the edge F is the Oriented edge D of the edge U being Source_Data edge D."
        },
        {
            "Category": "Definition When",
            "CNL": "edge U is Source_Data edge D when edge U is Source_Data edge F and also edge D is not Ending and also edge F is Oriented edge D.",
            "NL": "When the edge U is Source_Data edge F, the edge D is not the Ending but the Oriented edge D, whereas the edge U is Source_Data edge D."
        },
        {
            "Category": "Definition When",
            "CNL": "edge X has an inPath to edge Y when node X is reached and also node X has an edge to Y and also edge X have not outPath edge Y.",
            "NL": "When node X is reached, there is an inpath from edge X to edge Y, as well as an edge from X to edge Y, however, there is no outpath from edge X to edge Y."
        },
        {
            "Category": "Definition When",
            "CNL": "edge X has an inPath to edge Y when node X is reached and also node X has an edge to Y and also edge X have not outPath edge Y.",
            "NL": "When node X is reached, there is a path leading from edge X to edge Y, but no path that goes from edge X to edge Y."
        },
        {
            "Category": "Definition When",
            "CNL": "edge X has an inPath to edge Y when node X is reached and also node X has an edge to Y and also edge X have not outPath edge Y.",
            "NL": "When node X is reached, there is a path from edge X to edge Y, but there is no way to travel from edge X to edge Y in the opposite direction."
        },
        {
            "Category": "Definition When",
            "CNL": "edge X has an inPath to edge Y when node X is reached and also node X has an edge to Y and also edge X have not outPath edge Y.",
            "NL": "When node X is reached, there is an inpath from edge X to edge Y, and an edge from X to edge Y, however, there is no outpath from edge X to edge Y."
        },
        {
            "Category": "Definition When",
            "CNL": "edge X has an inPath to edge Y when node X is reached and also node X has an edge to Y and also edge X have not outPath edge Y.",
            "NL": "When node X is reached, there is an inpath from edge X to edge Y, as well as an edge from X to edge Y; however, there is no outpath from edge X to edge Y."
        },
        {
            "Category": "Definition When",
            "CNL": "edge X have an inPath to edge Y when node X is start and also node X has an edge to Y and also edge X have not outpath edge Y.",
            "NL": "When node X is started, there is a pathway from edge X to edge Y, as well as an edge from X to Y, however, there is no route from edge X to edge Y in the opposite direction."
        },
        {
            "Category": "Definition When",
            "CNL": "edge X have an inPath to edge Y when node X is start and also node X has an edge to Y and also edge X have not outpath edge Y.",
            "NL": "When node X is started, there is an inpath from edge X to edge Y, as well as an edge from X to edge Y, however, there is no outpath from edge X to edge Y."
        },
        {
            "Category": "Definition When",
            "CNL": "edge X have an inPath to edge Y when node X is start and also node X has an edge to Y and also edge X have not outpath edge Y.",
            "NL": "When node X is started, there is an inpath from edge X to edge Y as well as an edge from X to edge Y, however, there is not an outpath from edge X to edge Y."
        },
        {
            "Category": "Definition When",
            "CNL": "edge X have an inPath to edge Y when node X is start and also node X has an edge to Y and also edge X have not outpath edge Y.",
            "NL": "When node X is started, there is an inpath from edge X to edge Y, but there is no outpath from edge X to edge Y, despite the presence of an edge between them."
        },
        {
            "Category": "Definition When",
            "CNL": "edge X have an inPath to edge Y when node X is start and also node X has an edge to Y and also edge X have not outpath edge Y.",
            "NL": "When node X is started, there is an inpath from edge X to edge Y and an edge from X to edge Y, however, there is no outpath from edge X to edge Y."
        },
        {
            "Category": "Definition When",
            "CNL": "edge X have an outPath to edge Y when node X is reached and also node X have an edge to Y and also edge X have not inpath edge Y. ",
            "NL": "When node X is reached, there is a route from edge X to edge Y, but there is no way from edge X to edge Y."
        },
        {
            "Category": "Definition When",
            "CNL": "edge X have an outPath to edge Y when node X is reached and also node X have an edge to Y and also edge X have not inpath edge Y. ",
            "NL": "When node X is reached, there is a path from edge X to edge Y, but there is not a path from edge Y to edge X."
        },
        {
            "Category": "Definition When",
            "CNL": "edge X have an outPath to edge Y when node X is reached and also node X have an edge to Y and also edge X have not inpath edge Y. ",
            "NL": "When node X is reached, there is a path from edge X to edge Y, but there is no route from edge Y to edge X."
        },
        {
            "Category": "Definition When",
            "CNL": "edge X have an outPath to edge Y when node X is reached and also node X have an edge to Y and also edge X have not inpath edge Y. ",
            "NL": "When node X is reached, there is a route from edge X to edge Y, but there is no way to go from edge Y to edge X."
        },
        {
            "Category": "Definition When",
            "CNL": "edge X have an outPath to edge Y when node X is reached and also node X have an edge to Y and also edge X have not inpath edge Y. ",
            "NL": "When node X is reached, there is a path leading from edge X to edge Y, as well as an edge from X to edge Y, however, there is no path leading from edge X to edge Y."
        },
        {
            "Category": "Definition When",
            "CNL": "edge X have an outPath to edge Y when node X is start and also node X has an edge to Y and also edge X have not inpath edge Y.",
            "NL": "When node X is started, there is an outpath from edge X to edge Y, as well as an edge from X to edge Y, however, there is no inpath from edge X to edge Y."
        },
        {
            "Category": "Definition When",
            "CNL": "edge X have an outPath to edge Y when node X is start and also node X has an edge to Y and also edge X have not inpath edge Y.",
            "NL": "There is an outpath from node X to edge Y when X is started, however, there is no inpath from edge X to edge Y, despite there being an edge from X to Y."
        },
        {
            "Category": "Definition When",
            "CNL": "edge X have an outPath to edge Y when node X is start and also node X has an edge to Y and also edge X have not inpath edge Y.",
            "NL": "There is an outpath from node X to edge Y when node X is started, but there is no inpath from edge X to edge Y, even though there is an edge from X to Y."
        },
        {
            "Category": "Definition When",
            "CNL": "edge X have an outPath to edge Y when node X is start and also node X has an edge to Y and also edge X have not inpath edge Y.",
            "NL": "There is a path from node X to edge Y when node X is started, but there is no path from edge X to edge Y."
        },
        {
            "Category": "Definition When",
            "CNL": "edge X have an outPath to edge Y when node X is start and also node X has an edge to Y and also edge X have not inpath edge Y.",
            "NL": "There is an outpath from node X to edge Y when the node is started, but there is no inpath from edge X to edge Y, even though there is an edge from X to Y."
        },
        {
            "Category": "Definition When",
            "CNL": "edge3 Q Sorted edge3 W when edge3 Q have an Unarrowed to W.",
            "NL": "When the edge3 Q had an Unarrowed connection to the edge3 W, it sorted the edge3 W."
        },
        {
            "Category": "Definition When",
            "CNL": "edge3 Q Sorted edge3 W when edge3 Q have an Unarrowed to W.",
            "NL": "When the edge3 Q was Unarrowed to the edge3 W, the edge3 Q Sorted the edge3 W."
        },
        {
            "Category": "Definition When",
            "CNL": "edge3 Q Sorted edge3 W when edge3 Q have an Unarrowed to W.",
            "NL": "When the edge3 Q had an Unarrowed to the edge3 W, the edge3 Q organized the edge3 W."
        },
        {
            "Category": "Definition When",
            "CNL": "edge3 Q Sorted edge3 W when edge3 Q have an Unarrowed to W.",
            "NL": "When the edge3 Q had an Unarrowed to the edge3 W, it sorted the edge3 Q."
        },
        {
            "Category": "Definition When",
            "CNL": "edge3 Q Sorted edge3 W when edge3 Q have an Unarrowed to W.",
            "NL": "When the edge3 Q had an Unarrowed to the edge3 W, the edge3 Q sorted the edge3 W."
        },
        {
            "Category": "Definition When",
            "CNL": "field1 R is Layer field5 C when field1 R have an External_Group field5 C and also field1 R Painted field5 C and key4 T and also field1 R Painted field5 C and key4 O and also field1 R have P_Value field5 Y and also field1 C is P_Value field5 H, where Y is different from H.",
            "NL": "If field1 R has an External_Group field1 C, and there are Painted with field1 R, field5 C and key4 T, but no Painted with field1 R, field5 C and key4 O, and there is a P_Value with field1 R and field5 Y and also a P_Value with field1 C and field5 H, where Y is not equal to H, then there is a Layer between field1 R and field5 C."
        },
        {
            "Category": "Definition When",
            "CNL": "field1 R is Layer field5 C when field1 R have an External_Group field5 C and also field1 R Painted field5 C and key4 T and also field1 R Painted field5 C and key4 O and also field1 R have P_Value field5 Y and also field1 C is P_Value field5 H, where Y is different from H.",
            "NL": "If field1 R has an External_Group field1 C, and there is a Painted with field1 R, field5 C and key4 T, but no Painted with field1 R, field5 C and key4 O, and there is a P_Value with field1 R and field5 Y, as well as a P_Value with field1 C and field5 H, where Y is not equal to H, then there is a Layer between field1 R and field5 C."
        },
        {
            "Category": "Definition When",
            "CNL": "field1 R is Layer field5 C when field1 R have an External_Group field5 C and also field1 R Painted field5 C and key4 T and also field1 R Painted field5 C and key4 O and also field1 R have P_Value field5 Y and also field1 C is P_Value field5 H, where Y is different from H.",
            "NL": "If field1 R has an External_Group field1 C, and there is a Painted with field1 R, field5 C and key4 T, but no Painted with field1 R, field5 C and key4 O, as well as a P_Value with field1 R and field5 Y and a different P_Value with field1 C and field5 H, then there is a Layer between field1 R and field5 C."
        },
        {
            "Category": "Definition When",
            "CNL": "field1 R is Layer field5 C when field1 R have an External_Group field5 C and also field1 R Painted field5 C and key4 T and also field1 R Painted field5 C and key4 O and also field1 R have P_Value field5 Y and also field1 C is P_Value field5 H, where Y is different from H.",
            "NL": "If there is a Painted with field1 R, field5 C and key4 T, but no Painted with field1 R, field5 C and key4 O, and there are two P_Values, one with field1 R and field5 Y and another with field1 C and field5 H, where Y is not equal to H, then there is a Layer between field1 R and field5 C when the External_Group field1 C is present."
        },
        {
            "Category": "Definition When",
            "CNL": "field1 R is Layer field5 C when field1 R have an External_Group field5 C and also field1 R Painted field5 C and key4 T and also field1 R Painted field5 C and key4 O and also field1 R have P_Value field5 Y and also field1 C is P_Value field5 H, where Y is different from H.",
            "NL": "If field1 R has an External_Group field1 C, and there are Painted with field1 R, field5 C and key4 T, and there is no Painted with field1 R, field5 C and key4 O, and there are also P_Value with field1 R and field5 Y and P_Value with field1 C and field5 H, where Y is not equal to H, then there is a Layer between field1 R and field5 C."
        },
        {
            "Category": "Definition When",
            "CNL": "id 1 is singleton when id V is active and also id V is trivial.",
            "NL": "When id V is active, both id 1 and trivial id V are singletons."
        },
        {
            "Category": "Definition When",
            "CNL": "id 1 is singleton when id V is active and also id V is trivial.",
            "NL": "When the id V is active, the id 1 is a singleton, and the id V is trivial."
        },
        {
            "Category": "Definition When",
            "CNL": "id 1 is singleton when id V is active and also id V is trivial.",
            "NL": "When the id V is active, the id 1 is a singleton, as is the trivial id V."
        },
        {
            "Category": "Definition When",
            "CNL": "id 1 is singleton when id V is active and also id V is trivial.",
            "NL": "When id V is active, the id 1 is a singleton, as well as the trivial id V itself."
        },
        {
            "Category": "Definition When",
            "CNL": "id 1 is singleton when id V is active and also id V is trivial.",
            "NL": "When the id V is active, both the id 1 and the trivial id V are singletons."
        },
        {
            "Category": "Definition When",
            "CNL": "id M has a match id W when id M have a manAssignsScore id Fv1 and id Fv2 and also id W has a womanAssignsScore id Fv3 and id Fv4 and also id M not nonMatch id W. ",
            "NL": "If id M has manAssignsScore ids Fv1 and Fv2, as well as womanAssignsScore ids Fv3 and Fv4, then it is possible for it to have a match id W, but not if it has a nonMatch id M and id W."
        },
        {
            "Category": "Definition When",
            "CNL": "id M has a match id W when id M have a manAssignsScore id Fv1 and id Fv2 and also id W has a womanAssignsScore id Fv3 and id Fv4 and also id M not nonMatch id W. ",
            "NL": "If id M has manAssignsScore ids Fv1 and Fv2, and womanAssignsScore ids Fv3 and Fv4, then it is possible for it to have a match id W, but not if it has a nonMatch id M and id W."
        },
        {
            "Category": "Definition When",
            "CNL": "id M has a match id W when id M have a manAssignsScore id Fv1 and id Fv2 and also id W has a womanAssignsScore id Fv3 and id Fv4 and also id M not nonMatch id W. ",
            "NL": "If id M has a manAssignsScore of Fv1 and Fv2, and a womanAssignsScore of Fv3 and Fv4, it is possible for it to have a match id W, but not if it has a nonMatch id M and id W."
        },
        {
            "Category": "Definition When",
            "CNL": "id M has a match id W when id M have a manAssignsScore id Fv1 and id Fv2 and also id W has a womanAssignsScore id Fv3 and id Fv4 and also id M not nonMatch id W. ",
            "NL": "If id M has both a manAssignsScore id Fv1 and id Fv2, and a womanAssignsScore id Fv3 and id Fv4, then it is possible for it to have a match id W, but not if it has a nonMatch id M and id W."
        },
        {
            "Category": "Definition When",
            "CNL": "id M has a match id W when id M have a manAssignsScore id Fv1 and id Fv2 and also id W has a womanAssignsScore id Fv3 and id Fv4 and also id M not nonMatch id W. ",
            "NL": "If id M has manAssignsScore ids Fv1 and Fv2, and womanAssignsScore ids Fv3 and Fv4, it is possible for it to have a match id W, but not if it has a nonMatch id M and id W."
        },
        {
            "Category": "Definition When",
            "CNL": "id M has a nonMatch id W when id M has a manAssignsScore id FV1 and id FV2 and also id W has a womanAssignsScore id FV3 and id FV4 and also id M not Match id W.",
            "NL": "If id M has a manAssignsScore id Fv1 and id Fv2, and id W has a womanAssignsScore id Fv3 and id Fv4, it is possible for them to have a nonMatch id M and id W, not otherwise."
        },
        {
            "Category": "Definition When",
            "CNL": "id M has a nonMatch id W when id M has a manAssignsScore id FV1 and id FV2 and also id W has a womanAssignsScore id FV3 and id FV4 and also id M not Match id W.",
            "NL": "If id M and id W both have manAssignsScore id Fv1 and id Fv2 for id M, and womanAssignsScore id Fv3 and id Fv4 for id W, then it is possible for them to have a nonMatch id M; however, if only one of them has a nonMatch id M, then this is not possible."
        },
        {
            "Category": "Definition When",
            "CNL": "id M has a nonMatch id W when id M has a manAssignsScore id FV1 and id FV2 and also id W has a womanAssignsScore id FV3 and id FV4 and also id M not Match id W.",
            "NL": "If id M has a manAssignsScore id Fv1 and id Fv2, and id W has a womanAssignsScore id Fv3 and id Fv4, it is possible for them to have a nonmatch id M and id W, not if otherwise."
        },
        {
            "Category": "Definition When",
            "CNL": "id M has a nonMatch id W when id M has a manAssignsScore id FV1 and id FV2 and also id W has a womanAssignsScore id FV3 and id FV4 and also id M not Match id W.",
            "NL": "If id M has a manAssignsScore id Fv1 and id Fv2 and id W has a womanAssignsScore id Fv3 and id Fv4, it is possible for it to have a nonMatch id M and id W, not otherwise."
        },
        {
            "Category": "Definition When",
            "CNL": "id M has a nonMatch id W when id M has a manAssignsScore id FV1 and id FV2 and also id W has a womanAssignsScore id FV3 and id FV4 and also id M not Match id W.",
            "NL": "It is possible for id M to have a nonmatch id M if it has a manAssignsScore id Fv1 and id Fv2, and id W has a womanAssignsScore id Fv3 and id Fv4; however, if it has a nonMatch id M and id W, then this is not the case."
        },
        {
            "Category": "Definition When",
            "CNL": "id M is jailed when id M is match id Fv1.",
            "NL": "If the ID M matches the ID Fv1, then the ID M will be put in jail."
        },
        {
            "Category": "Definition When",
            "CNL": "id M is jailed when id M is match id Fv1.",
            "NL": "If the ID M matches the ID FV1, then it will be incarcerated."
        },
        {
            "Category": "Definition When",
            "CNL": "id M is jailed when id M is match id Fv1.",
            "NL": "When id Fv1 is matched by the id M, it is incarcerated."
        },
        {
            "Category": "Definition When",
            "CNL": "id M is jailed when id M is match id Fv1.",
            "NL": "M is put in prison when their ID coincides with Fv1's."
        },
        {
            "Category": "Definition When",
            "CNL": "id M is jailed when id M is match id Fv1.",
            "NL": "If the ID M matches the ID Fv1, then it will be imprisoned."
        },
        {
            "Category": "Definition When",
            "CNL": "id U is coppo id V when id U is oppo id V and also id U is first id V.",
            "NL": "When id U is opposite of id V, id U is initially id V, then id U counters id V."
        },
        {
            "Category": "Definition When",
            "CNL": "id U is coppo id V when id U is oppo id V and also id U is first id V.",
            "NL": "When id U is opposite to id V, first id U follows id V, then id U opposes id V."
        },
        {
            "Category": "Definition When",
            "CNL": "id U is coppo id V when id U is oppo id V and also id U is first id V.",
            "NL": "When id U is opposite of id V, id U starts off as id V but eventually competes against id V."
        },
        {
            "Category": "Definition When",
            "CNL": "id U is coppo id V when id U is oppo id V and also id U is first id V.",
            "NL": "When id U is opposite of id V, id V is first, then id U counteracts id V."
        },
        {
            "Category": "Definition When",
            "CNL": "id U is coppo id V when id U is oppo id V and also id U is first id V.",
            "NL": "When id U is the opposite of id V, id U is initially equal to id V, then id U competes with id V."
        },
        {
            "Category": "Definition When",
            "CNL": "id U is coppo id V when id U is oppo id V and also if W is coppo is V and also id W is ntedge id U and id V.",
            "NL": "If U opposes V, W is in agreement with V, leaving U and V in opposition, then U has gone against V."
        },
        {
            "Category": "Definition When",
            "CNL": "id U is coppo id V when id U is oppo id V and also if W is coppo is V and also id W is ntedge id U and id V.",
            "NL": "When U is opposite V, W is also opposite V, W is between U and V, then U has opposed V."
        },
        {
            "Category": "Definition When",
            "CNL": "id U is coppo id V when id U is oppo id V and also if W is coppo is V and also id W is ntedge id U and id V.",
            "NL": "If U is opposite V, W is in between U and V, then U has compromised with V."
        },
        {
            "Category": "Definition When",
            "CNL": "id U is coppo id V when id U is oppo id V and also if W is coppo is V and also id W is ntedge id U and id V.",
            "NL": "When U is in opposition to V, W is converse to V, thus connecting U and V, then U has converse V."
        },
        {
            "Category": "Definition When",
            "CNL": "id U is coppo id V when id U is oppo id V and also if W is coppo is V and also id W is ntedge id U and id V.",
            "NL": "When U opposes V, W is in support of V, thus creating a conflict between U and V, then U has challenged V."
        },
        {
            "Category": "Definition When",
            "CNL": "id U is diff id1 V when id U has an edge id1 V and also id U obs_vlabel id1 S and also id V obs_vlabel id1 S and also id U have obs_elabel id1 V and id2 M and also id U is obs_elabel id1 V and id2 P.",
            "NL": "If there is an edge between id U and V, and there is an obs_elabel with id U, id1 V and id2 M but no obs_elabel with id U, id1 V and id2 P, and there is an obs_vlabel with id1 U and id2 S and an obs_vlabel with id1 V and id2 S, then there is a difference between id U and id1 V."
        },
        {
            "Category": "Definition When",
            "CNL": "id U is diff id1 V when id U has an edge id1 V and also id U obs_vlabel id1 S and also id V obs_vlabel id1 S and also id U have obs_elabel id1 V and id2 M and also id U is obs_elabel id1 V and id2 P.",
            "NL": "If there is an edge between id U and id V, and there is an obs_elabel with id U, id1 V and id2 M, but no obs_elabel with id U, id1 V and id2 P, and there are two obs_vlabel with id1 U and id2 S and id1 V and id2 S, then there is a difference between id U and id1 V."
        },
        {
            "Category": "Definition When",
            "CNL": "id U is diff id1 V when id U has an edge id1 V and also id U obs_vlabel id1 S and also id V obs_vlabel id1 S and also id U have obs_elabel id1 V and id2 M and also id U is obs_elabel id1 V and id2 P.",
            "NL": "If id U has an edge with id V, and there is an obs_elabel with id U, id1 V, and id2 M, but there is no obs_elabel with id U, id1 V, and id2 P, and there is an obs_vlabel with id1 U and id2 S as well as an obs_vlabel with id1 V and id2 S, then there is a difference between id U and id1 V."
        },
        {
            "Category": "Definition When",
            "CNL": "id U is diff id1 V when id U has an edge id1 V and also id U obs_vlabel id1 S and also id V obs_vlabel id1 S and also id U have obs_elabel id1 V and id2 M and also id U is obs_elabel id1 V and id2 P.",
            "NL": "If there is an edge between id U and id V, and there is an obs_elabel with id U, id1 V and id2 M, but no obs_elabel with id U, id1 V and id2 P, and there are obs_vlabel with id1 U and id2 S and also obs_vlabel with id1 V and id2 S, then there is a difference between id U and id1 V."
        },
        {
            "Category": "Definition When",
            "CNL": "id U is diff id1 V when id U has an edge id1 V and also id U obs_vlabel id1 S and also id V obs_vlabel id1 S and also id U have obs_elabel id1 V and id2 M and also id U is obs_elabel id1 V and id2 P.",
            "NL": "If there is an edge between id U and id V, and there is an obs_elabel with id U, id1 V and id2 M, but there is no obs_elabel with id U, id1 V and id2 P, and there are also obs_vlabel with id1 U and id2 S and id1 V and id2 S, then there is a distinction between id U and id1 V."
        },
        {
            "Category": "Definition When",
            "CNL": "id U is first id V when id V is vertex and also id V is not Input and also id V is not trivial id V and also id U is edge id V and also id U is not nfirst id V. ",
            "NL": "If vertex id V is not an input, edge id U is not trivial and not the first vertex of id V, then id V is the first vertex."
        },
        {
            "Category": "Definition When",
            "CNL": "id U is first id V when id V is vertex and also id V is not Input and also id V is not trivial id V and also id U is edge id V and also id U is not nfirst id V. ",
            "NL": "If vertex id V is not an input, edge id U is not trivial for vertex id V, and edge id U is not the first edge connected to vertex id V, then vertex id V is the first vertex."
        },
        {
            "Category": "Definition When",
            "CNL": "id U is first id V when id V is vertex and also id V is not Input and also id V is not trivial id V and also id U is edge id V and also id U is not nfirst id V. ",
            "NL": "If vertex id V is not an input, edge id U is not trivial with respect to id V, and id U is not the first id V, then id V is the first id V."
        },
        {
            "Category": "Definition When",
            "CNL": "id U is first id V when id V is vertex and also id V is not Input and also id V is not trivial id V and also id U is edge id V and also id U is not nfirst id V. ",
            "NL": "If vertex id V is not an input, edge id U is not trivial and id U is not the first of id V, then id V is the first of id V."
        },
        {
            "Category": "Definition When",
            "CNL": "id U is first id V when id V is vertex and also id V is not Input and also id V is not trivial id V and also id U is edge id V and also id U is not nfirst id V. ",
            "NL": "If id V is a vertex and not an input, and id U is an edge of id V and not a trivial id V, and id U is not the first id V, then id V is the first id V."
        },
        {
            "Category": "Definition When",
            "CNL": "id U is last id V when id V is vertex and also id V is not Input and also id V is not trivial id V and also id U is edge id V and also id U is not nlast id V.",
            "NL": "If vertex id V is not an input and edge id U is associated with id V, not a trivial id V, and not the nlast id V, then id U is the last id V."
        },
        {
            "Category": "Definition When",
            "CNL": "id U is last id V when id V is vertex and also id V is not Input and also id V is not trivial id V and also id U is edge id V and also id U is not nlast id V.",
            "NL": "If id V is a vertex and not an input, and id U is an edge connected to id V, and id V is not a trivial vertex, and id U is not the last id V, then id U is the last id V."
        },
        {
            "Category": "Definition When",
            "CNL": "id U is last id V when id V is vertex and also id V is not Input and also id V is not trivial id V and also id U is edge id V and also id U is not nlast id V.",
            "NL": "If vertex id V is not an input and edge id U is not a trivial id V nor the nlast id V, then edge id U is the last id V."
        },
        {
            "Category": "Definition When",
            "CNL": "id U is last id V when id V is vertex and also id V is not Input and also id V is not trivial id V and also id U is edge id V and also id U is not nlast id V.",
            "NL": "If vertex id V is not an input, and edge id U is not the trivial id V nor the last id V of vertex id V, then edge id U is the last id V of vertex id V."
        },
        {
            "Category": "Definition When",
            "CNL": "id U is last id V when id V is vertex and also id V is not Input and also id V is not trivial id V and also id U is edge id V and also id U is not nlast id V.",
            "NL": "If vertex id V is not an input, and edge id U is associated with vertex id V but is not a trivial id V, and edge id U is not the last id V, then edge id U is the last id V."
        },
        {
            "Category": "Definition When",
            "CNL": "id U is llabel id V and id S when id U is edge id V and also id U is obs_elabel id V and id S and also id V is not trivial and also id V is not Input.",
            "NL": "If id U is on the brink of id V, which is not insignificant and does not require input, then id U can observe id V and id S, thus having control over them."
        },
        {
            "Category": "Definition When",
            "CNL": "id U is llabel id V and id S when id U is edge id V and also id U is obs_elabel id V and id S and also id V is not trivial and also id V is not Input.",
            "NL": "If U is on the brink of V, V is not insignificant, and U is observing V and S, then U has labeled V and S."
        },
        {
            "Category": "Definition When",
            "CNL": "id U is llabel id V and id S when id U is edge id V and also id U is obs_elabel id V and id S and also id V is not trivial and also id V is not Input.",
            "NL": "If U is on the brink of V, which is neither input nor trivial, then U has labeled both V and S."
        },
        {
            "Category": "Definition When",
            "CNL": "id U is llabel id V and id S when id U is edge id V and also id U is obs_elabel id V and id S and also id V is not trivial and also id V is not Input.",
            "NL": "If id U is on the brink of id V, which is neither input nor trivial, id U will have to assess both id V and id S, then id U will have labeled id V and id S."
        },
        {
            "Category": "Definition When",
            "CNL": "id U is llabel id V and id S when id U is edge id V and also id U is obs_elabel id V and id S and also id V is not trivial and also id V is not Input.",
            "NL": "If id U is on the brink of id V, which is not insignificant and not input, then id U has labeled both id V and id S."
        },
        {
            "Category": "Definition When",
            "CNL": "id U is nfirst id V when id W ntedge id U and id V. ",
            "NL": "When W precedes both U and V, then U comes before V."
        },
        {
            "Category": "Definition When",
            "CNL": "id U is nfirst id V when id W ntedge id U and id V. ",
            "NL": "If W precedes both U and V, then U is before V."
        },
        {
            "Category": "Definition When",
            "CNL": "id U is nfirst id V when id W ntedge id U and id V. ",
            "NL": "When W is between U and V, then U is before V."
        },
        {
            "Category": "Definition When",
            "CNL": "id U is nfirst id V when id W ntedge id U and id V. ",
            "NL": "When U precedes both W and V, then U is before V."
        },
        {
            "Category": "Definition When",
            "CNL": "id U is nfirst id V when id W ntedge id U and id V. ",
            "NL": "When W is between U and V, then U comes first before V."
        },
        {
            "Category": "Definition When",
            "CNL": "id U is oppo id V when id U llabel id V and id M and also id U has vlabel id S and also id V is not trivial and also id V is not Input and also id U have obs_elabel id V and id P and also id V is vlabel id S. ",
            "NL": "If U is labeled as V, M, U is seen as S, V is not an input, U observes V and P, and V is labeled as S, then U is in opposition to V."
        },
        {
            "Category": "Definition When",
            "CNL": "id U is oppo id V when id U llabel id V and id M and also id U has vlabel id S and also id V is not trivial and also id V is not Input and also id U have obs_elabel id V and id P and also id V is vlabel id S. ",
            "NL": "When id U is labeled as id V, id M, and id U is observed as id S, if id V is not input, id U is observed as id V and id P, and id V is labeled as id S, then id U has opposite id V."
        },
        {
            "Category": "Definition When",
            "CNL": "id U is oppo id V when id U llabel id V and id M and also id U has vlabel id S and also id V is not trivial and also id V is not Input and also id U have obs_elabel id V and id P and also id V is vlabel id S. ",
            "NL": "When id U is labeled as id V, id M, id U is observed as id S, if id V is not included as input, id U is observed to oppose id V and id P, and id V is labeled as id S, then id U has the opposite of id V."
        },
        {
            "Category": "Definition When",
            "CNL": "id U is oppo id V when id U llabel id V and id M and also id U has vlabel id S and also id V is not trivial and also id V is not Input and also id U have obs_elabel id V and id P and also id V is vlabel id S. ",
            "NL": "If U is labeled as V, M, and S, and V is not an input, U is observed as an element of V and P, and V is labeled as S, then U has an opposite of V."
        },
        {
            "Category": "Definition When",
            "CNL": "id U is oppo id V when id U llabel id V and id M and also id U has vlabel id S and also id V is not trivial and also id V is not Input and also id U have obs_elabel id V and id P and also id V is vlabel id S. ",
            "NL": "If U is labeled as V, M, U is observed as S, V is not input, U is observed as V and P, and V is labeled as S, then U has opposite of V."
        },
        {
            "Category": "Definition When",
            "CNL": "id U is oppo id V when id U llabel id V and id P and also id U has vlabel id S and also id V is not trivial and also id V is not Input and also id U have obs_elabel id V and id M and also id V is vlabel id T, where S is different from T.",
            "NL": "If U is labeled as V, P, S, and U is observed as V and M, V is labeled as T, then U has opposite V."
        },
        {
            "Category": "Definition When",
            "CNL": "id U is oppo id V when id U llabel id V and id P and also id U has vlabel id S and also id V is not trivial and also id V is not Input and also id U have obs_elabel id V and id M and also id V is vlabel id T, where S is different from T.",
            "NL": "If U is labeled as V, P, S, V is not trivial, V is not input, U is observed as V and M, V is labeled as T, then U has an opposite of V."
        },
        {
            "Category": "Definition When",
            "CNL": "id U is oppo id V when id U llabel id V and id P and also id U has vlabel id S and also id V is not trivial and also id V is not Input and also id U have obs_elabel id V and id M and also id V is vlabel id T, where S is different from T.",
            "NL": "If U is labeled as V, P, S, V is not trivial, V is not input, U is observed to be labeled as V and M, and V is labeled as T, then U has an opposite of V."
        },
        {
            "Category": "Definition When",
            "CNL": "id U is oppo id V when id U llabel id V and id P and also id U has vlabel id S and also id V is not trivial and also id V is not Input and also id U have obs_elabel id V and id M and also id V is vlabel id T, where S is different from T.",
            "NL": "If U is labeled as V, P, S, V is not trivial or input, U is observed as V and M, and V is labeled as T, then U has opposite of V."
        },
        {
            "Category": "Definition When",
            "CNL": "id U is oppo id V when id U llabel id V and id P and also id U has vlabel id S and also id V is not trivial and also id V is not Input and also id U have obs_elabel id V and id M and also id V is vlabel id T, where S is different from T.",
            "NL": "If U is labeled as V, P, S, not trivial, not input, observed as V and M, and labeled as T, then U has opposite V."
        },
        {
            "Category": "Definition When",
            "CNL": "id U is reach id V when id U is edge id V and also id V is active and also id V is not trivial.",
            "NL": "When id U is on the brink of id V, id V is energized, and id V is significant, id U attains id V."
        },
        {
            "Category": "Definition When",
            "CNL": "id U is reach id V when id U is edge id V and also id V is active and also id V is not trivial.",
            "NL": "When id U is nearing id V, id V is activated, and id V is significant, then id U attains id V."
        },
        {
            "Category": "Definition When",
            "CNL": "id U is reach id V when id U is edge id V and also id V is active and also id V is not trivial.",
            "NL": "When id U is close to id V, id V is engaged and not insignificant, id U will attain id V."
        },
        {
            "Category": "Definition When",
            "CNL": "id U is reach id V when id U is edge id V and also id V is active and also id V is not trivial.",
            "NL": "When U is close to achieving V, V is activated, and V is of significance, U will attain V."
        },
        {
            "Category": "Definition When",
            "CNL": "id U is reach id V when id U is edge id V and also id V is active and also id V is not trivial.",
            "NL": "When id U approaches id V's threshold, id V is activated and not inconsequential, thus id U is able to reach id V."
        },
        {
            "Category": "Definition When",
            "CNL": "id U is reach id W when id U is edge id V and also id V is active and also id V is not trivial and also id U is reach id W and also id W is vertex and also id U is obs_vlabel id P and also id U is obs_vlabel id M. ",
            "NL": "When id U is close to the boundary of id V, which is an active and complex area, and if id U is not obs_vlabel id P or id M, then id V will reach id W, a vertex."
        },
        {
            "Category": "Definition When",
            "CNL": "id U is reach id W when id U is edge id V and also id V is active and also id V is not trivial and also id U is reach id W and also id W is vertex and also id U is obs_vlabel id P and also id U is obs_vlabel id M. ",
            "NL": "If U is on the boundary of V, V is activated, not insignificant, and U progresses to W, which is a vertex and not obs_vlabel P or M, then V will reach W."
        },
        {
            "Category": "Definition When",
            "CNL": "id U is reach id W when id U is edge id V and also id V is active and also id V is not trivial and also id U is reach id W and also id W is vertex and also id U is obs_vlabel id P and also id U is obs_vlabel id M. ",
            "NL": "If U is on the brink of V, V is lively, V is not insignificant, and U gets to W, which is a vertex and U is not labeled P or M, then V will reach W."
        },
        {
            "Category": "Definition When",
            "CNL": "id U is reach id W when id U is edge id V and also id V is active and also id V is not trivial and also id U is reach id W and also id W is vertex and also id U is obs_vlabel id P and also id U is obs_vlabel id M. ",
            "NL": "When id U is close to the boundary of id V, which is active and not trivial, and id U is not obs_vlabel id P or id M, then id V will reach id W, which is a vertex."
        },
        {
            "Category": "Definition When",
            "CNL": "id U is reach id W when id U is edge id V and also id V is active and also id V is not trivial and also id U is reach id W and also id W is vertex and also id U is obs_vlabel id P and also id U is obs_vlabel id M. ",
            "NL": "When id U is close to the boundary of id V, and id V is engaged, not insignificant, and id U reaches id W, which is a vertex, and id U is not labeled as id P, nor id M, then id V will reach id W."
        },
        {
            "Category": "Definition When",
            "CNL": "id U is reach id W when id U is edge id V and also id V is active and also id V is not trivial and also id V is reach id W and also id W is vertex.",
            "NL": "If U is close to the boundary of V, which is not insignificant and reaches W, a vertex, then U will attain W."
        },
        {
            "Category": "Definition When",
            "CNL": "id U is reach id W when id U is edge id V and also id V is active and also id V is not trivial and also id V is reach id W and also id W is vertex.",
            "NL": "If U is at the brink of V, which is active, not insignificant, and leads to W, a vertex, then U will reach W."
        },
        {
            "Category": "Definition When",
            "CNL": "id U is reach id W when id U is edge id V and also id V is active and also id V is not trivial and also id V is reach id W and also id W is vertex.",
            "NL": "If id U is on the brink of id V, which is active, significant, and a vertex, then id U will reach id W."
        },
        {
            "Category": "Definition When",
            "CNL": "id U is reach id W when id U is edge id V and also id V is active and also id V is not trivial and also id V is reach id W and also id W is vertex.",
            "NL": "When id U is near the boundary of id V, which is not trivial and contains id W as a vertex, then id U can access id W."
        },
        {
            "Category": "Definition When",
            "CNL": "id U is reach id W when id U is edge id V and also id V is active and also id V is not trivial and also id V is reach id W and also id W is vertex.",
            "NL": "If U is close to V, V is active, not trivial, and W is a vertex, then U will reach W."
        },
        {
            "Category": "Definition When",
            "CNL": "id U llabel id V and id S when id 1 is bot and also id U is edge id V and also id S is sign and also id V is not trivial and also id V is not Input and also id U is obs_elabel id V and id P and also id U is ebs_elabel id V and id M.",
            "NL": "If bot 1 is present, edge id U is connected to id V, with id S as the sign, and id V is not trivial, not input, not obs_elabel of id V and id P, and not obs_elabel of id V and id M, then id U is assigned llabel to id V and id S."
        },
        {
            "Category": "Definition When",
            "CNL": "id U llabel id V and id S when id 1 is bot and also id U is edge id V and also id S is sign and also id V is not trivial and also id V is not Input and also id U is obs_elabel id V and id P and also id U is ebs_elabel id V and id M.",
            "NL": "If bot id 1 is present, edge id U is connected to id V, id S signs in, id V is not straightforward, id V is not inputted, edge id U is not labeled as both obs_elabel id V and id P, and obs_elabel id V and id M are not present then id U is labeled as llabel id V, and id S."
        },
        {
            "Category": "Definition When",
            "CNL": "id U llabel id V and id S when id 1 is bot and also id U is edge id V and also id S is sign and also id V is not trivial and also id V is not Input and also id U is obs_elabel id V and id P and also id U is ebs_elabel id V and id M.",
            "NL": "If id 1 is bot, id U is edge id V, id S signs, and id V is not trivial, input, obs_elabel id V and id P, or obs_elabel id V and id M, then id U is llabel id V and id S."
        },
        {
            "Category": "Definition When",
            "CNL": "id U llabel id V and id S when id 1 is bot and also id U is edge id V and also id S is sign and also id V is not trivial and also id V is not Input and also id U is obs_elabel id V and id P and also id U is ebs_elabel id V and id M.",
            "NL": "If id 1 is not bot, id U is the edge label of id V, id S signs, id V is not trivial, id V is not input, id U is not the observation label of id V and id P, and id U is not the observation label of id V and id M, then id U is the llabel of id V, and id S."
        },
        {
            "Category": "Definition When",
            "CNL": "id U llabel id V and id S when id 1 is bot and also id U is edge id V and also id S is sign and also id V is not trivial and also id V is not Input and also id U is obs_elabel id V and id P and also id U is ebs_elabel id V and id M.",
            "NL": "If id 1 is bot, id U is edge id V, id S signs, id V is not trivial, id V is not input, id U is not obs_elabel id V and id P, and id U is not obs_elabel id V and id M, then id U is llabel id V with id S."
        },
        {
            "Category": "Definition When",
            "CNL": "id V is active when id V is vertex and also id V is not Input and also id V is not Inactive.",
            "NL": "If id V is a vertex and not an input or an inactive id V, it is active."
        },
        {
            "Category": "Definition When",
            "CNL": "id V is active when id V is vertex and also id V is not Input and also id V is not Inactive.",
            "NL": "If id V is a vertex and not an input or inactive id V, then it is an active id V."
        },
        {
            "Category": "Definition When",
            "CNL": "id V is active when id V is vertex and also id V is not Input and also id V is not Inactive.",
            "NL": "If id V is a vertex and not an input or an inactive id V, then it is considered active."
        },
        {
            "Category": "Definition When",
            "CNL": "id V is active when id V is vertex and also id V is not Input and also id V is not Inactive.",
            "NL": "If id V is a vertex and not an input or an inactive id V, then it is considered to be active."
        },
        {
            "Category": "Definition When",
            "CNL": "id V is active when id V is vertex and also id V is not Input and also id V is not Inactive.",
            "NL": "If id V is a vertex and not an input or an inactive vertex, then it is active."
        },
        {
            "Category": "Definition When",
            "CNL": "id V is aedge when id V is vertex and also id V is not Input and also id V is not trivial and also id V is obs_vlabel id P and also id V is obs_vlabel id M and also id W is active and also id V is edge id W. ",
            "NL": "If vertex V is not an input, is trivial, not an obs_vlabel of P, not an obs_vlabel of M, and is an edge of W, then V has an aedge."
        },
        {
            "Category": "Definition When",
            "CNL": "id V is aedge when id V is vertex and also id V is not Input and also id V is not trivial and also id V is obs_vlabel id P and also id V is obs_vlabel id M and also id W is active and also id V is edge id W. ",
            "NL": "If vertex V is not an input, is trivial, is not labeled P or M, and is connected to edge W, then V has an edge."
        },
        {
            "Category": "Definition When",
            "CNL": "id V is aedge when id V is vertex and also id V is not Input and also id V is not trivial and also id V is obs_vlabel id P and also id V is obs_vlabel id M and also id W is active and also id V is edge id W. ",
            "NL": "If vertex V is not an input, is trivial, and is an edge W, but not an obs_vlabel of P or M, then V has an edge."
        },
        {
            "Category": "Definition When",
            "CNL": "id V is aedge when id V is vertex and also id V is not Input and also id V is not trivial and also id V is obs_vlabel id P and also id V is obs_vlabel id M and also id W is active and also id V is edge id W. ",
            "NL": "If vertex id V is not an input, is trivial, and does not have an edge labeled obs_vlabel id P or obs_vlabel id M, but does have an edge labeled id W, then it has an edge."
        },
        {
            "Category": "Definition When",
            "CNL": "id V is aedge when id V is vertex and also id V is not Input and also id V is not trivial and also id V is obs_vlabel id P and also id V is obs_vlabel id M and also id W is active and also id V is edge id W. ",
            "NL": "If vertex V is not an input, is trivial, does not have an obs_vlabel of P, does not have an obs_vlabel of M, and is an edge of W, then V has aedge."
        },
        {
            "Category": "Definition When",
            "CNL": "id V is diff id1 V when id V has edge id1 V1 and also id V have obs_elabel id1 V1 and id2 M and also id V have obs_elabel id1 V1 and id2 P.",
            "NL": "If there is an edge with id V, and there are obs_elabels with id V, id1 V and id2 M, but no obs_elabel with id V, id1 V and id2 P, then we can observe a difference between id V and id1 V."
        },
        {
            "Category": "Definition When",
            "CNL": "id V is diff id1 V when id V has edge id1 V1 and also id V have obs_elabel id1 V1 and id2 M and also id V have obs_elabel id1 V1 and id2 P.",
            "NL": "If there is an edge between idV and idV, and there is an obs_elabel with idV, id1V and id2M, but no obs_elabel with idV, id1V and id2P, then we can see a difference between idV and id1V."
        },
        {
            "Category": "Definition When",
            "CNL": "id V is diff id1 V when id V has edge id1 V1 and also id V have obs_elabel id1 V1 and id2 M and also id V have obs_elabel id1 V1 and id2 P.",
            "NL": "If there is an edge between id V and id1 V, and there is an obs_elabel between them with id2 M, but no obs_elabel between them with id2 P, then there is a difference between id V and id1 V."
        },
        {
            "Category": "Definition When",
            "CNL": "id V is diff id1 V when id V has edge id1 V1 and also id V have obs_elabel id1 V1 and id2 M and also id V have obs_elabel id1 V1 and id2 P.",
            "NL": "If there is an edge with id V, and there are obs_elabels with id V, id1 V, and id2 M, but there are no obs_elabels with id V, id1 V, and id2 P, then we see a discrepancy between id V and id1 V."
        },
        {
            "Category": "Definition When",
            "CNL": "id V is diff id1 V when id V has edge id1 V1 and also id V have obs_elabel id1 V1 and id2 M and also id V have obs_elabel id1 V1 and id2 P.",
            "NL": "If there is an edge with id V, and there are obs_elabels with id V, id1 V and id2 M, but there is no obs_elabel with id V, id1 V and id2 P, then there is a distinction between id V and id1 V."
        },
        {
            "Category": "Definition When",
            "CNL": "id V is Inactive when id V is vertex and also id V is not Input and also id V is not active.",
            "NL": "If id V is a vertex and not an input or active id V, then it is inactive."
        },
        {
            "Category": "Definition When",
            "CNL": "id V is Inactive when id V is vertex and also id V is not Input and also id V is not active.",
            "NL": "If id V is a vertex that is neither an input nor an active id V, then it is inactive."
        },
        {
            "Category": "Definition When",
            "CNL": "id V is Inactive when id V is vertex and also id V is not Input and also id V is not active.",
            "NL": "If id V is a vertex but not an input or active id V, then it is inactive."
        },
        {
            "Category": "Definition When",
            "CNL": "id V is Inactive when id V is vertex and also id V is not Input and also id V is not active.",
            "NL": "If id V is a vertex and not an input or an active id V, then it is considered inactive."
        },
        {
            "Category": "Definition When",
            "CNL": "id V is Inactive when id V is vertex and also id V is not Input and also id V is not active.",
            "NL": "If id V is a vertex and not input and is not an active id V, then it is inactive."
        },
        {
            "Category": "Definition When",
            "CNL": "id V is Inactive when id V is vertex and also id V is not Input and also id W is active and also id W is trivial, where V is different from W.",
            "NL": "If id V is a vertex and not an input, id W is active and not trivial, and id V is not equal to id W, then id V is inactive."
        },
        {
            "Category": "Definition When",
            "CNL": "id V is Inactive when id V is vertex and also id V is not Input and also id W is active and also id W is trivial, where V is different from W.",
            "NL": "If id V is a vertex and not an input, id W is active and not trivial, and id V is not the same as W, then id V is inactive."
        },
        {
            "Category": "Definition When",
            "CNL": "id V is Inactive when id V is vertex and also id V is not Input and also id W is active and also id W is trivial, where V is different from W.",
            "NL": "If id V is a vertex and not an input, id W is active, and id V is not equal to W, then id V is inactive as long as trivial id W is present."
        },
        {
            "Category": "Definition When",
            "CNL": "id V is Inactive when id V is vertex and also id V is not Input and also id W is active and also id W is trivial, where V is different from W.",
            "NL": "If id V is a vertex which is not an input, id W is active and not trivial, and V is not equal to W, then V is inactive."
        },
        {
            "Category": "Definition When",
            "CNL": "id V is Inactive when id V is vertex and also id V is not Input and also id W is active and also id W is trivial, where V is different from W.",
            "NL": "If id V is a vertex but not an input, id W is active and not trivial, and id V is not equal to W, then id V is inactive."
        },
        {
            "Category": "Definition When",
            "CNL": "id V is nontriv when id V is vertex and also id V is not Input and also id U is edge id1 V and also id U is not diff id1 V.",
            "NL": "If id V is a vertex and not an input, and id U is an edge connecting id1 V and not a difference between id1 V, then id V is not trivial."
        },
        {
            "Category": "Definition When",
            "CNL": "id V is nontriv when id V is vertex and also id V is not Input and also id U is edge id1 V and also id U is not diff id1 V.",
            "NL": "If id V is a vertex but not an input, and id U is an edge from id1 V but not a different id1 V, then id V is significant."
        },
        {
            "Category": "Definition When",
            "CNL": "id V is nontriv when id V is vertex and also id V is not Input and also id U is edge id1 V and also id U is not diff id1 V.",
            "NL": "If id V is a vertex and not an input, and id U is an edge connecting id1 V and not a difference in id1 V, then id V is not trivial."
        },
        {
            "Category": "Definition When",
            "CNL": "id V is nontriv when id V is vertex and also id V is not Input and also id U is edge id1 V and also id U is not diff id1 V.",
            "NL": "If id V is a vertex and not an input, and id U is the edge between id1 V and not the difference between id1 V, then id V is not trivial."
        },
        {
            "Category": "Definition When",
            "CNL": "id V is nontriv when id V is vertex and also id V is not Input and also id U is edge id1 V and also id U is not diff id1 V.",
            "NL": "If id V is a vertex and not an input, and id U is an edge between id1 V and not a different id1 V, then id V is significant."
        },
        {
            "Category": "Definition When",
            "CNL": "id V is reach id U when id U is edge id V and also id V is active and also id V is not trivial and also id U is obs_vlabel id P and also id U is obs_vlabel id M. ",
            "NL": "When id U is approaching the boundary of id V, which is active and not insignificant, and id U is not obs_vlabel id P or id M, then id V will reach id U."
        },
        {
            "Category": "Definition When",
            "CNL": "id V is reach id U when id U is edge id V and also id V is active and also id V is not trivial and also id U is obs_vlabel id P and also id U is obs_vlabel id M. ",
            "NL": "If id U is close to the borders of id V, with id V being active and not trivial, and id U is not labeled as id P or id M, then id V will reach id U."
        },
        {
            "Category": "Definition When",
            "CNL": "id V is reach id U when id U is edge id V and also id V is active and also id V is not trivial and also id U is obs_vlabel id P and also id U is obs_vlabel id M. ",
            "NL": "When id U is close to the boundary of id V, id V is active and not insignificant, and id U is neither obs_vlabel id P nor obs_vlabel id M, then id V is able to connect with id U."
        },
        {
            "Category": "Definition When",
            "CNL": "id V is reach id U when id U is edge id V and also id V is active and also id V is not trivial and also id U is obs_vlabel id P and also id U is obs_vlabel id M. ",
            "NL": "When id U is close to the boundaries of id V, which is active and not insignificant, and does not contain id P or id M, then id V will reach id U."
        },
        {
            "Category": "Definition When",
            "CNL": "id V is reach id U when id U is edge id V and also id V is active and also id V is not trivial and also id U is obs_vlabel id P and also id U is obs_vlabel id M. ",
            "NL": "When id U is close to the boundaries of id V, such that id V is functioning, not trivial, and not obstructed by id P or id M, then id V will reach id U."
        },
        {
            "Category": "Definition When",
            "CNL": "id V is vlabel id S when id V is vertex and also id V is obs_vlabel id S and also id V is not trivial and also id V is not Input. ",
            "NL": "If vertex id V is not an input, not trivial, and has obs_vlabel id S, then it has vlabel id S."
        },
        {
            "Category": "Definition When",
            "CNL": "id V is vlabel id S when id V is vertex and also id V is obs_vlabel id S and also id V is not trivial and also id V is not Input. ",
            "NL": "If vertex V has an observation label S and is neither an input nor trivial, then V has a label S."
        },
        {
            "Category": "Definition When",
            "CNL": "id V is vlabel id S when id V is vertex and also id V is obs_vlabel id S and also id V is not trivial and also id V is not Input. ",
            "NL": "If vertex id V is neither an input nor trivial, and has obs_vlabel id S, then it has vlabel id S."
        },
        {
            "Category": "Definition When",
            "CNL": "id V is vlabel id S when id V is vertex and also id V is obs_vlabel id S and also id V is not trivial and also id V is not Input. ",
            "NL": "If vertex id V is not input, not trivial, and has an obs_vlabel of id S, then its vlabel is also id S."
        },
        {
            "Category": "Definition When",
            "CNL": "id V is vlabel id S when id V is vertex and also id V is obs_vlabel id S and also id V is not trivial and also id V is not Input. ",
            "NL": "If vertex id V is not input, not trivial, and has vlabel id S as its obs_vlabel, then it has vlabel id S."
        },
        {
            "Category": "Definition When",
            "CNL": "id V vlabel id S when id 1 is bot and also id U is edge id V and also id S is sign and also id V is not trivial and also id V is not Input and also id U is obs_vlabel id P and also id U is obs_vlabel id M.",
            "NL": "If id 1 is a bot, id U is an edge of id V, id S signs, id V is not trivial, id V is not an input, id U is not the obs_vlabel of id P, and id U is not the obs_vlabel of id M, then id U is the vlabel of S."
        },
        {
            "Category": "Definition When",
            "CNL": "id V vlabel id S when id 1 is bot and also id U is edge id V and also id S is sign and also id V is not trivial and also id V is not Input and also id U is obs_vlabel id P and also id U is obs_vlabel id M.",
            "NL": "If id 1 is bot, id U is edge id V, id S signs, id V is not trivial, id V is not input, and id U is not obs_vlabel id M, then id U is vlabel is S."
        },
        {
            "Category": "Definition When",
            "CNL": "id V vlabel id S when id 1 is bot and also id U is edge id V and also id S is sign and also id V is not trivial and also id V is not Input and also id U is obs_vlabel id P and also id U is obs_vlabel id M.",
            "NL": "If ID 1 is a bot, ID U is an edge ID V, ID S signs, and ID V is not trivial or an input, but ID U is an observed label ID P, and ID U is not an observed label ID M, then ID U is a label S."
        },
        {
            "Category": "Definition When",
            "CNL": "id V vlabel id S when id 1 is bot and also id U is edge id V and also id S is sign and also id V is not trivial and also id V is not Input and also id U is obs_vlabel id P and also id U is obs_vlabel id M.",
            "NL": "If ID 1 is a bot, ID U is an edge ID V, and ID S signs, and ID V is not trivial, and ID V is not an input, and ID U is an obs_vlabel ID P, but ID U is not an obs_vlabel ID M, then ID U's vlabel is S."
        },
        {
            "Category": "Definition When",
            "CNL": "id V vlabel id S when id 1 is bot and also id U is edge id V and also id S is sign and also id V is not trivial and also id V is not Input and also id U is obs_vlabel id P and also id U is obs_vlabel id M.",
            "NL": "If id 1 is a bot, id U is an edge of id V, with id S as the sign, and id V is not trivial or an input, but id U is an obs_vlabel of id P, and id U is not an obs_vlabel of id M, then id U is a vlabel of S."
        },
        {
            "Category": "Definition When",
            "CNL": "id V vlabel id S when id 1 is bot and also id V is vertex and also id S is sign and also id V is not trivial and also id V is not Input and also id V is obs_vlabel id P and also id V is obs_vlabel id M.",
            "NL": "If id 1 is a bot, id V is a vertex, id S is a sign, id V is not a trivial input, id V is not an obs_vlabel of id P and id V is not an obs_vlabel of id M, then id V's vlabel is S."
        },
        {
            "Category": "Definition When",
            "CNL": "id V vlabel id S when id 1 is bot and also id V is vertex and also id S is sign and also id V is not trivial and also id V is not Input and also id V is obs_vlabel id P and also id V is obs_vlabel id M.",
            "NL": "If id 1 is a bot, id V is a vertex, id S signs, id V is not trivial, id V is not input, id V is not obs_vlabel id P, and id V is not obs_vlabel id M, then the vlabel of id V is S."
        },
        {
            "Category": "Definition When",
            "CNL": "id V vlabel id S when id 1 is bot and also id V is vertex and also id S is sign and also id V is not trivial and also id V is not Input and also id V is obs_vlabel id P and also id V is obs_vlabel id M.",
            "NL": "If id 1 is a bot, id V is a vertex, id S signifies, id V is not trivial, id V is not an input, id V is not the obs_vlabel of id P, and id V is not the obs_vlabel of id M, then the vlabel of id V is S."
        },
        {
            "Category": "Definition When",
            "CNL": "id V vlabel id S when id 1 is bot and also id V is vertex and also id S is sign and also id V is not trivial and also id V is not Input and also id V is obs_vlabel id P and also id V is obs_vlabel id M.",
            "NL": "If ID 1 is a bot, ID V is a vertex, ID S is signed, ID V is not trivial, ID V is not an input, ID V is not an observation label for ID P, and ID V is not an observation label for ID M, then ID V's vlabel is S."
        },
        {
            "Category": "Definition When",
            "CNL": "id V vlabel id S when id 1 is bot and also id V is vertex and also id S is sign and also id V is not trivial and also id V is not Input and also id V is obs_vlabel id P and also id V is obs_vlabel id M.",
            "NL": "If id 1 is a bot, id V is the vertex, id S is the sign, id V is not trivial, id V is not an input, id V is not an obs_vlabel for id P, and id V is not an obs_vlabel for id M, then the vlabel for id V is S."
        },
        {
            "Category": "Definition When",
            "CNL": "id W is btedge id U and id V when id V is vertex and also id V is not Input and also id V is not Trivial id V and also id W is edge id V and also id U edge id V and also id Z edge id V, where W is less than Z and Z is less than U. ",
            "NL": "If vertex id V has an edge id W, and is not an input or trivial, and edge id U is greater than W and less than U, then there is a btedge with ids W, U, and V."
        },
        {
            "Category": "Definition When",
            "CNL": "id W is btedge id U and id V when id V is vertex and also id V is not Input and also id V is not Trivial id V and also id W is edge id V and also id U edge id V and also id Z edge id V, where W is less than Z and Z is less than U. ",
            "NL": "If vertex V is present, edge W is connected to V, V is not an input, V is not trivial, edge U is connected to V, and Z is greater than W and less than U, then we have an edge with IDs W, U, and V."
        },
        {
            "Category": "Definition When",
            "CNL": "id W is btedge id U and id V when id V is vertex and also id V is not Input and also id V is not Trivial id V and also id W is edge id V and also id U edge id V and also id Z edge id V, where W is less than Z and Z is less than U. ",
            "NL": "If vertex V is present, edge W is connected to V, V is not an input, V is not trivial, and edge U is connected to V, where Z is greater than W and less than U, then there is an edge with IDs W, U, and V."
        },
        {
            "Category": "Definition When",
            "CNL": "id W is btedge id U and id V when id V is vertex and also id V is not Input and also id V is not Trivial id V and also id W is edge id V and also id U edge id V and also id Z edge id V, where W is less than Z and Z is less than U. ",
            "NL": "If vertex id V is present, edge id W is connected to it; edge id V is not an input, nor is it trivial; edge id U is connected to vertex id V, and Z is greater than W and less than U, then we have a btedge with ids W, U, and V."
        },
        {
            "Category": "Definition When",
            "CNL": "id W is btedge id U and id V when id V is vertex and also id V is not Input and also id V is not Trivial id V and also id W is edge id V and also id U edge id V and also id Z edge id V, where W is less than Z and Z is less than U. ",
            "NL": "If vertex id V is present, edge ids W and U are connected to it, where W is less than U and greater than Z, then we have an edge with ids W, U, and V."
        },
        {
            "Category": "Definition When",
            "CNL": "id W is nlast id V when id W ntedge id U and id V.",
            "NL": "When W is between U and V, then W is the last one before V."
        },
        {
            "Category": "Definition When",
            "CNL": "id W is nlast id V when id W ntedge id U and id V.",
            "NL": "When W is between U and V, then W is the last one to V."
        },
        {
            "Category": "Definition When",
            "CNL": "id W is nlast id V when id W ntedge id U and id V.",
            "NL": "When W is between U and V, then W is the last before V."
        },
        {
            "Category": "Definition When",
            "CNL": "id W is nlast id V when id W ntedge id U and id V.",
            "NL": "When W is between U and V, then W is the last one of V."
        },
        {
            "Category": "Definition When",
            "CNL": "id W is nlast id V when id W ntedge id U and id V.",
            "NL": "When id W is between id U and id V, then id V is the last one for id W."
        },
        {
            "Category": "Definition When",
            "CNL": "id W is ntedge id U and id V when id V is vertex and also id V is not Input and also id V is not trivial and also id W is edge id V and also id U edge id V and also id W is not btedge id U and id V, where W is less than U.",
            "NL": "If vertex V is present, edge W is connected to V, V is not an input, V is not trivial, and edge U is connected to V, where Z is less than U, then there exists a ntedge with ids W, U, and V."
        },
        {
            "Category": "Definition When",
            "CNL": "id W is ntedge id U and id V when id V is vertex and also id V is not Input and also id V is not trivial and also id W is edge id V and also id U edge id V and also id W is not btedge id U and id V, where W is less than U.",
            "NL": "If vertex id V is given, edge id W is connected to it, id V is not an input, and id U is an edge connected to id V where Z is less than U, then we have a ntedge with id W, id1 U, and id2 V."
        },
        {
            "Category": "Definition When",
            "CNL": "id W is ntedge id U and id V when id V is vertex and also id V is not Input and also id V is not trivial and also id W is edge id V and also id U edge id V and also id W is not btedge id U and id V, where W is less than U.",
            "NL": "If vertex id V is present, edge id V is not input, and edge id U is less than Z, then we have a ntedge with id W, id1 U, and id2 V."
        },
        {
            "Category": "Definition When",
            "CNL": "id W is ntedge id U and id V when id V is vertex and also id V is not Input and also id V is not trivial and also id W is edge id V and also id U edge id V and also id W is not btedge id U and id V, where W is less than U.",
            "NL": "If vertex id V is not input or trivial, and edge id U is connected to vertex id V, where Z is less than U, then we have a ntedge with id W, id1 U, and id2 V."
        },
        {
            "Category": "Definition When",
            "CNL": "id W is ntedge id U and id V when id V is vertex and also id V is not Input and also id V is not trivial and also id W is edge id V and also id U edge id V and also id W is not btedge id U and id V, where W is less than U.",
            "NL": "If vertex id V is given, edge id W is connected to id V, which is not input or trivial, and edge id U is connected to id V, where Z is less than U, then there is an ntedge with ids W, U, and V."
        },
        {
            "Category": "Definition When",
            "CNL": "id W mvlabel id U and id M when id U is edge id V and also id W is active and also id V is not trivial and also id W is not trivial and also id V is active and also id V is reach id W and also id W is reach id V and also id W is mvlabel id U and id P, where W is different from V.",
            "NL": "If U is an edge of V, W is active, V is not trivial, W is not trivial, V is active, V reaches W, W reaches V, W is not equal to V, W is not an mvlabel of V and P, then W is an mvlabel of U, and M."
        },
        {
            "Category": "Definition When",
            "CNL": "id W mvlabel id U and id M when id U is edge id V and also id W is active and also id V is not trivial and also id W is not trivial and also id V is active and also id V is reach id W and also id W is reach id V and also id W is mvlabel id U and id P, where W is different from V.",
            "NL": "If U is adjacent to V, W is active, V is not trivial, W is not trivial, V is active, V reaches W, W reaches V, where W is not equal to V, W is not the same label as V, and P then W is the same label as U, and M."
        },
        {
            "Category": "Definition When",
            "CNL": "id W mvlabel id U and id M when id U is edge id V and also id W is active and also id V is not trivial and also id W is not trivial and also id V is active and also id V is reach id W and also id W is reach id V and also id W is mvlabel id U and id P, where W is different from V.",
            "NL": "If U is at the edge of V, W is active, V is not trivial, W is not trivial, V is active, V can reach W, W can reach V, where W is not equal to V, W is not the same label as V and P, then W is the same label as U, and M."
        },
        {
            "Category": "Definition When",
            "CNL": "id W mvlabel id U and id M when id U is edge id V and also id W is active and also id V is not trivial and also id W is not trivial and also id V is active and also id V is reach id W and also id W is reach id V and also id W is mvlabel id U and id P, where W is different from V.",
            "NL": "If U is adjacent to V, W is active, V is not trivial, W is not trivial, V is active, V reaches W, W reaches V, W is not equal to V, W is not the same as V, and P then W is the same as U, and M."
        },
        {
            "Category": "Definition When",
            "CNL": "id W mvlabel id U and id M when id U is edge id V and also id W is active and also id V is not trivial and also id W is not trivial and also id V is active and also id V is reach id W and also id W is reach id V and also id W is mvlabel id U and id P, where W is different from V.",
            "NL": "When edge U is between vertices V and W, where W is not equal to V, W is not a multilabel of V, and P is a multilabel of U, then W is a multilabel of U, and M."
        },
        {
            "Category": "Definition When",
            "CNL": "id W mvlabel id U and id P when id U is edge id V and also id W is active and also id V is not trivial and also id W is not trivial and also id V is active and also id V is reach id W and also id W is reach id V and also id W is mvlabel id U and id M, where W is different from V.",
            "NL": "If U is on the edge of V, W is active, V is not trivial, W is not trivial, V is active, V reaches W, W reaches V, where W is not equal to V, W is not labeled as V and M, then W is labeled as U, and P."
        },
        {
            "Category": "Definition When",
            "CNL": "id W mvlabel id U and id P when id U is edge id V and also id W is active and also id V is not trivial and also id W is not trivial and also id V is active and also id V is reach id W and also id W is reach id V and also id W is mvlabel id U and id M, where W is different from V.",
            "NL": "When U is on the edge of V, W is active, V is not insignificant, W is not insignificant, V is active, V reaches W, W reaches V, where W is not the same as V, and W is not labeled by V and M, then W is labeled by U, and P."
        },
        {
            "Category": "Definition When",
            "CNL": "id W mvlabel id U and id P when id U is edge id V and also id W is active and also id V is not trivial and also id W is not trivial and also id V is active and also id V is reach id W and also id W is reach id V and also id W is mvlabel id U and id M, where W is different from V.",
            "NL": "If U is an edge of V, W is active, V is not trivial, W is not trivial, V is active, V reaches W, W reaches V, where W is not equal to V, and W is not an mvlabel of V and M, then W is an mvlabel of U, and P."
        },
        {
            "Category": "Definition When",
            "CNL": "id W mvlabel id U and id P when id U is edge id V and also id W is active and also id V is not trivial and also id W is not trivial and also id V is active and also id V is reach id W and also id W is reach id V and also id W is mvlabel id U and id M, where W is different from V.",
            "NL": "When U is at the edge of V, W is active, V is not inconsequential, W is not inconsequential, V is active, V reaches W, W reaches V, where W is not equal to V, and W is not the same label as V and M, then W is the same label as U, and P."
        },
        {
            "Category": "Definition When",
            "CNL": "id W mvlabel id U and id P when id U is edge id V and also id W is active and also id V is not trivial and also id W is not trivial and also id V is active and also id V is reach id W and also id W is reach id V and also id W is mvlabel id U and id M, where W is different from V.",
            "NL": "If U is adjacent to V, W is active, V is not trivial, W is not trivial, V is active, V reaches W, W reaches V, where W is not equal to V, and W is not a multiple label of V and M, then W is a multiple label of U, and P."
        },
        {
            "Category": "Definition When",
            "CNL": "id W mvlabel id U and id S when id U is obs_vlabel id S and also id U edge id V and also id W is vertex and also id V is not trivial and also id W is not trivial and also id V is not Input and also id W is not Input, where W is different from V.",
            "NL": "If id V is the obs_vlabel of id S, id U is the edge of id V, id W is the vertex, id V is not trivial, id W is not trivial, id V is not an input, id W is an input, and id W is not equal to id V, then id W is the mvlabel of id U and id S."
        },
        {
            "Category": "Definition When",
            "CNL": "id W mvlabel id U and id S when id U is obs_vlabel id S and also id U edge id V and also id W is vertex and also id V is not trivial and also id W is not trivial and also id V is not Input and also id W is not Input, where W is different from V.",
            "NL": "When vertex V is observed to have label S, edge U is incident to vertex V, vertex W is distinct from V, both V and W are non-trivial, and V is not an input while W is an input, then vertex W has label U, and V has label S."
        },
        {
            "Category": "Definition When",
            "CNL": "id W mvlabel id U and id S when id U is obs_vlabel id S and also id U edge id V and also id W is vertex and also id V is not trivial and also id W is not trivial and also id V is not Input and also id W is not Input, where W is different from V.",
            "NL": "When id V is observed to be a vlabel of id S, id U is an edge of id V, id W is a vertex, id V is not trivial, id W is not trivial, id V is not an input, id W is an input, and id W is not equal to id V, then id W becomes the mvlabel of id U, with id S as its source."
        },
        {
            "Category": "Definition When",
            "CNL": "id W mvlabel id U and id S when id U is obs_vlabel id S and also id U edge id V and also id W is vertex and also id V is not trivial and also id W is not trivial and also id V is not Input and also id W is not Input, where W is different from V.",
            "NL": "When id V is observed as the label of id S, id U is the edge connected to id V, id W is the vertex, and neither id V nor id W is trivial or input (where id W is not equal to id V), then id W is the label of the edge id U, and id S."
        },
        {
            "Category": "Definition When",
            "CNL": "id W mvlabel id U and id S when id U is obs_vlabel id S and also id U edge id V and also id W is vertex and also id V is not trivial and also id W is not trivial and also id V is not Input and also id W is not Input, where W is different from V.",
            "NL": "If id V is the obs_vlabel of id S, id U is an edge of id V, id W is a vertex, id V is non-trivial, id W is non-trivial, id V is not an input, and id W is an input but not equal to id V, then id W is the mvlabel of id U, and id S."
        },
        {
            "Category": "Definition When",
            "CNL": "id W mvlabel id V and id M when id W is active and also id V is not trivial and also id W is not trivial and also id V is active and also id W is reach id V and also id V is reach id W and also id W is mvlabel id V and id P, where W is different from V. ",
            "NL": "When id W is active, id V is not trivial; when id W is not trivial, id V is active; when id V is reachable from id W, and id W is reachable from id V, where id W is not equal to id V, and id W is mvlabeling id V and id P then id W is mvlabeling id V, and id M."
        },
        {
            "Category": "Definition When",
            "CNL": "id W mvlabel id V and id M when id W is active and also id V is not trivial and also id W is not trivial and also id V is active and also id W is reach id V and also id V is reach id W and also id W is mvlabel id V and id P, where W is different from V. ",
            "NL": "When id W is active, id V is not trivial, and conversely, when id V is active, id W is not trivial. Assuming that id W is not equal to id V, and that id W is mvlabel id V and id P, then id W is mvlabel id V and id M."
        },
        {
            "Category": "Definition When",
            "CNL": "id W mvlabel id V and id M when id W is active and also id V is not trivial and also id W is not trivial and also id V is active and also id W is reach id V and also id V is reach id W and also id W is mvlabel id V and id P, where W is different from V. ",
            "NL": "When id W is active, id V is not trivial; when id W is not trivial, id V is active and reaches id W; when id W is not equal to id V, and id W mvlabels id V and id P, then id W mvlabels id V and id M."
        },
        {
            "Category": "Definition When",
            "CNL": "id W mvlabel id V and id M when id W is active and also id V is not trivial and also id W is not trivial and also id V is active and also id W is reach id V and also id V is reach id W and also id W is mvlabel id V and id P, where W is different from V. ",
            "NL": "When id W is active, id V is not trivial, and vice versa; id W is reachable from id V and id V is reachable from id W, provided that id W is not equal to id V, and if id W is mvlabel id V and id P then id M is also mvlabel id V."
        },
        {
            "Category": "Definition When",
            "CNL": "id W mvlabel id V and id M when id W is active and also id V is not trivial and also id W is not trivial and also id V is active and also id W is reach id V and also id V is reach id W and also id W is mvlabel id V and id P, where W is different from V. ",
            "NL": "When id W is active, id V is not trivial and vice versa; if id W is not equal to id V, and id W has mvlabeled id V and id P, then id W has mvlabeled id V and id M."
        },
        {
            "Category": "Definition When",
            "CNL": "id W mvlabel id V and id P when id W is active and also id V is not trivial and also id W is not trivial and also id V is active and also id W is reach id V and also id V is reach id W and also id W is mvlabel id V and id M, where W is different from V. ",
            "NL": "If id W is active, id V is not trivial, id W is not trivial, id V is active, id V reaches id W, id W reaches id V, where id W is not equal to id V, and id W is not mvlabeled to id M, then id W mvlabels id V, and id P."
        },
        {
            "Category": "Definition When",
            "CNL": "id W mvlabel id V and id P when id W is active and also id V is not trivial and also id W is not trivial and also id V is active and also id W is reach id V and also id V is reach id W and also id W is mvlabel id V and id M, where W is different from V. ",
            "NL": "If id W is active, id V is not trivial, id W is not trivial, id V is active, id V is not equal to id W, and id W is not mvlabel id V and id M, then id W mvlabels id V, and id P."
        },
        {
            "Category": "Definition When",
            "CNL": "id W mvlabel id V and id P when id W is active and also id V is not trivial and also id W is not trivial and also id V is active and also id W is reach id V and also id V is reach id W and also id W is mvlabel id V and id M, where W is different from V. ",
            "NL": "If W is active, V is not trivial, W is not trivial, V is active, V can reach W, W can reach V, W is not equal to V, W is not labeled M, and V is labeled P, then W labels V."
        },
        {
            "Category": "Definition When",
            "CNL": "id W mvlabel id V and id P when id W is active and also id V is not trivial and also id W is not trivial and also id V is active and also id W is reach id V and also id V is reach id W and also id W is mvlabel id V and id M, where W is different from V. ",
            "NL": "If id W is active, id V is not trivial, id W is not trivial, id V is active, id V reaches id W, id W reaches id V, where id W is not the same as id V, and id W is not mvlabeled id V and id M, then id W mvlabels id V, and id P."
        },
        {
            "Category": "Definition When",
            "CNL": "id W mvlabel id V and id P when id W is active and also id V is not trivial and also id W is not trivial and also id V is active and also id W is reach id V and also id V is reach id W and also id W is mvlabel id V and id M, where W is different from V. ",
            "NL": "If W is active, V is not trivial, W is not trivial, V is active, V is reachable from W, W is reachable from V, W is not equal to V, W is not mvlabeled by V and M, then W mvlabels V, and P."
        },
        {
            "Category": "Definition When",
            "CNL": "id W mvlabel id V and id S when id V is obs_vlabel id S and also id W is vertex and also id V is not trivial and also id W is not trivial and also id V is not Input and also id W is not Input, where W is different from V.",
            "NL": "If V is the observed vertex label of S, and W is a vertex such that V is not trivial, W is not trivial, V is not an input, and W is not equal to V, then W is the multivertex label of V, and S."
        },
        {
            "Category": "Definition When",
            "CNL": "id W mvlabel id V and id S when id V is obs_vlabel id S and also id W is vertex and also id V is not trivial and also id W is not trivial and also id V is not Input and also id W is not Input, where W is different from V.",
            "NL": "When vertex id V is labeled as obs_vlabel id S, and vertex id W is not equal to id V, and both id V and id W are not trivial or input, then id W is labeled mvlabel id V, and id S."
        },
        {
            "Category": "Definition When",
            "CNL": "id W mvlabel id V and id S when id V is obs_vlabel id S and also id W is vertex and also id V is not trivial and also id W is not trivial and also id V is not Input and also id W is not Input, where W is different from V.",
            "NL": "If id V is the obs_vlabel of id S, and id W is a vertex such that id W is not equal to id V, id W is not trivial, and id V is not trivial or an input, then id W is the mvlabel of id V and id S."
        },
        {
            "Category": "Definition When",
            "CNL": "id W mvlabel id V and id S when id V is obs_vlabel id S and also id W is vertex and also id V is not trivial and also id W is not trivial and also id V is not Input and also id W is not Input, where W is different from V.",
            "NL": "When id V is observed as the vertex label of id S, and id W is a vertex such that id W is not equal to id V, and neither id V nor id W is trivial or an input, then id W is the mvlabel of id V, and id S."
        },
        {
            "Category": "Definition When",
            "CNL": "id W mvlabel id V and id S when id V is obs_vlabel id S and also id W is vertex and also id V is not trivial and also id W is not trivial and also id V is not Input and also id W is not Input, where W is different from V.",
            "NL": "If id V is the observed vertex label for id S, id W is a vertex, id V is not trivial, id W is not trivial, and id W is not equal to id V, then id W is the mvlabel for id V, and id S."
        },
        {
            "Category": "Definition When",
            "CNL": "key2 Q OutgoingRoute key2 L and key2 E when key2 L is NonFollowing key2 E and also key2 Q is Sub_Index and also key2 L is not Simple_Graph and also key2 Q is not Simple_Graph and also key2 L is not Walk and also key2 Q is not Walk, where Q is different from L.",
            "NL": "If key2 L is not Following key2 E, key2 Q is Sub_Index, key2 L is not Simple_Graph, key2 Q is not Simple_Graph, and key2 Q is not equal to key2 L, then key2 Q is OutgoingRoute of key2 L, and key2 E."
        },
        {
            "Category": "Definition When",
            "CNL": "key2 Q OutgoingRoute key2 L and key2 E when key2 L is NonFollowing key2 E and also key2 Q is Sub_Index and also key2 L is not Simple_Graph and also key2 Q is not Simple_Graph and also key2 L is not Walk and also key2 Q is not Walk, where Q is different from L.",
            "NL": "If key2 L is not Following key2 E, key2 Q is not equal to key2 L, key2 L is not a Simple_Graph, and key2 Q is not a Simple_Graph, and key2 L is not a Walk, then key2 Q is an OutgoingRoute from key2 L to key2 E."
        },
        {
            "Category": "Definition When",
            "CNL": "key2 Q OutgoingRoute key2 L and key2 E when key2 L is NonFollowing key2 E and also key2 Q is Sub_Index and also key2 L is not Simple_Graph and also key2 Q is not Simple_Graph and also key2 L is not Walk and also key2 Q is not Walk, where Q is different from L.",
            "NL": "If key2 L is not NonFollowing key2 E, key2 Q is not Sub_Index, key2 L is not Simple_Graph, key2 Q is not Simple_Graph, and key2 L is not Walk, and key2 Q is not equal to key2 L, then key2 Q is OutgoingRoute from key2 L to key2 E."
        },
        {
            "Category": "Definition When",
            "CNL": "key2 Q OutgoingRoute key2 L and key2 E when key2 L is NonFollowing key2 E and also key2 Q is Sub_Index and also key2 L is not Simple_Graph and also key2 Q is not Simple_Graph and also key2 L is not Walk and also key2 Q is not Walk, where Q is different from L.",
            "NL": "When key2 L is not Following key2 E, key2 Q is an OutgoingRoute of key2 L, and key2 E is not equal to key2 Q or key2 L, and neither key2 Q nor key2 L is a Simple_Graph or a Walk."
        },
        {
            "Category": "Definition When",
            "CNL": "key2 Q OutgoingRoute key2 L and key2 E when key2 L is NonFollowing key2 E and also key2 Q is Sub_Index and also key2 L is not Simple_Graph and also key2 Q is not Simple_Graph and also key2 L is not Walk and also key2 Q is not Walk, where Q is different from L.",
            "NL": "If key2 L is not NonFollowing key2 E, key2 Q is not Sub_Index, key2 L is Simple_Graph, key2 Q is Simple_Graph, key2 L is Walk, and key2 Q is not equal to key2 L, then key2 Q is OutgoingRoute key2 L, and key2 E."
        },
        {
            "Category": "Definition When",
            "CNL": "key5 C is Triad when key5 C is Outgroup and also key5 C is not Elabel.",
            "NL": "If key5 C is an Outgroup and is not Elabeled, then it is a Triad."
        },
        {
            "Category": "Definition When",
            "CNL": "key5 C is Triad when key5 C is Outgroup and also key5 C is not Elabel.",
            "NL": "If key5 C is an Outgroup but not Elabel, then it is a Triad."
        },
        {
            "Category": "Definition When",
            "CNL": "key5 C is Triad when key5 C is Outgroup and also key5 C is not Elabel.",
            "NL": "If key5 C is an Outgroup that is not Elabel, then it is a Triad."
        },
        {
            "Category": "Definition When",
            "CNL": "key5 C is Triad when key5 C is Outgroup and also key5 C is not Elabel.",
            "NL": "If key5 C is an Outgroup and not Elabel, it is a Triad."
        },
        {
            "Category": "Definition When",
            "CNL": "key5 C is Triad when key5 C is Outgroup and also key5 C is not Elabel.",
            "NL": "If key5 C is an Outgroup and is not Elabel, then key5 C is a Triad."
        },
        {
            "Category": "Definition When",
            "CNL": "key5 J have a Count key5 V when key5 V have a Following key5 J and also key5 J has a Solitary key5 V.",
            "NL": "When the key5 J has a Following key5 V and the key5 V has a Solitary key5 J, the key5 J has a Count key5 V."
        },
        {
            "Category": "Definition When",
            "CNL": "key5 J have a Count key5 V when key5 V have a Following key5 J and also key5 J has a Solitary key5 V.",
            "NL": "When the Count key5 V has a Following key5 J, and when the Solitary key5 V has a key5 J, the key5 J has a key5 V."
        },
        {
            "Category": "Definition When",
            "CNL": "key5 J have a Count key5 V when key5 V have a Following key5 J and also key5 J has a Solitary key5 V.",
            "NL": "When the Count key5 J has a Following key5 V and the Solitary key5 J has a key5 V, the key5 J has a key5 V."
        },
        {
            "Category": "Definition When",
            "CNL": "key5 J have a Count key5 V when key5 V have a Following key5 J and also key5 J has a Solitary key5 V.",
            "NL": "When the key5 J has a Following key5 V and also when the key5 V has a Solitary key5 J, the key5 J has a Count key5 V."
        },
        {
            "Category": "Definition When",
            "CNL": "key5 J have a Count key5 V when key5 V have a Following key5 J and also key5 J has a Solitary key5 V.",
            "NL": "When the key5 J has a Count key5 V, the key5 V has a Following key5 J; likewise, when the key5 J has a Solitary key5 V, the key5 V also has a Following key5 J."
        },
        {
            "Category": "Definition When",
            "CNL": "key7 E is Compare key7 D when key7 E is Attained key7 M and also key7 D is Walk key7 P, where P is less than or equal to E and D is different from M.",
            "NL": "When the key7 E is attained, comparing key7 M is key7 D is also a walk, where P is less than or equal to E and D is not equal to M."
        },
        {
            "Category": "Definition When",
            "CNL": "key7 E is Compare key7 D when key7 E is Attained key7 M and also key7 D is Walk key7 P, where P is less than or equal to E and D is different from M.",
            "NL": "When the key7 E is attained, compare it to key7 M. Additionally, the key7 D is a walk key7 P, where P is less than or equal to E and D is not equal to M."
        },
        {
            "Category": "Definition When",
            "CNL": "key7 E is Compare key7 D when key7 E is Attained key7 M and also key7 D is Walk key7 P, where P is less than or equal to E and D is different from M.",
            "NL": "When key7 E is achieved, compare it to key7 M; additionally, key7 D is a lower key7 P, but D is not equal to M and P is less than or equal to E."
        },
        {
            "Category": "Definition When",
            "CNL": "key7 E is Compare key7 D when key7 E is Attained key7 M and also key7 D is Walk key7 P, where P is less than or equal to E and D is different from M.",
            "NL": "Compare key7 M to key7 E when key7 E is attained, and key7 P is less than or equal to key7 E, but key7 D is not equal to key7 M."
        },
        {
            "Category": "Definition When",
            "CNL": "key7 E is Compare key7 D when key7 E is Attained key7 M and also key7 D is Walk key7 P, where P is less than or equal to E and D is different from M.",
            "NL": "Compare key7 M to key7 E once key7 E is attained, and key7 D is also a different type of key7 P, where P is less than or equal to E and D is not equal to M."
        },
        {
            "Category": "Definition When",
            "CNL": "key7 J have an Width key7 34 when key7 J is Intersect and also key7 J is not Centrality.",
            "NL": "When the key7 J is an Intersection, as well as when it is not Central, it has a Width of 34."
        },
        {
            "Category": "Definition When",
            "CNL": "key7 J have an Width key7 34 when key7 J is Intersect and also key7 J is not Centrality.",
            "NL": "When the key7 J is an Intersection, and even when it is not Centrality, it has a Width of 34."
        },
        {
            "Category": "Definition When",
            "CNL": "key7 J have an Width key7 34 when key7 J is Intersect and also key7 J is not Centrality.",
            "NL": "When the key7 J is an Intersection, as well as when it is not Centrality, it has a Width of 34."
        },
        {
            "Category": "Definition When",
            "CNL": "key7 J have an Width key7 34 when key7 J is Intersect and also key7 J is not Centrality.",
            "NL": "When the key7 J is an Intersection, it has a width of 34, as well as when the key7 J is not Centrality."
        },
        {
            "Category": "Definition When",
            "CNL": "key7 J have an Width key7 34 when key7 J is Intersect and also key7 J is not Centrality.",
            "NL": "When the key7 J is an Intersection, it has a width of 34, as well as when it is not Centrality."
        },
        {
            "Category": "Definition When",
            "CNL": "list 1 has an asgn to list A when list A is fstatom.",
            "NL": "There is a correlation between List 1 and List A when List A is finalized."
        },
        {
            "Category": "Definition When",
            "CNL": "list 1 has an asgn to list A when list A is fstatom.",
            "NL": "There is a correlation between List 1 and List A when List A is analyzed."
        },
        {
            "Category": "Definition When",
            "CNL": "list 1 has an asgn to list A when list A is fstatom.",
            "NL": "A connection exists between List 1 and List A when List A is finalized."
        },
        {
            "Category": "Definition When",
            "CNL": "list 1 has an asgn to list A when list A is fstatom.",
            "NL": "There is a connection between list 1 and list A when list A is finalized."
        },
        {
            "Category": "Definition When",
            "CNL": "list 1 has an asgn to list A when list A is fstatom.",
            "NL": "A correlation exists between List 1 and List A when List A is finalized."
        },
        {
            "Category": "Definition When",
            "CNL": "list 2N-1 is node when list N is Atomcnt.",
            "NL": "If a list N is an Atomic, then a node is a list with 2N-1 elements."
        },
        {
            "Category": "Definition When",
            "CNL": "list 2N-1 is node when list N is Atomcnt.",
            "NL": "If a list N is Atomic, then a node is a list 2N-1."
        },
        {
            "Category": "Definition When",
            "CNL": "list 2N-1 is node when list N is Atomcnt.",
            "NL": "If a list N is an Atomcnt, then a node is a list 2N-1."
        },
        {
            "Category": "Definition When",
            "CNL": "list 2N-1 is node when list N is Atomcnt.",
            "NL": "If a list N is an Atomicnt, then a node is a list 2N-1."
        },
        {
            "Category": "Definition When",
            "CNL": "list 2N-1 is node when list N is Atomcnt.",
            "NL": "If an Atomicnt is a list N, then a node is a list 2N-1."
        },
        {
            "Category": "Definition When",
            "CNL": "list E is proj when list E has a member to E, and L.",
            "NL": "If a project has a member from both list E and list L, it is classified as list E."
        },
        {
            "Category": "Definition When",
            "CNL": "list E is proj when list E has a member to E, and L.",
            "NL": "If a project has a member from both List E and List L, it is referred to as List E."
        },
        {
            "Category": "Definition When",
            "CNL": "list E is proj when list E has a member to E, and L.",
            "NL": "If there is a representative from both E and L on list E, it can be classified as a project."
        },
        {
            "Category": "Definition When",
            "CNL": "list E is proj when list E has a member to E, and L.",
            "NL": "If a list E contains a member from both E and L, it is considered to be a project."
        },
        {
            "Category": "Definition When",
            "CNL": "list E is proj when list E has a member to E, and L.",
            "NL": "A project is considered to be a list E if it has a representative from both E and L."
        },
        {
            "Category": "Definition When",
            "CNL": "list L is assigned when list X has an asgn list L and also list L is comp.",
            "NL": "When list X is assigned, list L is also assigned, as it is a complementary list."
        },
        {
            "Category": "Definition When",
            "CNL": "list L is assigned when list X has an asgn list L and also list L is comp.",
            "NL": "When list X has an assigned list L, list L is also designated as a composite list."
        },
        {
            "Category": "Definition When",
            "CNL": "list L is assigned when list X has an asgn list L and also list L is comp.",
            "NL": "When list X has an assigned list L, list L is both assigned and a comprehensive list."
        },
        {
            "Category": "Definition When",
            "CNL": "list L is assigned when list X has an asgn list L and also list L is comp.",
            "NL": "When list X has an assigned list L, list L is also designated as a completed list."
        },
        {
            "Category": "Definition When",
            "CNL": "list L is assigned when list X has an asgn list L and also list L is comp.",
            "NL": "When list X has an assigned list L, list L is designated as a comprehensive list."
        },
        {
            "Category": "Definition When",
            "CNL": "list L is sublist list1 L when list L is comp.",
            "NL": "If list L is a component, it is a subset of list L1."
        },
        {
            "Category": "Definition When",
            "CNL": "list L is sublist list1 L when list L is comp.",
            "NL": "If list L is a component, then list L is a subset of list1 L."
        },
        {
            "Category": "Definition When",
            "CNL": "list L is sublist list1 L when list L is comp.",
            "NL": "If list L is a component, it is a sublist of list L1."
        },
        {
            "Category": "Definition When",
            "CNL": "list L is sublist list1 L when list L is comp.",
            "NL": "If list L is a subset, then list L is a component of list1 L."
        },
        {
            "Category": "Definition When",
            "CNL": "list L is sublist list1 L when list L is comp.",
            "NL": "If list L is a component, list L is a subset of list1 L."
        },
        {
            "Category": "Definition When",
            "CNL": "list N-1 has an asgn to list B when list N has an asgn list A and also list A have a nxtatom list B.",
            "NL": "When list N has an assignment to list A and list A has a subsequent atom list B, list N-1 has an assignment to list B."
        },
        {
            "Category": "Definition When",
            "CNL": "list N-1 has an asgn to list B when list N has an asgn list A and also list A have a nxtatom list B.",
            "NL": "When list N has an assignment to list A and list A has a next atom list B, list N-1 has an assignment to list B."
        },
        {
            "Category": "Definition When",
            "CNL": "list N-1 has an asgn to list B when list N has an asgn list A and also list A have a nxtatom list B.",
            "NL": "If list N has an assignment to list A and list A has a next atom list B, then list N-1 will have an assignment to list B."
        },
        {
            "Category": "Definition When",
            "CNL": "list N-1 has an asgn to list B when list N has an asgn list A and also list A have a nxtatom list B.",
            "NL": "When list N has an assignment to list A, and list A has a next atom list B, list N-1 is assigned to list B."
        },
        {
            "Category": "Definition When",
            "CNL": "list N-1 has an asgn to list B when list N has an asgn list A and also list A have a nxtatom list B.",
            "NL": "When list N has an assignment to list A, and list A has a next atom list B, list N-1 has an assignment to list B."
        },
        {
            "Category": "Definition When",
            "CNL": "list N-1 is node when list N is node, where N is greater than 1.",
            "NL": "When N is greater than 1, N-1 is the number of nodes in the list, with one node present."
        },
        {
            "Category": "Definition When",
            "CNL": "list N-1 is node when list N is node, where N is greater than 1.",
            "NL": "When N is greater than 1, there is a node in the list at N-1, with N being the number of nodes."
        },
        {
            "Category": "Definition When",
            "CNL": "list N-1 is node when list N is node, where N is greater than 1.",
            "NL": "When the number of nodes N is greater than 1, there is a node at position N-1 in the list."
        },
        {
            "Category": "Definition When",
            "CNL": "list N-1 is node when list N is node, where N is greater than 1.",
            "NL": "When the number of nodes, N, is greater than 1, there is a node at position N-1 in the list."
        },
        {
            "Category": "Definition When",
            "CNL": "list N-1 is node when list N is node, where N is greater than 1.",
            "NL": "When N, the number of nodes, is greater than 1, there is a node in the list at position N-1."
        },
        {
            "Category": "Definition When",
            "CNL": "list X has a denied list L when list X has an edge list L and also list L have a comp and also list Y has a reach list L.",
            "NL": "When list X has an edge list Y, list L contains both a denied list X and a complete reach list Y."
        },
        {
            "Category": "Definition When",
            "CNL": "list X has a denied list L when list X has an edge list L and also list L have a comp and also list Y has a reach list L.",
            "NL": "If list X has an edge list Y, list L will contain a denied list X and both a complete and a reach list Y."
        },
        {
            "Category": "Definition When",
            "CNL": "list X has a denied list L when list X has an edge list L and also list L have a comp and also list Y has a reach list L.",
            "NL": "When list X contains an edge list Y, list L has a denied list X and both a complete and a reach list Y."
        },
        {
            "Category": "Definition When",
            "CNL": "list X has a denied list L when list X has an edge list L and also list L have a comp and also list Y has a reach list L.",
            "NL": "When list X has an edge list Y, list L contains both a denied list X and a complete and reach list Y."
        },
        {
            "Category": "Definition When",
            "CNL": "list X has a denied list L when list X has an edge list L and also list L have a comp and also list Y has a reach list L.",
            "NL": "When list X has an edge list Y, list L contains a denied list X, a complete list Y, and a reach list Y."
        },
        {
            "Category": "Definition When",
            "CNL": "list X has a reach list A when list Y has a reach list A and also list X have an edge list Y.",
            "NL": "List A has a reach list X, and List Y has a reach list A and an edge list X."
        },
        {
            "Category": "Definition When",
            "CNL": "list X has a reach list A when list Y has a reach list A and also list X have an edge list Y.",
            "NL": "When list Y has a reach list A, there is a corresponding reach list X in list A, and likewise, list Y has an edge list X."
        },
        {
            "Category": "Definition When",
            "CNL": "list X has a reach list A when list Y has a reach list A and also list X have an edge list Y.",
            "NL": "When list Y has a reach list A, list A also has a reach list X and list Y has an edge list X."
        },
        {
            "Category": "Definition When",
            "CNL": "list X has a reach list A when list Y has a reach list A and also list X have an edge list Y.",
            "NL": "When list Y has a reach list A, both list A and list Y have a reach list X and an edge list X."
        },
        {
            "Category": "Definition When",
            "CNL": "list X has a reach list A when list Y has a reach list A and also list X have an edge list Y.",
            "NL": "When list Y has a reach list A, both list A and list Y have a rich list X, as well as an edge list X."
        },
        {
            "Category": "Definition When",
            "CNL": "list X has a transs to list Y when list X has an edge list Y and also list X is node. ",
            "NL": "When list X has an advantage over list Y and has nodes in list X+1, there is a connection between list X and list Y."
        },
        {
            "Category": "Definition When",
            "CNL": "list X has a transs to list Y when list X has an edge list Y and also list X is node. ",
            "NL": "When list X has an advantage over list Y and has nodes in list X+1, a transition exists between list X and list Y."
        },
        {
            "Category": "Definition When",
            "CNL": "list X has a transs to list Y when list X has an edge list Y and also list X is node. ",
            "NL": "When list X has an advantage over list Y and contains nodes in list X+1, there is a connection between list X and list Y."
        },
        {
            "Category": "Definition When",
            "CNL": "list X has a transs to list Y when list X has an edge list Y and also list X is node. ",
            "NL": "When list X has an advantage over list Y and contains nodes from list X+1, there is a connection between list X and list Y."
        },
        {
            "Category": "Definition When",
            "CNL": "list X has a transs to list Y when list X has an edge list Y and also list X is node. ",
            "NL": "When list X has an advantage over list Y and has elements in list X+1, there is a connection between list X and list Y."
        },
        {
            "Category": "Definition When",
            "CNL": "list X has an asgn to list L when list X have a haschild and also list L have a comp and also list X have not denied list L. ",
            "NL": "If list X has a haschild and list L has a comp and list X has not denied list L, a connection is established between list X and list L."
        },
        {
            "Category": "Definition When",
            "CNL": "list X has an asgn to list L when list X have a haschild and also list L have a comp and also list X have not denied list L. ",
            "NL": "If list X has a haschild, list L has a comp, and list X has not denied list L, then an asgn is formed between the two lists."
        },
        {
            "Category": "Definition When",
            "CNL": "list X has an asgn to list L when list X have a haschild and also list L have a comp and also list X have not denied list L. ",
            "NL": "If list X has a haschild and list L has a comp and list X has not denied list L, then an asgn is created between list X and list L."
        },
        {
            "Category": "Definition When",
            "CNL": "list X has an asgn to list L when list X have a haschild and also list L have a comp and also list X have not denied list L. ",
            "NL": "When list X has a haschild and list L has a comp and list X has not refused list L, an assignment is established between list X and list L."
        },
        {
            "Category": "Definition When",
            "CNL": "list X has an asgn to list L when list X have a haschild and also list L have a comp and also list X have not denied list L. ",
            "NL": "If list X has a haschild and list L has a comp with no denial from list X, then an asgn is created between lists X and L."
        },
        {
            "Category": "Definition When",
            "CNL": "list X have a next list A when list A have member list L and also list X have an edge list Y and also list Y has an asgn list A.",
            "NL": "When list A has a member list L, List X has a subsequent list A and when list Y has an asgn list A, List X has an edge list Y."
        },
        {
            "Category": "Definition When",
            "CNL": "list X have a next list A when list A have member list L and also list X have an edge list Y and also list Y has an asgn list A.",
            "NL": "When list A has a member list L, List X has a next list A and when list Y has an asgn list A, List X has an edge list Y."
        },
        {
            "Category": "Definition When",
            "CNL": "list X have a next list A when list A have member list L and also list X have an edge list Y and also list Y has an asgn list A.",
            "NL": "When list A has a member list L, list X has a next list A, and when list Y has an asgn list A, list X has an edge list Y."
        },
        {
            "Category": "Definition When",
            "CNL": "list X have a next list A when list A have member list L and also list X have an edge list Y and also list Y has an asgn list A.",
            "NL": "When list A contains member list L, list X has a subsequent list A, and when list Y has an assignment list A, list X has an edge list Y."
        },
        {
            "Category": "Definition When",
            "CNL": "list X have a next list A when list A have member list L and also list X have an edge list Y and also list Y has an asgn list A.",
            "NL": "When list A contains a member list L, list X has a subsequent list A and when list Y has an asgn list A, list X has an edge list Y."
        },
        {
            "Category": "Definition When",
            "CNL": "list X have a pair to list Y when list X is node and also list Y is node and also list N is Atomcnt, where X is greater than Y and X is greater than N.",
            "NL": "When X is greater than both Y and N, there is a pair between list X and list Y, with list X being a node and list Y being a node and list N being an Atomcnt."
        },
        {
            "Category": "Definition When",
            "CNL": "list X have a pair to list Y when list X is node and also list Y is node and also list N is Atomcnt, where X is greater than Y and X is greater than N.",
            "NL": "When List X is a node, List Y is a node, and List N is an Atomicnt, there is a pair between List X and List Y where X is greater than both Y and N."
        },
        {
            "Category": "Definition When",
            "CNL": "list X have a pair to list Y when list X is node and also list Y is node and also list N is Atomcnt, where X is greater than Y and X is greater than N.",
            "NL": "When list X is a node, list Y is a node, and list N is an Atomcnt, there is a pair between X and Y where X is greater than both Y and N."
        },
        {
            "Category": "Definition When",
            "CNL": "list X have a pair to list Y when list X is node and also list Y is node and also list N is Atomcnt, where X is greater than Y and X is greater than N.",
            "NL": "When List X is a node greater than both List Y and List N, which are both nodes and N is an Atomcnt, there is a pair between List X and List Y."
        },
        {
            "Category": "Definition When",
            "CNL": "list X have a pair to list Y when list X is node and also list Y is node and also list N is Atomcnt, where X is greater than Y and X is greater than N.",
            "NL": "When List X is a node, List Y is a node, and List N is an Atomicnt, there is a pairing between List X and List Y with X being greater than both Y and N."
        },
        {
            "Category": "Definition When",
            "CNL": "list X have a reach list A when list X has an asgn list A.",
            "NL": "When List A has an assignment for List X, there is a record of it on List A."
        },
        {
            "Category": "Definition When",
            "CNL": "list X have a reach list A when list X has an asgn list A.",
            "NL": "When there is an assignment list X on list A, there is a corresponding checklist X on list A."
        },
        {
            "Category": "Definition When",
            "CNL": "list X have a reach list A when list X has an asgn list A.",
            "NL": "When list A has an assignment list X, there is a corresponding checklist X on list A."
        },
        {
            "Category": "Definition When",
            "CNL": "list X have a reach list A when list X has an asgn list A.",
            "NL": "When list A has an assigned list X, there is a corresponding list X on list A."
        },
        {
            "Category": "Definition When",
            "CNL": "list X have a reach list A when list X has an asgn list A.",
            "NL": "If there is a list X on list A, there is an assignment list X on list A."
        },
        {
            "Category": "Definition When",
            "CNL": "list X have a transs to list Y when list X have an transs list Z and also list Z have an edge list Y.",
            "NL": "If list X is connected to list Z, and list Z is linked to list Y, then list X is also connected to list Y."
        },
        {
            "Category": "Definition When",
            "CNL": "list X have a transs to list Y when list X have an transs list Z and also list Z have an edge list Y.",
            "NL": "If list X is connected to list Z, and list Z is connected to list Y, then list X has a direct connection to list Y."
        },
        {
            "Category": "Definition When",
            "CNL": "list X have a transs to list Y when list X have an transs list Z and also list Z have an edge list Y.",
            "NL": "If list X has a transition to list Z and list Z has a connection to list Y, then list X also has a transition to list Y."
        },
        {
            "Category": "Definition When",
            "CNL": "list X have a transs to list Y when list X have an transs list Z and also list Z have an edge list Y.",
            "NL": "If list X has a transition to list Z and list Z has an edge to list Y, then list X has a transition to list Y."
        },
        {
            "Category": "Definition When",
            "CNL": "list X have a transs to list Y when list X have an transs list Z and also list Z have an edge list Y.",
            "NL": "If list X has a transition to list Z, and list Z has an edge to list Y, then list X also has a transition to list Y."
        },
        {
            "Category": "Definition When",
            "CNL": "list X is Acnt list 1 when list X is Atom.",
            "NL": "If list X is Atom, then list X is Acnt list 1."
        },
        {
            "Category": "Definition When",
            "CNL": "list X is Acnt list 1 when list X is Atom.",
            "NL": "When list X is Atom, list X is labeled as list 1."
        },
        {
            "Category": "Definition When",
            "CNL": "list X is Acnt list 1 when list X is Atom.",
            "NL": "If list X is Atoms, then list X is Acnt list 1."
        },
        {
            "Category": "Definition When",
            "CNL": "list X is Acnt list 1 when list X is Atom.",
            "NL": "When list X is Atom, list X is also known as list 1."
        },
        {
            "Category": "Definition When",
            "CNL": "list X is Acnt list 1 when list X is Atom.",
            "NL": "When list X is Atom, list 1 is Acnt list X."
        },
        {
            "Category": "Definition When",
            "CNL": "list X is Atom when list X is proj and also list X is not comp.",
            "NL": "X is referred to as Atom when it is a project and also when it does not constitute a component."
        },
        {
            "Category": "Definition When",
            "CNL": "list X is Atom when list X is proj and also list X is not comp.",
            "NL": "When List X is a project, it is Atom, and when it is not a component, it is still Atom."
        },
        {
            "Category": "Definition When",
            "CNL": "list X is Atom when list X is proj and also list X is not comp.",
            "NL": "When it is a project, List X is Atom, and even when it is not a component."
        },
        {
            "Category": "Definition When",
            "CNL": "list X is Atom when list X is proj and also list X is not comp.",
            "NL": "X is considered to be Atom whether it is a project or not a component."
        },
        {
            "Category": "Definition When",
            "CNL": "list X is Atom when list X is proj and also list X is not comp.",
            "NL": "When List X is a project, it is Atom; likewise, when it is not a component, it is still Atom."
        },
        {
            "Category": "Definition When",
            "CNL": "list X is outgroup when list Y have an asgn list outgroup and also list X have an edge list Y.",
            "NL": "If list Y is assigned an outgroup and list X has the advantage over list Y, then list X is the outgroup."
        },
        {
            "Category": "Definition When",
            "CNL": "list X is outgroup when list Y have an asgn list outgroup and also list X have an edge list Y.",
            "NL": "If list Y is assigned an outgroup and list X has an advantage over list Y, then list X is the outgroup."
        },
        {
            "Category": "Definition When",
            "CNL": "list X is outgroup when list Y have an asgn list outgroup and also list X have an edge list Y.",
            "NL": "When list Y is assigned an outgroup and list X has an advantage over list Y, then list X is the outgroup."
        },
        {
            "Category": "Definition When",
            "CNL": "list X is outgroup when list Y have an asgn list outgroup and also list X have an edge list Y.",
            "NL": "If list Y has an assigned outgroup and list X has an advantage over list Y, then list X is the outgroup."
        },
        {
            "Category": "Definition When",
            "CNL": "list X is outgroup when list Y have an asgn list outgroup and also list X have an edge list Y.",
            "NL": "When list Y has an assigned outgroup and list X has an advantage over list Y, then list X is the outgroup."
        },
        {
            "Category": "Definition When",
            "CNL": "list Y has an order to list Z when list X have an edge list Y and also list X have a edge list Z and also list N is Atomcnt, where N is less than Z and Z is less than Y.",
            "NL": "When list X has an edge list Y and list X also has an edge list Z, and list N (Atomcnt) is less than Z and Z is less than Y, there is an order between list Y and list Z."
        },
        {
            "Category": "Definition When",
            "CNL": "list Y has an order to list Z when list X have an edge list Y and also list X have a edge list Z and also list N is Atomcnt, where N is less than Z and Z is less than Y.",
            "NL": "When list X has an edge over list Y, and list X also has an edge over list Z, and list N is Atomic, where N is less than Z and Z is less than Y, there is an order between list Y and list Z."
        },
        {
            "Category": "Definition When",
            "CNL": "list Y has an order to list Z when list X have an edge list Y and also list X have a edge list Z and also list N is Atomcnt, where N is less than Z and Z is less than Y.",
            "NL": "When List X has an edge on List Y, and List X also has an edge on List Z, and List N (with Atomic Count less than Z and Z less than Y), there is an order between List Y and List Z."
        },
        {
            "Category": "Definition When",
            "CNL": "list Y has an order to list Z when list X have an edge list Y and also list X have a edge list Z and also list N is Atomcnt, where N is less than Z and Z is less than Y.",
            "NL": "When the edge lists of list X are list Y and list Z, and list N is Atomicnt with N being less than Z and Z less than Y, there is an order between list Y and list Z."
        },
        {
            "Category": "Definition When",
            "CNL": "list Y has an order to list Z when list X have an edge list Y and also list X have a edge list Z and also list N is Atomcnt, where N is less than Z and Z is less than Y.",
            "NL": "When List X has an edge list Y and an edge list Z, and List N is Atomic, where N is less than Z and Z is less than Y, there is an order between List Y and List Z."
        },
        {
            "Category": "Definition When",
            "CNL": "node C okin node X when node C have not in node X and also node C pair node X. ",
            "NL": "It is clear that node C is associated with node X when node C does not have IN node X as well as when node C does not have Okin node X."
        },
        {
            "Category": "Definition When",
            "CNL": "node C okin node X when node C have not in node X and also node C pair node X. ",
            "NL": "It is clear that node C is associated with node X both when node C lacks IN node X and when node C lacks Okin node X."
        },
        {
            "Category": "Definition When",
            "CNL": "node C okin node X when node C have not in node X and also node C pair node X. ",
            "NL": "It is clear that node C is linked to node X whether node C has IN or Okin node X or not."
        },
        {
            "Category": "Definition When",
            "CNL": "node C okin node X when node C have not in node X and also node C pair node X. ",
            "NL": "It is clear that node C links with node X whether or not node C has an IN node with X, or an Okin node with X."
        },
        {
            "Category": "Definition When",
            "CNL": "node C okin node X when node C have not in node X and also node C pair node X. ",
            "NL": "It is clear that node C forms a link with node X when there is no IN node X present, and also when there is no Okin node X present."
        },
        {
            "Category": "Definition When",
            "CNL": "node C1 cex node C2 when node X have a member node X and node C1 and also node C2 is clique and also node X not member node X and node C2. ",
            "NL": "When node X has a member in node C1, and node C2 is also a clique but node X is not a member of node C2."
        },
        {
            "Category": "Definition When",
            "CNL": "node C1 cex node C2 when node X have a member node X and node C1 and also node C2 is clique and also node X not member node X and node C2. ",
            "NL": "When node X has a member with node C1, and node C2 is also a clique, node X is not a member of node C2."
        },
        {
            "Category": "Definition When",
            "CNL": "node C1 cex node C2 when node X have a member node X and node C1 and also node C2 is clique and also node X not member node X and node C2. ",
            "NL": "When node X has a member with node C1 and node C2 is a clique, node X is not a member of node C2."
        },
        {
            "Category": "Definition When",
            "CNL": "node C1 cex node C2 when node X have a member node X and node C1 and also node C2 is clique and also node X not member node X and node C2. ",
            "NL": "If node X has a member with node C1, and node C2 is part of a clique with node X, but not a member of node C2."
        },
        {
            "Category": "Definition When",
            "CNL": "node C1 cex node C2 when node X have a member node X and node C1 and also node C2 is clique and also node X not member node X and node C2. ",
            "NL": "When node X has a member in node C1 and node C2 is a clique which node X is not a part of,"
        },
        {
            "Category": "Definition When",
            "CNL": "node C1 rest node X and node C2 when node X have an member node C1 and also node C2 have an subeq node C1 and also node C1 has a cliquesize node S and also node C2 has a cliquesize node S-1, where S is greater than 1.",
            "NL": "If node X has a member node C1, and node C2 has a subeq node C1, and node C1 has a cliquesize node S, and node C2 has a cliquesize node S-1, where S is greater than one, then node C1 rests on node X and node C2."
        },
        {
            "Category": "Definition When",
            "CNL": "node C1 rest node X and node C2 when node X have an member node C1 and also node C2 have an subeq node C1 and also node C1 has a cliquesize node S and also node C2 has a cliquesize node S-1, where S is greater than 1.",
            "NL": "Node C1 is situated between node X, which has a member node C1, and node C2, which has a subeq node C1, and both nodes have a cliquesize of S and S-1 respectively, where S is greater than 1."
        },
        {
            "Category": "Definition When",
            "CNL": "node C1 rest node X and node C2 when node X have an member node C1 and also node C2 have an subeq node C1 and also node C1 has a cliquesize node S and also node C2 has a cliquesize node S-1, where S is greater than 1.",
            "NL": "If node X contains a member node C1 and node C2 has a subeq node C1 with cliquesize node S and S-1 respectively, and S is greater than 1, then node C1 rests on both node X and node C2."
        },
        {
            "Category": "Definition When",
            "CNL": "node C1 rest node X and node C2 when node X have an member node C1 and also node C2 have an subeq node C1 and also node C1 has a cliquesize node S and also node C2 has a cliquesize node S-1, where S is greater than 1.",
            "NL": "If node X has a member node C1, node C2 has a subeq node C1, and both node C1 and node C2 have cliquesize nodes S and S-1 respectively, with S being greater than 1, then node C1 rests on node X and node C2."
        },
        {
            "Category": "Definition When",
            "CNL": "node C1 rest node X and node C2 when node X have an member node C1 and also node C2 have an subeq node C1 and also node C1 has a cliquesize node S and also node C2 has a cliquesize node S-1, where S is greater than 1.",
            "NL": "Node C1 is located on both node X, which has a member node C1, and node C2, which has a subeq node C1. Node C1 has a cliquesize of S and node C2 has a cliquesize of S-1, where S is greater than 1."
        },
        {
            "Category": "Definition When",
            "CNL": "node C1 subseq node C2 when node C1 is clique and also node C2 is clique and also node C1 is not cex node C2.",
            "NL": "There is a relationship between node C1 and node C2 when both nodes are cliques and node C1 is not a CEX node of node C2."
        },
        {
            "Category": "Definition When",
            "CNL": "node C1 subseq node C2 when node C1 is clique and also node C2 is clique and also node C1 is not cex node C2.",
            "NL": "A relationship exists between node C1 and node C2 when C1 is a clique and C2 is a clique, and C1 is not a CEX node of C2."
        },
        {
            "Category": "Definition When",
            "CNL": "node C1 subseq node C2 when node C1 is clique and also node C2 is clique and also node C1 is not cex node C2.",
            "NL": "There is a relationship between node C1 and node C2 when both are cliques and node C1 is not a CEX node of node C2."
        },
        {
            "Category": "Definition When",
            "CNL": "node C1 subseq node C2 when node C1 is clique and also node C2 is clique and also node C1 is not cex node C2.",
            "NL": "There is a relationship between node C1 and node C2 when node C1 is a clique and node C2 is a clique but node C1 is not a CEX node of node C2."
        },
        {
            "Category": "Definition When",
            "CNL": "node C1 subseq node C2 when node C1 is clique and also node C2 is clique and also node C1 is not cex node C2.",
            "NL": "There is a relation between node C1 and node C2 when both nodes are cliques, and node C1 is not a CEX node of node C2."
        },
        {
            "Category": "Definition When",
            "CNL": "node P diffpen node X when node C have an in node X and also node C penalty node X and node P and also node P not minpen node X. ",
            "NL": "Node P does not have a minpen node X while Node C has an IN node X and is also a penalty node X."
        },
        {
            "Category": "Definition When",
            "CNL": "node P diffpen node X when node C have an in node X and also node C penalty node X and node P and also node P not minpen node X. ",
            "NL": "Node P does not have a minpen node X, while node C has both an IN node X and a penalty node X."
        },
        {
            "Category": "Definition When",
            "CNL": "node P diffpen node X when node C have an in node X and also node C penalty node X and node P and also node P not minpen node X. ",
            "NL": "Node P does not have a minpen node X, whereas node C has an IN node X and is a penalty node X."
        },
        {
            "Category": "Definition When",
            "CNL": "node P diffpen node X when node C have an in node X and also node C penalty node X and node P and also node P not minpen node X. ",
            "NL": "Node P does not have a minpen node X, whereas node C has an IN node X and is also a penalty node X."
        },
        {
            "Category": "Definition When",
            "CNL": "node P diffpen node X when node C have an in node X and also node C penalty node X and node P and also node P not minpen node X. ",
            "NL": "Node P does not have a minpen node X, whereas Node C has both an IN node X and a penalty node X."
        },
        {
            "Category": "Definition When",
            "CNL": "node P1 diffpen node X when node P2 diffpen node X and also node P1 nextpen node P2 and node X and also node P1 not minpen node X.",
            "NL": "When node P1 differs from node X, node P2 also differs from node X, and node P1 is adjacent to node P2 and node X, but node P1 is not the smallest node X."
        },
        {
            "Category": "Definition When",
            "CNL": "node P1 diffpen node X when node P2 diffpen node X and also node P1 nextpen node P2 and node X and also node P1 not minpen node X.",
            "NL": "When Node P1 differs from Node X compared to Node P2, Node P1 also nextpen Node P2 and Node X, but Node P1 is not the minimum of Node X."
        },
        {
            "Category": "Definition When",
            "CNL": "node P1 diffpen node X when node P2 diffpen node X and also node P1 nextpen node P2 and node X and also node P1 not minpen node X.",
            "NL": "When node P1 differs from node X compared to node P2, and node P1 is adjacent to both node P2 and node X but is not the minimum of node X,"
        },
        {
            "Category": "Definition When",
            "CNL": "node P1 diffpen node X when node P2 diffpen node X and also node P1 nextpen node P2 and node X and also node P1 not minpen node X.",
            "NL": "When node P1 differs from node X, but node P2 does the same, node P1 is not the least similar to node X, and it also nextpens both node P2 and node X."
        },
        {
            "Category": "Definition When",
            "CNL": "node P1 diffpen node X when node P2 diffpen node X and also node P1 nextpen node P2 and node X and also node P1 not minpen node X.",
            "NL": "When node P1 differs from node X, and node P2 also differs from node X, and node P1 is adjacent to node P2 and node X, but node P1 is not the minimum node of node X."
        },
        {
            "Category": "Definition When",
            "CNL": "node R aux node Y when node C has an aux node Y and also node C rest node Z and node R and also node R not cliquesize node 1.",
            "NL": "When node C does not have an aux node Y, Node R has an aux node Y and is not cliqued to node 1, whereas node C is located under node Z."
        },
        {
            "Category": "Definition When",
            "CNL": "node R aux node Y when node C has an aux node Y and also node C rest node Z and node R and also node R not cliquesize node 1.",
            "NL": "When node C does not have an aux node Y, node R has one and node C is situated under node Z, while node R is not connected to node 1."
        },
        {
            "Category": "Definition When",
            "CNL": "node R aux node Y when node C has an aux node Y and also node C rest node Z and node R and also node R not cliquesize node 1.",
            "NL": "When node C does not have an aux node Y, node R has an aux node Y and is not cliqued to node 1, while node C rests under node Z."
        },
        {
            "Category": "Definition When",
            "CNL": "node R aux node Y when node C has an aux node Y and also node C rest node Z and node R and also node R not cliquesize node 1.",
            "NL": "When node C does not have an auxiliary node Y, and rests under node Z, node R has an auxiliary node Y and is not connected to node 1."
        },
        {
            "Category": "Definition When",
            "CNL": "node R aux node Y when node C has an aux node Y and also node C rest node Z and node R and also node R not cliquesize node 1.",
            "NL": "When node C does not have an aux node Y, node R has one, and node C is located beneath node Z while node R is not cliqued to node 1."
        },
        {
            "Category": "Definition When",
            "CNL": "node R aux node Y when node R have an in node Y and also node R not cliquesize node 1.",
            "NL": "If node R has an IN node Y, node R will aux the node Y, but it will not if node R is the cliquesize node 1."
        },
        {
            "Category": "Definition When",
            "CNL": "node R aux node Y when node R have an in node Y and also node R not cliquesize node 1.",
            "NL": "If node R has an IN node Y, node R will aux node Y; however, if node R is the cliquesize node 1, it will not."
        },
        {
            "Category": "Definition When",
            "CNL": "node R aux node Y when node R have an in node Y and also node R not cliquesize node 1.",
            "NL": "If node R has an IN node Y, node R will aux the node Y; however, this does not apply if node R is the cliquesize node 1."
        },
        {
            "Category": "Definition When",
            "CNL": "node R aux node Y when node R have an in node Y and also node R not cliquesize node 1.",
            "NL": "If node R has an IN node Y, node R will auxiliary node Y; however, this would not be the case if node R is the cliquesize node 1."
        },
        {
            "Category": "Definition When",
            "CNL": "node R aux node Y when node R have an in node Y and also node R not cliquesize node 1.",
            "NL": "If node R has an IN node Y, node R aux the node Y; however, if node R is the cliquesize node 1, this does not apply."
        },
        {
            "Category": "Definition When",
            "CNL": "node X is ok when node X has an oktr node C and node Y and also field1 X not pred field2 C and field3 Y.",
            "NL": "In this instance, it is acceptable for node X to have an oktr node C, node Y and field1 X, however, it is not permissible to have a predicted field2 C and field3 Y."
        },
        {
            "Category": "Definition When",
            "CNL": "node X is ok when node X has an oktr node C and node Y and also field1 X not pred field2 C and field3 Y.",
            "NL": "Node X is acceptable if it has an oktr node C, node Y, and field1 X; however, it cannot have a predicted field2 C or field3 Y."
        },
        {
            "Category": "Definition When",
            "CNL": "node X is ok when node X has an oktr node C and node Y and also field1 X not pred field2 C and field3 Y.",
            "NL": "For this situation, node X is acceptable if it has an oktr node C, node Y, and field1 X, however, it must not have a predicted field2 C and field3 Y."
        },
        {
            "Category": "Definition When",
            "CNL": "node X is ok when node X has an oktr node C and node Y and also field1 X not pred field2 C and field3 Y.",
            "NL": "Node X is acceptable if it has an oktr node C, node Y, and field1 X; however, it is not acceptable if it has a predicted field2 C and field3 Y."
        },
        {
            "Category": "Definition When",
            "CNL": "node X is ok when node X has an oktr node C and node Y and also field1 X not pred field2 C and field3 Y.",
            "NL": "Node X is acceptable if it has an oktr node C, node Y, and field1 X, but not field2 C and field3 Y predicted."
        },
        {
            "Category": "Definition When",
            "CNL": "node X is reached when node X have a start.",
            "NL": "Node X is attained once it has commenced."
        },
        {
            "Category": "Definition When",
            "CNL": "node X is reached when node X have a start.",
            "NL": "Once the node X has begun, it is attained."
        },
        {
            "Category": "Definition When",
            "CNL": "node X is reached when node X have a start.",
            "NL": "Once the node X has begun, it can be accessed."
        },
        {
            "Category": "Definition When",
            "CNL": "node X is reached when node X have a start.",
            "NL": "Node X is attained once it has begun."
        },
        {
            "Category": "Definition When",
            "CNL": "node X is reached when node X have a start.",
            "NL": "Once node X has begun, it can be accessed."
        },
        {
            "Category": "Definition When",
            "CNL": "node X is reached when node Y is reached and also node Y have an inPath node X.",
            "NL": "When node Y is reached, node X is also reachable since node Y has an inPath to it."
        },
        {
            "Category": "Definition When",
            "CNL": "node X is reached when node Y is reached and also node Y have an inPath node X.",
            "NL": "When node Y is reached, node X is also attained, and node Y has a path leading to node X."
        },
        {
            "Category": "Definition When",
            "CNL": "node X is reached when node Y is reached and also node Y have an inPath node X.",
            "NL": "When node Y is reached, node X is also accessed, and node Y has a connection to node X."
        },
        {
            "Category": "Definition When",
            "CNL": "node X is reached when node Y is reached and also node Y have an inPath node X.",
            "NL": "When node Y is reached, it has an inPath to node X, thus node X is also reached."
        },
        {
            "Category": "Definition When",
            "CNL": "node X is reached when node Y is reached and also node Y have an inPath node X.",
            "NL": "When node Y is reached, node X is also accessible due to node Y having an inPath to it."
        },
        {
            "Category": "Definition When",
            "CNL": "Node X is uconnected to Node Y when node X is adjacent to node Y, where X is less than Y. ",
            "NL": "When node X is adjacent to node Y and X is less than Y, there is a condition in which node X is unconnected from node Y."
        },
        {
            "Category": "Definition When",
            "CNL": "Node X is uconnected to Node Y when node X is adjacent to node Y, where X is less than Y. ",
            "NL": "When node X is adjacent to node Y, but not connected, and X is less than Y, there is a condition present."
        },
        {
            "Category": "Definition When",
            "CNL": "Node X is uconnected to Node Y when node X is adjacent to node Y, where X is less than Y. ",
            "NL": "When node X is adjacent to node Y, but not connected, and X is less than Y, there is a particular condition."
        },
        {
            "Category": "Definition When",
            "CNL": "Node X is uconnected to Node Y when node X is adjacent to node Y, where X is less than Y. ",
            "NL": "When node X is adjacent to node Y, and X is less than Y, there is a condition in which node X is unconnected from node Y."
        },
        {
            "Category": "Definition When",
            "CNL": "Node X is uconnected to Node Y when node X is adjacent to node Y, where X is less than Y. ",
            "NL": "When node X is adjacent to node Y and X is less than Y, there is a condition in which node X is not connected to node Y."
        },
        {
            "Category": "Definition When",
            "CNL": "Node X is uedge Node Y when node X have an edge node Y, where X is less than Y. ",
            "NL": "When node X is connected to node Y, and X is less than Y, there is a condition in which X is unconnected from Y."
        },
        {
            "Category": "Definition When",
            "CNL": "Node X is uedge Node Y when node X have an edge node Y, where X is less than Y. ",
            "NL": "When node X is less than node Y, a condition exists in which node X is uedge from node Y, yet still connected to it."
        },
        {
            "Category": "Definition When",
            "CNL": "Node X is uedge Node Y when node X have an edge node Y, where X is less than Y. ",
            "NL": "When node X is connected to node Y and X is less than Y, node X is not edge from node Y."
        },
        {
            "Category": "Definition When",
            "CNL": "Node X is uedge Node Y when node X have an edge node Y, where X is less than Y. ",
            "NL": "When node X is connected to node Y, and X is less than Y, then node X is not connected to node Y."
        },
        {
            "Category": "Definition When",
            "CNL": "Node X is uedge Node Y when node X have an edge node Y, where X is less than Y. ",
            "NL": "When node X is connected to node Y and X is less than Y, node X is not disconnected from node Y."
        },
        {
            "Category": "Definition When",
            "CNL": "node X oktr node C2 and node Y2 when node X have an next node C1 and node Y1 and also node X oktr node C1 and node Y1 and also node C2 okin node Y2.",
            "NL": "When node X has a subsequent node C1 and a node Y1, it will also oktr node C1 and node Y1, and node C2 will okin node Y2, along with node X okaying node C2 and node Y2."
        },
        {
            "Category": "Definition When",
            "CNL": "node X oktr node C2 and node Y2 when node X have an next node C1 and node Y1 and also node X oktr node C1 and node Y1 and also node C2 okin node Y2.",
            "NL": "When node X has a next node C1 and a node Y1, it will oktr both node C1 and node Y1; additionally, node C2 will okin node Y2, and node X will also oktr node C2 and node Y2."
        },
        {
            "Category": "Definition When",
            "CNL": "node X oktr node C2 and node Y2 when node X have an next node C1 and node Y1 and also node X oktr node C1 and node Y1 and also node C2 okin node Y2.",
            "NL": "When node X has a next node C1 and a node Y1, it will oktr both node C1 and node Y1, and node C2 will okin node Y2, as well as node X oktrring node C2 and node Y2."
        },
        {
            "Category": "Definition When",
            "CNL": "node X oktr node C2 and node Y2 when node X have an next node C1 and node Y1 and also node X oktr node C1 and node Y1 and also node C2 okin node Y2.",
            "NL": "When node X has a next node C1 and a node Y1, it will oktr both C1 and Y1, and node C2 will okin node Y2 as well as node X oktr-ing node C2 and node Y2."
        },
        {
            "Category": "Definition When",
            "CNL": "node X oktr node C2 and node Y2 when node X have an next node C1 and node Y1 and also node X oktr node C1 and node Y1 and also node C2 okin node Y2.",
            "NL": "When node X has a subsequent node C1 and a node Y1, it will oktr both C1 and Y1, and node C2 will okin node Y2, as well as node X oktring node C2 and node Y2."
        },
        {
            "Category": "Definition When",
            "CNL": "Node Y is uconnected to Node X when node X is adjacent to node Y, where Y is less than X. ",
            "NL": "When node X is adjacent to node Y, and Y is less than X, there is a condition in which node Y is unconnected from node X."
        },
        {
            "Category": "Definition When",
            "CNL": "Node Y is uconnected to Node X when node X is adjacent to node Y, where Y is less than X. ",
            "NL": "When node X is adjacent to node Y and Y is less than X, there is a condition in which node Y is unconnected from node X."
        },
        {
            "Category": "Definition When",
            "CNL": "Node Y is uconnected to Node X when node X is adjacent to node Y, where Y is less than X. ",
            "NL": "When node X is adjacent to node Y and X is greater than Y, there is a situation where node Y is not connected to node X."
        },
        {
            "Category": "Definition When",
            "CNL": "Node Y is uconnected to Node X when node X is adjacent to node Y, where Y is less than X. ",
            "NL": "When node X is adjacent to node Y, and X is greater than Y, node Y is not connected to node X."
        },
        {
            "Category": "Definition When",
            "CNL": "Node Y is uconnected to Node X when node X is adjacent to node Y, where Y is less than X. ",
            "NL": "When node X is adjacent to node Y, and Y is less than X, there is a condition in which node Y is not connected to node X."
        },
        {
            "Category": "Definition When",
            "CNL": "Node Y is uedge Node X when node X have an edge node Y, where Y is less than X. ",
            "NL": "When node X is connected to node Y, and Y is less than X, node Y is unconnected from node X."
        },
        {
            "Category": "Definition When",
            "CNL": "Node Y is uedge Node X when node X have an edge node Y, where Y is less than X. ",
            "NL": "When node X is connected to node Y, and Y is less than X, node Y is not connected to node X."
        },
        {
            "Category": "Definition When",
            "CNL": "Node Y is uedge Node X when node X have an edge node Y, where Y is less than X. ",
            "NL": "When node X is edge to node Y and Y is less than X, there is a condition in which node Y is uedge from node X."
        },
        {
            "Category": "Definition When",
            "CNL": "Node Y is uedge Node X when node X have an edge node Y, where Y is less than X. ",
            "NL": "When node X is edge to node Y and Y is less than X, node Y is uedge from node X."
        },
        {
            "Category": "Definition When",
            "CNL": "Node Y is uedge Node X when node X have an edge node Y, where Y is less than X. ",
            "NL": "When node X is connected to node Y and Y is less than X, node Y will not be connected to node X."
        },
        {
            "Category": "Definition When",
            "CNL": "node1 L Order node1 E and node1 V when value10 L have an Final value1 E and vtx6 V and also node1 E Triple node1 V and also value10 L not Index value1 E and vtx6 V.",
            "NL": "Order node1 E and node1 V when value10 L has a Final value1 E and vtx6 V, then Triple node1 V and ensure value10 L does not Index in value1 E and vtx6 V."
        },
        {
            "Category": "Definition When",
            "CNL": "node1 L Order node1 E and node1 V when value10 L have an Final value1 E and vtx6 V and also node1 E Triple node1 V and also value10 L not Index value1 E and vtx6 V.",
            "NL": "When value10 L has a Final value1 E and vtx6 V, Order the node1 E and node1 V, and Triple the node1 V. Additionally, value10 L does not Index in value1 E and vtx6 V."
        },
        {
            "Category": "Definition When",
            "CNL": "node1 L Order node1 E and node1 V when value10 L have an Final value1 E and vtx6 V and also node1 E Triple node1 V and also value10 L not Index value1 E and vtx6 V.",
            "NL": "When value10 L has a Final value1 E and vtx6 V, order the node1 E and node1 V, triple the node1 V, and make sure value10 L does not Index in value1 E and vtx6 V."
        },
        {
            "Category": "Definition When",
            "CNL": "node1 L Order node1 E and node1 V when value10 L have an Final value1 E and vtx6 V and also node1 E Triple node1 V and also value10 L not Index value1 E and vtx6 V.",
            "NL": "When value10 L has a Final value1 E and vtx6 V, the node1 L should Order the node1 E and Triple the node1 V, but it should not Index in value1 E and vtx6 V."
        },
        {
            "Category": "Definition When",
            "CNL": "node1 L Order node1 E and node1 V when value10 L have an Final value1 E and vtx6 V and also node1 E Triple node1 V and also value10 L not Index value1 E and vtx6 V.",
            "NL": "Order node1 E and node1 V when Final value1 E and vtx6 V have value10 L, Triple node1 V, and value10 L does not Index in value1 E and vtx6 V."
        },
        {
            "Category": "Definition When",
            "CNL": "node3 V is Shortest_Path node3 A and node3 S when node3 S is Valency and also node3 S is not Outpath and also node3 S is not Embedding node3 S and also node3 V is Sanction node3 S and also node3 A Sanction node3 S and also node3 T Sanction node3 S, where V is less than T and T is less than A.",
            "NL": "If the value of node3 S is Valency, and node3 A is Sanctioning node3 S, and T is greater than node3 V and less than node3 A, then the Shortest_Path will include node3 V, edge7 A, and key1 S."
        },
        {
            "Category": "Definition When",
            "CNL": "node3 V is Shortest_Path node3 A and node3 S when node3 S is Valency and also node3 S is not Outpath and also node3 S is not Embedding node3 S and also node3 V is Sanction node3 S and also node3 A Sanction node3 S and also node3 T Sanction node3 S, where V is less than T and T is less than A.",
            "NL": "If node3 S has Valency, node3 V sanctions node3 S, node3 S is neither Outpath nor Embedding, node3 A sanctions node3 S, and T is between V and A, then we have the Shortest_Path with node3 V, edge7 A, and key1 S."
        },
        {
            "Category": "Definition When",
            "CNL": "node3 V is Shortest_Path node3 A and node3 S when node3 S is Valency and also node3 S is not Outpath and also node3 S is not Embedding node3 S and also node3 V is Sanction node3 S and also node3 A Sanction node3 S and also node3 T Sanction node3 S, where V is less than T and T is less than A.",
            "NL": "If Valency is present at node3 S, Sanctioning node3 S is not Outpath or Embedding, and Sanctioning node3 S is greater than node3 V and less than node3 A, then the Shortest_Path between node3 V, edge7 A, and key1 S exists."
        },
        {
            "Category": "Definition When",
            "CNL": "node3 V is Shortest_Path node3 A and node3 S when node3 S is Valency and also node3 S is not Outpath and also node3 S is not Embedding node3 S and also node3 V is Sanction node3 S and also node3 A Sanction node3 S and also node3 T Sanction node3 S, where V is less than T and T is less than A.",
            "NL": "If node3 S has Valency, and node3 V sanctions node3 S, but node3 S is not an Outpath or Embedding, and node3 A sanctions node3 S, when T is between V and A, then the Shortest_Path consists of node3 V, edge7 A, and key1 S."
        },
        {
            "Category": "Definition When",
            "CNL": "node3 V is Shortest_Path node3 A and node3 S when node3 S is Valency and also node3 S is not Outpath and also node3 S is not Embedding node3 S and also node3 V is Sanction node3 S and also node3 A Sanction node3 S and also node3 T Sanction node3 S, where V is less than T and T is less than A.",
            "NL": "If node3 S is Valency, node3 V has Sanctioned node3 S, node3 S is neither Outpath nor Embedding, and node3 A has Sanctioned node3 S, where T is between V and A, then we have a Shortest_Path with node3 V, edge7 A, and key1 S."
        },
        {
            "Category": "Definition When",
            "CNL": "node9 U Input_Data node9 C when node9 U have an Used_Edge node9 C and also node9 U not Minor node9 34.",
            "NL": "If node9 U has an Used_Edge to node9 C, then node9 U will input data to node9 C, but not if node9 U is the Minor node9 34."
        },
        {
            "Category": "Definition When",
            "CNL": "node9 U Input_Data node9 C when node9 U have an Used_Edge node9 C and also node9 U not Minor node9 34.",
            "NL": "If node9 U has an Used_Edge node9 C, then node9 U will input data to node9 C, but not if node9 U is the Minor node9 34."
        },
        {
            "Category": "Definition When",
            "CNL": "node9 U Input_Data node9 C when node9 U have an Used_Edge node9 C and also node9 U not Minor node9 34.",
            "NL": "If node9 U has an Used_Edge node9 C, node9 U will Input_Data node9 C, but not if node9 U is the Minor node9 34."
        },
        {
            "Category": "Definition When",
            "CNL": "node9 U Input_Data node9 C when node9 U have an Used_Edge node9 C and also node9 U not Minor node9 34.",
            "NL": "If node9 U has an Used_Edge to node9 C, then node9 U can input data to node9 C, but not if node9 U is the Minor node9 34."
        },
        {
            "Category": "Definition When",
            "CNL": "node9 U Input_Data node9 C when node9 U have an Used_Edge node9 C and also node9 U not Minor node9 34.",
            "NL": "If node9 U has an Used_Edge node9 C, then node9 U Input_Data the node9 C, but not if node9 U is the Minor node9 34."
        },
        {
            "Category": "Definition When",
            "CNL": "point Y is visit when point X is road point Y and also point X is start.",
            "NL": "Point Y can be reached by traveling from point X, which is the starting point."
        },
        {
            "Category": "Definition When",
            "CNL": "point Y is visit when point X is road point Y and also point X is start.",
            "NL": "Point Y is reached when traveling from point X, which is the starting point."
        },
        {
            "Category": "Definition When",
            "CNL": "point Y is visit when point X is road point Y and also point X is start.",
            "NL": "Point Y is the destination when Point X is the starting point and the route to Point Y."
        },
        {
            "Category": "Definition When",
            "CNL": "point Y is visit when point X is road point Y and also point X is start.",
            "NL": "When point X is the starting point, the road to point Y goes through it, so point Y is visited."
        },
        {
            "Category": "Definition When",
            "CNL": "point Y is visit when point X is road point Y and also point X is start.",
            "NL": "Point Y is reached when Point X is the starting point and the route to Point Y is taken from Point X."
        },
        {
            "Category": "Definition When",
            "CNL": "point Y is visit when point X is road point Y and also point X is visit.",
            "NL": "When point X is the road to point Y, point Y can be visited from point X."
        },
        {
            "Category": "Definition When",
            "CNL": "point Y is visit when point X is road point Y and also point X is visit.",
            "NL": "Point X is the road to Point Y and is also the visiting point."
        },
        {
            "Category": "Definition When",
            "CNL": "point Y is visit when point X is road point Y and also point X is visit.",
            "NL": "Point Y can be reached by travelling to point X, which is the visiting point."
        },
        {
            "Category": "Definition When",
            "CNL": "point Y is visit when point X is road point Y and also point X is visit.",
            "NL": "Point X is the road to Point Y and is also the point of visitation."
        },
        {
            "Category": "Definition When",
            "CNL": "point Y is visit when point X is road point Y and also point X is visit.",
            "NL": "Point Y can be reached by traveling on the road from point X, which is the visiting point."
        },
        {
            "Category": "Definition When",
            "CNL": "tree X is haschild when tree X have an edge to Y.",
            "NL": "A tree X is said to be superior to another tree Y when it has an edge over it."
        },
        {
            "Category": "Definition When",
            "CNL": "tree X is haschild when tree X have an edge to Y.",
            "NL": "X is said to be superior to Y when it has an edge over the latter."
        },
        {
            "Category": "Definition When",
            "CNL": "tree X is haschild when tree X have an edge to Y.",
            "NL": "X is said to be the parenttree when it has an advantage over tree Y."
        },
        {
            "Category": "Definition When",
            "CNL": "tree X is haschild when tree X have an edge to Y.",
            "NL": "X is said to be superior to Y when it has an edge over the other tree."
        },
        {
            "Category": "Definition When",
            "CNL": "tree X is haschild when tree X have an edge to Y.",
            "NL": "A tree X is said to be dominant over another tree Y when it has an advantage."
        },
        {
            "Category": "Definition When",
            "CNL": "tree X is hasparent when tree Y have an edge to X.",
            "NL": "Tree X is the parent of tree Y when it has an edge to it."
        },
        {
            "Category": "Definition When",
            "CNL": "tree X is hasparent when tree Y have an edge to X.",
            "NL": "If tree Y has a connection to tree X, tree X is a parent."
        },
        {
            "Category": "Definition When",
            "CNL": "tree X is hasparent when tree Y have an edge to X.",
            "NL": "If tree Y has a connection with tree X, tree X is the parent."
        },
        {
            "Category": "Definition When",
            "CNL": "tree X is hasparent when tree Y have an edge to X.",
            "NL": "Tree X is the parent of tree Y if there is an edge between them."
        },
        {
            "Category": "Definition When",
            "CNL": "tree X is hasparent when tree Y have an edge to X.",
            "NL": "When tree Y is connected to tree X, tree X is the parent."
        },
        {
            "Category": "Definition When",
            "CNL": "value C1 has an index value 1 when value C1 is colour and also value C1 is not later.",
            "NL": "If the value C1 is a color, its index value is 1, even if it is not later."
        },
        {
            "Category": "Definition When",
            "CNL": "value C1 has an index value 1 when value C1 is colour and also value C1 is not later.",
            "NL": "The index value of C1 is 1 regardless of whether it is a color or not at a later time."
        },
        {
            "Category": "Definition When",
            "CNL": "value C1 has an index value 1 when value C1 is colour and also value C1 is not later.",
            "NL": "If C1 is a colour, its index value is 1, regardless of whether it is later or not."
        },
        {
            "Category": "Definition When",
            "CNL": "value C1 has an index value 1 when value C1 is colour and also value C1 is not later.",
            "NL": "The index value 1 is associated with the value C1 regardless of whether it is a colour or not at a later time."
        },
        {
            "Category": "Definition When",
            "CNL": "value C1 has an index value 1 when value C1 is colour and also value C1 is not later.",
            "NL": "The index value for C1 is 1, regardless of whether C1 is a colour or not."
        },
        {
            "Category": "Definition When",
            "CNL": "value C1 have colourss value C2 when value C1 is colourss and also value C2 is colourss, where C1 is less than C2.",
            "NL": "If C1 is less than C2, then C1 has the same colors as C2, and if C2 has colors, then C1 does too."
        },
        {
            "Category": "Definition When",
            "CNL": "value C1 have colourss value C2 when value C1 is colourss and also value C2 is colourss, where C1 is less than C2.",
            "NL": "If C1 is less than C2, then C1 will take on the color of C2, and if C2 is colored, then C1 will also be colored."
        },
        {
            "Category": "Definition When",
            "CNL": "value C1 have colourss value C2 when value C1 is colourss and also value C2 is colourss, where C1 is less than C2.",
            "NL": "If C1 is less than C2, C1 has the same colour value as C2, and if C2 is coloured, then C1 is also coloured."
        },
        {
            "Category": "Definition When",
            "CNL": "value C1 have colourss value C2 when value C1 is colourss and also value C2 is colourss, where C1 is less than C2.",
            "NL": "If C1 is less than C2 and both C1 and C2 have colours, then C1 has the colours of C2."
        },
        {
            "Category": "Definition When",
            "CNL": "value C1 have colourss value C2 when value C1 is colourss and also value C2 is colourss, where C1 is less than C2.",
            "NL": "If the value of C1 is less than C2, then C1 will take on the color of C2, and if C2 is colored, then C1 will be colored as well."
        },
        {
            "Category": "Definition When",
            "CNL": "value C1 have next value C2 when value C1 is colourss value C2 and also value C1 have not notnext value C2.",
            "NL": "If value C1 is the same color as value C2, and value C1 is not the following value of C2, then value C1 does have the succeeding value of C2."
        },
        {
            "Category": "Definition When",
            "CNL": "value C1 have next value C2 when value C1 is colourss value C2 and also value C1 have not notnext value C2.",
            "NL": "If value C1 is the same as value C2, and value C1 is not the next value of C2, then value C1 does have a subsequent value of C2."
        },
        {
            "Category": "Definition When",
            "CNL": "value C1 have next value C2 when value C1 is colourss value C2 and also value C1 have not notnext value C2.",
            "NL": "If value C1 is the same color as value C2, and value C1 is not the next value of C2, then value C1 does have a following value of C2."
        },
        {
            "Category": "Definition When",
            "CNL": "value C1 have next value C2 when value C1 is colourss value C2 and also value C1 have not notnext value C2.",
            "NL": "If value C1 is the same color as value C2 and is not the next value of C2, then value C1 does have a subsequent value of C2."
        },
        {
            "Category": "Definition When",
            "CNL": "value C1 have next value C2 when value C1 is colourss value C2 and also value C1 have not notnext value C2.",
            "NL": "If value C1 is the same color as value C2, and value C1 is not the immediate next value of C2, then value C1 does have the subsequent value of C2."
        },
        {
            "Category": "Definition When",
            "CNL": "value C1 have notnext value C3 when value C1 is colourss value C2 and also value C2 is colourss value C3.",
            "NL": "If value C1 is not the same color as value C2, and value C2 is not the same color as value C3, then value C1 does not follow value C3."
        },
        {
            "Category": "Definition When",
            "CNL": "value C1 have notnext value C3 when value C1 is colourss value C2 and also value C2 is colourss value C3.",
            "NL": "If value C1 is not the same color as value C2, and value C2 is not the same color as value C3, then value C1 does not equal value C3."
        },
        {
            "Category": "Definition When",
            "CNL": "value C1 have notnext value C3 when value C1 is colourss value C2 and also value C2 is colourss value C3.",
            "NL": "If value C1 is the same color as value C2, and value C2 is a different color than value C3, then value C1 does not equal value C3."
        },
        {
            "Category": "Definition When",
            "CNL": "value C1 have notnext value C3 when value C1 is colourss value C2 and also value C2 is colourss value C3.",
            "NL": "If value C1 is the same colour as value C2, and value C2 is the same colour as value C3, then value C1 does not equal value C3."
        },
        {
            "Category": "Definition When",
            "CNL": "value C1 have notnext value C3 when value C1 is colourss value C2 and also value C2 is colourss value C3.",
            "NL": "If value C1 is the same color as value C2 and value C2 is the same color as value C3, then value C1 does not equal value C3."
        },
        {
            "Category": "Definition When",
            "CNL": "value C2 is later when value C1 have a next value C2.",
            "NL": "When a value C1 is followed by a value C2, C2 is later."
        },
        {
            "Category": "Definition When",
            "CNL": "value C2 is later when value C1 have a next value C2.",
            "NL": "When a value C1 has a subsequent value C2, C2 is later."
        },
        {
            "Category": "Definition When",
            "CNL": "value C2 is later when value C1 have a next value C2.",
            "NL": "Once C1 has been assigned a subsequent value C2, C2 is later."
        },
        {
            "Category": "Definition When",
            "CNL": "value C2 is later when value C1 have a next value C2.",
            "NL": "The value C2 comes after the value C1 when C1 has its subsequent value C2."
        },
        {
            "Category": "Definition When",
            "CNL": "value C2 is later when value C1 have a next value C2.",
            "NL": "The value C2 comes after C1 when C1 has a subsequent value of C2."
        },
        {
            "Category": "Definition When",
            "CNL": "value N is chosenColour value C when value N is node and also value C is index value I and also value N is not notChosenColour value C, where I is less than or equal to N.",
            "NL": "If N is a node, C is an index value of I, and N is not notChosenColour C, where I is less than or equal to N, then N is chosenColour C."
        },
        {
            "Category": "Definition When",
            "CNL": "value N is chosenColour value C when value N is node and also value C is index value I and also value N is not notChosenColour value C, where I is less than or equal to N.",
            "NL": "If N is a node, C is an index value for I, and N is not notChosenColour for C, where I is less than or equal to N, then N is chosenColour for C."
        },
        {
            "Category": "Definition When",
            "CNL": "value N is chosenColour value C when value N is node and also value C is index value I and also value N is not notChosenColour value C, where I is less than or equal to N.",
            "NL": "If N is a node, C is an index value for I, and N is not notChosenColour for C where I is less than or equal to N, then N is chosenColour for C."
        },
        {
            "Category": "Definition When",
            "CNL": "value N is chosenColour value C when value N is node and also value C is index value I and also value N is not notChosenColour value C, where I is less than or equal to N.",
            "NL": "If node N is indexed as value I and is not notChosenColour C, and I is less than or equal to N, then N is chosenColour C."
        },
        {
            "Category": "Definition When",
            "CNL": "value N is chosenColour value C when value N is node and also value C is index value I and also value N is not notChosenColour value C, where I is less than or equal to N.",
            "NL": "If value N is a node, value C is an index value I, and value N is not notChosenColour value C, where I is less than or equal to N, then value N is chosenColour value C."
        },
        {
            "Category": "Definition When",
            "CNL": "value N is colored when value N has chosencolour value C.",
            "NL": "If value N is given the color value C, it will be colored."
        },
        {
            "Category": "Definition When",
            "CNL": "value N is colored when value N has chosencolour value C.",
            "NL": "When value N is assigned color value C, it is given the color."
        },
        {
            "Category": "Definition When",
            "CNL": "value N is colored when value N has chosencolour value C.",
            "NL": "When N is assigned the color C, it becomes colored."
        },
        {
            "Category": "Definition When",
            "CNL": "value N is colored when value N has chosencolour value C.",
            "NL": "When N is assigned the color C, it is given the hue."
        },
        {
            "Category": "Definition When",
            "CNL": "value N is colored when value N has chosencolour value C.",
            "NL": "When value N is given the color value C, it is colored."
        },
        {
            "Category": "Definition When",
            "CNL": "value N is notChosenColour value C when value N is chosenColour value CC and also value C is index value I, where I is less than or equal to N and C is different from CC.",
            "NL": "When N is selected, the corresponding color value C is not equal to CC, and the index value I is less than or equal to N."
        },
        {
            "Category": "Definition When",
            "CNL": "value N is notChosenColour value C when value N is chosenColour value CC and also value C is index value I, where I is less than or equal to N and C is different from CC.",
            "NL": "The value N is chosen as the color value C, and the index value I is less than or equal to N, with C not being equal to CC."
        },
        {
            "Category": "Definition When",
            "CNL": "value N is notChosenColour value C when value N is chosenColour value CC and also value C is index value I, where I is less than or equal to N and C is different from CC.",
            "NL": "When N is chosen as the color value C, the index value I is less than or equal to N and C is not equal to CC."
        },
        {
            "Category": "Definition When",
            "CNL": "value N is notChosenColour value C when value N is chosenColour value CC and also value C is index value I, where I is less than or equal to N and C is different from CC.",
            "NL": "When N is chosen, the color value C is not equal to CC, and the index value I is less than or equal to N and C is not equal to CC."
        },
        {
            "Category": "Definition When",
            "CNL": "value N is notChosenColour value C when value N is chosenColour value CC and also value C is index value I, where I is less than or equal to N and C is different from CC.",
            "NL": "When N is chosen as the color value C, the index value I is less than or equal to N and C is not equal to CC, and the value C is also an index value I."
        },
        {
            "Category": "Definition When",
            "CNL": "value N is notChosenColour value C when value NN is chosencolour value C and also value NN is link value N, where NN is less than N.",
            "NL": "If NN is less than N and value NN is chosenColour value C, then value N will not be chosenColour value C."
        },
        {
            "Category": "Definition When",
            "CNL": "value N is notChosenColour value C when value NN is chosencolour value C and also value NN is link value N, where NN is less than N.",
            "NL": "If value NN is less than N and chosenColour value C is selected, value N will not be chosenColour value C."
        },
        {
            "Category": "Definition When",
            "CNL": "value N is notChosenColour value C when value NN is chosencolour value C and also value NN is link value N, where NN is less than N.",
            "NL": "If NN is less than N and value NN is chosen as Colour value C, then value N will not be ChosenColour value C."
        },
        {
            "Category": "Definition When",
            "CNL": "value N is notChosenColour value C when value NN is chosencolour value C and also value NN is link value N, where NN is less than N.",
            "NL": "If NN is less than N, and either NN or N is chosen as Colour value C, then N will not be selected as Colour value C."
        },
        {
            "Category": "Definition When",
            "CNL": "value N is notChosenColour value C when value NN is chosencolour value C and also value NN is link value N, where NN is less than N.",
            "NL": "When value NN is less than N and chosenColour value C is selected, value N is not chosenColour value C."
        },
        {
            "Category": "Definition When",
            "CNL": "value N1 is inorder value N2 when value N1 has a compare value N2 and also value L has a gt value N2 and value P and also value L have a not gt value N1 and value P.",
            "NL": "When N1 is less than or equal to N2, and L is greater than N2, but L is not greater than N1 and P, then N1 is in between N2 and P."
        },
        {
            "Category": "Definition When",
            "CNL": "value N1 is inorder value N2 when value N1 has a compare value N2 and also value L has a gt value N2 and value P and also value L have a not gt value N1 and value P.",
            "NL": "When N1 is not greater than N2, and L is greater than N2, and P is not greater than N1 and greater than L, then N1 is in between N2 and P."
        },
        {
            "Category": "Definition When",
            "CNL": "value N1 is inorder value N2 when value N1 has a compare value N2 and also value L has a gt value N2 and value P and also value L have a not gt value N1 and value P.",
            "NL": "If N1 is not greater than N2, and L is greater than N2 and P is not greater than N1, then N1 is in between N2 and L."
        },
        {
            "Category": "Definition When",
            "CNL": "value N1 is inorder value N2 when value N1 has a compare value N2 and also value L has a gt value N2 and value P and also value L have a not gt value N1 and value P.",
            "NL": "If N1 is not greater than N2, and L is greater than N2, but L is not greater than N1 and P is, then N1 is in between N2 and P."
        },
        {
            "Category": "Definition When",
            "CNL": "value N1 is inorder value N2 when value N1 has a compare value N2 and also value L has a gt value N2 and value P and also value L have a not gt value N1 and value P.",
            "NL": "If value N1 is not greater than value N2, and value L is greater than value N2, but value L is not greater than value N1 and value P, then value N1 is between value N2 and value P."
        },
        {
            "Category": "Definition When",
            "CNL": "value N2 is compare value N4 when value N2 has a edge_paired value N4, where N2 is less than N4.",
            "NL": "If value N2 is edge_paired with value N4, and N2 is less than N4, then N2 will be compared to N4."
        },
        {
            "Category": "Definition When",
            "CNL": "value N2 is compare value N4 when value N2 has a edge_paired value N4, where N2 is less than N4.",
            "NL": "When value N2 has an edge_paired value N4, and N2 is less than N4, a comparison of N2 to N4 is made."
        },
        {
            "Category": "Definition When",
            "CNL": "value N2 is compare value N4 when value N2 has a edge_paired value N4, where N2 is less than N4.",
            "NL": "If value N2 is paired with value N4, and N2 is less than N4, then N2 is compared to N4."
        },
        {
            "Category": "Definition When",
            "CNL": "value N2 is compare value N4 when value N2 has a edge_paired value N4, where N2 is less than N4.",
            "NL": "If value N2 has an edge_paired value N4 and is less than it, then N2 is compared to N4."
        },
        {
            "Category": "Definition When",
            "CNL": "value N2 is compare value N4 when value N2 has a edge_paired value N4, where N2 is less than N4.",
            "NL": "When value N2 is paired with value N4, and N2 is less than N4, N2 is compared to N4."
        },
        {
            "Category": "Definition When",
            "CNL": "value N4 is compare value N2 when value N2 has an edge_paired value N4, where N4 is less than N2.",
            "NL": "If value N4 is less than value N2 and the two values are edge-paired, then value N4 is compared to value N2."
        },
        {
            "Category": "Definition When",
            "CNL": "value N4 is compare value N2 when value N2 has an edge_paired value N4, where N4 is less than N2.",
            "NL": "If value N4 is less than value N2 and has an edge-paired value, then value N4 is compared to value N2."
        },
        {
            "Category": "Definition When",
            "CNL": "value N4 is compare value N2 when value N2 has an edge_paired value N4, where N4 is less than N2.",
            "NL": "If value N4 has an edge_paired value of N2 and is less than N2, then value N4 is compared to N2."
        },
        {
            "Category": "Definition When",
            "CNL": "value N4 is compare value N2 when value N2 has an edge_paired value N4, where N4 is less than N2.",
            "NL": "If value N4 is less than value N2 when the two values are paired, then N4 is compared to N2."
        },
        {
            "Category": "Definition When",
            "CNL": "value N4 is compare value N2 when value N2 has an edge_paired value N4, where N4 is less than N2.",
            "NL": "If value N4 is less than value N2 and the two values are edge_paired, then value N4 is compared to value N2."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex B is bucket vertex Z when vertex B is bucket vertex Y and also vertex Z is not Abss and also vertex Y is edge vertex Z. ",
            "NL": "When vertex B is bucket vertex Y, vertex Z is not Abss and vertex Y is the edge vertex Z, while vertex B is bucket vertex Z."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex B is bucket vertex Z when vertex B is bucket vertex Y and also vertex Z is not Abss and also vertex Y is edge vertex Z. ",
            "NL": "When the vertex B is bucket vertex Y, the vertex Z is not Abss and the vertex Y is the edge vertex Z, making vertex B the bucket vertex for vertex Z."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex B is bucket vertex Z when vertex B is bucket vertex Y and also vertex Z is not Abss and also vertex Y is edge vertex Z. ",
            "NL": "When vertex B is bucket vertex Y, vertex Z is not Abss and vertex Y is the edge vertex Z, with vertex B being bucket vertex Z."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex B is bucket vertex Z when vertex B is bucket vertex Y and also vertex Z is not Abss and also vertex Y is edge vertex Z. ",
            "NL": "When vertex B is bucketed as vertex Y, vertex Z is not Abss and vertex Y is the edge vertex of Z, whereas vertex B is bucketed as vertex Z."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex B is bucket vertex Z when vertex B is bucket vertex Y and also vertex Z is not Abss and also vertex Y is edge vertex Z. ",
            "NL": "When vertex B is bucketed as vertex Y, and vertex Z is not Abss, vertex Y is the edge vertex of vertex Z."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex B is bucket vertex Z when vertex B is bucket vertex Y and also vertex Z is not Abss and also vertex Z is edge vertex Y.",
            "NL": "When vertex B is bucket vertex Y, vertex Z is not Abss and is the edge vertex Y, instead of the bucket vertex B being vertex Z."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex B is bucket vertex Z when vertex B is bucket vertex Y and also vertex Z is not Abss and also vertex Z is edge vertex Y.",
            "NL": "When vertex B is bucket vertex Y, vertex Z is not Abss and is the edge vertex Y, instead of vertex B being bucket vertex Z."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex B is bucket vertex Z when vertex B is bucket vertex Y and also vertex Z is not Abss and also vertex Z is edge vertex Y.",
            "NL": "When vertex B is bucket vertex Y, vertex Z is not Abss and is instead the edge vertex Y, with vertex B being bucket vertex Z."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex B is bucket vertex Z when vertex B is bucket vertex Y and also vertex Z is not Abss and also vertex Z is edge vertex Y.",
            "NL": "When vertex B is bucket vertex Y, vertex Z is not Abss and is the edge vertex Y, whereas vertex B is bucket vertex Z."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex B is bucket vertex Z when vertex B is bucket vertex Y and also vertex Z is not Abss and also vertex Z is edge vertex Y.",
            "NL": "When vertex B is bucket vertex Y, vertex Z is not Abss and is the edge vertex Y, while vertex B is also bucket vertex Z."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex V is No_In vertex V2 when vertex V is In vertex V1 and also vertex V2 is vertex, where V1 is different from V2.",
            "NL": "In the scenario where vertex V is part of vertex V1, and vertex V2 is a vertex with a difference from V1, vertex V is a No_In vertex V2."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex V is No_In vertex V2 when vertex V is In vertex V1 and also vertex V2 is vertex, where V1 is different from V2.",
            "NL": "If vertex V is in vertex V1 and vertex V2 is not the same as V1, then vertex V is not located in vertex V2."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex V is No_In vertex V2 when vertex V is In vertex V1 and also vertex V2 is vertex, where V1 is different from V2.",
            "NL": "If vertex V is in vertex V1 and vertex V2 is different from V1, then vertex V is not in vertex V2."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex V is No_In vertex V2 when vertex V is In vertex V1 and also vertex V2 is vertex, where V1 is different from V2.",
            "NL": "If vertex V is in vertex V1 and vertex V2 is distinct from V1, then vertex V is not contained in vertex V2."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex V is No_In vertex V2 when vertex V is In vertex V1 and also vertex V2 is vertex, where V1 is different from V2.",
            "NL": "If vertex V is in vertex V1 and vertex V2 is distinct from V1, then vertex V is not located in vertex V2."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex V is no_reached when vertex V is vertex and also vertex V is not reached.",
            "NL": "Vertex V is not reached when it is a vertex, as well as when it is not reached."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex V is no_reached when vertex V is vertex and also vertex V is not reached.",
            "NL": "Vertex V is not reached when it is either a vertex or when it has not been reached."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex V is no_reached when vertex V is vertex and also vertex V is not reached.",
            "NL": "Vertex V is not reached when it is a vertex, and also when it is not reached."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex V is no_reached when vertex V is vertex and also vertex V is not reached.",
            "NL": "A vertex V is not reached when it is a vertex, as well as when it is not attained."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex V is no_reached when vertex V is vertex and also vertex V is not reached.",
            "NL": "Vertex V is not reached when it is a vertex, as well as when it has not been reached."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex V2 is No_In vertex V when vertex V1 is In vertex V and also vertex V2 is vertex, where V1 is different from V2.",
            "NL": "If vertex V1 is distinct from vertex V2, and both are present in vertex V, then vertex V2 is not contained within vertex V."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex V2 is No_In vertex V when vertex V1 is In vertex V and also vertex V2 is vertex, where V1 is different from V2.",
            "NL": "If vertex V1 is different from vertex V2, and vertex V2 is in vertex V, then vertex V1 is not in vertex V."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex V2 is No_In vertex V when vertex V1 is In vertex V and also vertex V2 is vertex, where V1 is different from V2.",
            "NL": "If vertex V1 is different from vertex V2, and V2 is in vertex V, then vertex V1 is not in vertex V."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex V2 is No_In vertex V when vertex V1 is In vertex V and also vertex V2 is vertex, where V1 is different from V2.",
            "NL": "If vertex V1 is different from vertex V2 and both are in vertex V, then vertex V2 is not in vertex V."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex V2 is No_In vertex V when vertex V1 is In vertex V and also vertex V2 is vertex, where V1 is different from V2.",
            "NL": "If vertex V1 is different from vertex V2 and both of them are in vertex V, then vertex V2 is not in vertex V."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex V2 is reached when vertex V1 is Init and also vertex V1 is In vertex V2.",
            "NL": "When vertex V1 is initialized or is IN a vertex V2, vertex V2 is reached."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex V2 is reached when vertex V1 is Init and also vertex V1 is In vertex V2.",
            "NL": "When vertex V1 is initialized or IN, it will reach vertex V2."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex V2 is reached when vertex V1 is Init and also vertex V1 is In vertex V2.",
            "NL": "When vertex V1 is initialized or IN, it will arrive at vertex V2."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex V2 is reached when vertex V1 is Init and also vertex V1 is In vertex V2.",
            "NL": "When vertex V1 is initialized or within vertex V2, vertex V2 is reached."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex V2 is reached when vertex V1 is Init and also vertex V1 is In vertex V2.",
            "NL": "When vertex V1 is initialized or in a vertex V2, vertex V2 is reached."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex V2 is reached when vertex V1 is reached and also vertex V1 is In vertex V2.",
            "NL": "Once vertex V1 is visited, vertex V2 is also attained, and when vertex V1 is located within vertex V2."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex V2 is reached when vertex V1 is reached and also vertex V1 is In vertex V2.",
            "NL": "When vertex V1 is at vertex V2, it is also considered to be reached."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex V2 is reached when vertex V1 is reached and also vertex V1 is In vertex V2.",
            "NL": "When vertex V1 is reached, vertex V2 is also entered."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex V2 is reached when vertex V1 is reached and also vertex V1 is In vertex V2.",
            "NL": "When vertex V1 is IN vertex V2, vertex V2 is also reached."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex V2 is reached when vertex V1 is reached and also vertex V1 is In vertex V2.",
            "NL": "When vertex V1 is encountered, vertex V2 is also encountered, and vertex V1 is contained within vertex V2."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex W is r vertex V and id W when vertex V is In and also vertex V is edge vertex W and also vertex W is In.",
            "NL": "When vertex V is present, vertex W is the corresponding vertex and the ID of W is also present. Conversely, when vertex W is present, vertex V is the corresponding edge vertex."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex W is r vertex V and id W when vertex V is In and also vertex V is edge vertex W and also vertex W is In.",
            "NL": "When vertex V is in, vertex W is the r vertex of V and the id W; likewise, when vertex W is in, vertex V is the edge vertex of W."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex W is r vertex V and id W when vertex V is In and also vertex V is edge vertex W and also vertex W is In.",
            "NL": "When vertex V is in, vertex W is the r vertex and the id of vertex V, while when vertex W is in, vertex V is the edge vertex of W."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex W is r vertex V and id W when vertex V is In and also vertex V is edge vertex W and also vertex W is In.",
            "NL": "The vertex W is the corresponding vertex V when V is in, and the vertex V is the edge vertex W when W is in."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex W is r vertex V and id W when vertex V is In and also vertex V is edge vertex W and also vertex W is In.",
            "NL": "When vertex V is in, vertex W is the corresponding r-vertex and the id-vertex, and when vertex W is in, vertex V is the associated edge-vertex."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex X is bucket id X when vertex X is edge vertex _ and also vertex X is not Abss.",
            "NL": "When vertex X is an edge vertex, there is a bucket ID associated with it, and even when vertex X is not an Abss."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex X is bucket id X when vertex X is edge vertex _ and also vertex X is not Abss.",
            "NL": "When vertex X is an edge vertex or not an Abss, there is a bucket ID associated with it."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex X is bucket id X when vertex X is edge vertex _ and also vertex X is not Abss.",
            "NL": "When vertex X is an edge vertex and also when it is not, there is a bucket ID X associated with it."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex X is bucket id X when vertex X is edge vertex _ and also vertex X is not Abss.",
            "NL": "When vertex X is an edge vertex, there is a bucket associated with it, as well as when vertex X is not an Abss."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex X is bucket id X when vertex X is edge vertex _ and also vertex X is not Abss.",
            "NL": "When vertex X is an edge vertex or not, there is a bucket ID X associated with it."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex X is clique when vertex X is node and also vertex X is not nonClique.",
            "NL": "If vertex X is a node and not nonClique, then it is a clique."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex X is clique when vertex X is node and also vertex X is not nonClique.",
            "NL": "If vertex X is a node and not a nonClique, then it is a clique."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex X is clique when vertex X is node and also vertex X is not nonClique.",
            "NL": "If vertex X is a node and is not a nonClique, then it is a clique."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex X is clique when vertex X is node and also vertex X is not nonClique.",
            "NL": "If vertex X is a node and not a nonClique, then vertex X is a clique."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex X is clique when vertex X is node and also vertex X is not nonClique.",
            "NL": "If vertex X is a node and not a nonClique, it is a clique."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex X is In when vertex V is In and also vertex V is edge vertex W and also vertex W is In.",
            "NL": "Vertex X is IN when it is not Absent and is Present."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex X is In when vertex V is In and also vertex V is edge vertex W and also vertex W is In.",
            "NL": "Vertex X is Present when it is not Absent and vertex X is Positive."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex X is In when vertex V is In and also vertex V is edge vertex W and also vertex W is In.",
            "NL": "When vertex X is not Abs, it is IN, and when it is Abs, it is P."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex X is In when vertex V is In and also vertex V is edge vertex W and also vertex W is In.",
            "NL": "Vertex X is present when it is not absent and is positive."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex X is In when vertex V is In and also vertex V is edge vertex W and also vertex W is In.",
            "NL": "When vertex X is not Absent, vertex X is Present."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex X is nonclique when vertex X is node and also vertex X is not Clique.",
            "NL": "If vertex X is a node but not part of a Clique, then it is a nonclique."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex X is nonclique when vertex X is node and also vertex X is not Clique.",
            "NL": "If vertex X is a node but not a Clique, it is a nonclique."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex X is nonclique when vertex X is node and also vertex X is not Clique.",
            "NL": "If vertex X is a node and not a part of a Clique, then it is a nonclique."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex X is nonclique when vertex X is node and also vertex X is not Clique.",
            "NL": "If vertex X is a node but not a part of a Clique, then it is a nonclique."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex X is nonclique when vertex X is node and also vertex X is not Clique.",
            "NL": "If vertex X is a node but not a Clique, then it is a nonclique."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex X is parent vertex Y when vertex X is not Abss and also vertex Y is not Abss and also vertex X is edge vertex Y and also vertex Y is not parent vertex X.",
            "NL": "Vertex X is a parent of vertex Y when both X and Y are not Abss and X is an edge of Y, but Y is not a parent of X."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex X is parent vertex Y when vertex X is not Abss and also vertex Y is not Abss and also vertex X is edge vertex Y and also vertex Y is not parent vertex X.",
            "NL": "When neither Vertex X nor Vertex Y are Abss, and Vertex X is an edge for Vertex Y but not the parent of Vertex X, Vertex Y is the parent of Vertex X."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex X is parent vertex Y when vertex X is not Abss and also vertex Y is not Abss and also vertex X is edge vertex Y and also vertex Y is not parent vertex X.",
            "NL": "Vertex X is the parent of vertex Y when neither of them is an Abss, and vertex Y is not the parent of vertex X, with vertex X being an edge vertex of vertex Y."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex X is parent vertex Y when vertex X is not Abss and also vertex Y is not Abss and also vertex X is edge vertex Y and also vertex Y is not parent vertex X.",
            "NL": "Vertex X is a parent of vertex Y when neither X nor Y are Abs, and X is an edge of Y, but Y is not a parent of X."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex X is parent vertex Y when vertex X is not Abss and also vertex Y is not Abss and also vertex X is edge vertex Y and also vertex Y is not parent vertex X.",
            "NL": "Vertex X is a parent of vertex Y if neither X nor Y are Abss, and X is an edge of Y but Y is not an edge of X."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex X is r vertex V and vertex W when vertex Y is In and also vertex Y is edge vertex X and also vertex Y is r vertex V and id W, where X is different from V.",
            "NL": "Essentially, vertex X is different from vertex V and W, and when vertex Y is included, it corresponds to vertex X, as well as vertex V and W."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex X is r vertex V and vertex W when vertex Y is In and also vertex Y is edge vertex X and also vertex Y is r vertex V and id W, where X is different from V.",
            "NL": "Essentially, vertex X is distinct from vertices V and W, and corresponds to vertex Y when present; likewise, vertex Y corresponds to both vertex X and vertices V and W."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex X is r vertex V and vertex W when vertex Y is In and also vertex Y is edge vertex X and also vertex Y is r vertex V and id W, where X is different from V.",
            "NL": "Essentially, vertex X is distinct from vertices V and W, and corresponds to vertex Y when it is present. Additionally, vertex Y corresponds to vertex X and vertices V and W, respectively."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex X is r vertex V and vertex W when vertex Y is In and also vertex Y is edge vertex X and also vertex Y is r vertex V and id W, where X is different from V.",
            "NL": "Essentially, vertex X is distinct from vertices V and W when vertex Y is included, and vertex Y corresponds to both vertex X and the pair of vertices V and W."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex X is r vertex V and vertex W when vertex Y is In and also vertex Y is edge vertex X and also vertex Y is r vertex V and id W, where X is different from V.",
            "NL": "Essentially, vertex X corresponds to vertex V and vertex W when vertex Y is present, while vertex Y corresponds to vertex X and vertex V as well as vertex W, with X being distinct from V."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex X is r vertex V and vertex W when vertex Y is In and also vertex Y is edge vertex X and also vertex Y is r vertex V and id W, where Y is different from W.",
            "NL": "Vertex X corresponds to vertex V and vertex W when vertex Y is included, and vertex Y corresponds to vertex X, as well as vertex V and W, with Y being distinct from W."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex X is r vertex V and vertex W when vertex Y is In and also vertex Y is edge vertex X and also vertex Y is r vertex V and id W, where Y is different from W.",
            "NL": "Essentially, vertex X is connected to vertex V and vertex W when vertex Y is present, and vertex Y is linked to vertex X, as well as vertex V and W, where Y is distinct from W."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex X is r vertex V and vertex W when vertex Y is In and also vertex Y is edge vertex X and also vertex Y is r vertex V and id W, where Y is different from W.",
            "NL": "Essentially, vertex X is related to vertices V and W when vertex Y is present, and vertex Y is connected to vertex X as well as vertices V and W, with Y being distinct from W."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex X is r vertex V and vertex W when vertex Y is In and also vertex Y is edge vertex X and also vertex Y is r vertex V and id W, where Y is different from W.",
            "NL": "Vertex X corresponds to vertex V and W when vertex Y is present, and vertex Y corresponds to vertex X, as well as vertex V and W, but Y is distinct from W."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex X is r vertex V and vertex W when vertex Y is In and also vertex Y is edge vertex X and also vertex Y is r vertex V and id W, where Y is different from W.",
            "NL": "Essentially, vertex X corresponds to vertex V and W when vertex Y is present, and vertex Y corresponds to vertex X, V, and W, where Y is distinct from W."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex X is r vertex Y when vertex X is parent vertex Y.",
            "NL": "When vertex X is the parent of vertex Y, then vertex X is the root of vertex Y."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex X is r vertex Y when vertex X is parent vertex Y.",
            "NL": "When vertex Y is the parent of vertex X, then vertex X is the child of vertex Y."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex X is r vertex Y when vertex X is parent vertex Y.",
            "NL": "When vertex X is the parent of vertex Y, then X is the root of Y."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex X is r vertex Y when vertex X is parent vertex Y.",
            "NL": "Vertex X is the parent of vertex Y when it is the r of vertex Y."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex X is r vertex Y when vertex X is parent vertex Y.",
            "NL": "When vertex Y has vertex X as its parent, then vertex X is the root of vertex Y."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex X is r vertex Y when vertex X is r vertex Z and also vertex Z is parent vertex Y.",
            "NL": "Vertex X is related to vertex Y when vertex X is connected to vertex Z and vertex Z is the parent of vertex Y."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex X is r vertex Y when vertex X is r vertex Z and also vertex Z is parent vertex Y.",
            "NL": "Vertex X is an r vertex Y if vertex X is an r vertex Z and vertex Z is the parent of vertex Y."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex X is r vertex Y when vertex X is r vertex Z and also vertex Z is parent vertex Y.",
            "NL": "Vertex X is an r vertex Y when it is an r vertex Z and Z is the parent of Y."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex X is r vertex Y when vertex X is r vertex Z and also vertex Z is parent vertex Y.",
            "NL": "Vertex X is related to vertex Y when both vertex X is related to vertex Z and vertex Z is the parent of vertex Y."
        },
        {
            "Category": "Definition When",
            "CNL": "vertex X is r vertex Y when vertex X is r vertex Z and also vertex Z is parent vertex Y.",
            "NL": "Vertex X is an r vertex Y when X is an r vertex of Z, and Z is the parent vertex of Y."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx C is clique when vtx C pair vtx X.",
            "NL": "Vertex C forms a clique when it is paired with vertex X."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx C is clique when vtx C pair vtx X.",
            "NL": "A clique is formed when vertex C is connected to vertex X."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx C is clique when vtx C pair vtx X.",
            "NL": "When vertex C and vertex X are paired, a clique C is formed."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx C is clique when vtx C pair vtx X.",
            "NL": "Vertex C forms a clique when it pairs with vertex X."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx C is clique when vtx C pair vtx X.",
            "NL": "When vertex C is paired with vertex X, a clique C is formed."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx C pair vtx X when vtx C have an penalty to X, and P.",
            "NL": "When C incurs a penalty to X and P, C is paired with X."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx C pair vtx X when vtx C have an penalty to X, and P.",
            "NL": "When C incurs a penalty to X and P, it pairs with vertex X."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx C pair vtx X when vtx C have an penalty to X, and P.",
            "NL": "When C incurs a penalty to X and P, it pairs with the vertex X."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx C pair vtx X when vtx C have an penalty to X, and P.",
            "NL": "When vertex C incurs a punishment from vertex X and P, vertex C pairs with vertex X."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx C pair vtx X when vtx C have an penalty to X, and P.",
            "NL": "When C has a penalty to X and P, C is paired with X at the vertex."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx K has a reach vtx U when vtx U has a partition vtx K and also vtx U have a not existslesss vtx K.",
            "NL": "There is a connection between vertex U and vertex K when vertex U is partitioned with vertex K, and no vertex U and vertex K is left out."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx K has a reach vtx U when vtx U has a partition vtx K and also vtx U have a not existslesss vtx K.",
            "NL": "There is a connection between vertex U and vertex K when there is a division between them, and there is no lack of vertex U and vertex K."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx K has a reach vtx U when vtx U has a partition vtx K and also vtx U have a not existslesss vtx K.",
            "NL": "There is a connection between vertex U and vertex K when they are both partitioned, and no vertex is left out."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx K has a reach vtx U when vtx U has a partition vtx K and also vtx U have a not existslesss vtx K.",
            "NL": "There is a connection between vertex U and vertex K when there is a partition between them, as well as when there is no absence of either vertex U or vertex K."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx K has a reach vtx U when vtx U has a partition vtx K and also vtx U have a not existslesss vtx K.",
            "NL": "A connection exists between vertex U and vertex K when vertex U is partitioned with vertex K, and there is no lack of vertex U and vertex K."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx K have a reach vtx V when vtx U uedge vtx V and also vtx K reach vtx U and also vtx V partition vtx K.",
            "NL": "Vertex K is connected to vertex V when vertex U has an edge to vertex V, and there is a connection between vertex K and vertex U, as well as a separation between vertex V and vertex K."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx K have a reach vtx V when vtx U uedge vtx V and also vtx K reach vtx U and also vtx V partition vtx K.",
            "NL": "When vertex U has an edge to vertex V, vertex K can reach vertex V, and there is also a partition between vertex K and vertex V."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx K have a reach vtx V when vtx U uedge vtx V and also vtx K reach vtx U and also vtx V partition vtx K.",
            "NL": "Vertex K is connected to vertex V when vertex U has an edge to vertex V and there is a connection between vertex K and vertex U, as well as a separation between vertex V and vertex K."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx K have a reach vtx V when vtx U uedge vtx V and also vtx K reach vtx U and also vtx V partition vtx K.",
            "NL": "When vertex U has an edge connecting it to vertex V and there is a path between vertex K and vertex U, vertex K can reach vertex V, with a partition existing between vertex V and vertex K."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx K have a reach vtx V when vtx U uedge vtx V and also vtx K reach vtx U and also vtx V partition vtx K.",
            "NL": "Vertex K is connected to vertex V when vertex U is linked to vertex V, and there is a connection between vertex K and vertex U, with a partition between vertex V and vertex K."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx K have a reach vtx V when vtx V uedge vtx U and also vtx K reach vtx U and also vtx V partition vtx K.",
            "NL": "When vertex U has an edge connecting it to vertex V, and there is a reach from vertex K to vertex U, as well as a partition between vertex V and vertex K, vertex K reaches vertex V."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx K have a reach vtx V when vtx V uedge vtx U and also vtx K reach vtx U and also vtx V partition vtx K.",
            "NL": "When vertex U has an edge connecting it to vertex V, and there is a reach between vertex K and vertex U, there is a partition between vertex V and vertex K that allows vertex K to reach vertex V."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx K have a reach vtx V when vtx V uedge vtx U and also vtx K reach vtx U and also vtx V partition vtx K.",
            "NL": "When vertex U has an edge connecting it to vertex V, and there is a reach between vertex K and vertex U, there is a partition between vertex V and vertex K that reaches vertex K."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx K have a reach vtx V when vtx V uedge vtx U and also vtx K reach vtx U and also vtx V partition vtx K.",
            "NL": "When vertex U is connected to vertex V, vertex K can be reached, and there is a partition between vertex V and vertex K."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx K have a reach vtx V when vtx V uedge vtx U and also vtx K reach vtx U and also vtx V partition vtx K.",
            "NL": "Vertex K can get to vertex V when vertex U is connected to vertex V and there is a connection between vertex K and vertex U, as well as a divide between vertex V and vertex K."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx U has an u_edge vtx V and vtx W when vtx U have uedge vtx V and also vtx U have weight_wtedge vtx V and vtx W.",
            "NL": "Vertex U has an edge to Vertex V with a weight of W, and Vertex U also has a weighted edge to Vertex V with a weight of W."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx U has an u_edge vtx V and vtx W when vtx U have uedge vtx V and also vtx U have weight_wtedge vtx V and vtx W.",
            "NL": "Vertex U has an edge to Vertex V with weight W, and Vertex U also has a weighted edge to Vertex V with weight W."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx U has an u_edge vtx V and vtx W when vtx U have uedge vtx V and also vtx U have weight_wtedge vtx V and vtx W.",
            "NL": "Vertex U has an edge to vertex V with weight W, and also has a weighted edge to vertex V with weight W."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx U has an u_edge vtx V and vtx W when vtx U have uedge vtx V and also vtx U have weight_wtedge vtx V and vtx W.",
            "NL": "Vertex U has an edge to vertex V with a weight of W, and also vertex U has a weighted edge to vertex V with a weight of W."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx U has an u_edge vtx V and vtx W when vtx U have uedge vtx V and also vtx U have weight_wtedge vtx V and vtx W.",
            "NL": "Vertex U has an edge to vertex V with weight W, and also vertex U has a weighted edge to vertex V with weight W."
        },
        {
            "Category": "Definition When",
            "CNL": "Vtx U has an uedge to Vtx V when Vtx U has an edge to V, where U is less than V. ",
            "NL": "When node U is less than node V, there is a condition in which node U is edged from node V when node U is also edged to node V."
        },
        {
            "Category": "Definition When",
            "CNL": "Vtx U has an uedge to Vtx V when Vtx U has an edge to V, where U is less than V. ",
            "NL": "When node U is less than node V, there is a condition in which node U is an edge from node V when node U is also an edge to node V."
        },
        {
            "Category": "Definition When",
            "CNL": "Vtx U has an uedge to Vtx V when Vtx U has an edge to V, where U is less than V. ",
            "NL": "When node U is less than node V, there is a condition in which U is edged from V while still being edged to it."
        },
        {
            "Category": "Definition When",
            "CNL": "Vtx U has an uedge to Vtx V when Vtx U has an edge to V, where U is less than V. ",
            "NL": "When node U is less than node V, there is a condition in which node U is edged from node V but is also edged to it."
        },
        {
            "Category": "Definition When",
            "CNL": "Vtx U has an uedge to Vtx V when Vtx U has an edge to V, where U is less than V. ",
            "NL": "When node U is less than node V, there is a condition in which node U is edged from node V while also being edged to node V."
        },
        {
            "Category": "Definition When",
            "CNL": "Vtx U has an uedge to Vtx V when Vtx V have an edge to U, where U is less than V. ",
            "NL": "When node U is uedge from node V and U is less than V, there is a condition in which node V is edge to node U."
        },
        {
            "Category": "Definition When",
            "CNL": "Vtx U has an uedge to Vtx V when Vtx V have an edge to U, where U is less than V. ",
            "NL": "When node U is less than node V, there is a condition in which node U is uedge from node V when node V is edge to node U."
        },
        {
            "Category": "Definition When",
            "CNL": "Vtx U has an uedge to Vtx V when Vtx V have an edge to U, where U is less than V. ",
            "NL": "If node U is uedge from node V and node V is edge to node U, and U is less than V, then there is a certain condition."
        },
        {
            "Category": "Definition When",
            "CNL": "Vtx U has an uedge to Vtx V when Vtx V have an edge to U, where U is less than V. ",
            "NL": "When node U is less than node V, there is a condition in which node U is uedge from node V if node V is edge to node U."
        },
        {
            "Category": "Definition When",
            "CNL": "Vtx U has an uedge to Vtx V when Vtx V have an edge to U, where U is less than V. ",
            "NL": "When node V is connected to node U and U is less than V, node U is not connected to node V."
        },
        {
            "Category": "Definition When",
            "CNL": "Vtx U has an used_edge to Vtx V when Vtx U is dom and also Vtx V is dom and also Vtx U have an uedge to V.",
            "NL": "A directed_edge exists between vertex U and vertex V when vertex U is dominant, as well as an undirected_edge between vertex U and vertex V when vertex U is dominant."
        },
        {
            "Category": "Definition When",
            "CNL": "Vtx U has an used_edge to Vtx V when Vtx U is dom and also Vtx V is dom and also Vtx U have an uedge to V.",
            "NL": "There is a used_edge connecting vertex U and vertex V when vertex U is dominant, as well as an uedge between the two vertices when U is dominant."
        },
        {
            "Category": "Definition When",
            "CNL": "Vtx U has an used_edge to Vtx V when Vtx U is dom and also Vtx V is dom and also Vtx U have an uedge to V.",
            "NL": "A directed edge exists between vertex U and vertex V when vertex U is dominant, as well as an undirected edge between vertex U and vertex V when vertex U is dominant."
        },
        {
            "Category": "Definition When",
            "CNL": "Vtx U has an used_edge to Vtx V when Vtx U is dom and also Vtx V is dom and also Vtx U have an uedge to V.",
            "NL": "An edge exists between vertex U and vertex V when vertex U is dominant, as well as a used edge when vertex U is dominant."
        },
        {
            "Category": "Definition When",
            "CNL": "Vtx U has an used_edge to Vtx V when Vtx U is dom and also Vtx V is dom and also Vtx U have an uedge to V.",
            "NL": "An edge exists between vertex U and vertex V when vertex U is dominant, as well as a used edge between the two vertices when vertex U is the dominant one."
        },
        {
            "Category": "Definition When",
            "CNL": "Vtx U has an used_edge to Vtx V when Vtx U is dom and also Vtx V is dom and also Vtx V has an uedge to U.",
            "NL": "When vertex U is dominant, there is a used_edge connecting vertex U and vertex V, as well as an uedge connecting vertex V and vertex U."
        },
        {
            "Category": "Definition When",
            "CNL": "Vtx U has an used_edge to Vtx V when Vtx U is dom and also Vtx V is dom and also Vtx V has an uedge to U.",
            "NL": "When vertex U is dominant, there is a used_edge between vertex U and vertex V, as well as an uedge between vertex V and vertex U."
        },
        {
            "Category": "Definition When",
            "CNL": "Vtx U has an used_edge to Vtx V when Vtx U is dom and also Vtx V is dom and also Vtx V has an uedge to U.",
            "NL": "An edge exists between vertex U and vertex V when vertex U is dominant, and a reciprocal edge exists between vertex V and vertex U when vertex U is dominant."
        },
        {
            "Category": "Definition When",
            "CNL": "Vtx U has an used_edge to Vtx V when Vtx U is dom and also Vtx V is dom and also Vtx V has an uedge to U.",
            "NL": "When vertex U is dominant, there is a used_edge between U and V, as well as an uedge between V and U."
        },
        {
            "Category": "Definition When",
            "CNL": "Vtx U has an used_edge to Vtx V when Vtx U is dom and also Vtx V is dom and also Vtx V has an uedge to U.",
            "NL": "There is a used_edge connecting vertex U to vertex V when vertex U is dominant, as well as an uedge linking vertex V to vertex U when vertex U is dominant."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx U have a existslesss vtx K when vtx U have a partition vtx K and also vtx V have a partition vtx K and also vtx V is Vtx, where V is less than U.",
            "NL": "Vertex U has a partition vertex K that does not exist, while vertex V, which is less than U, has a partition vertex K and is also a Vtx."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx U have a existslesss vtx K when vtx U have a partition vtx K and also vtx V have a partition vtx K and also vtx V is Vtx, where V is less than U.",
            "NL": "When vertex U has a partition vertex K, and vertex V which is less than U also has a partition vertex K, vertex V is Vtx."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx U have a existslesss vtx K when vtx U have a partition vtx K and also vtx V have a partition vtx K and also vtx V is Vtx, where V is less than U.",
            "NL": "Vertex V, which is less than U, has a partition vertex K and is Vtx, while U has an existless vertex K."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx U have a existslesss vtx K when vtx U have a partition vtx K and also vtx V have a partition vtx K and also vtx V is Vtx, where V is less than U.",
            "NL": "Vertex U is less than Vertex V when Vertex K is partitioned, and Vertex V is Vtx."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx U have a existslesss vtx K when vtx U have a partition vtx K and also vtx V have a partition vtx K and also vtx V is Vtx, where V is less than U.",
            "NL": "Vertex U is less than Vertex V, and both have a partition vertex K, where Vertex V is Vtx."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx U have a reach vtx V when vtx U has an used_edge vtx V.",
            "NL": "Vertex U is connected to vertex V via an used_edge when vertex U has a reachable vertex V."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx U have a reach vtx V when vtx U has an used_edge vtx V.",
            "NL": "U has a connected vertex V when U has an edge to V."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx U have a reach vtx V when vtx U has an used_edge vtx V.",
            "NL": "Vertex U is connected to vertex V via an edge when U and V are both present."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx U have a reach vtx V when vtx U has an used_edge vtx V.",
            "NL": "Vertex U is connected to vertex V when there is an edge connecting U to V."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx U have a reach vtx V when vtx U has an used_edge vtx V.",
            "NL": "Vertex U is connected to vertex V when there is an edge between them."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx U have a reach vtx V when vtx U have a used_edge vtx U and also vtx Z have a reach vtx V, where U is different from V.",
            "NL": "Vertex U is connected to Vertex V when U has an edge to Vertex Z and Z has a reach to V, provided U is different from V."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx U have a reach vtx V when vtx U have a used_edge vtx U and also vtx Z have a reach vtx V, where U is different from V.",
            "NL": "Vertex U is connected to vertex V when there is an edge connecting U and vertex Z, and vertex Z is connected to vertex V when U is distinct from V."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx U have a reach vtx V when vtx U have a used_edge vtx U and also vtx Z have a reach vtx V, where U is different from V.",
            "NL": "Vertex U is connected to vertex V when there is an edge between U and vertex Z, and when U and V are different, vertex Z can link them together."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx U have a reach vtx V when vtx U have a used_edge vtx U and also vtx Z have a reach vtx V, where U is different from V.",
            "NL": "Vertex U is connected to vertex V when vertex U has an edge to vertex Z, and vertex Z is connected to vertex V when U is not the same as V."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx U have a reach vtx V when vtx U have a used_edge vtx U and also vtx Z have a reach vtx V, where U is different from V.",
            "NL": "Vertex U has a connection to vertex V when there is an edge from U to vertex Z, and vertex Z has a connection to vertex V when U is not the same as V."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx U have a u_edge vtx V and vtx W when vtx U have uedge vtx V and also vtx V have weight_wtedge vtx U and vtx W.",
            "NL": "Vertex U has an edge to vertex V, with weight W, and vertex V has an edge to vertex U, with weight W."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx U have a u_edge vtx V and vtx W when vtx U have uedge vtx V and also vtx V have weight_wtedge vtx U and vtx W.",
            "NL": "Vertex U has an edge to vertex V with a weight of W, and vertex V also has an edge to vertex U with a weight of W."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx U have a u_edge vtx V and vtx W when vtx U have uedge vtx V and also vtx V have weight_wtedge vtx U and vtx W.",
            "NL": "Vertex U and Vertex V have a Weight_wtedge between them, with a weight of W in both directions."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx U have a u_edge vtx V and vtx W when vtx U have uedge vtx V and also vtx V have weight_wtedge vtx U and vtx W.",
            "NL": "Vertex U and vertex V have a weight_wtedge between them with a weight of W, with U having an uedge to V and V having a weight_wtedge to U."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx U have a u_edge vtx V and vtx W when vtx U have uedge vtx V and also vtx V have weight_wtedge vtx U and vtx W.",
            "NL": "Vertex U has an edge to vertex V with a weight of W, and likewise vertex V has an edge to vertex U with a weight of W."
        },
        {
            "Category": "Definition When",
            "CNL": "Vtx U reach Vtx V when Vtx U has an used_edge to V.",
            "NL": "When the vertex U has an edge connecting it to the vertex V, the vertex U is said to have reached the vertex V."
        },
        {
            "Category": "Definition When",
            "CNL": "Vtx U reach Vtx V when Vtx U has an used_edge to V.",
            "NL": "When the vertex U has an edge connecting it to the vertex V, the vertex U will reach the vertex V."
        },
        {
            "Category": "Definition When",
            "CNL": "Vtx U reach Vtx V when Vtx U has an used_edge to V.",
            "NL": "U and V are connected when U has an edge to V."
        },
        {
            "Category": "Definition When",
            "CNL": "Vtx U reach Vtx V when Vtx U has an used_edge to V.",
            "NL": "When the vertex U has an edge connecting to the vertex V, the vertex U will reach the vertex V."
        },
        {
            "Category": "Definition When",
            "CNL": "Vtx U reach Vtx V when Vtx U has an used_edge to V.",
            "NL": "When the vertex U has an edge connecting to the vertex V, it reaches the vertex V."
        },
        {
            "Category": "Definition When",
            "CNL": "Vtx U reach Vtx V when Vtx U have an used_edge to Z and also Vtx Z reach Vtx V, where U is different from V.",
            "NL": "When a vertex U has an used_edge to Z and U is not equal to V, U can reach a vertex V with the help of Z."
        },
        {
            "Category": "Definition When",
            "CNL": "Vtx U reach Vtx V when Vtx U have an used_edge to Z and also Vtx Z reach Vtx V, where U is different from V.",
            "NL": "When U is not equal to V, a vertex U can reach a vertex V if it has an used_edge to Z and a vertex Z can reach a vertex V."
        },
        {
            "Category": "Definition When",
            "CNL": "Vtx U reach Vtx V when Vtx U have an used_edge to Z and also Vtx Z reach Vtx V, where U is different from V.",
            "NL": "When a vertex U has an used_edge to Z and U is not equal to V, a vertex U can reach a vertex V through the vertex Z."
        },
        {
            "Category": "Definition When",
            "CNL": "Vtx U reach Vtx V when Vtx U have an used_edge to Z and also Vtx Z reach Vtx V, where U is different from V.",
            "NL": "When U is not equal to V, a vertex U can reach vertex V if it has an used_edge to a vertex Z, and a vertex Z can reach vertex V if U is not equal to V."
        },
        {
            "Category": "Definition When",
            "CNL": "Vtx U reach Vtx V when Vtx U have an used_edge to Z and also Vtx Z reach Vtx V, where U is different from V.",
            "NL": "When U is not equal to V, a vertex U can reach a vertex V if there is an used_edge from U to Z, and a vertex Z can reach a vertex V if U has an used_edge to Z."
        },
        {
            "Category": "Definition When",
            "CNL": "Vtx V is considered when Vtx U has an uedge to V and also Vtx U is dom.",
            "NL": "When vertex U is dominating, vertex V is taken into consideration if it has an edge connecting to vertex U."
        },
        {
            "Category": "Definition When",
            "CNL": "Vtx V is considered when Vtx U has an uedge to V and also Vtx U is dom.",
            "NL": "If vertex U has an edge to vertex V and vertex U is dominating, then V is taken into consideration."
        },
        {
            "Category": "Definition When",
            "CNL": "Vtx V is considered when Vtx U has an uedge to V and also Vtx U is dom.",
            "NL": "If vertex U has an edge to vertex V and vertex U is dominating, then V is considered."
        },
        {
            "Category": "Definition When",
            "CNL": "Vtx V is considered when Vtx U has an uedge to V and also Vtx U is dom.",
            "NL": "If vertex U has an edge to vertex V and is dominating, V is taken into consideration."
        },
        {
            "Category": "Definition When",
            "CNL": "Vtx V is considered when Vtx U has an uedge to V and also Vtx U is dom.",
            "NL": "When vertex U has an edge to vertex V and is dominating, V is considered a vertex."
        },
        {
            "Category": "Definition When",
            "CNL": "Vtx V is considered when Vtx V has an uedge to U and also Vtx U is dom.",
            "NL": "When vertex V has an edge to vertex U and vertex U is a dominating vertex, V is taken into account."
        },
        {
            "Category": "Definition When",
            "CNL": "Vtx V is considered when Vtx V has an uedge to U and also Vtx U is dom.",
            "NL": "When a vertex V has a connection to another vertex U and U is dominating, V is taken into consideration."
        },
        {
            "Category": "Definition When",
            "CNL": "Vtx V is considered when Vtx V has an uedge to U and also Vtx U is dom.",
            "NL": "When vertex V has an edge to vertex U and vertex U is dominating, V is taken into account."
        },
        {
            "Category": "Definition When",
            "CNL": "Vtx V is considered when Vtx V has an uedge to U and also Vtx U is dom.",
            "NL": "When vertex V has an edge connecting it to vertex U and U is a dominating vertex, V is taken into consideration."
        },
        {
            "Category": "Definition When",
            "CNL": "Vtx V is considered when Vtx V has an uedge to U and also Vtx U is dom.",
            "NL": "If a vertex V has an edge to vertex U, and U is dominating, V is taken into consideration."
        },
        {
            "Category": "Definition When",
            "CNL": "Vtx V is considered when Vtx V is dom.",
            "NL": "Vertex V is taken into account when it is dominant."
        },
        {
            "Category": "Definition When",
            "CNL": "Vtx V is considered when Vtx V is dom.",
            "NL": "The dominance of Vertex V is taken into consideration."
        },
        {
            "Category": "Definition When",
            "CNL": "Vtx V is considered when Vtx V is dom.",
            "NL": "Vertex V is taken into account when it is the dominant factor."
        },
        {
            "Category": "Definition When",
            "CNL": "Vtx V is considered when Vtx V is dom.",
            "NL": "V is taken into account when it is dominant."
        },
        {
            "Category": "Definition When",
            "CNL": "Vtx V is considered when Vtx V is dom.",
            "NL": "When V dominates, it is taken into consideration."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx V is reached when vtx U have a reach vtx V.",
            "NL": "When the vertex U arrives at the vertex V, V is reached."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx V is reached when vtx U have a reach vtx V.",
            "NL": "When the vertex U arrives at the vertex V, it has reached the vertex V."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx V is reached when vtx U have a reach vtx V.",
            "NL": "When the vertex U reaches the vertex V, it is considered to be at the vertex V."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx V is reached when vtx U have a reach vtx V.",
            "NL": "When the vertex U reaches V, the vertex V has been attained."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx V is reached when vtx U have a reach vtx V.",
            "NL": "When the vertex U reaches the vertex V, the vertex V is attained."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx V is reached when vtx U is reached and also vtx U has a link vtx V.",
            "NL": "When a vertex U is reached, it is possible to proceed to a connected vertex V."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx V is reached when vtx U is reached and also vtx U has a link vtx V.",
            "NL": "Once vertex U has been reached, a connection from it to vertex V can be made."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx V is reached when vtx U is reached and also vtx U has a link vtx V.",
            "NL": "Once vertex U has been attained, vertex V can be accessed since vertex U is connected to it."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx V is reached when vtx U is reached and also vtx U has a link vtx V.",
            "NL": "When vertex U has been reached, it has a link to a different vertex V which can then be accessed."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx V is reached when vtx U is reached and also vtx U has a link vtx V.",
            "NL": "Once vertex U has been attained, vertex V can be accessed due to the connection between the two vertices."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx V is reached when vtx U is reached and also vtx V has a link vtx U.",
            "NL": "When vertex U has been attained, vertex V can be accessed since it is linked to vertex U."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx V is reached when vtx U is reached and also vtx V has a link vtx U.",
            "NL": "When vertex U is attained, vertex V can be accessed since there is a link between them."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx V is reached when vtx U is reached and also vtx V has a link vtx U.",
            "NL": "Once vertex U has been attained, vertex V can be accessed since it is connected to vertex U."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx V is reached when vtx U is reached and also vtx V has a link vtx U.",
            "NL": "Once vertex U has been attained, vertex V can be accessed due to its connection to vertex U."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx V is reached when vtx U is reached and also vtx V has a link vtx U.",
            "NL": "Once vertex U has been attained, vertex V can be accessed since it is linked to vertex U."
        },
        {
            "Category": "Definition When",
            "CNL": "Vtx V is reached when Vtx U reach Vtx V.",
            "NL": "When the vertex U reaches the vertex V, the vertex V is attained."
        },
        {
            "Category": "Definition When",
            "CNL": "Vtx V is reached when Vtx U reach Vtx V.",
            "NL": "When the vertex U arrives at vertex V, the vertex V is attained."
        },
        {
            "Category": "Definition When",
            "CNL": "Vtx V is reached when Vtx U reach Vtx V.",
            "NL": "When the vertex U arrives at the vertex V, the vertex V is attained."
        },
        {
            "Category": "Definition When",
            "CNL": "Vtx V is reached when Vtx U reach Vtx V.",
            "NL": "When the vertex U arrives at the vertex V, it has reached the vertex V."
        },
        {
            "Category": "Definition When",
            "CNL": "Vtx V is reached when Vtx U reach Vtx V.",
            "NL": "When the vertex U arrives at the vertex V, V is attained."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx X has a hc vtx Y when vtx Y have a in_hm vtx X and also vtx X have a edge vtx Y.",
            "NL": "When vertex X has an edge to vertex Y and vertex Y has an in_hm to vertex X, vertex X is a HC vertex of Y."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx X has a hc vtx Y when vtx Y have a in_hm vtx X and also vtx X have a edge vtx Y.",
            "NL": "When the vertex X has an edge vertex Y and the vertex Y has an in_hm vertex X, there is a HC vertex Y for the vertex X."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx X has a hc vtx Y when vtx Y have a in_hm vtx X and also vtx X have a edge vtx Y.",
            "NL": "When the vertex X has an edge vertex Y and the vertex Y has an in_hm vertex X, there is a HC vertex Y at the vertex X."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx X has a hc vtx Y when vtx Y have a in_hm vtx X and also vtx X have a edge vtx Y.",
            "NL": "When vertex X has a connection to vertex Y, and vertex Y has an in_hm connection to vertex X, there is a HC connection between X and Y."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx X has a hc vtx Y when vtx Y have a in_hm vtx X and also vtx X have a edge vtx Y.",
            "NL": "When vertex X has an edge to vertex Y and vertex Y has an in_hm edge to vertex X, vertex X has a HC vertex Y."
        },
        {
            "Category": "Definition When",
            "CNL": "Vtx X has an arc to Vtx Y when Vtx X has an edge to Y.",
            "NL": "Vertex X has an arc connecting to vertex Y, while it has an edge linking to vertex Y."
        },
        {
            "Category": "Definition When",
            "CNL": "Vtx X has an arc to Vtx Y when Vtx X has an edge to Y.",
            "NL": "Vertex X has an arc connecting it to vertex Y, while vertex X has an edge linking it to vertex Y."
        },
        {
            "Category": "Definition When",
            "CNL": "Vtx X has an arc to Vtx Y when Vtx X has an edge to Y.",
            "NL": "Vertex X has an arc connecting it to vertex Y, and an edge linking it to vertex Y."
        },
        {
            "Category": "Definition When",
            "CNL": "Vtx X has an arc to Vtx Y when Vtx X has an edge to Y.",
            "NL": "Vertex X has an arc connecting to vertex Y, while vertex X has an edge linking to vertex Y."
        },
        {
            "Category": "Definition When",
            "CNL": "Vtx X has an arc to Vtx Y when Vtx X has an edge to Y.",
            "NL": "Vertex X has an arc connecting it to vertex Y, and an edge connecting it to vertex Y."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx X have a hc vtx Y when vtx X has an in_hm vtx Y and also vtx X have a edge vtx Y.",
            "NL": "When vertex X has a HC vertex Y or an in_hm vertex Y and an edge vertex Y, it has a vertex X."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx X have a hc vtx Y when vtx X has an in_hm vtx Y and also vtx X have a edge vtx Y.",
            "NL": "When vertex X has an in_hm vertex Y or an edge vertex Y, it has a HC vertex Y."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx X have a hc vtx Y when vtx X has an in_hm vtx Y and also vtx X have a edge vtx Y.",
            "NL": "When vertex X has a HC vertex Y or an in_hm vertex Y, it also has an edge vertex Y."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx X have a hc vtx Y when vtx X has an in_hm vtx Y and also vtx X have a edge vtx Y.",
            "NL": "When X is a HC vertex and X has an in_hm vertex Y, or when X has an edge vertex Y, X and Y are connected."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx X have a hc vtx Y when vtx X has an in_hm vtx Y and also vtx X have a edge vtx Y.",
            "NL": "When the vertex X has a HC vertex Y or an in_hm vertex Y, it also has an edge vertex Y."
        },
        {
            "Category": "Definition When",
            "CNL": "Vtx X is reached when Vtx Dummy has an inpath vtx X.",
            "NL": "When the vertex Dummy has an inpath to the vertex X, it is reached."
        },
        {
            "Category": "Definition When",
            "CNL": "Vtx X is reached when Vtx Dummy has an inpath vtx X.",
            "NL": "When the vertex Dummy has an inpath to the vertex X, it has reached X."
        },
        {
            "Category": "Definition When",
            "CNL": "Vtx X is reached when Vtx Dummy has an inpath vtx X.",
            "NL": "When the vertex Dummy has an inpath to it, the vertex X is reached."
        },
        {
            "Category": "Definition When",
            "CNL": "Vtx X is reached when Vtx Dummy has an inpath vtx X.",
            "NL": "When the vertex Dummy has an inpath leading to the vertex X, it is reached."
        },
        {
            "Category": "Definition When",
            "CNL": "Vtx X is reached when Vtx Dummy has an inpath vtx X.",
            "NL": "When the vertex Dummy has an inpath to the vertex X, X is reached."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx X is var when vtx C pair vtx X.",
            "NL": "Vertex C and vertex X are connected when variable C is present."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx X is var when vtx C pair vtx X.",
            "NL": "Vertex C is paired with vertex X when a variable C is present."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx X is var when vtx C pair vtx X.",
            "NL": "Vertex C is paired with vertex X, creating a variable C."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx X is var when vtx C pair vtx X.",
            "NL": "There is a variable C that is formed when vertex C is paired with vertex X."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx X is var when vtx C pair vtx X.",
            "NL": "Vertex C is paired with vertex X, resulting in the existence of a variable C."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx X triple vtx C and vtx Y when vtx C have an pair vtx Y and also vtx X has a member vtx C and also vtx X is var, where Y is different from X.",
            "NL": "Vertex X has a triple connection with vertex C and vertex Y, while vertex C has a pair connection with vertex Y, and vertex X is variable, where Y is different from X."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx X triple vtx C and vtx Y when vtx C have an pair vtx Y and also vtx X has a member vtx C and also vtx X is var, where Y is different from X.",
            "NL": "Vertex X is variable and has a triple vertex C and a pair vertex Y, while vertex C has a pair vertex Y, with Y being different from X."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx X triple vtx C and vtx Y when vtx C have an pair vtx Y and also vtx X has a member vtx C and also vtx X is var, where Y is different from X.",
            "NL": "Vertex X has three connections: C, Y, and X itself, with C being paired to Y and X being variable, and Y being distinct from X."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx X triple vtx C and vtx Y when vtx C have an pair vtx Y and also vtx X has a member vtx C and also vtx X is var, where Y is different from X.",
            "NL": "Vertex X has a triple connection to vertex C and Y, while vertex C has a pair connection to Y, where X is variable and Y is distinct from X."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx X triple vtx C and vtx Y when vtx C have an pair vtx Y and also vtx X has a member vtx C and also vtx X is var, where Y is different from X.",
            "NL": "Vertex X, which is variable, has a triple vertex C and a pair vertex Y, while C has a member vertex Y and is different from X."
        },
        {
            "Category": "Definition When",
            "CNL": "Vtx Y have an arc to Vtx X when Vtx X have an edge to Y.",
            "NL": "Vertex Y has an arc connecting it to vertex X, while vertex X has an edge linking it to vertex Y."
        },
        {
            "Category": "Definition When",
            "CNL": "Vtx Y have an arc to Vtx X when Vtx X have an edge to Y.",
            "NL": "Vertex Y has an arc connected to vertex X, while vertex X has an edge connected to vertex Y."
        },
        {
            "Category": "Definition When",
            "CNL": "Vtx Y have an arc to Vtx X when Vtx X have an edge to Y.",
            "NL": "Vertex Y is connected to vertex X via an arc, while vertex X is linked to vertex Y through an edge."
        },
        {
            "Category": "Definition When",
            "CNL": "Vtx Y have an arc to Vtx X when Vtx X have an edge to Y.",
            "NL": "Vertex Y has an arc connected to vertex X, while vertex X has an edge linking to vertex Y."
        },
        {
            "Category": "Definition When",
            "CNL": "Vtx Y have an arc to Vtx X when Vtx X have an edge to Y.",
            "NL": "Vertex Y has an arc connecting to vertex X while vertex X has an edge leading to vertex Y."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx3 T has a Next vtx3 D when vtx3 D Influential vtx3 O and also vtx3 T Next vtx3 O and also vtx3 D Connected vtx3 T.",
            "NL": "When the vtx3 D has an influential vtx3 O, the next vtx3 T is connected to it, as well as the next vtx3 O."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx3 T has a Next vtx3 D when vtx3 D Influential vtx3 O and also vtx3 T Next vtx3 O and also vtx3 D Connected vtx3 T.",
            "NL": "When there is an influential connection between the Next vtx3D and the vtx3T, and there is also a connection between the vtx3D and the Next vtx3T, the vtx3D will be followed by the vtx3T."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx3 T has a Next vtx3 D when vtx3 D Influential vtx3 O and also vtx3 T Next vtx3 O and also vtx3 D Connected vtx3 T.",
            "NL": "When the vtx3 D has an influential vtx3 O, there is a connection between it and the next vtx3 T, and there is also a link between the vtx3 T and the subsequent vtx3 D with its vtx3 O."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx3 T has a Next vtx3 D when vtx3 D Influential vtx3 O and also vtx3 T Next vtx3 O and also vtx3 D Connected vtx3 T.",
            "NL": "When the vtx3 D has an influential vtx3 O, there is a connection between the vtx3 D and the next vtx3 T, and there is also a link between the next vtx3 T and vtx3 O."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx3 T has a Next vtx3 D when vtx3 D Influential vtx3 O and also vtx3 T Next vtx3 O and also vtx3 D Connected vtx3 T.",
            "NL": "When there is an influential connection between the Next vtx3 D and vtx3 T, and there is also a Next with vtx3 T and vtx3 O, there is a link between the vtx3 D and vtx3 T."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx3 X Selected_Color vtx3 Q when vtx3 X have an Lacking vtx3 Q and also vtx3 Q has a Final and also vtx3 X has a Maximal vtx3 Q.",
            "NL": "If vtx3 X has a Minimum amount of vtx3 Q and vtx3 Q has a Maximum amount, then vtx3 X is chosen to be the same color as vtx3 Q."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx3 X Selected_Color vtx3 Q when vtx3 X have an Lacking vtx3 Q and also vtx3 Q has a Final and also vtx3 X has a Maximal vtx3 Q.",
            "NL": "If vtx3 X has the least amount of vtx3 Q and vtx3 Q has a final and vtx3 X has the highest amount of vtx3 Q, then vtx3 X is chosen to be the Selected_Color with vtx3 Q."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx3 X Selected_Color vtx3 Q when vtx3 X have an Lacking vtx3 Q and also vtx3 Q has a Final and also vtx3 X has a Maximal vtx3 Q.",
            "NL": "If vtx3 X has a Lacking vtx3 Q and vtx3 Q has a Final, and vtx3 X has a Maximal vtx3 Q, then vtx3 X is Selected_Color along with vtx3 Q."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx3 X Selected_Color vtx3 Q when vtx3 X have an Lacking vtx3 Q and also vtx3 Q has a Final and also vtx3 X has a Maximal vtx3 Q.",
            "NL": "If vtx3 X has a Minimum amount of vtx3 Q and vtx3 Q has a Final and also vtx3 X has a Maximum amount of vtx3 Q, then vtx3 X is Selected_Color with vtx3 Q."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx3 X Selected_Color vtx3 Q when vtx3 X have an Lacking vtx3 Q and also vtx3 Q has a Final and also vtx3 X has a Maximal vtx3 Q.",
            "NL": "If vtx3 X has a Minimal amount of vtx3 Q and vtx3 Q has a Terminal and also vtx3 X has a Maximum amount of vtx3 Q, then vtx3 X is Chosen_Color with vtx3 Q."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx9 F is Arc_Label vtx9 Y when vtx9 F Refused vtx9 Y and vtx9 W and also vtx9 F has Symbol vtx9 T and also vtx9 Y is not Concluding and also vtx9 Y is not Starting and also vtx9 F have Simple_Graph vtx9 Y and vtx9 A and also vtx9 Y is Symbol vtx9 T.",
            "NL": "If vtx9 F is declined vtx9 Y, vtx9 W, vtx9 F is denoted vtx9 T, vtx9 Y does not initiate, vtx9 F is a Simple Graph of vtx9 Y and vtx9 A, vtx9 Y is labeled vtx9 T, then vtx9 F is connected to vtx9 Y by an Arc Label."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx9 F is Arc_Label vtx9 Y when vtx9 F Refused vtx9 Y and vtx9 W and also vtx9 F has Symbol vtx9 T and also vtx9 Y is not Concluding and also vtx9 Y is not Starting and also vtx9 F have Simple_Graph vtx9 Y and vtx9 A and also vtx9 Y is Symbol vtx9 T.",
            "NL": "If vtx9 F is denied vtx9 Y, vtx9 W, and vtx9 F is represented by vtx9 T, and vtx9 Y does not initiate, with vtx9 F being a Simple_Graph of vtx9 Y and vtx9 A, and vtx9 Y is depicted by vtx9 T, then vtx9 F has an Arc_Label of vtx9 Y."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx9 F is Arc_Label vtx9 Y when vtx9 F Refused vtx9 Y and vtx9 W and also vtx9 F has Symbol vtx9 T and also vtx9 Y is not Concluding and also vtx9 Y is not Starting and also vtx9 F have Simple_Graph vtx9 Y and vtx9 A and also vtx9 Y is Symbol vtx9 T.",
            "NL": "If vtx9 F is denied vtx9 Y, vtx9 W, vtx9 F is designated as vtx9 T, vtx9 Y is not initiated, vtx9 F is a basic graph of vtx9 Y and vtx9 A, vtx9 Y is tagged as vtx9 T, then vtx9 F has an arc label of vtx9 Y."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx9 F is Arc_Label vtx9 Y when vtx9 F Refused vtx9 Y and vtx9 W and also vtx9 F has Symbol vtx9 T and also vtx9 Y is not Concluding and also vtx9 Y is not Starting and also vtx9 F have Simple_Graph vtx9 Y and vtx9 A and also vtx9 Y is Symbol vtx9 T.",
            "NL": "If vtx9 F is rejected, vtx9 Y is not initiated, and vtx9 F is a Simple Graph with vtx9 Y and vtx9 A, where vtx9 Y is represented by vtx9 T, then vtx9 F has an Arc Label of vtx9 Y."
        },
        {
            "Category": "Definition When",
            "CNL": "vtx9 F is Arc_Label vtx9 Y when vtx9 F Refused vtx9 Y and vtx9 W and also vtx9 F has Symbol vtx9 T and also vtx9 Y is not Concluding and also vtx9 Y is not Starting and also vtx9 F have Simple_Graph vtx9 Y and vtx9 A and also vtx9 Y is Symbol vtx9 T.",
            "NL": "If vtx9 F is denied vtx9 Y, vtx9 W, vtx9 F is represented by vtx9 T, vtx9 Y is not initiated, vtx9 F is a simple graph of vtx9 Y and vtx9 A, vtx9 Y is signified by vtx9 T, then vtx9 F has an arc label of vtx9 Y."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a Adjacency_List with node6 K, whenever there is a Regular with fifth node K, and with fake value M, whenever there is not an Variation with fifth node K, and with fake value M, then there must be an Unmatched with fifth node K, and with fake value M.",
            "NL": "A Adjacency_List point with node6 K, an Regular with fifth node K, and an edge with fake value M need to be present, and even when there is no Variation with fifth node K, and no Variation with fake value M, there must be an Unmatched with fifth node K, and with fake value M."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a Arc_Label with vtx1 L, whenever there is Associated with field8 R, with node N, whenever there is OutgoingPath with field8 R, with node N, then we must have a NonCohesive with fourth id equal to 20.",
            "NL": "Whenever there is an Arc_Label with vtx1 L, there is Associated with field8 R, with node N, there is OutgoingPath with field8 R, with node N, then we must have a NonCohesive with fourth id equal to 20. "
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a Cell with node L, with vtx8 F, with value4 P, whenever there is a Diagram with value5 L, with vtx10 F, whenever there is a NonOriented with value5 O, whenever there is not a Breadth with value5 F, whenever there is not a Breadth with value5 O, whenever there is not an Complete_Graph with value5 F, whenever there is not an Complete_Graph with value5 O different from F, then there must be a Minus with key4 O, with value8 L, with id4 F, with vtx1 P.",
            "NL": "whenever there is a Cell with node L, with vtx8 F, with value4 P, there is a Diagram with value5 L, with vtx10 F, there is a NonOriented with value5 O, there is not a Breadth with value5 F, there is not a Breadth with value5 O, there is no Complete_Graph with value5 F, there is not Complete_Graph with value5 O, where O is not equal to F, then there must be a Minus with key4 O, with value8 L, with id4 F, with vtx1 P."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a Child with value7 M, whenever there is an Augmenting_Path with fifth id M, and with fourth vertex Q, whenever there is not an Breadth with fifth id M, and with fourth vertex Q, then there must be an Indication with fifth id M, and with fourth vertex Q.",
            "NL": "A Child point with value7 M, an Augmenting_Path with fifth id M, and an edge with fourth vertex Q need to be present, and even when there is no Breadth with fifth id M, and no Breadth with fourth vertex Q, there must be an Indication with fifth id M, and with fourth vertex Q."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a Duo with vtx K, with field I, whenever there is a Success with node10 U, with id7 I, with key3 A, whenever there is not a Success with node10 U, with id7 K, with key3 A, then we must have a Radius with vtx K, with field I.",
            "NL": "whenever there is a Duo with vtx K, with field I, there is a Success with node10 U, with id7 I, with key3 A, when there is no Success with node10 U, with id7 K, with key3 A, then we must have a Radius with vtx K, with field I."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a Examine with key10 X, with value9 B, with field8 F Joined than Y2, whenever there is a Examine with key10 X, with value9 B, with field8 H, then there must be a less with key10 X, with value9 B, with field8 F, with node1 B, and with value H. ",
            "NL": "whenever there is an Examine with key10 X, with value9 B, with field8 F, there is an Examine with key10 X, with value9 B, with field8 H, where Y1 is less than Y2, then there must be a Joined with key10 X, with value9 B, with field8 F, with node1 B, and with value H."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a Gravity with id10 N, with value10 T, Whenever there is a Path with id10 W, with value10 T, Whenever there is a Unit with edge1 W, with node N, with vtx5 T, then we must have an Outpath with id10 N, with value10 T.",
            "NL": "Whenever there is a Gravity with id10 N, with value10 T, there is a Path with id10 W, with value10 T, there is an Unit with edge1 W, with node N, with vtx5 T, then we must have an Outpath with id10 N, with value10 T."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a Hint with edge6 U, with key P, with field5 M, with key1 A, and with node10 T, whenever there is a Hint with edge6 U, with key A, with field5 T, with key1 W, and with node10 C, then there must be a Span with edge6 U, with key P, with field5 M, with key1 W, and with node10 C.",
            "NL": "whenever there is a Hint with edge6 U, with key P, with field5 M, with key1 A, and with node10 T, and there is a Hint with edge6 U, with key A, with field5 T, with key1 W, and with node10 C, then there must be a Span with edge6 U, with key P, with field5 M, with key1 W, and with node10 C."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a Jailed with value5 X, with key7 B, whenever there is a Indication with value5 X, with key7 G less than B, then there must be a Indication with value5 X, and with key7 K.",
            "NL": "whenever there is a Jailed with value5 X, with key7 B, there is an Indication with value5 X, with key7 G, where G is less than B, then there must be a Indication with value5 X, and with key7 K."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a Layer with fifth id J, with fifth point K, then we must have a Line_Graph with fifth id J, with fifth point K or Layer with fifth id J, and with fifth point K.",
            "NL": "Whenever there is a Layer between the fifth id J, and the fifth point K, then there must either be an Line_Graph between the fifth id J, and the fifth point K, or we must has a Layer between the fifth id J, and the fifth point K."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a NonForemost with id6 B, whenever there is not an Radius with second id B, then there must be an NonSubsequent with node field1 B.",
            "NL": "Whenever there is a NonForemost with id6 B, that has not a Radius with second id B, there must be a NonSubsequent with node field1 B."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a Pair with first id equal to 31, whenever there is a Projection with edge2 K, with id6 S, whenever there is a Tally with edge2 T, whenever there is not a Arc with value2 S, Whenever there is not a Duo with value2 S, whenever there is not a Notnext with id7 K, with field2 W, whenever there is not a Notnext with id7 K, with field2 I, then we must have a Penalty with id7 K, with field2 T.",
            "NL": "Whenever there is a Pair with a first id equal to 31, there is a Projection with edge2 K, with id6 S, there is a Tally with edge2 T, there is not a Arc with value2 S, there is no Duo with value2 S, there is not an Notnext with id7 K, with field2 W, there is not an Notnext with id7 K, with field2 I, then we must have a Penalty with id7 K, with field2 T. "
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a Partition with id8 V, whenever there is an Unvalued with first point V, and with fake value D, whenever there is not an IngoingPath with first point V, and with fake value D, then there must be an Member with first point V, and with fake value D.",
            "NL": "A Partition point with id8 V, an Unvalued with first point V, and an edge with fake value D need to be present, and even when there is no IngoingPath with first point V, and no IngoingPath with fake value D, there must be an Member with first point V, and with fake value D."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a Probability_Value with key3 O, with node7 M, with id8 A less than V, with field1 F different from Y, whenever there is a Probability_Value with key3 O, with node7 M, with id8 V, with field1 Y, then we must have a Unimportant with key3 A, with node7 F, with id8 V, with field1 Y.",
            "NL": "whenever there is a Probability_Value with key3 O, with node7 M, with id8 A, with field1 F, whenever there is a Probability_Value with key3 O, with node7 M, with id8 V, with field1 Y, where A is less than V and F is not equal to Y, then we must have an Unimportant with key3 A, with node7 F, with id8 V, with field1 Y."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a Sanction with id6 V, and with key6 M, then there must be an Tint with id6 V. ",
            "NL": "Every time there is a Sanction with the id6 V and with the key6 M, there must be a Tint with the id6 V as well."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a Sequence with value7 T, whenever there is an Mass with first point T, and with third vertex R, whenever there is not an Auxiliary with first point T, and with third vertex R, then there must be an Information with first point T, and with third vertex R.",
            "NL": "A Sequence point with value7 T, an Mass with first point T, and an Mass with third vertex R need to be present, and even when there is no Auxiliary with first point T, and with third vertex R, there must be an Information with first point T, and with third vertex R."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a Short I, whenever there is a Adjacency_Matrix I then there must be a Distinct with third id equal to 41. ",
            "NL": "Whenever there is a Short I, and there is an Adjacency_Matrix I, there must be a Distinct with a third id equal to 41."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a Signal with vtx6 D, with vtx4 B less than D, then we must have a Punishment with vtx6 B, with vtx4 D.",
            "NL": "Every time there is a Signal with vtx6 D, with vtx4 B, where B is less than D, it is necessary to perform a Punishment with vtx6 B, with vtx4 D."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a Significant with third point C, and with third node T then we must have a Complete with field7 T. ",
            "NL": "When there is a Significant between the third point C and the third node T, we need to have a Complete with the field7 T."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a Single W, whenever there is not an Wanting with field6 W, with value9 K, whenever there is Complete with field6 K, and with value9 A less than or equal to W, then there must be an Statistical_Significance with field6 W, with value9 K. ",
            "NL": "Whenever there is a Single W, an Complete with field6 K and with value9 A, and not Wanting with field6 W, with value9 K, considering value9 A is less than and equal to W, then there must be a Statistical_Significance with field6 W, and value9 K. "
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a Starting with field1 Z, with value8 C, whenever there is a Name with vtx8 I, with vtx5 C, with edge4 K, whenever there is not a Name with vtx8 I, with vtx5 Z, with edge4 K, then we must have a Input with field1 Z, with value8 C.",
            "NL": "whenever there is a Starting with field1 Z, with value8 C, there is a Name with vtx8 I, with vtx5 C, with edge4 K, when there is no Name with vtx8 I, with vtx5 Z, with edge4 K, then we must have an Input with field1 Z, with value8 C."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a Tally with id1 Z, with node4 V, with field2 M, with vtx5 U, and with node6 I, then there must be a Relevant with id1 Z, with node4 U, with field2 I.",
            "NL": "It follows that whenever there is a Tally with id1 Z, node4 V, field2 M, vtx5 U, and node6 I, there must also be a Relevant with id1 Z, node4 U, and field2 I."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a Trail with field5 L, whenever there is not a Allocate with field5 L, whenever there is not a Width with field5 L, whenever there is not an Out with field2 L, with id3 U, whenever there is not an Out with field2 L, with id3 N, whenever there is a Color with field5 M, whenever there is an Out_Hamiltonian_Tour with field5 L, with node5 M, then there must be a Trapped with field5 L.",
            "NL": "whenever there is a Trail with field5 L, there is no a Allocate with field5 L, there is not a Width with field5 L, there is not an Out with field2 L, with id3 U, there is not an Out with field2 L, with id3 N, there is a Color with field5 M, and when there is an Out_Hamiltonian_Tour with field5 L, with node5 M, then there must be an Trapped with field5 L."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an Complicated with id6 X, with edge A, with value1 I, with key7 C, then we must have a List with field X, with edge5 I.",
            "NL": "For every Complicated with id6 X, with edge A, with value1 I, with key7 C, we must List with field X, with edge5 I."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an Dormant with field W, whenever there is not an Particle with field W, whenever there is a Dual_Graph with field G, with node1 W, whenever there is not an Planar_Embedding with field G, with node1 W, then there must be a Offspring with field W.",
            "NL": "Whenever there is a Dormant V, and Dual_Graph with field G, with node1 W there is no Particle with field W, there is not a Planar_Embedding with id1 U, and with id2 V, then there must be a Offspring with field W."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an Edge with field6 D then we must have a Line_Graph with vtx4 D. ",
            "NL": "Whenever there is an Edge with field6 D there must be a Line_Graph with vtx4 D."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an Engaged with vtx5 B, with key X, with node4 I, with vtx9 A, then we must have a Colored with vtx10 B, with value4 I.",
            "NL": "For every Engaged with vtx5 B, with key X, with node4 I, with vtx9 A, we must Colored with vtx10 B, with value4 I."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an Examine with key2 H, whenever there is an Accessed with third id H, and with third node E, whenever there is not an Inorder with third id H, and with third node E, then there must be an Network with third id H, and with third node E.",
            "NL": "A Examine point with key2 H, an Accessed with third id H, and an Accessed with third node E need to be present, and even when there is no Inorder with third id H, and with third node E, there must be an Network with third id H, and with third node E."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an Foremost with first id G, and with third vertex K then we must have a Penalty with first id G, and with third vertex K.",
            "NL": "When there is a Foremost between the first id G and the third vertex K, there must be a Penalty between the first id G and the third vertex K."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an In with edge7 T, with edge7 A, whenever there is a Couple with edge10 U, with node5 A, whenever there is a Duo with edge7 T, with edge7 U then we must have a Couple with edge10 U, with node5 T. ",
            "NL": "Whenever there is an In with edge7 T and edge7 A, having a Couple with edge10 U, with node5 A, and Duo with edge7 T and with edge7 U, then we must have a Couple with edge10 U, node5 T."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an Incorporates with field2 Z, whenever there is not an Parent with field2 Z, whenever there is a Selected_Color with field2 Y, with id3 Z, whenever there is not an Cycle with field2 Y, with id3 Z, then there must be a Triad with field2 Z.",
            "NL": "Whenever there is an Incorporates V, and Selected_Color with field2 Y, with id3 Z there is no Parent with field2 Z, there is not a Cycle with id1 U, and with id2 V, then there must be a Triad with field2 Z."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an Indication with third node M, then there must be a Depth_Vertex with edge10 M.",
            "NL": "A Depth_Vertex edge10 M must be present whenever there is an Indication with third node M."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an Information with id4 E, and with vtx8 L, and with vtx8 M, whenever there is a Contrast with id4 V, and with vtx8 F, and with node6 N, whenever there is not an Weighted_Graph with edge9 E, and with key9 V, then there must be an NonClustering with edge9 E, with key9 V.",
            "NL": "whenever there is an Information with id4 E, with vtx8 L, and with vtx8 M, a Contrast with id4 V, with vtx8 F, and with node6 N, and when there is not a Weighted_Graph with edge9 E, and with key9 V, then there must be a NonClustering with edge9 E, with key9 V. "
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an Intersect with value10 V, Whenever there is not a Symbol with value10 V, Whenever there is not a Trio with value V, with key4 M, Whenever there is not a Trio with value V, with key4 U, then we must have a Load with value V, with key4 M or Load with value V, with key4 U.",
            "NL": "Whenever there is an Intersect with value10 V, there is not a Symbol with value10 V, there is not na Trio with value V, with key4 M, there is not an Trio with value V, with key4 U, then we must have a Load with value V, with key4 M or Load with value V, with key4 U."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an Ordered with value7 H, with vtx9 I, whenever there is a Check with field9 H, with id2 Z, whenever there is a Check with field9 I, with id2 N, and with id2 Z greater than N, then we must have a Inspect with value7 H, with vtx9 I, with field N, with vtx5 Z.",
            "NL": "Whenever there is an Ordered with id2 H and id2 I, having a Check with id2 H, with id2 Z, and Check with id2 I and with id2 N, considering N is less than Z, then we must have an Inspect with id2 H, id2 I, id2 N, and with id2 Z."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an Outbound with second vertex O, with second node X, then we must have an Less with second vertex O, with second node X or Outbound with second vertex O, and with second node X.",
            "NL": "Whenever there is an Outbound between the second vertex O, and the second node X, then there must either be an Less between the second vertex O, and the second node X, or we must has an Outbound between the second vertex O, and the second node X."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an Succeeding with edge2 W, with id9 K less than W, then we must have a Root with edge2 K, with id9 W.",
            "NL": "Every time there is a Succeeding with edge2 W, with id9 K, where K is less than W, it is necessary to perform a Root with edge2 K, with id9 W."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an Unweighted with edge5 F, and with node5 K, whenever there is an Unweighted with edge5 K, and with node5 L, then we must have a NonCohesive with edge5 F, with node5 L. ",
            "NL": "Whenever there is an Unweighted with edge5 F, with node5 K, and Unweighted with edge5 K, with node5 L, then we must have a NonCohesive with edge5 F, and node5 L."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is Matching with value4 J, with vtx4 E, with vtx L, then there must be a Calculation with node3 E, with id2 L.",
            "NL": "There must be Calculation with node3 E, with id2 L, whenever there is a Matching with value4 J, vtx4 E, vtx L."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is Maximum_Matching with key7 E, with value8 U, with value5 V, then there must be a Hamiltonian_Graph with value9 E, with vtx V.",
            "NL": "There must be Hamiltonian_Graph with value9 E, with vtx V, whenever there is a Maximum_Matching with key7 E, value8 U, value5 V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is Refused with edge1 Y, with edge Q, with node C, then there must be a Partition with key Q, with id2 C.",
            "NL": "There must be Partition with key Q, with id2 C, whenever there is a Refused with edge1 Y, edge Q, node C."
        },
        {
            "Category": "Definition Whenever",
            "CNL": " whenever there is a gt with id1 L, with id2 N, with id3 P, whenever there is not a gt with id1 L, with id2 N, with id3 P+1, then there must be a position with value N, and with id P+1.",
            "NL": "Whenever there is a GT with id1 L, id2 N, id3 P, and there is not a GT with id1 L, id2 N, id3 P+1, then there must be a position with value N, and with id P+1."
        },
        {
            "Category": "Definition Whenever",
            "CNL": " whenever there is a next with value C1, and with id1 C2, then there must be an later with value C2.",
            "NL": "Every time there is a next with the value C1 and with the id1 C2, there must be a later with the value C2 as well."
        },
        {
            "Category": "Definition Whenever",
            "CNL": " Whenever there is a vertex with value V, Whenever there is a obs_vlabel with id1 V, with id2 S, Whenever there is not a trivial with key V, Whenever there is not a input with key V, then we must have a vlabel with id1 V, with id2 S.",
            "NL": "Whenever there is a vertex with value V, there is an obs_vlabel with id1 V, with id2 S, there is not a trivial with key V, there is not input with key V, then we must have a vlabel with id1 V, with id2 S."
        },
        {
            "Category": "Definition Whenever",
            "CNL": " whenever there is a vertex with value V, whenever there is not a input with value V, whenever there is not a trivial with value V, whenever there is an edge with value W, and with id V, whenever there is an edge with value U greater than W, with id V, whenever there is not an btedge with id1 W, with id2 U, with id3 V, then there must be a ntedge with id1 W, with id2 U, with id3 V.",
            "NL": "Whenever there is a vertex V, there is no input with value V, there is not a trivial with value V, there is an edge with value W, with id V, and also there is an edge with value U, with id V, and there is not btedge with id1 W, with id2 U, with id3 V, considering W is less than U, then there must has a ntedge with id1 W, with id2 U, with id3 V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": " whenever there is an chosenColour with value N, and with id1 C, then there must be an colored with value N.",
            "NL": "Whenever there is a chosencolour with value N, with id1 C, there must has a coloured with value N."
        },
        {
            "Category": "Definition Whenever",
            "CNL": " whenever there is an edge with value N2, with id N1, whenever there is an in_layer with value L1 less than L2, with id N1, whenever there is an in_layer with value L2, with id N2, then we must have an edge_layer with id1 L1, with id2 L2, with id3 N1, with id4 N2.",
            "NL": "Every time there is an edge with value N2, with id N1, there is an in_layer with value L1 less than L2, with id N1, and every time there is an in_layer with value L2, with id N2, we must has an edge_layer with id1 L1, id2 L2, id3 N1, and id4 N2."
        },
        {
            "Category": "Definition Whenever",
            "CNL": " whenever there is an edge_pair with id1 N1, with id2 N2, with id3 N3, with id4 N4, then we must have a compare with value N1, with id N3. ",
            "NL": "For every edge_pair with id1 N1, with id2 N2, with id3 N3, with id4 N4, we must compare with value N1, with id N3."
        },
        {
            "Category": "Definition Whenever",
            "CNL": " whenever there is an obs_elabel with id1 U, with id2 V, with id3 S, whenever there is an edge with value U, with id V, whenever there is a vertex with value W, whenever there is not a trivial with value V, whenever there is not a trivial with value W, whenever there is not an input with value V, whenever there is not an input with value W different from V, then there must be a mllabel with field1 W, with field2 U, with field3 V, with field4 S.",
            "NL": "whenever there is an obs_elabel with id1 U, with id2 V, with id3 S, there is an edge with value U, with id V, there is a vertex with value W, there is not a trivial with value V, there is not a trivial with value W, there is no input with value V, there is not input with value W, where W is not equal to V, then there must be a mllabel with field1 W, with field2 U, with field3 V, with field4 S."
        },
        {
            "Category": "Definition Whenever",
            "CNL": " whenever there is an vertex with value V, whenever there is not an input with value V, whenever there is an edge with value U, with id V, whenever there is not an diff with value U, with id V, then there must be a nontriv with value V.",
            "NL": "Whenever there is a vertex V, and edge with value U, with id V there is no input with value V, there is not a difference with id1 U, and with id2 V, then there must be a nontrive with value V. "
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a active with key V, whenever there is coppo with field1 U, with field2 V, whenever there is last with field1 U, with field2 V, then we must have a bot with fake value equal to 1.",
            "NL": "Whenever there is an active with key V, there is coppo with field1 U, with field2 V, there is last with field1 U, with field2 V, then we must have a bot with fake value equal to 1."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a active with key V, Whenever there is not a trivial with key V, whenever there is an edge with value U, with id V, Whenever there is not a obs_vlabel with id1 U, with id2 P, Whenever there is not a obs_vlabel with id1 U, with id2 M, then we must have a vlable with id1 U, with id2 P or vlabel with id1 U, with id2 M.",
            "NL": "Whenever there is an active with key V, there is not a trivial with key V, there is an edge with value U, with id V, there is not an obs_vlabel with id1 U, with id2 P, there is not an obs_vlabel with id1 U, with id2 M, then we must have a vlable with id1 U, with id2 P or vlabel with id1 U, with id2 M."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a arc with first vtx X, with second vtx Y, whenever there is a bound with first vtx X, then we must have a in_hm with id1 X, with id2 Y or out_hm with first vtx X, with second vtx Y.",
            "NL": "Whenever there is an arc with first vertex X, with second vertex Y, whenever there is a bound with first vertex X, there must be an in_hm with id X, with id Y, or an out_hm with first vertex X, with second vertex Y."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a bot with fake value equal to 1, whenever there is a vertex with value V, whenever there is a sign with value S, whenever there is not a trivial with key V, Whenever there is not a input with key V, whenever there is not a obs_vlabel with id1 V, with id2 P, whenever there is not a obs_vlabel with id1 V, with id2 M, then we must have a vlabel with id1 V, with id2 S. ",
            "NL": "Whenever there is a bot with a fake value equal to 1, there is a vertex with value V, whenever there is a sign with value S, there is not a trivial with key V, and there is no input with key V, whenever there is not an obs_vlabel with id1 V, with id2 P, whenever there is not an obs_vlabel with id1 V, with id2 M, then we must have a vlabel with id1 V, with id2 S."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a bot with fake value equal to 1, whenever there is an edge with value U, with id V, whenever there is a sign with value S, whenever there is not a trivial with key V, Whenever there is not a input with key V, whenever there is not a obs_vlabel with id1 U, with id2 P, whenever there is not a obs_vlabel with id1 U, with id2 M, then we must have a vlabel with id1 U, with id2 S. ",
            "NL": "Whenever there is a bot with a fake value equal to 1, there is an edge with value U, with id V, there is a sign with value S, there is not a trivial with key V, there is no input with key V, there is not an obs_vlabel with id1 U, with id2 P, there is not an obs_vlabel with id1 U, with id2 M, then we must have a vlabel with id1 U, with id2 S."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a bot with fake value equal to 1, whenever there is an edge with value U, with id V, whenever there is a sign with value S, whenever there is not a trivial with key V, Whenever there is not a input with key V, whenever there is not a obs_elabel with id1 U, with id2 V, with id3 P, whenever there is not a obs_elabel with id1 U, with id2 V, with id3 M, then we must have a llabel with field1 U, with field2 V, with field3 S. ",
            "NL": "Whenever there is a bot with a fake value equal to 1, there is an edge with value U, with id V, there is a sign with value S, there is not a trivial with key V, there is no input with key V, there is not an obs_elabel with id1 U, with id2 V, with id3 P, there is not an obs_elabel with id1 U, with id2 V, with id3 M, then we must have a llabel with field1 U, with field2 V, with field3 S."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a ChosenColour with value N, with id1 CC different from C, whenever there is index with value C, and with id1 I less than or equal to N, then there must be an notchosenColour with value N, with id1 C.",
            "NL": "Whenever there is a chosencolour with value N, with id1 CC, an index with value C and with id1 I, considering I is less than and equal to N and C is not equal to CC, then there must notchosencolour with value N, and id1 C. "
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a ChosenColour with value NN, with id1 C, whenever there is a link with value NN, with id1 N greater than NN, then there must be an notchosenColour with value N, with id1 C.",
            "NL": "Whenever there is a chosencolour with value NN, with id1 C, and a link with value NN and with id1 N, considering NN is less than N, then there must notchosencolour with value N, and id1 C."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a colour with value C1, whenever there is not an later with value C1, then there must be an index with value C1 , with id1 equal to 1.",
            "NL": "whenever there is a colour with value C1, and there is no later colour that has the same value for C1, then there must be an index with value C1, where id1 is equal to 1."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a colour with value C2, whenever there is a colour with id C1 less than C2, then we must have a colours with value C1 , with id1 C2. ",
            "NL": "Whenever there is a colour with id C1, and another colour with value C2, and the value of C1 is always less than C2, we must have colours with value C1, with id1 C2. "
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a colours with value C1, and with id1 C2, whenever there is a colours with value C2, and with id1 C3, then we must have a notnext with value C1 , with id1 C3. ",
            "NL": "Whenever there is a colours with value C1, with id1 C2, and colours with value C2, with id1 C3, then we must have a notnext with value C1, and id1 C3. "
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a compare with value N1, with id N2, whenever there is a gt with id1 L, with id2 N2, with id3 P, whenever there is not a gt with id1 L, with id2 N1, with id3 P, then we must have a inorder with value N1, with id N2.",
            "NL": "Whenever there is a compare with value N1, with id N2, there is a GT with id1 L, with id2 N2, with id3 P, when there is no GT with id1 L, with id2 N1, with id3 P, then we must have an inorder with value N1, with id N2."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a edge with value U, with id V, whenever there is a active with value V, whenever there is not a trivial with value V, whenever there is a reach with field1 V, with field2 W, whenever there is a vertex with value W, then there must be a reach with field1 U, with field2 W.",
            "NL": "whenever there is an edge with value U, with id V, there is an active with value V, there is not a trivial with value V, there is a reach with field1 V, with field2 W, there is a vertex with value W, then there must be a reach with field1 U, with field2 W."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a edge with value U, with id V, Whenever there is a obs_elabel with id1 U, with id2 V, with id3 S, Whenever there is not a trivial with key V, Whenever there is not a input with key V, then we must have a llabel with field1 U, with field2 V, with field3 S. ",
            "NL": "Whenever there is an edge with value U, with id V, there is an obs_elabel with id1 U, with id2 V, with id3 S, there is not a trivial with key V, there is not input with key V, then we must have a llabel with field1 U, with field2 V, with field3 S."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a edge with value U, with id V, Whenever there is a obs_vlabel with id1 U, with id2 S, Whenever there is not a trivial with key V, Whenever there is not a input with key V, then we must have a vlabel with id1 U, with id2 S.",
            "NL": "Whenever there is an edge with value U, with id V, there is an obs_vlabel with id1 U, with id2 S, there is not a trivial with key V, there is no input with key V, then we must have a vlabel with id1 U, with id2 S."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a edge with value U, with id V, whenever there is an active with key W, whenever there is not a trivial with value V, whenever there is not a trivial with value W, whenever there is an active with key V, whenever there is a reach with field1 V, and with field2 W different from V, whenever there is a reach with field1 W, and with field2 V, whenever there is not a mvlabel with field1 W, with field2 V, with field3 M, then there must be a mvlabel with field1 W, with field2 V, with field3 P.",
            "NL": "whenever there is an edge with value U, with id V, there is an active with key W, whenever there is not a trivial with value V, there is not a trivial with value W, there is an active with key V, whenever there is a reach with field1 V, and with field2 W, there is a reach with field1 W, and with field2 V, there is not a mvlabel with field1 W, with field2 V, with field3 M, where W is not equal to V, then there must be a mvlabel with field1 W, with field2 V, with field3 P."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a edge with value U, with id V, whenever there is an active with key W, whenever there is not a trivial with value V, whenever there is not a trivial with value W, whenever there is an active with key V, whenever there is a reach with field1 V, and with field2 W different from V, whenever there is a reach with field1 W, and with field2 V, whenever there is not a mllabel with field1 W, with field2 U, with field3 V, with field4 P then there must be a mllabel with field1 W, with field2 U, with field3 V, with field4 M. ",
            "NL": "whenever there is an edge with value U, with id V, there is an active with key W, there is not a trivial with value V, there is not a trivial with value W, there is an active with key V, there is a reach with field1 V, and with field2 W, there is a reach with field1 W, and with field2 V, there is not a mllabel with field1 W, with field2 U, with field3 V, with field4 P, where W is not equal to V, then there must be a mllabel with field1 W, with field2 U, with field3 V, with field4 M."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a edge with value U, with id V, whenever there is an active with value V, whenever there is not a trivial with value V, whenever there is a reach with field1 U, with field2 W, whenever there is a vertex with value W, whenever there is not an obs_vlabel with id1 U, with id2 P, whenever there is not an obs_vlabel with id1 U, with id2 M, then there must be a reach with field1 V, with field2 W.",
            "NL": "whenever there is an edge with value U, with id V, there is an active with value V, there is not a trivial with value V, there is a reach with field1 U, with field2 W, there is a vertex with value W, there is not an obs_vlabel with id1 U, with id2 P, there is not an obs_vlabel with id1 U, with id2 M, then there must be a reach with field1 V, with field2 W."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a edge_pair with id1 N1, with id2 N2, with id3 N3, with id4 N4, whenever there is not a edge_pair with id1 N1, with id2 N4, with id3 N3, with id4 N2, whenever there is a compare with value N2, with id N4, whenever there is a inorder with value N2, with id N4, whenever there is not a inorder with value N1, with id N3, then we must have a crossing with id1 N1, with id2 N2, with id3 N3, with id4 N4. ",
            "NL": "whenever there is an edge pair with id1 N1, with id2 N2, with id3 N3, with id4 N4, whenever there is not a edgep air with id1 N1, with id2 N4, with id3 N3, with id4 N2, when there is a compare with value N2, with id N4, there is an inorder with value N2, with id N4, there is not a inorder with value N1, with id N3, then we must have a crossing with id1 N1, with id2 N2, with id3 N3, with id4 N4."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a less with field1 X, with field2 C1, with field3 Y1, with field4 C, and with field5 Y, whenever there is a less with field1 X, with field2 C, with field3 Y, with field4 C2, and with field5 Y2, then there must be a diff with field1 X, with field2 C1, with field3 Y1, with field4 C2, and with field5 Y2. ",
            "NL": "whenever there is a less with field1 X, with field2 C1, with field3 Y1, with field4 C, and with field5 Y, and there is a less with field1 X, with field2 C, with field3 Y, with field4 C2, and with field5 Y2, then there must be a difference with field1 X, with field2 C1, with field3 Y1, with field4 C2, and with field5 Y2."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a less with field1 X, with field2 C1, with field3 Y1, with field4 C2, and with field5 Y2, whenever there is not a diff with field1 X, with field2 C1, with field3 Y1, with field4 C2, and with field5 Y2, then there must be a next with field1 X, with field2 C1, with field3 Y1, with field4 C2, and with field5 Y2.",
            "NL": "whenever there is a less with field1 X, with field2 C1, with field3 Y1, with field4 C2, and with field5 Y2, and there is not a difference with field1 X, with field2 C1, with field3 Y1, with field4 C2, and with field5 Y2, then there must be a next with field1 X, with field2 C1, with field3 Y1, with field4 C2, and with field5 Y2."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a llabel with field1 U, with field2 V, with field3 M, Whenever there is a vlabel with id1 U, with id2 S, Whenever there is not a trivial with key V, Whenever there is not a input with key V, Whenever there is not a obs_elabel with id1 U, with id2 V, with id3 P, Whenever there is a vlabel with id1 V, with id2 S, then we must have an oppo with field1 U, with field2 V.",
            "NL": "Whenever there is a llabel with field1 U, with field2 V, with field3 M, there is a vlabel with id1 U, with id2 S, there is not a trivial with key V, there is not an input with key V, there is not an obs_elabel with id1 U, with id2 V, with id3 P, there is a vlabel with id1 V, with id2 S, then we must have an oppo with field1 U, with field2 V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a llabel with field1 U, with field2 V, with field3 P, Whenever there is a vlabel with id1 U, with id2 S different from T, Whenever there is not a trivial with key V, Whenever there is not a input with key V, Whenever there is not a obs_elabel with id1 U, with id2 V, with id3 M, Whenever there is a vlabel with id1 V, with id2 T, then we must have an oppo with field1 U, with field2 V. ",
            "NL": "Whenever there is a llabel with field1 U, with field2 V, with field3 P, there is a vlabel with id1 U, with id2 S different from T, there is not a trivial with key V, there is no input with key V, there is not an obs_elabel with id1 U, with id2 V, with id3 M, there is a vlabel with id1 V, with id2 T, then we must have an oppo with field1 U, with field2 V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a manAssignsScore with id1 M, and with id2 FV1, and with id3 FV2, whenever there is an womanAssignsScore with id1 W, and with id2 FV3, and with id3 FV4, whenever there is not an nonMatch with value M, and with id W, then there must be an match with value M, with id W.",
            "NL": "whenever there is a manAssignsScore with id1 M, with id2 FV1, and with id3 FV2, a womanAssignsScore with id1 W, with id2 FV3, and with id3 FV4, and when there is not a nonMatch with value M, and with id W, then there must be a match with value M, with id W."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a manAssignsScore with id1 M, and with id2 FV1, and with id3 FV2, whenever there is an womanAssignsScore with id1 W, and with id2 FV3, and with id3 FV4, whenever there is not an nonMatch with value M, and with id W, then there must be an nonmatch with value M, with id W. ",
            "NL": "Whenever there is a manAssignsScore with id1 M, with id2 FV1, and with id3 FV2, a womanAssignsScore with id1 W, with id2 FV3, and with id3 FV4, and when there is not a match with value M, and with id W, then there must be a nonmatch with value M, with id W."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a match with value M, with id FV1 then we must have jailed with value M.",
            "NL": "As soon as there is a match with value M, with id FV1, we must have jailed the instance with value M."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a mvlabel with field1 W, with field2 U, with field3 S different from T, whenever there is a mllabel with field1 W different from V, with field2 U, with field3 V, with field4 T, then there must be a minfl with field1 W, with field2 V, with field3 M.",
            "NL": "whenever there is a mvlabel with field1 W, with field2 U, with field3 S, whenever there is a mllabel with field1 W, with field2 U, with field3 V, with field4 T, where W is not equal to V and S is not equal to T, then there must be a minfl with field1 W, with field2 V, with field3 M."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a mvlabel with field1 W, with field2 U, with field3 S, whenever there is a mllabel with field1 W different from V, with field2 U, with field3 V, with field4 S, then there must be a minfl with field1 W, with field2 V, with field3 P.",
            "NL": "whenever there is a mvlabel with field1 W, with field2 U, with field3 S, there is a mllabel with field1 W, with field2 U, with field3 V, with field4 S, where W is not equal to V then there must be a minfl with field1 W, with field2 V, with field3 P."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a next with field1 X, with field2 C1, with field3 Y1, with field4 C2, and with field5 Y2, then there must be a pred with field1 X, with field2 C1, with field3 Y1, with field4 C2, and with field5 Y2. ",
            "NL": "whenever there is a next with field1 X, with field2 C1, with field3 Y1, with field4 C2, and with field5 Y2, then there must be a prediction with field1 X, with field2 C1, with field3 Y1, with field4 C2, and with field5 Y2."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a next with field1 X, with field2 C1, with field3 Y1, with field4 C2, and with field5 Y2, then there must be a succ with field1 X, with field2 C2, with field3 Y2.",
            "NL": "It follows that whenever there is a next with field1 X, field2 C1, field3 Y1, field4 C2, and field5 Y2, there must also be a success with field1 X, field2 C2, and field3 Y2."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a next with value C1 , with id1 C2, whenever there is an index with value C1, and with id1 I, then there must be an index with value C2 , with id1 I+1.",
            "NL": "Whenever there is a next with value C1, with id1 C2, and an index with value C1, with the id1 I then we must have an index with value C2, and id1 I+1."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a node N, whenever there is not an notChosenColour with value N, with id1 C, whenever there is index with value C, and with id1 I less than or equal to N, then there must be an chosenColour with value N, with id1 C.",
            "NL": "Whenever there is a node N, an index with value C and with id1 I, and not notchosencolour with value N, with id1 C, considering id1 I is less than and equal to N, then there must be a chosencolour with value N, and id1 C."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a node with edge X, whenever there is not an Clique with first node X, then there must be an nonclique with node value X.",
            "NL": "Whenever there is a node with edge X, that has no clique with node X, there must be a nonclique with node X."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a node with edge X, whenever there is not an nonClique with first node X, then there must be an clique with node value X.",
            "NL": "Whenever there is a node with edge X, that has not a nonclique with first node X, there must be a clique with node value X."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a obs_vlabel with id1 U, with id2 S, whenever there is a edge with value U, with id V, whenever there is a vertex with value W, whenever there is not a trivial with value V, whenever there is not a trivial with value W, whenever there is not an input with value V, whenever there is not an input with value W different from V, then there must be a mvlabel with field1 W, with field2 U, with field3 S.",
            "NL": "whenever there is an obs_vlabel with id1 U, with id2 S, there is an edge with value U, with id V, there is a vertex with value W, there is not a trivial with value V, there is not a trivial with value W, whenever there is not input with value V, there is no input with value W, where W is not equal to V, then there must be a mvlabel with field1 W, with field2 U, with field3 S."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a obs_vlabel with id1 V, with id2 S, whenever there is a vertex with value W, whenever there is not a trivial with value V, whenever there is not a trivial with value W, whenever there is not an input with value V, whenever there is not an input with value W different from V, then there must be a mvlabel with field1 W, with field2 V, with field3 S. ",
            "NL": "whenever there is an obs_vlabel with id1 V, with id2 S, there is a vertex with value W, there is not a trivial with value V, there is not a trivial with value W, there is not an input with value V, there is not an input with value W, where W is not equal to V, then there must be a mvlabel with field1 W, with field2 V, with field3 S."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a oppo with field1 U, with field2 V, Whenever there is a first with field1 U, with field2 V, then we must have a coppo with field1 U, with field2 V.",
            "NL": "Whenever there is an oppo with field1 U, with field2 V, there is a first with field1 U, with field2 V, then we must have a coppo with field1 U, with field2 V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a reach with first vtx U, and with second vtx V then we must have a reached with value V.",
            "NL": "When there is a reach between the first vertex U and the second vertex V, we need to have a reached with the value V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a reach with first vtx Z, with second vtx V, whenever there is an used_edge with first vtx U, with second vtx Z, then we must have a reach with first vtx U, with second vtx V.",
            "NL": "The presence of a reach between the first vertex Z and second vertex V, as well as the presence of a used_edge between the first vertex U and second vertex Z, indicates that there must also be a reach between the first vertex U and second vertex V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a reached with node X, whenever there is an edge with first node X, and with second node Y, whenever there is not an inpath with first node X, and with second node Y, then there must be an outpath with first node X, and with second node Y.",
            "NL": "A reached point with node X, an edge with first node X, and an edge with second node Y need to be present, and even when there is no in path with first node X, and with second node Y, there must be an out path with first node X, and with second node Y."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a reached with node X, whenever there is an edge with first node X, and with second node Y, whenever there is not an outpath with first node X, and with second node Y, then there must be an inpath with first node X, and with second node Y. ",
            "NL": "A reached point with node X, an edge with first node X, and an edge with second node Y need to be present, and even when there is no outpath with first node X, and with second node Y, there must be an inpath with first node X, and with second node Y. "
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a reached with value U, whenever there is a link with id1 U, with id2 V then we must have a reached with value V.",
            "NL": "Whenever there is a reached with value U, and there is a link with id1 U, with id2 V then we must have a reached with value V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a reached with value U, whenever there is a link with id1 V, with id2 U then we must have a reached with value V.",
            "NL": "Whenever there is a reached with value U, and there is a link with id1 V, with id2 U then we must have a reached with value V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a road with first point X, with second point Y, whenever there is a start with first point X, then we must have a visit with second point Y.",
            "NL": "When there is a road that connects first point X with second point Y, we must start with first point X, and then visit second point Y."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a road with first point X, with second point Y, whenever there is an visit with first point X, then we must have a visit with second point Y.",
            "NL": "When there is a road that connects first point X with second point Y, we must visit with first point X, and then visit second point Y."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a singleton 1, then we must have a bot with fake value equal to 1.",
            "NL": "Every time there is a singleton 1, we must create a bot with fake value 1 as well."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a start with node X, whenever there is an edge with first node X, and with second node Y, whenever there is not an inpath with first node X, and with second node Y, then there must be an outpath with first node X, and with second node Y.",
            "NL": "A start point with node X, an edge with first node X, and an edge with second node Y need to be present, and even when there is no in path with first node X, and no inpath with second node Y, there must be an outpath with first node X, and with second node Y."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a start with node X, whenever there is an edge with first node X, and with second node Y, whenever there is not an outpath with first node X, and with second node Y, then there must be an inpath with first node X, and with second node Y. ",
            "NL": "A start point with node X, an edge with first node X, and an edge with second node Y need to be present, and even when there is no out path with first node X, and no outpath with second node Y, there must be an inpath with first node X, and with second node Y."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a triple with field1 X, with field2 C, with field3 Y1 less than Y2, whenever there is a triple with field1 X, with field2 C, with field3 Y2, then there must be a less with field1 X, with field2 C, with field3 Y1, with field4 C, and with field5 Y2.",
            "NL": "whenever there is a triple with field1 X, with field2 C, with field3 Y1, there is a triple with field1 X, with field2 C, with field3 Y2, where Y1 is less than Y2, then there must be a less with field1 X, with field2 C, with field3 Y1, with field4 C, and with field5 Y2."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a triple with field1 X, with field2 C1 less than C2, with field3 Y1, whenever there is a triple with field1 X, with field2 C2, with field3 Y2, then there must be a less with field1 X, with field2 C1, with field3 Y1, with field4 C2, and with field5 Y2.",
            "NL": "whenever there is a triple with field1 X, with field2 C1, with field3 Y1, there is a triple with field1 X, with field2 C2, with field3 Y2, where C1 is less than C2, then there must be a less with field1 X, with field2 C1, with field3 Y1, with field4 C2, and with field5 Y2."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a uedge with id1 U, with id2 V, whenever there is an partition with value U, with id X, whenever there is an partition with value V, with id Y, and with id Y greater than X, then we must have an adjacent with id1 U, with id2 V, with id3 X, with id4 Y.",
            "NL": "Whenever there is an uedge with id U and id V, having a partition with id U, with id X, and partition with id V and with id Y, considering X is less than Y, then we must have an adjacent with id U, id V, id X, and with id Y."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a uedge with id1 U, with id2 V, whenever there is an weight_edgewt with first vtx V, with second vtx U, with third weight W, then we must have an u_edge with id1 U, with id2 V, with id3 W.",
            "NL": "Whenever there is an undirected edge with id U and id V, whenever there is an edge weight with weight W, with first vertex V, and with second vertex U, there must be an undirected edge with id U, with id V, with weight W."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a uedge with value U, with id V, whenever there is a reach with id1 K, with id2 U, whenever there is a partition with value V, with id K then we must have a reach with id1 K, with id2 V. ",
            "NL": "Whenever there is an uedge with id U and id V, having a reach with id K, with id U, and partition with id V and with id X, then we must have a reach with id K, id V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a vertex with value V, whenever there is not a input with value V, whenever there is not a trivial with value V, whenever there is an edge with value U, and with id V, whenever there is not a nfirst with field1 U, with field2 V, then there must be a first with field1 U, with field2 V.",
            "NL": "whenever there is a vertex with value V, there is no input with value V, there is not a trivial with value V, there is an edge with value U, and with id V, there is not a nfirst with field1 U, with field2 V, then there must be a first with field1 U, with field2 V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a vertex with value V, whenever there is not a input with value V, whenever there is not a trivial with value V, whenever there is an edge with value U, and with id V, whenever there is not a nlast with field1 U, with field2 V, then there must be a last with field1 U, with field2 V.",
            "NL": "whenever there is a vertex with value V, there is no input with value V, there is not a trivial with value V, there is an edge with value U, and with id V, there is not a nlast with field1 U, with field2 V, then there must be a last with field1 U, with field2 V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a vertex with value V, whenever there is not a input with value V, whenever there is not a trivial with value V, whenever there is an edge with value W less than Z, and with id V, whenever there is an edge with value U greater than Z, with id V, whenever there is an edge with value Z, with id V, then there must be a btedge with id1 W, with id2 U, with id3 V.",
            "NL": "Whenever there is a vertex V, there is no input with value V, there is not a trivial with value V, there is an edge with value W, with id V, and also there is an edge with value Z, with id V, considering Z is greater than W and less than U, then there must has a btedge with id1 W, with id2 U, with id3 V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a vertex with value V, whenever there is not a input with value V, whenever there is not a trivial with value V, whenever there is not an obs_vlabel with id1 V, with id2 P, whenever there is not an obs_vlabel with id1 V, with id2 M, whenever there is an active with key W, whenever there is a edge with value V, with id W, then there must be a aedge with value V.",
            "NL": "whenever there is a vertex with value V, there is no a input with value V, there is not a trivial with value V, there is not an obs_vlabel with id1 V, with id2 P, there is not an obs_vlabel with id1 V, with id2 M, there is an active with key W, and when there is an edge with value V, with id W, then there must be an aedge with value V. "
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a vertex with value V, whenever there is not an input V, whenever there is not an inactive V, then there must be an active with key V.",
            "NL": "Whenever there is a vertex with value V, there is not an input V, there is not an inactive V, and then there must be an active with key V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a vertex with value V, whenever there is not an input with value V, whenever there is not an nontriv with value V, then there must be a trivial with value V. ",
            "NL": "Whenever there is a vertex V, there is no input with value V, there is not a nontrivial with value V, then there must be a trivial with value V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a width with value L, with id T greater than 0, then there must be a pvalue with value L, and with id T equal to 1.",
            "NL": "Whenever there is a width with value L and an id T greater than 0, there must also be a pvalue with value L and an id T equal to 1."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a width with value L, with id T, whenever there is a pvalue with value L, with id X less than T, then there must be a pvalue with value L, and with id X+1.",
            "NL": "whenever there is a width with value L, with id T, there is a pvalue with value L, with id X, where X is less than T, then there must be a pvalue with value L, and with id X+1."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an active V, whenever there is a trivial V then there must be a singleton with fake value equal to 1.",
            "NL": "Whenever there is an active V, and there is a trivial V, there must be a singleton with a fake value equal to 1."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an active with key V, Whenever there is not a trivial with key V, whenever there is an edge with value U, with id V, Whenever there is not a obs_elabel with id1 U, with id2 V, with id3 P, Whenever there is not a obs_elabel with id1 U, with id2 V, with id3 M, then we must have a llabel with field1 U, with field2 V, with field3 P or llabel with field1 U, with field2 V, with field3 M.",
            "NL": "Whenever there is an active with key V, there is not a trivial with key V, there is an edge with value U, with id V, there is not a obs_elabel with id1 U, with id2 V, with id3 P, there is not a obs_elabel with id1 U, with id2 V, with id3 M, then we must have a llabel with field1 U, with field2 V, with field3 P or llabel with field1 U, with field2 V, with field3 M."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an active with key V, Whenever there is not a trivial with key V, Whenever there is not a obs_vlabel with id1 V, with id2 P, Whenever there is not a obs_vlabel with id1 V, with id2 M, then we must have a vlable with id1 V, with id2 P or vlabel with id1 V, with id2 M. ",
            "NL": "Whenever there is an active with key V, there is not a trivial with key V, there is not na obs_vlabel with id1 V, with id2 P, there is not an obs_vlabel with id1 V, with id2 M, then we must have a vlable with id1 V, with id2 P or vlabel with id1 V, with id2 M."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an active with key W, whenever there is not a trivial with value V, whenever there is not a trivial with value W, whenever there is an active with key V, whenever there is a reach with field1 V, and with field2 W different from V, whenever there is a reach with field1 W, and with field2 V, whenever there is not a mvlabel with field1 W, with field2 V, with field3 M, then there must be a mvlabel with field1 W, with field2 V, with field3 P.",
            "NL": "Whenever there is an active with key W, there is not a trivial with value V, there is not a trivial with value W, there is an active with key V, there is a reach with field1 V, and with field2 W different from V, there is a reach with field1 W, and with field2 V, there is not a mvlabel with field1 W, with field2 V, with field3 M, then there must be a mvlabel with field1 W, with field2 V, with field3 P."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an active with key W, whenever there is not a trivial with value V, whenever there is not a trivial with value W, whenever there is an active with key V, whenever there is a reach with field1 V, and with field2 W different from V, whenever there is a reach with field1 W, and with field2 V, whenever there is not a mvlabel with field1 W, with field2 V, with field3 P, then there must be a mvlabel with field1 W, with field2 V, with field3 M.",
            "NL": "whenever there is an active with key W, whenever there is not a trivial with value V, there is not a trivial with value W, there is an active with key V, there is a reach with field1 V, and with field2 W, there is a reach with field1 W, and with field2 V, there is not a mvlabel with field1 W, with field2 V, with field3 P, where W is not equal to V then there must be a mvlabel with field1 W, with field2 V, with field3 M. "
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an arc with first vtx X, with second vtx Y, whenever there is a reached with first vtx X, then we must have a in_hm with id1 X, with id2 Y or out_hm with first vtx X, with second vtx Y.",
            "NL": "Whenever there is an arc with first vertex X, with second vertex Y, whenever there is a reached with first vertex X, there must be an in_hm with id X, with id Y, or an out_hm with first vertex X, with second vertex Y."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an colours with value C1, and with id1 C2, whenever there is not an notnext with value C1 , with id1 C2, then there must be an next with value C1 , with id1 C2.",
            "NL": "Whenever there is a colours with value C1, with id1 C2, and no notnext with value C1, with id1 C2, then we must have a next with value C1, and id1 C2."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an edge with first vtx V1, with second vtx V2, then we must have an In with first vtx V1, with second vtx V2 or no_In with first vtx V1, and with second vtx V2.",
            "NL": "Whenever there is an edge between the first vertex V1, and the second vertex V2, then there must either be an In between the first vertex V1, and the second vertex V2, or we must has a no_In between the first vertex V1, and the second vertex V2."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an edge with first vtx X, with second vtx Y, then we must have a inPath with first vtx X, with second vtx Y or outPath with first vtx X, with second vtx Y.",
            "NL": "As soon as there is an edge between the first vertex X and the second vertex Y, then we need to have either an inPath with the first vertex X and the second vertex Y, or an outPath with the first vertex X and the second vertex Y."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an edge with value N1, with id N2, whenever there is an in_layer with value L1 less than L2, with id N1, whenever there is an in_layer with value L2, with id N2, then we must have an edge_layer with id1 L1, with id2 L2, with id3 N1, with id4 N2.",
            "NL": "Every time there is an edge with value N1, with id N2, there is an in_layer with value L1 less than L2, with id N1, and every time there is an in_layer with value L2, with id N2, we must has an edge_layer with id1 L1, id2 L2, id3 N1, and id4 N2."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an edge with value U, with id V, whenever there is a active with value V, whenever there is not a trivial with value V, whenever there is not a obs_vlabel with id1 U, with id2 P, whenever there is not a obs_vlabel with id1 U, with id2 M, then there must be a reach with field1 V, with field2 U.",
            "NL": "whenever there is an edge with value U, with id V, there is an active with value V, there is not a trivial with value V, there is not an obs_vlabel with id1 U, with id2 P, there is not an obs_vlabel with id1 U, with id2 M, then there must be a reach with field1 V, with field2 U."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an edge with value U, with id V, whenever there is an active with key W, whenever there is not a trivial with value V, whenever there is not a trivial with value W, whenever there is an active with key V, whenever there is a reach with field1 V, and with field2 W different from V, whenever there is a reach with field1 W, and with field2 V, whenever there is not a mvlabel with field1 W, with field2 V, with field3 P, then there must be a mvlabel with field1 W, with field2 V, with field3 M. ",
            "NL": "Whenever there is an edge with value U, with id V, there is an active with key W, there is not a trivial with value V, there is not a trivial with value W, there is an active with key V, there is a reach with field1 V, and with field2 W different from V, there is a reach with field1 W, and with field2 V, there is not a mvlabel with field1 W, with field2 V, with field3 M, then there must be a mvlabel with field1 W, with field2 V, with field3 P. "
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an edge with value U, with id V, whenever there is an active with key W, whenever there is not a trivial with value V, whenever there is not a trivial with value W, whenever there is an active with key V, whenever there is a reach with field1 V, and with field2 W different from V, whenever there is a reach with field1 W, and with field2 V, whenever there is not a mllabel with field1 W, with field2 U, with field3 V, with field4 M then there must be a mllabel with field1 W, with field2 U, with field3 V, with field4 P.",
            "NL": "whenever there is an edge with value U, with id V, there is an active with key W, whenever there is not a trivial with value V, there is not a trivial with value W, there is an active with key V, there is a reach with field1 V, and with field2 W, there is a reach with field1 W, and with field2 V, there is not a mllabel with field1 W, with field2 U, with field3 V, with field4 M, where W is not equal to V, then there must be a mllabel with field1 W, with field2 U, with field3 V, with field4 P."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an edge with value U, with id V, whenever there is an active with value V, whenever there is not a trivial with value V, then there must be a reach with field1 U, with field2 V.",
            "NL": "whenever there is an edge with value U, with id V, there is an active with value V, there is not a trivial with value V, then there must be a reach with field1 U, with field2 V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an edge with value U, with id V, whenever there is an obs_elabel with id1 U, with id2 V, with id3 M, whenever there is not an obs_elabel with id1 U, with id2 V, with id3 P, whenever there is an obs_vlabel with id1 U, with id2 S, whenever there is an obs_vlabel with id1 V, with id2 S then there must be a diff with value U, with id V.",
            "NL": "Whenever there is an edge with value U, with id V, there is an obs_elabel with id1 U, with id2 V, with id3 M, there is not an obs_elabel with id1 U, with id2 V, with id3 P, there is an obs_vlabel with id1 U, with id2 S, and there is an obs_vlabel with id1 V, with id2 S, then there must be a difference with value U, with id V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an edge with value U, with id V, whenever there is an obs_elabel with id1 U, with id2 V, with id3 P, whenever there is not an obs_elabel with id1 U, with id2 V, with id3 M, whenever there is an obs_vlabel with id1 U, with id2 S different from T, whenever there is an obs_vlabel with id1 V, with id2 T then there must be a diff with value U, with id V.",
            "NL": "Whenever there is an edge with value U, with id V, there is an obs_elabel with id1 U, with id2 V, with id3 P, there is not an obs_elabel with id1 U, with id2 V, with id3 M, there is an obs_vlabel with id1 U, with id2 S, and there is an obs_vlabel with id1 V, with id2 T, and id S is not equal to T, then there must be a difference with value U, with id V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an edge with value V, with id V1, whenever there is an obs_elabel with id1 V, with id2 V1, with id3 M, whenever there is not an obs_elabel with id1 V, with id2 V1, with id3 P, then there must be a diff with value V, with id V1.",
            "NL": "whenever there is an edge with value V, with id V1, obs_elabel with id1 V, with id2 V1, with id3 M and there is not an obs_elabel with id1 V, with id2 V1, with id3 P then there must be a difference with value V, with id V1."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an edge_layer with id1 L1, with id2 L2, with id3 N1 less than N3, with id4 N2 different from N4, whenever there is an edge_layer with id1 L1, with id2 L2, with id3 N3, with id4 N4, then we must have an edge_pair with id1 N1, with id2 N2, with id3 N3, with id4 N4. ",
            "NL": "whenever there is an edge_layer with id1 L1, with id2 L2, with id3 N1, with id4 N2, whenever there is an edge_layer with id1 L1, with id2 L2, with id3 N3, with id4 N4, where N1 is less than N3 and N2 is not equal to N4, then we must have an edge_pair with id1 N1, with id2 N2, with id3 N3, with id4 N4."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an edge_pair with id1 N1, with id2 N2, with id3 N3, with id4 N4, then we must have an edge_paired with value N2, with id N4.",
            "NL": "whenever there is an edge_pair with id1 N1, with id2 N2, with id3 N3, with id4 N4, then we must have an edge_paired with value N2, with id N4."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an edge_pair with id1 N1, with id2 N2, with id3 N3, with id4 N4, whenever there is not a edge_pair with id1 N1, with id2 N4, with id3 N3, with id4 N2, whenever there is a compare with value N2, with id N4, whenever there is a inorder with value N1, with id N3, whenever there is not a inorder with value N2, with id N4, then we must have a crossing with id1 N1, with id2 N2, with id3 N3, with id4 N4. ",
            "NL": "whenever there is an edge_pair with id1 N1, with id2 N2, with id3 N3, with id4 N4, there is not a edge_pair with id1 N1, with id2 N4, with id3 N3, with id4 N2, when there is a compare with value N2, with id N4, there is an inorder with value N1, with id N3, there is not a inorder with value N2, with id N4, then we must have a crossing with id1 N1, with id2 N2, with id3 N3, with id4 N4."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an edge_pair with id1 N1, with id2 N4, with id3 N3, with id4 N2, whenever there is not a edge_pair with id1 N1, with id2 N2, with id3 N3, with id4 N4, whenever there is a compare with value N2, with id N4, whenever there is an inorder with value N1, with id N3, whenever there is an inorder with value N1, with id N4, then we must have a crossing with id1 N1, with id2 N4, with id3 N3, with id4 N2.",
            "NL": "whenever there is an edge_pair with id1 N1, with id2 N4, with id3 N3, with id4 N2, whenever there is not a edge_pair with id1 N1, with id2 N2, with id3 N3, with id4 N4, when there is a compare with value N2, with id N4, and there is an inorder with value N1, with id N3, there is an inorder with value N1, with id N4, then we must have a crossing with id1 N1, with id2 N4, with id3 N3, with id4 N2."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an edge_pair with id1 N1, with id2 N4, with id3 N3, with id4 N2, whenever there is not a edge_pair with id1 N1, with id2 N2, with id3 N3, with id4 N4, whenever there is a compare with value N2, with id N4, whenever there is not a inorder with value N1, with id N3, whenever there is not a inorder with value N2, with id N4, then we must have a crossing with id1 N1, with id2 N4, with id3 N3, with id4 N2.",
            "NL": "whenever there is an edge pair with id1 N1, with id2 N4, with id3 N3, with id4 N2, there is not a edge_pair with id1 N1, with id2 N2, with id3 N3, with id4 N4, there is a compare with value N2, with id N4, when there is not a inorder with value N1, with id N3, there is not a inorder with value N2, with id N4, then we must have a crossing with id1 N1, with id2 N4, with id3 N3, with id4 N2."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an edge_paired with value N2 less than N4, with id N4, then we must have a compare with value N2, with id N4.",
            "NL": "Every time there is an edge_paired with value N2, with id N4, where N2 is less than N4, we must compare it with value N2, with id N4."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an edge_paired with value N2, with id N4 less than N2, then we must have a compare with value N4, with id N2.",
            "NL": "Every time there is an edge_paired with value N2, with id N4, where N4 is less than N2, it is necessary to perform a compare with value N4, with id N2."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an in_hm with id1 X, with id2 Y, whenever there is an edge with first vtx X, with second vtx Y, then we must have a hc with first vtx X, with second vtx Y.",
            "NL": "When there is an in_hm with id X, with id Y, whenever there is an edge with first vertex X, with second vertex Y, there must be a hc with first vertex X, with second vertex Y."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an in_hm with id1 Y, with id2 X, whenever there is an edge with first vtx X, with second vtx Y, then we must have a hc with first vtx X, with second vtx Y.",
            "NL": "When there is an in_hm with id Y, with id X, whenever there is an edge with first vertex X, with second vertex Y, there must must be a hc with first vertex X, with second vertex Y."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an in_hm with id2 Y then we must have a reached with value Y.",
            "NL": "Whenever there is an in_hm with id Y there must be a reached with vertex X."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an in_layer with value L, with id N, whenever there is a width with value L, with id T greater than 0, whenever there is not a gt with id1 L, with id2 N, with id3 P equal to 1, then there must be a position with value N, and with id X equal to 1.",
            "NL": "When there is an in_layer with value L, with id N, there exists a width with value L, with id T greater than 0, there does not exist a GT with id1 L, with id2 N, with id3 P equal to 1, then there must exist a position with value N, and with id X equal to 1. "
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an inpath with second node X, then there must be a reached with node X.",
            "NL": "A reached node X must be present whenever there is an inpath with second node X."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an oppo with field1 U, with field2 V, Whenever there is a coppo with field1 W, with field2 V, Whenever there is a ntedge with id1 W, with id2 U, with id3 V, then we must have a coppo with field1 U, with field2 V. ",
            "NL": "Whenever there is an oppo with field1 U, with field2 V, there is a coppo with field1 W, with field2 V, there is a ntedge with id1 W, with id2 U, with id3 V, then we must have a coppo with field1 U, with field2 V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an partition with value U, with id K, whenever there is an partition with value V, with id K, whenever there is an vtx with id V, and with id V less than U, then we must have an existsless with id1 U, with id2 K.",
            "NL": "Whenever there is a partition with value U and id K, and a partition with value V and id K, with a vtx id V, considering id V is less than U, then we must have an existsless with id1 U, id2 K."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an partition with value U, with id K, whenever there is not an existsless with id1 U, with id2 K, then we must have a reach with id1 K, and with id2 U. ",
            "NL": "Whenever there is a partition with value U and id K, that does not existsless with id1 U and id2 K, then we must have a reach with id1 K and id2 U."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an uedge with id1 U, with id2 V, whenever there is a partition with value U, with id Y, whenever there is a partition with value V, with id X, and with id X less than Y, then we must have an adjacent with id1 U, with id2 V, with id3 X, with id4 Y.",
            "NL": "Whenever there is an uedge with id U and id V, having a partition with id U, with id Y, and partition with id V and with id X, considering X is less than Y, then we must have an adjacent with id U, id V, id X, and with id Y."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an uedge with id1 U, with id2 V, whenever there is a weight_edgewt with first vtx U, with second vtx V, with third weight W, then we must have an u_edge with id1 U, with id2 V, with id3 W.",
            "NL": "Whenever there is an uedge with id U, with id V, whenever there is an edge_weight with third weight W, with first vertex U, with second vertex V, there must be an uedge with id U, with id V, with weight W."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an uedge with value V, with id U, whenever there is a reach with id1 K, with id2 U, whenever there is a partition with value V, with id K then we must have a reach with id1 K, with id2 V. ",
            "NL": "Whenever there is an uedge with id V and id U, having a reach with id K, with id U, and partition with id V and with id X, then we must have a reach with id K, id V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an used_edge with first vtx U, and with second vtx V then we must have a reach with first vtx U, and with second vtx V.",
            "NL": "When there is an used_edge between the first vertex U and the second vertex V, there must be a reach between the first vertex U and the second vertex V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an vertex with value V, whenever there is not an input V, whenever there is an active W with key W different from V, whenever there is a trivial W then there must be an inactive with value V.",
            "NL": "whenever there is a vertex with value V, there is not an input V, there is an active with key W, when V is not equal to W, there is a trivial W then there must be an inactive with value V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an vertex with value V, whenever there is not an input V, whenever there is not an active V, then there must be an inactive with value V.",
            "NL": "whenever there is a vertex with value V, there is not an input V, there is not an active V, then there must be an inactive vertex with value V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is ntedge with id1 W, with id2 U, with id3 V, then there must be a nfirst with field1 U, with field2 V.",
            "NL": "There must be nfirst with field1 U, with field2 V, whenever there is a ntedge with id1 W, id2 U, id3 V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is ntedge with id1 W, with id2 U, with id3 V, then there must be a nlast with field1 W, with field2 V.",
            "NL": "There must be nlast with field1 W, with field2 V, whenever there is a ntedge with id1 W, id2 U, id3 V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": " whenever there is a chosenColour with value N, and with id1 C, then there must be an colored with value N.",
            "NL": "Whenever a color of value N with ID C is chosen, there must be a corresponding color of value N."
        },
        {
            "Category": "Definition Whenever",
            "CNL": " whenever there is a chosenColour with value N, and with id1 C, then there must be an colored with value N.",
            "NL": "Whenever a colour with value N and ID C is chosen, there must be a corresponding colour with the same value N."
        },
        {
            "Category": "Definition Whenever",
            "CNL": " whenever there is a chosenColour with value N, and with id1 C, then there must be an colored with value N.",
            "NL": "Whenever a colour with the value N and ID C is selected, there must also be a colour with the value N."
        },
        {
            "Category": "Definition Whenever",
            "CNL": " whenever there is a chosenColour with value N, and with id1 C, then there must be an colored with value N.",
            "NL": "Whenever a colour is selected with a value of N and an ID of C, there must also be a colour with the same value of N."
        },
        {
            "Category": "Definition Whenever",
            "CNL": " whenever there is a chosenColour with value N, and with id1 C, then there must be an colored with value N.",
            "NL": "Whenever a color with value N and ID1 C is selected, there must be a corresponding color with the same value N."
        },
        {
            "Category": "Definition Whenever",
            "CNL": " whenever there is a gt with id1 L, with id2 N, with id3 P, whenever there is not a gt with id1 L, with id2 N, with id3 P+1, then there must be a position with value N, and with id P+1.",
            "NL": "If a GT with id1 L, id2 N, and id3 P is present, but there is not a GT with id1 L, id2 N, and id3 P+1, then it is necessary for there to be a position with value N and the id P+1."
        },
        {
            "Category": "Definition Whenever",
            "CNL": " whenever there is a gt with id1 L, with id2 N, with id3 P, whenever there is not a gt with id1 L, with id2 N, with id3 P+1, then there must be a position with value N, and with id P+1.",
            "NL": "If there is not a GT with the combination of id1 L, id2 N, and id3 P+1, then there must be a position with value N and id P+1."
        },
        {
            "Category": "Definition Whenever",
            "CNL": " whenever there is a gt with id1 L, with id2 N, with id3 P, whenever there is not a gt with id1 L, with id2 N, with id3 P+1, then there must be a position with value N, and with id P+1.",
            "NL": "If there is not a GT with id1 L, id2 N, and id3 P+1, then there must be a position with value N and id P+1 for every GT with id1 L, id2 N, and id3 P."
        },
        {
            "Category": "Definition Whenever",
            "CNL": " whenever there is a gt with id1 L, with id2 N, with id3 P, whenever there is not a gt with id1 L, with id2 N, with id3 P+1, then there must be a position with value N, and with id P+1.",
            "NL": "If no GT exists with the identifiers id1 L, id2 N, and id3 P+1 when there is a GT with the identifiers id1 L, id2 N, and id3 P, then there must be a position with a value of N, and with id P+1."
        },
        {
            "Category": "Definition Whenever",
            "CNL": " whenever there is a gt with id1 L, with id2 N, with id3 P, whenever there is not a gt with id1 L, with id2 N, with id3 P+1, then there must be a position with value N, and with id P+1.",
            "NL": "If there is no GT consisting of id1 L, id2 N, and id3 P+1, then there must be a position with value N and an id of P+1."
        },
        {
            "Category": "Definition Whenever",
            "CNL": " whenever there is a next with value C1, and with id1 C2, then there must be an later with value C2.",
            "NL": "For every instance of a next with the value C1 and the id1 C2, a later with the value C2 must also exist."
        },
        {
            "Category": "Definition Whenever",
            "CNL": " whenever there is a next with value C1, and with id1 C2, then there must be an later with value C2.",
            "NL": "Whenever C1 and id1 C2 appear together, there must be an accompanying C2 afterwards."
        },
        {
            "Category": "Definition Whenever",
            "CNL": " whenever there is a next with value C1, and with id1 C2, then there must be an later with value C2.",
            "NL": "Whenever a record with the value C1 and ID C2 appears, there must also be a subsequent record with the value C2."
        },
        {
            "Category": "Definition Whenever",
            "CNL": " whenever there is a next with value C1, and with id1 C2, then there must be an later with value C2.",
            "NL": "Whenever a record is found with the value C1 and ID1 C2, there must also be a subsequent record containing the value C2."
        },
        {
            "Category": "Definition Whenever",
            "CNL": " whenever there is a next with value C1, and with id1 C2, then there must be an later with value C2.",
            "NL": "Whenever C1 and id1 C2 are present together, there must also be a subsequent occurrence of C2."
        },
        {
            "Category": "Definition Whenever",
            "CNL": " Whenever there is a vertex with value V, Whenever there is an obs_vlabel with id1 V, with id2 S, Whenever there is not a trivial with key V, Whenever there is not a input with key V, then we must have a vlabel with id1 V, with id2 S.",
            "NL": "If there is a vertex with a value of V, but there is no trivial with key V, and no input with key V, then there must be an obs_vlabel with id1 V and id2 S."
        },
        {
            "Category": "Definition Whenever",
            "CNL": " Whenever there is a vertex with value V, Whenever there is an obs_vlabel with id1 V, with id2 S, Whenever there is not a trivial with key V, Whenever there is not a input with key V, then we must have a vlabel with id1 V, with id2 S.",
            "NL": "If there is a vertex with the value V, but there is no trivial with the key V or input with the key V, then an obs_vlabel with id1 V and id2 S must be present."
        },
        {
            "Category": "Definition Whenever",
            "CNL": " Whenever there is a vertex with value V, Whenever there is an obs_vlabel with id1 V, with id2 S, Whenever there is not a trivial with key V, Whenever there is not a input with key V, then we must have a vlabel with id1 V, with id2 S.",
            "NL": "If there is no trivial with key V and no input with key V, when a vertex has value V, there must be an obs_vlabel with id1 V and id2 S."
        },
        {
            "Category": "Definition Whenever",
            "CNL": " Whenever there is a vertex with value V, Whenever there is an obs_vlabel with id1 V, with id2 S, Whenever there is not a trivial with key V, Whenever there is not a input with key V, then we must have a vlabel with id1 V, with id2 S.",
            "NL": "If there is a vertex with value V, but no trivial with key V or input with key V, then an obs_vlabel must be present with id1 V and id2 S."
        },
        {
            "Category": "Definition Whenever",
            "CNL": " Whenever there is a vertex with value V, Whenever there is an obs_vlabel with id1 V, with id2 S, Whenever there is not a trivial with key V, Whenever there is not a input with key V, then we must have a vlabel with id1 V, with id2 S.",
            "NL": "If there is a vertex with value V, but no trivial with key V or input with key V, then we must have an obs_vlabel with id1 V and id2 S."
        },
        {
            "Category": "Definition Whenever",
            "CNL": " whenever there is a vertex with value V, whenever there is not a input with value V, whenever there is not a trivial with value V, whenever there is an edge with value W, and with id V, whenever there is an edge with value U greater than W, with id V, whenever there is not an btedge with id1 W, with id2 U, with id3 V, then there must be a ntedge with id1 W, with id2 U, with id3 V.",
            "NL": "If there is a vertex V for which there is no input with value V, no trivial with value V, an edge with value W and id V, and an edge with value U and id V, and no btedge with id1 W, id2 U and id3 V, where W is less than U, then there must be a ntedge with id1 W, id2 U and id3 V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": " whenever there is a vertex with value V, whenever there is not a input with value V, whenever there is not a trivial with value V, whenever there is an edge with value W, and with id V, whenever there is an edge with value U greater than W, with id V, whenever there is not an btedge with id1 W, with id2 U, with id3 V, then there must be a ntedge with id1 W, with id2 U, with id3 V.",
            "NL": "If there is a vertex V, and an edge with value W and id V, along with an edge with value U and id V, where W is less than U, then a ntedge with id1 W, id2 U, and id3 V must exist, and there is no input or trivial with value V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": " whenever there is a vertex with value V, whenever there is not a input with value V, whenever there is not a trivial with value V, whenever there is an edge with value W, and with id V, whenever there is an edge with value U greater than W, with id V, whenever there is not an btedge with id1 W, with id2 U, with id3 V, then there must be a ntedge with id1 W, with id2 U, with id3 V.",
            "NL": "If there is a vertex V and no input has value V, nor a trivial with value V, and an edge with value W, ID V, an edge with value U, ID V, and no btedge with ID1 W, ID2 U, and ID3 V, where W is less than U, then there must be a ntedge with ID1 W, ID2 U, and ID3 V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": " whenever there is a vertex with value V, whenever there is not a input with value V, whenever there is not a trivial with value V, whenever there is an edge with value W, and with id V, whenever there is an edge with value U greater than W, with id V, whenever there is not an btedge with id1 W, with id2 U, with id3 V, then there must be a ntedge with id1 W, with id2 U, with id3 V.",
            "NL": "If there is a vertex V, and the input has no value V, the trivial has no value V, there is an edge with value W and an edge with value U, both with id V, and there is not an btedge with id1 W, id2 U, and id3 V, and W is less than U, then there must be a ntedge with id1 W, id2 U, and id3 V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": " whenever there is a vertex with value V, whenever there is not a input with value V, whenever there is not a trivial with value V, whenever there is an edge with value W, and with id V, whenever there is an edge with value U greater than W, with id V, whenever there is not an btedge with id1 W, with id2 U, with id3 V, then there must be a ntedge with id1 W, with id2 U, with id3 V.",
            "NL": "If there is a vertex V and no input with value V, no trivial with value V, an edge with value W and id V, an edge with value U and id V, and no btedge with id1 W, id2 U, and id3 V, given that W is less than U, then there must be a ntedge with id1 W, id2 U, and id3 V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": " whenever there is a vertex with value V, whenever there is not an input with value V, whenever there is an edge with value U, with id V, whenever there is not an diff with value U, with id V, then there must be a nontriv with value V.",
            "NL": "If there is a vertex V and an edge with value U, and no input with value V, and both the edge's id1 and id2 are the same as the vertex's value V, then there must be a nontrivial value V present."
        },
        {
            "Category": "Definition Whenever",
            "CNL": " whenever there is a vertex with value V, whenever there is not an input with value V, whenever there is an edge with value U, with id V, whenever there is not an diff with value U, with id V, then there must be a nontriv with value V.",
            "NL": "If there is a vertex V, an edge with value U, and inputs with id1 U and id2 V, but no input with value V, then there must exist a non-trivial value V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": " whenever there is a vertex with value V, whenever there is not an input with value V, whenever there is an edge with value U, with id V, whenever there is not an diff with value U, with id V, then there must be a nontriv with value V.",
            "NL": "When there is a vertex V, an edge with value U and an ID V, but no input with value V, there is no distinction between ID1 U and ID2 V, so there must be a non-trivial value V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": " whenever there is a vertex with value V, whenever there is not an input with value V, whenever there is an edge with value U, with id V, whenever there is not an diff with value U, with id V, then there must be a nontriv with value V.",
            "NL": "If there is no input with value V for a vertex V and an edge with value U, where id1 is U and id2 is V, then there must be a non-trivial value V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": " whenever there is a vertex with value V, whenever there is not an input with value V, whenever there is an edge with value U, with id V, whenever there is not an diff with value U, with id V, then there must be a nontriv with value V.",
            "NL": "If there is a vertex V and an edge with value U, which has ids V and U respectively, and no input with value V, then there must be a non-trivial value V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": " whenever there is an edge with value N2, with id N1, whenever there is an in_layer with value L1 less than L2, with id N1, whenever there is an in_layer with value L2, with id N2, then we must have an edge_layer with id1 L1, with id2 L2, with id3 N1, with id4 N2.",
            "NL": "For every edge with value N2 and id N1, there must be an in_layer with value L1 less than L2, and id N1; and for every in_layer with value L2 and id N2, there must be an edge_layer with id1 L1, id2 L2, id3 N1, and id4 N2."
        },
        {
            "Category": "Definition Whenever",
            "CNL": " whenever there is an edge with value N2, with id N1, whenever there is an in_layer with value L1 less than L2, with id N1, whenever there is an in_layer with value L2, with id N2, then we must have an edge_layer with id1 L1, with id2 L2, with id3 N1, with id4 N2.",
            "NL": "Whenever an edge with a value of N2 and an ID of N1 is present, there must be an in_layer with a value of L1 less than L2, and an ID of N1. Additionally, when an in_layer with a value of L2 and an ID of N2 is present, an edge_layer with IDs L1, L2, N1, and N2 must be present."
        },
        {
            "Category": "Definition Whenever",
            "CNL": " whenever there is an edge with value N2, with id N1, whenever there is an in_layer with value L1 less than L2, with id N1, whenever there is an in_layer with value L2, with id N2, then we must have an edge_layer with id1 L1, with id2 L2, with id3 N1, with id4 N2.",
            "NL": "Whenever an edge is present with value N2 and ID N1, there must be an in_layer of value less than L2 with ID N1. Similarly, if an in_layer with value L2 and ID N2 is present, then an edge_layer with ID1 L1, ID2 L2, ID3 N1, and ID4 N2 is required."
        },
        {
            "Category": "Definition Whenever",
            "CNL": " whenever there is an edge with value N2, with id N1, whenever there is an in_layer with value L1 less than L2, with id N1, whenever there is an in_layer with value L2, with id N2, then we must have an edge_layer with id1 L1, with id2 L2, with id3 N1, with id4 N2.",
            "NL": "Whenever an edge with value N2 and id N1 exists, an in_layer with value L1 less than L2 and the same id N1 must be present, and when an in_layer with value L2 and id N2 is present, an edge_layer with id1 L1, id2 L2, id3 N1, and id4 N2 must also be present."
        },
        {
            "Category": "Definition Whenever",
            "CNL": " whenever there is an edge with value N2, with id N1, whenever there is an in_layer with value L1 less than L2, with id N1, whenever there is an in_layer with value L2, with id N2, then we must have an edge_layer with id1 L1, with id2 L2, with id3 N1, with id4 N2.",
            "NL": "For every edge with value N2 and id N1, there must be an in_layer with value L1 less than L2 and the same id N1; likewise, for every in_layer with value L2 and id N2, there must be an edge_layer with ids L1, L2, N1, and N2."
        },
        {
            "Category": "Definition Whenever",
            "CNL": " whenever there is an edge_pair with id1 N1, with id2 N2, with id3 N3, with id4 N4, then we must have a compare with value N1, with id N3. ",
            "NL": "We must compare the value of N1 with that of N3 for every edge_pair with ids N1, N2, N3, and N4."
        },
        {
            "Category": "Definition Whenever",
            "CNL": " whenever there is an edge_pair with id1 N1, with id2 N2, with id3 N3, with id4 N4, then we must have a compare with value N1, with id N3. ",
            "NL": "We must compare the value of N1 with that of N3 for each edge_pair having ids N1, N2, N3, and N4."
        },
        {
            "Category": "Definition Whenever",
            "CNL": " whenever there is an edge_pair with id1 N1, with id2 N2, with id3 N3, with id4 N4, then we must have a compare with value N1, with id N3. ",
            "NL": "We must compare the value of id1 N1 with that of id3 N3 for each edge_pair containing id2 N2 and id4 N4."
        },
        {
            "Category": "Definition Whenever",
            "CNL": " whenever there is an edge_pair with id1 N1, with id2 N2, with id3 N3, with id4 N4, then we must have a compare with value N1, with id N3. ",
            "NL": "We must compare the value of N1 with N3 for each edge_pair having id1 N1, id2 N2, and id4 N4."
        },
        {
            "Category": "Definition Whenever",
            "CNL": " whenever there is an edge_pair with id1 N1, with id2 N2, with id3 N3, with id4 N4, then we must have a compare with value N1, with id N3. ",
            "NL": "We must compare the value of N1 with the id of N3 for each edge pair consisting of id1 N1, id2 N2, id3 N3, and id4 N4."
        },
        {
            "Category": "Definition Whenever",
            "CNL": " whenever there is an obs_elabel with id1 U, with id2 V, with id3 S, whenever there is a edge with value U, with id V, whenever there is a vertex with value W, whenever there is not a trivial with value V, whenever there is not a trivial with value W, whenever there is not an input with value V, whenever there is not an input with value W different from V, then there must be a mllabel with field1 W, with field2 U, with field3 V, with field4 S.",
            "NL": "If the values of U, V, and S are not equal to each other and W is not equal to V, then when there is an obs_elabel with id1 U, id2 V, and id3 S, there must be an edge with value U and id V, a vertex with value W, no trivial with values V or W, no input with values V or W, and a mllabel with field1 W, field2 U, field3 V, and field4 S."
        },
        {
            "Category": "Definition Whenever",
            "CNL": " whenever there is an obs_elabel with id1 U, with id2 V, with id3 S, whenever there is a edge with value U, with id V, whenever there is a vertex with value W, whenever there is not a trivial with value V, whenever there is not a trivial with value W, whenever there is not an input with value V, whenever there is not an input with value W different from V, then there must be a mllabel with field1 W, with field2 U, with field3 V, with field4 S.",
            "NL": "If there is an obs_elabel with id1 U, id2 V, and id3 S, an edge with value U and id V, a vertex with value W, no trivial with either value V or W, no input with either value V or W, and W is not equal to V, then a mllabel must exist with field1 W, field2 U, field3 V, and field4 S."
        },
        {
            "Category": "Definition Whenever",
            "CNL": " whenever there is an obs_elabel with id1 U, with id2 V, with id3 S, whenever there is a edge with value U, with id V, whenever there is a vertex with value W, whenever there is not a trivial with value V, whenever there is not a trivial with value W, whenever there is not an input with value V, whenever there is not an input with value W different from V, then there must be a mllabel with field1 W, with field2 U, with field3 V, with field4 S.",
            "NL": "If an obs_elabel with id1 U, id2 V, and id3 S exists, an edge with value U and id V, a vertex with value W, no trivial with either value V or W, nor any input with either value V or W, where W is not equal to V, then a mllabel with field1 W, field2 U, field3 V, and field4 S must be present."
        },
        {
            "Category": "Definition Whenever",
            "CNL": " whenever there is an obs_elabel with id1 U, with id2 V, with id3 S, whenever there is a edge with value U, with id V, whenever there is a vertex with value W, whenever there is not a trivial with value V, whenever there is not a trivial with value W, whenever there is not an input with value V, whenever there is not an input with value W different from V, then there must be a mllabel with field1 W, with field2 U, with field3 V, with field4 S.",
            "NL": "If there is an obs_elabel with id1 U, id2 V, and id3 S, and W is not equal to V, then there must be an edge with id U and value W, a vertex with value W, no trivial with value V or W, no input with value V or W, and a mllabel with field1 W, field2 U, field3 V, and field4 S."
        },
        {
            "Category": "Definition Whenever",
            "CNL": " whenever there is an obs_elabel with id1 U, with id2 V, with id3 S, whenever there is a edge with value U, with id V, whenever there is a vertex with value W, whenever there is not a trivial with value V, whenever there is not a trivial with value W, whenever there is not an input with value V, whenever there is not an input with value W different from V, then there must be a mllabel with field1 W, with field2 U, with field3 V, with field4 S.",
            "NL": "If there is an obs_elabel with id1 U, id2 V, and id3 S, an edge with value U and id V, a vertex with value W, no trivial with value V or W, no input with value V or W, and W is not equal to V, then there must be a mllabel with field1 W, field2 U, field3 V, and field4 S."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a active with key V, whenever there is coppo with field1 U, with field2 V, whenever there is last with field1 U, with field2 V, then we must have a bot with fake value equal to 1.",
            "NL": "If there is a key V present in an active field, then there should be a coppo with field1 U and field2 V, followed by a last field with field1 U and field2 V, and a bot with a fake value of 1."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a active with key V, whenever there is coppo with field1 U, with field2 V, whenever there is last with field1 U, with field2 V, then we must have a bot with fake value equal to 1.",
            "NL": "If V is an active key, U and V are coppo's fields, U and V are last's fields, the bot must have a fake value of 1."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a active with key V, whenever there is coppo with field1 U, with field2 V, whenever there is last with field1 U, with field2 V, then we must have a bot with fake value equal to 1.",
            "NL": "If there is a key V in an active, Coppo with field1 U and field2 V will be present, likewise Last with field1 U and field2 V will also be present; therefore, a Bot with a fake value of 1 must be included."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a active with key V, whenever there is coppo with field1 U, with field2 V, whenever there is last with field1 U, with field2 V, then we must have a bot with fake value equal to 1.",
            "NL": "If key V is active, Coppo must have field1 U and field2 V, Last must have field1 U and field2 V, and a Bot with fake value of 1 must be present."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a active with key V, whenever there is coppo with field1 U, with field2 V, whenever there is last with field1 U, with field2 V, then we must have a bot with fake value equal to 1.",
            "NL": "If V is active, U and V are present in Coppo and Last respectively, a Bot with a fake value of 1 must be included."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a active with key V, Whenever there is not a trivial with key V, whenever there is an edge with value U, with id V, Whenever there is not a obs_vlabel with id1 U, with id2 P, Whenever there is not a obs_vlabel with id1 U, with id2 M, then we must have a vlable with id1 U, with id2 P or vlabel with id1 U, with id2 M.",
            "NL": "If there is an active with key V, but no trivial with key V, and an edge with value U and id V, but no obs_vlabel with id1 U and id2 P, and no obs_vlabel with id1 U and id2 M, then we must have either a vlabel with id1 U and id2 P or a vlabel with id1 U and id2 M."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a active with key V, Whenever there is not a trivial with key V, whenever there is an edge with value U, with id V, Whenever there is not a obs_vlabel with id1 U, with id2 P, Whenever there is not a obs_vlabel with id1 U, with id2 M, then we must have a vlable with id1 U, with id2 P or vlabel with id1 U, with id2 M.",
            "NL": "If there is an active with key V, but no trivial with key V, and an edge with value U, and id V, and no obs_vlabel with id1 U, and id2 P, and no obs_vlabel with id1 U, and id2 M, then there must be either a vlabel with id1 U, and id2 P, or a vlabel with id1 U, and id2 M."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a active with key V, Whenever there is not a trivial with key V, whenever there is an edge with value U, with id V, Whenever there is not a obs_vlabel with id1 U, with id2 P, Whenever there is not a obs_vlabel with id1 U, with id2 M, then we must have a vlable with id1 U, with id2 P or vlabel with id1 U, with id2 M.",
            "NL": "If there is an active with key V, but not a trivial with key V, and an edge with value U and id V, but no obs_vlabel with id1 U and id2 P, or obs_vlabel with id1 U and id2 M, then there must be either a vlabel with id1 U and id2 P, or a vlabel with id1 U and id2 M."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a active with key V, Whenever there is not a trivial with key V, whenever there is an edge with value U, with id V, Whenever there is not a obs_vlabel with id1 U, with id2 P, Whenever there is not a obs_vlabel with id1 U, with id2 M, then we must have a vlable with id1 U, with id2 P or vlabel with id1 U, with id2 M.",
            "NL": "If there is an active with key V, but no trivial with key V, an edge with value U and id V, but no obs_vlabel with id1 U and id2 P, and no obs_vlabel with id1 U and id2 M, then we must have either a vlabel with id1 U, id2 P or a vlabel with id1 U, id2 M."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a active with key V, Whenever there is not a trivial with key V, whenever there is an edge with value U, with id V, Whenever there is not a obs_vlabel with id1 U, with id2 P, Whenever there is not a obs_vlabel with id1 U, with id2 M, then we must have a vlable with id1 U, with id2 P or vlabel with id1 U, with id2 M.",
            "NL": "Whenever there is an active with key V, there is no trivial with key V, and an edge with value U and id V, and no obs_vlabel with id1 U and id2 P, and no obs_vlabel with id1 U and id2 M, then we must have either a vlabel with id1 U and id2 P or a vlabel with id1 U and id2 M."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a active with key V, Whenever there is not a trivial with key V, Whenever there is not a obs_vlabel with id1 V, with id2 P, Whenever there is not a obs_vlabel with id1 V, with id2 M, then we must have a vlable with id1 V, with id2 P or vlabel with id1 V, with id2 M. ",
            "NL": "If there is an active key V, no trivial key V, no obs_vlabel with id1 V and id2 P, and no obs_vlabel with id1 V and id2 M, then a vlabel with id1 V and either id2 P or id2 M must be present."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a active with key V, Whenever there is not a trivial with key V, Whenever there is not a obs_vlabel with id1 V, with id2 P, Whenever there is not a obs_vlabel with id1 V, with id2 M, then we must have a vlable with id1 V, with id2 P or vlabel with id1 V, with id2 M. ",
            "NL": "If there is an active with key V, but no trivial with key V, no obs_vlabel with id1 V and id2 P, and no obs_vlabel with id1 V and id2 M, then either a vlable with id1 V and id2 P or a vlabel with id1 V and id2 M must exist."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a active with key V, Whenever there is not a trivial with key V, Whenever there is not a obs_vlabel with id1 V, with id2 P, Whenever there is not a obs_vlabel with id1 V, with id2 M, then we must have a vlable with id1 V, with id2 P or vlabel with id1 V, with id2 M. ",
            "NL": "If there is an active vlabel with key V, there cannot be a trivial vlabel with key V, an obs_vlabel with id1 V and id2 P, or an obs_vlabel with id1 V and id2 M; in this case, we must have either a vlabel with id1 V and id2 P or a vlabel with id1 V and id2 M."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a active with key V, Whenever there is not a trivial with key V, Whenever there is not a obs_vlabel with id1 V, with id2 P, Whenever there is not a obs_vlabel with id1 V, with id2 M, then we must have a vlable with id1 V, with id2 P or vlabel with id1 V, with id2 M. ",
            "NL": "If there is an active with key V, but no trivial with key V, no obs_vlabel with id1 V and id2 P, and no obs_vlabel with id1 V and id2 M, then we must have either a vlabel with id1 V and id2 P, or a vlabel with id1 V and id2 M."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a active with key V, Whenever there is not a trivial with key V, Whenever there is not a obs_vlabel with id1 V, with id2 P, Whenever there is not a obs_vlabel with id1 V, with id2 M, then we must have a vlable with id1 V, with id2 P or vlabel with id1 V, with id2 M. ",
            "NL": "If there is an active vlabel with key V, there must be either a vlabel with id1 V and id2 P or a vlabel with id1 V and id2 M, but not both a trivial vlabel with key V or an obs_vlabel with id1 V, id2 P and id2 M."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a Additional with edge8 U, with id4 V, Whenever there is a Maximum with value1 I, with edge I, Whenever there is not a Incorporates with key5 V, Whenever there is not a Weighted_Graph with key5 V, then we must have a Check with value1 I, with edge I. ",
            "NL": "If there is an Additional with edge8 U and id4 V, then there must be a Maximum with value1 I and edge I, but there is no Incorporates with key5 V or Weighted_Graph with key5 V, so a Check with value1 I and edge I is required."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a Additional with edge8 U, with id4 V, Whenever there is a Maximum with value1 I, with edge I, Whenever there is not a Incorporates with key5 V, Whenever there is not a Weighted_Graph with key5 V, then we must have a Check with value1 I, with edge I. ",
            "NL": "If there is an Additional with edge8 U and id4 V, then we must have a Maximum with value1 I and edge I, but there is no Incorporates with key5 V or Weighted_Graph with key5 V, so a Check with value1 I and edge I must be present."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a Additional with edge8 U, with id4 V, Whenever there is a Maximum with value1 I, with edge I, Whenever there is not a Incorporates with key5 V, Whenever there is not a Weighted_Graph with key5 V, then we must have a Check with value1 I, with edge I. ",
            "NL": "In the case where there is an Additional with edge8 U and id4 V, there is a Maximum with value1 I and edge I, but no Incorporates with key5 V or Weighted_Graph with key5 V, we must have a Check with value1 I and edge I."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a Additional with edge8 U, with id4 V, Whenever there is a Maximum with value1 I, with edge I, Whenever there is not a Incorporates with key5 V, Whenever there is not a Weighted_Graph with key5 V, then we must have a Check with value1 I, with edge I. ",
            "NL": "Whenever there is an edge8 U with id4 V, there is a Maximum with value1 I and edge I, however, there is no Incorporates with key5 V nor Weighted_Graph with key5 V, then we must have a Check with value1 I and edge I."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a Additional with edge8 U, with id4 V, Whenever there is a Maximum with value1 I, with edge I, Whenever there is not a Incorporates with key5 V, Whenever there is not a Weighted_Graph with key5 V, then we must have a Check with value1 I, with edge I. ",
            "NL": "If there is an Additional with edge8 U and id4 V, then there must be a Maximum with value1 I and edge I, but there is no Incorporates with key5 V or Weighted_Graph with key5 V, so a Check with value1 I and edge I needs to be present."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a arc with first vtx X, with second vtx Y, whenever there is a reached with first vtx X, then we must have an in_hm with id1 X, with id2 Y or out_hm with first vtx X, with second vtx Y.",
            "NL": "Whenever there is an arc with first vertex X and second vertex Y, there must be either an in_hm with id X and id Y or an out_hm with first vertex X and second vertex Y."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a arc with first vtx X, with second vtx Y, whenever there is a reached with first vtx X, then we must have an in_hm with id1 X, with id2 Y or out_hm with first vtx X, with second vtx Y.",
            "NL": "Whenever there is an arc with X as its first vertex and Y as its second vertex, there must either be an in_hm with X and Y as their respective IDs or an out_hm with X as its first vertex and Y as its second vertex."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a arc with first vtx X, with second vtx Y, whenever there is a reached with first vtx X, then we must have an in_hm with id1 X, with id2 Y or out_hm with first vtx X, with second vtx Y.",
            "NL": "Whenever there is an arc connecting vertex X to vertex Y, there must either be an in_hm with ids X and Y, or an out_hm with vertices X and Y."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a arc with first vtx X, with second vtx Y, whenever there is a reached with first vtx X, then we must have an in_hm with id1 X, with id2 Y or out_hm with first vtx X, with second vtx Y.",
            "NL": "Whenever there is an arc connecting vertex X to vertex Y, there must be either an in_hm with ID X and ID Y or an out_hm with vertex X and vertex Y."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a arc with first vtx X, with second vtx Y, whenever there is a reached with first vtx X, then we must have an in_hm with id1 X, with id2 Y or out_hm with first vtx X, with second vtx Y.",
            "NL": "Whenever an arc is created with vertex X as the first vertex and Y as the second vertex, there must be either an in_hm with IDs X and Y or an out_hm with X as the first vertex and Y as the second vertex."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a Augmenting_Path with vtx2 K, whenever there is Name with vtx8 Q, with id10 L, whenever there is Foremost with vtx8 Q, with id10 L, then we must have an OutgoingRoute with third id equal to 14.",
            "NL": "Whenever there is an Augmenting Path containing vertex K, Name containing vertex Q with id L, and Foremost containing vertex Q with id L, then the third id of the OutgoingRoute must be equal to 14."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a Augmenting_Path with vtx2 K, whenever there is Name with vtx8 Q, with id10 L, whenever there is Foremost with vtx8 Q, with id10 L, then we must have an OutgoingRoute with third id equal to 14.",
            "NL": "If there is an Augmenting_Path which has vertex 2 K, Name with vertex 8 Q and id 10 L, and Foremost with vertex 8 Q and id 10 L, then there must be an OutgoingRoute with third id equal to 14."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a Augmenting_Path with vtx2 K, whenever there is Name with vtx8 Q, with id10 L, whenever there is Foremost with vtx8 Q, with id10 L, then we must have an OutgoingRoute with third id equal to 14.",
            "NL": "If there exists an Augmenting_Path with vertex2 K, Name with vertex8 Q, and id10 L, as well as Foremost with vertex8 Q, and id10 L, then the third id of the OutgoingRoute must be 14."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a Augmenting_Path with vtx2 K, whenever there is Name with vtx8 Q, with id10 L, whenever there is Foremost with vtx8 Q, with id10 L, then we must have an OutgoingRoute with third id equal to 14.",
            "NL": "If there is an Augmenting Path with vertex 2 K, Name with vertex 8 Q and ID 10 L, and Foremost with vertex 8 Q and ID 10 L, then the Third ID for the Outgoing Route must be 14."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a Augmenting_Path with vtx2 K, whenever there is Name with vtx8 Q, with id10 L, whenever there is Foremost with vtx8 Q, with id10 L, then we must have an OutgoingRoute with third id equal to 14.",
            "NL": "Whenever there is an Augmenting_Path with vertex 2 (K), Name with vertex 8 (Q) and ID 10 (L), and Foremost with vertex 8 (Q) and ID 10 (L), then there must be an OutgoingRoute with Third ID equal to 14."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a Basic with value7 J, Whenever there is not a Cut_Vertex with value7 J, whenever there is a Valency with id1 J, with key2 J, Whenever there is not a Intersect with value3 J, with id8 J, with field1 S, Whenever there is not a Intersect with value3 J, with id8 J, with field1 D, then we must have a Complex with field3 J, with field2 J, with field3 S or Complex with field3 J, with vtx9 J, with id9 D.",
            "NL": "If there is a Basic with value7 J, but not a Cut_Vertex with value7 J, as well as a Valency with id1 J and key2 J, and no Intersect with value3 J, id8 J, and field1 S, or Intersect with value3 J, id8 J, and field1 D, then we must have either a Complex with field3 J, vtx9 J, and id9 S, or a Complex with field3 J, vtx9 J, and id9 D."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a Basic with value7 J, Whenever there is not a Cut_Vertex with value7 J, whenever there is a Valency with id1 J, with key2 J, Whenever there is not a Intersect with value3 J, with id8 J, with field1 S, Whenever there is not a Intersect with value3 J, with id8 J, with field1 D, then we must have a Complex with field3 J, with field2 J, with field3 S or Complex with field3 J, with vtx9 J, with id9 D.",
            "NL": "If there is a Basic with value7 J, but not a Cut_Vertex with value7 J, and Valency with id1 J and key2 J, but not a Intersect with value3 J, id8 J, and field1 S, and not a Intersect with value3 J, id8 J, and field1 D, then either a Complex with field3 J, vtx9 J, and id9 S or a Complex with field3 J, vtx9 J, and id9 D must exist."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a Basic with value7 J, Whenever there is not a Cut_Vertex with value7 J, whenever there is a Valency with id1 J, with key2 J, Whenever there is not a Intersect with value3 J, with id8 J, with field1 S, Whenever there is not a Intersect with value3 J, with id8 J, with field1 D, then we must have a Complex with field3 J, with field2 J, with field3 S or Complex with field3 J, with vtx9 J, with id9 D.",
            "NL": "If Basic has a value of 7 J, Cut_Vertex does not have a value of 7 J, and Valency has an id of 1 J and a key of 2 J, but Intersect does not have a value of 3 J, id of 8 J, or field1 of S, and Intersect does not have a value of 3 J, an id of 8 J, or field1 of D, then Complex must have a field3 of J, vtx9 of J, and either id9 of S or id9 of D."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a Basic with value7 J, Whenever there is not a Cut_Vertex with value7 J, whenever there is a Valency with id1 J, with key2 J, Whenever there is not a Intersect with value3 J, with id8 J, with field1 S, Whenever there is not a Intersect with value3 J, with id8 J, with field1 D, then we must have a Complex with field3 J, with field2 J, with field3 S or Complex with field3 J, with vtx9 J, with id9 D.",
            "NL": "If value7 J is present in a Basic, Cut_Vertex with value7 J is absent, Valency with id1 J and key2 J is present, Intersect with value3 J, id8 J, and field1 S is absent, and Intersect with value3 J, id8 J, and field1 D is absent, then either a Complex with field3 J, vtx9 J, and id9 S or a Complex with field3 J, vtx9 J, and id9 D must be present."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a Basic with value7 J, Whenever there is not a Cut_Vertex with value7 J, whenever there is a Valency with id1 J, with key2 J, Whenever there is not a Intersect with value3 J, with id8 J, with field1 S, Whenever there is not a Intersect with value3 J, with id8 J, with field1 D, then we must have a Complex with field3 J, with field2 J, with field3 S or Complex with field3 J, with vtx9 J, with id9 D.",
            "NL": "If there is a Basic with a value of 7 J, there is not a Cut_Vertex with a value of 7 J, there is a Valency with an id of 1 J and a key of 2 J, there is not an Intersect with a value of 3 J, an id of 8 J, and a field of S, and there is not an Intersect with a value of 3 J, an id of 8 J, and a field of D, then we must have either a Complex with a field of 3 J, a vtx of 9 J, and an id of 9 S or a Complex with a field of 3 J, a vtx of 9 J, and an id of 9 D."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a bot with fake value equal to 1, whenever there is a vertex with value V, whenever there is a sign with value S, whenever there is not a trivial with key V, Whenever there is not a input with key V, whenever there is not a obs_vlabel with id1 V, with id2 P, whenever there is not a obs_vlabel with id1 V, with id2 M, then we must have a vlabel with id1 V, with id2 S. ",
            "NL": "Whenever a bot has a fake value of 1, there must be a vertex with value V; if there is a sign with value S, there is no trivial with key V and no input with key V; if there is not an obs_vlabel with id1 V and id2 P, and not an obs_vlabel with id1 V and id2 M, then there must be a vlabel with id1 V and id2 S."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a bot with fake value equal to 1, whenever there is a vertex with value V, whenever there is a sign with value S, whenever there is not a trivial with key V, Whenever there is not a input with key V, whenever there is not a obs_vlabel with id1 V, with id2 P, whenever there is not a obs_vlabel with id1 V, with id2 M, then we must have a vlabel with id1 V, with id2 S. ",
            "NL": "If there is a bot with a fake value of 1, a vertex with value V, a sign with value S, and no trivial with key V or input with key V, and no obs_vlabel with id1 V and id2 P or id1 V and id2 M, then a vlabel with id1 V and id2 S must be present."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a bot with fake value equal to 1, whenever there is a vertex with value V, whenever there is a sign with value S, whenever there is not a trivial with key V, Whenever there is not a input with key V, whenever there is not a obs_vlabel with id1 V, with id2 P, whenever there is not a obs_vlabel with id1 V, with id2 M, then we must have a vlabel with id1 V, with id2 S. ",
            "NL": "If a bot has a phony value of 1, there should be a vertex with value V; if a sign has a value of S, there should not be a trivial with key V and no input with key V; and if there is not an obs_vlabel with id1 V and id2 P, and there is not an obs_vlabel with id1 V and id2 M, then we need to have a vlabel with id1 V and id2 S."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a bot with fake value equal to 1, whenever there is a vertex with value V, whenever there is a sign with value S, whenever there is not a trivial with key V, Whenever there is not a input with key V, whenever there is not a obs_vlabel with id1 V, with id2 P, whenever there is not a obs_vlabel with id1 V, with id2 M, then we must have a vlabel with id1 V, with id2 S. ",
            "NL": "If there is a bot with a fake value equal to 1, a vertex with value V, a sign with value S, but no trivial with key V, no input with key V, no obs_vlabel with id1 V, id2 P, and no obs_vlabel with id1 V, id2 M, then a vlabel with id1 V, id2 S must be present."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a bot with fake value equal to 1, whenever there is a vertex with value V, whenever there is a sign with value S, whenever there is not a trivial with key V, Whenever there is not a input with key V, whenever there is not a obs_vlabel with id1 V, with id2 P, whenever there is not a obs_vlabel with id1 V, with id2 M, then we must have a vlabel with id1 V, with id2 S. ",
            "NL": "If a bot has a fake value of 1, there must be a vertex with value V; when a sign has value S, there is no trivial with key V and no input with key V; if there is no obs_vlabel with id1 V and id2 P, and no obs_vlabel with id1 V and id2 M, then a vlabel with id1 V and id2 S must be present."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a bot with fake value equal to 1, whenever there is an edge with value U, with id V, whenever there is a sign with value S, whenever there is not a trivial with key V, Whenever there is not a input with key V, whenever there is not a obs_vlabel with id1 U, with id2 P, whenever there is not a obs_vlabel with id1 U, with id2 M, then we must have a vlabel with id1 U, with id2 S. ",
            "NL": "If there is a bot with a fake value of 1, an edge with value U and id V, a sign with value S, no trivial with key V, no input with key V, no obs_vlabel with id1 U and id2 P, and no obs_vlabel with id1 U and id2 M, then a vlabel with id1 U and id2 S must be present."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a bot with fake value equal to 1, whenever there is an edge with value U, with id V, whenever there is a sign with value S, whenever there is not a trivial with key V, Whenever there is not a input with key V, whenever there is not a obs_vlabel with id1 U, with id2 P, whenever there is not a obs_vlabel with id1 U, with id2 M, then we must have a vlabel with id1 U, with id2 S. ",
            "NL": "If a bot has a fake value of 1, an edge with value U and id V, a sign with value S, no trivial with key V, no input with key V, no obs_vlabel with id1 U and id2 P, and no obs_vlabel with id1 U and id2 M, then a vlabel must be present with id1 U and id2 S."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a bot with fake value equal to 1, whenever there is an edge with value U, with id V, whenever there is a sign with value S, whenever there is not a trivial with key V, Whenever there is not a input with key V, whenever there is not a obs_vlabel with id1 U, with id2 P, whenever there is not a obs_vlabel with id1 U, with id2 M, then we must have a vlabel with id1 U, with id2 S. ",
            "NL": "If there is a bot with a fake value set to 1, an edge with value U and id V, a sign with value S, no trivial with key V, no input with key V, no obs_vlabel with id1 U and id2 P, and no obs_vlabel with id1 U and id2 M, then we must have a vlabel with id1 U and id2 S."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a bot with fake value equal to 1, whenever there is an edge with value U, with id V, whenever there is a sign with value S, whenever there is not a trivial with key V, Whenever there is not a input with key V, whenever there is not a obs_vlabel with id1 U, with id2 P, whenever there is not a obs_vlabel with id1 U, with id2 M, then we must have a vlabel with id1 U, with id2 S. ",
            "NL": "If a bot has a false value of 1, an edge with value U and id V, a sign with value S, no trivial with key V, no input with key V, no obs_vlabel with id1 U and id2 P, and no obs_vlabel with id1 U and id2 M, then we must have a vlabel with id1 U and id2 S."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a bot with fake value equal to 1, whenever there is an edge with value U, with id V, whenever there is a sign with value S, whenever there is not a trivial with key V, Whenever there is not a input with key V, whenever there is not a obs_vlabel with id1 U, with id2 P, whenever there is not a obs_vlabel with id1 U, with id2 M, then we must have a vlabel with id1 U, with id2 S. ",
            "NL": "If there is a bot with a fake value of 1, an edge with value U and id V, a sign with value S, no trivial with key V, no input with key V, no obs_vlabel with id1 U and id2 P, and no obs_vlabel with id1 U and id2 M, then there must be a vlabel with id1 U and id2 S."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a bot with fake value equal to 1, whenever there is an edge with value U, with id V, whenever there is a sign with value S, whenever there is not a trivial with key V, Whenever there is not a input with key V, whenever there is not a obs_elabel with id1 U, with id2 V, with id3 P, whenever there is not a obs_elabel with id1 U, with id2 V, with id3 M, then we must have a llabel with field1 U, with field2 V, with field3 S. ",
            "NL": "If a bot has a fake value of 1, an edge with value U and id V, a sign with value S, no trivial with key V, no input with key V, no obs_elabel with id1 U, id2 V, and id3 P, and no obs_elabel with id1 U, id2 V, and id3 M, then a llabel with field1 U, field2 V, and field3 S must exist."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a bot with fake value equal to 1, whenever there is an edge with value U, with id V, whenever there is a sign with value S, whenever there is not a trivial with key V, Whenever there is not a input with key V, whenever there is not a obs_elabel with id1 U, with id2 V, with id3 P, whenever there is not a obs_elabel with id1 U, with id2 V, with id3 M, then we must have a llabel with field1 U, with field2 V, with field3 S. ",
            "NL": "If there is not a bot with a fake value of 1, an edge with value U and id V, a sign with value S, a trivial with key V, an input with key V, an obs_elabel with id1 U, id2 V, and id3 P, and an obs_elabel with id1 U, id2 V, and id3 M, then it is necessary to have a llabel with field1 U, field2 V, and field3 S."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a bot with fake value equal to 1, whenever there is an edge with value U, with id V, whenever there is a sign with value S, whenever there is not a trivial with key V, Whenever there is not a input with key V, whenever there is not a obs_elabel with id1 U, with id2 V, with id3 P, whenever there is not a obs_elabel with id1 U, with id2 V, with id3 M, then we must have a llabel with field1 U, with field2 V, with field3 S. ",
            "NL": "If there is not an obs_elabel with id1 U, id2 V, and id3 P, or an obs_elabel with id1 U, id2 V, and id3 M, and there is a bot with a fake value of 1, an edge with value U and id V, a sign with value S, no trivial with key V, and no input with key V, then we must have a llabel with field1 U, field2 V, and field3 S."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a bot with fake value equal to 1, whenever there is an edge with value U, with id V, whenever there is a sign with value S, whenever there is not a trivial with key V, Whenever there is not a input with key V, whenever there is not a obs_elabel with id1 U, with id2 V, with id3 P, whenever there is not a obs_elabel with id1 U, with id2 V, with id3 M, then we must have a llabel with field1 U, with field2 V, with field3 S. ",
            "NL": "If there is no bot with a fake value of 1, no edge with value U and id V, no sign with value S, a trivial with key V, an input with key V, an obs_elabel with id1 U, id2 V, and id3 P, and another obs_elabel with id1 U, id2 V, and id3 M, then there must be a llabel with field1 U, field2 V, and field3 S."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a bot with fake value equal to 1, whenever there is an edge with value U, with id V, whenever there is a sign with value S, whenever there is not a trivial with key V, Whenever there is not a input with key V, whenever there is not a obs_elabel with id1 U, with id2 V, with id3 P, whenever there is not a obs_elabel with id1 U, with id2 V, with id3 M, then we must have a llabel with field1 U, with field2 V, with field3 S. ",
            "NL": "If there is not a bot with a fake value equal to 1, no edge with value U and id V, no sign with value S, a trivial with key V, an input with key V, an obs_elabel with id1 U, id2 V, and id3 P, and an obs_elabel with id1 U, id2 V, and id3 M, then we must have a llabel with field1 U, field2 V, and field3 S."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a Centrality F, whenever there is a Calculation F then there must be a Painted with fake value equal to 11. ",
            "NL": "If Centrality F and Calculation F are present, then the fake value must be painted as 11."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a Centrality F, whenever there is a Calculation F then there must be a Painted with fake value equal to 11. ",
            "NL": "Whenever Centrality F and Calculation F are present, a fake value of 11 must be depicted."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a Centrality F, whenever there is a Calculation F then there must be a Painted with fake value equal to 11. ",
            "NL": "If Centrality F and Calculation F are present, the fake value must be 11 painted on it."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a Centrality F, whenever there is a Calculation F then there must be a Painted with fake value equal to 11. ",
            "NL": "Whenever Centrality F and Calculation F are both present, the fake value must be painted as 11."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a Centrality F, whenever there is a Calculation F then there must be a Painted with fake value equal to 11. ",
            "NL": "Whenever Centrality F and Calculation F exist, a fake value of 11 must be Painted."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a ChosenColour with value N, with id1 CC different from C, whenever there is index with value C, and with id1 I less than or equal to N, then there must be an notchosenColour with value N, with id1 C.",
            "NL": "If the index I is less than or equal to the chosencolour value N and the index C is not equal to the chosencolour id1 CC, then there can be no chosencolour with value N and id1 C."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a ChosenColour with value N, with id1 CC different from C, whenever there is index with value C, and with id1 I less than or equal to N, then there must be an notchosenColour with value N, with id1 C.",
            "NL": "If there is a chosen colour with value N, ID1 CC, and an index with value C and ID1 I, where I is less than or equal to N and C is not equal to CC, then there cannot be a chosen colour with value N and ID1 C."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a ChosenColour with value N, with id1 CC different from C, whenever there is index with value C, and with id1 I less than or equal to N, then there must be an notchosenColour with value N, with id1 C.",
            "NL": "If the index value C does not equal the chosencolour value CC, and I is less than or equal to N, there cannot be a chosencolour with value N and id1 C."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a ChosenColour with value N, with id1 CC different from C, whenever there is index with value C, and with id1 I less than or equal to N, then there must be an notchosenColour with value N, with id1 C.",
            "NL": "If there is a chosencolour with value N, id1 CC, an index with value C, and id1 I, where I is less than or equal to N and C is not equal to CC, then there cannot be any chosencolour with value N and id1 C."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a ChosenColour with value N, with id1 CC different from C, whenever there is index with value C, and with id1 I less than or equal to N, then there must be an notchosenColour with value N, with id1 C.",
            "NL": "If there is a chosen colour with value N, ID1 CC, an index with value C, and ID1 I, where I is less than or equal to N and C is not equal to CC, there cannot be a chosen colour with value N and ID1 C."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a Circuit with first node D, and with second point I then we must have a Remaining with first node D, and with second point I.",
            "NL": "When there is a Circuit connecting the first node D and the second point I, there must be a Remaining link between the first node D and the second point I."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a Circuit with first node D, and with second point I then we must have a Remaining with first node D, and with second point I.",
            "NL": "If there is a Circuit connecting the first node D and the second point I, there must be a Resistance between the first node D and the second point I."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a Circuit with first node D, and with second point I then we must have a Remaining with first node D, and with second point I.",
            "NL": "If there is a Circuit between Node D and Point I, there must be a Remaining between them."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a Circuit with first node D, and with second point I then we must have a Remaining with first node D, and with second point I.",
            "NL": "If there is a Circuit connecting Node D to Point I, there must be a Remaining between them."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a Circuit with first node D, and with second point I then we must have a Remaining with first node D, and with second point I.",
            "NL": "When there is a Circuit connecting the first node D and the second point I, there must be a Resistance between the first node D and the second point I."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a Clue with vtx2 I at most W, with key5 W, then we must have a Tone with vtx2 I, with key5 W.",
            "NL": "Whenever there is a Clue with vtx2 I and key5 W where I is not more than W, we must Tone it with vtx2 I and key5 W."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a Clue with vtx2 I at most W, with key5 W, then we must have a Tone with vtx2 I, with key5 W.",
            "NL": "Whenever Clue vtx2 I and key5 W are present where I is not greater than W, we must Tone it with vtx2 I and key5 W."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a Clue with vtx2 I at most W, with key5 W, then we must have a Tone with vtx2 I, with key5 W.",
            "NL": "Whenever Clue vtx2 I and key5 W are present, and the I is less than or equal to W, we must Tone it with vtx2 I and key5 W."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a Clue with vtx2 I at most W, with key5 W, then we must have a Tone with vtx2 I, with key5 W.",
            "NL": "If Clue with vtx2 I and key5 W has I at the most W, we ought to Tone it with vtx2 I and key5 W."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a Clue with vtx2 I at most W, with key5 W, then we must have a Tone with vtx2 I, with key5 W.",
            "NL": "Whenever Clue is accompanied by vtx2 I and key5 W, and I is no greater than W, we should Tone it using vtx2 I and key5 W."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a colour with value C1, whenever there is not an later with value C1, then there must be an index with value C1 , with id1 equal to 1.",
            "NL": "If C1 is the value of a color and there is no subsequent color with the same value, there must be an index with the value of C1 such that id1 is equal to 1."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a colour with value C1, whenever there is not an later with value C1, then there must be an index with value C1 , with id1 equal to 1.",
            "NL": "If C1 is the value of a certain color and there is no later color that has the same value for C1, then an index with value C1 must exist, with id1 equal to 1."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a colour with value C1, whenever there is not an later with value C1, then there must be an index with value C1 , with id1 equal to 1.",
            "NL": "If C1 is the value of a given color and no later color has the same value for C1, then an index must exist with a value of C1, wherein id1 is equal to 1."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a colour with value C1, whenever there is not an later with value C1, then there must be an index with value C1 , with id1 equal to 1.",
            "NL": "If there is a colour with value C1 and no later colour has the same value, then an index must exist with C1 as its value, and id1 must be equal to 1."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a colour with value C1, whenever there is not an later with value C1, then there must be an index with value C1 , with id1 equal to 1.",
            "NL": "If C1 is the value of a certain colour and there is no other colour that has the same value, then an index with value C1 must exist, and id1 must be 1."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a colours with value C1, and with id1 C2, whenever there is a colours with value C2, and with id1 C3, then we must have a notnext with value C1 , with id1 C3. ",
            "NL": "Whenever the colours have values C1 (with id1 C2) and C2 (with id1 C3), then a notnext of value C1 and id1 C3 must be present."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a colours with value C1, and with id1 C2, whenever there is a colours with value C2, and with id1 C3, then we must have a notnext with value C1 , with id1 C3. ",
            "NL": "If we have colours with value C1, identified as C2, and colours with value C2, identified as C3, then the notnext must have a value of C1 and an id of C3."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a colours with value C1, and with id1 C2, whenever there is a colours with value C2, and with id1 C3, then we must have a notnext with value C1 , with id1 C3. ",
            "NL": "If there are colors with value C1, identified by C2, and colors with value C2, identified by C3, then there must be a notnext with value C1 and id1 C3."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a colours with value C1, and with id1 C2, whenever there is a colours with value C2, and with id1 C3, then we must have a notnext with value C1 , with id1 C3. ",
            "NL": "If there is a colour with a value of C1 and ID1 C2, as well as another colour with a value of C2 and ID1 C3, then there must be a notnext with a value of C1 and ID1 C3."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a colours with value C1, and with id1 C2, whenever there is a colours with value C2, and with id1 C3, then we must have a notnext with value C1 , with id1 C3. ",
            "NL": "If there are colors with a value of C1 and an ID of C2, as well as colors with a value of C2 and an ID of C3, then we need to have a notnext with a value of C1 and an ID of C3."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a compare with value N1, with id N2, whenever there is a gt with id1 L, with id2 N2, with id3 P, whenever there is not a gt with id1 L, with id2 N1, with id3 P, then we must have a inorder with value N1, with id N2.",
            "NL": "If there is no GT with id1 L, id2 N1, and id3 P, then an inorder with value N1 and id N2 should be present whenever there is a compare with value N1 and id N2."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a compare with value N1, with id N2, whenever there is a gt with id1 L, with id2 N2, with id3 P, whenever there is not a gt with id1 L, with id2 N1, with id3 P, then we must have a inorder with value N1, with id N2.",
            "NL": "In the event that there is no GT with id1 L, id2 N1, and id3 P, an inorder with value N1 and id N2 must be present when there is a compare with value N1 and id N2, alongside a GT with id1 L, id2 N2, and id3 P."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a compare with value N1, with id N2, whenever there is a gt with id1 L, with id2 N2, with id3 P, whenever there is not a gt with id1 L, with id2 N1, with id3 P, then we must have a inorder with value N1, with id N2.",
            "NL": "If there is no GT with id1 L, id2 N1, and id3 P, then an inorder with value N1 and id N2 must be present whenever there is a compare with value N1 and id N2."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a compare with value N1, with id N2, whenever there is a gt with id1 L, with id2 N2, with id3 P, whenever there is not a gt with id1 L, with id2 N1, with id3 P, then we must have a inorder with value N1, with id N2.",
            "NL": "If there is no GT with id1 L, id2 N1, and id3 P, then when there is a compare with value N1 and id N2, there must be an inorder with the same value N1 and id N2."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a compare with value N1, with id N2, whenever there is a gt with id1 L, with id2 N2, with id3 P, whenever there is not a gt with id1 L, with id2 N1, with id3 P, then we must have a inorder with value N1, with id N2.",
            "NL": "Whenever there is a comparison of value N1 with id N2, and there is no GT with id1 L, id2 N1, and id3 P, then an inorder with value N1 and id N2 must be created."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a Complex with value8 V, with id2 A, Whenever there is a Pigmented with key4 U, with field7 U, Whenever there is not a Incidence with key6 A, Whenever there is not a Mark with key6 A, then we must have a Trail with key4 U, with field7 U. ",
            "NL": "If there is a Complex with value 8V and id 2A, a Pigmented with key 4U and field 7U, but no Incidence with key 6A or Mark with key 6A, then we must have a Trail with key 4U and field 7U."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a Complex with value8 V, with id2 A, Whenever there is a Pigmented with key4 U, with field7 U, Whenever there is not a Incidence with key6 A, Whenever there is not a Mark with key6 A, then we must have a Trail with key4 U, with field7 U. ",
            "NL": "If there is a Complex with value8 V and id2 A, then we must have a Pigmented with key4 U and field7 U, but not an Incidence with key6 A nor a Mark with key6 A; instead, there must be a Trail with key4 U and field7 U."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a Complex with value8 V, with id2 A, Whenever there is a Pigmented with key4 U, with field7 U, Whenever there is not a Incidence with key6 A, Whenever there is not a Mark with key6 A, then we must have a Trail with key4 U, with field7 U. ",
            "NL": "If there is a Complex with a value of 8 V and an id of 2 A, then there must be a Pigmented with a key of 4 U and a field of 7 U; however, there is no Incidence with a key of 6 A nor Mark with a key of 6 A, but instead we must have a Trail with a key of 4 U and a field of 7 U."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a Complex with value8 V, with id2 A, Whenever there is a Pigmented with key4 U, with field7 U, Whenever there is not a Incidence with key6 A, Whenever there is not a Mark with key6 A, then we must have a Trail with key4 U, with field7 U. ",
            "NL": "If there is a Complex with a value of 8 V and an ID of 2 A, then there must be a Pigmented with a key of 4 U and a field of 7 U; however, there will not be an Incidence with a key of 6 A or a Mark with a key of 6 A, but rather a Trail with a key of 4 U and a field of 7 U."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a Complex with value8 V, with id2 A, Whenever there is a Pigmented with key4 U, with field7 U, Whenever there is not a Incidence with key6 A, Whenever there is not a Mark with key6 A, then we must have a Trail with key4 U, with field7 U. ",
            "NL": "If there is a Complex with value 8 V and id 2 A, a Pigmented with key 4 U and field 7 U, but no Incidence with key 6 A or Mark with key 6 A, then a Trail with key 4 U and field 7 U must be present."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a Container with id1 T, with key A, whenever there is an Adjacency_Matrix with field5 W, with id8 A, with id7 H, whenever there is not a Adjacency_Matrix with field5 W, with id8 T, with id7 H, then we must have a Vertex with id1 T, with key A.",
            "NL": "If there is a Container with id1 T and key A, there should also be an Adjacency_Matrix with field5 W, id8 A, and id7 H. If there is no Adjacency_Matrix with field5 W, id8 T, and id7 H, then we must have a Vertex with id1 T and key A."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a Container with id1 T, with key A, whenever there is an Adjacency_Matrix with field5 W, with id8 A, with id7 H, whenever there is not a Adjacency_Matrix with field5 W, with id8 T, with id7 H, then we must have a Vertex with id1 T, with key A.",
            "NL": "If there is a Container with id1 T and key A, then there must be an Adjacency_Matrix with field5 W, id8 A, and id7 H; if there is no Adjacency_Matrix with field5 W, id8 T, and id7 H, then a Vertex with id1 T and key A must be present."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a Container with id1 T, with key A, whenever there is an Adjacency_Matrix with field5 W, with id8 A, with id7 H, whenever there is not a Adjacency_Matrix with field5 W, with id8 T, with id7 H, then we must have a Vertex with id1 T, with key A.",
            "NL": "If there is a Container with id1 T and key A, then there must be an Adjacency_Matrix with field5 W, id8 A, and id7 H. However, if there is no Adjacency_Matrix with field5 W, id8 T, and id7 H, then there must be a Vertex with id1 T and key A."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a Container with id1 T, with key A, whenever there is an Adjacency_Matrix with field5 W, with id8 A, with id7 H, whenever there is not a Adjacency_Matrix with field5 W, with id8 T, with id7 H, then we must have a Vertex with id1 T, with key A.",
            "NL": "If there is a Container with id1 T and key A, then an Adjacency_Matrix with field5 W, id8 A, and id7 H must also exist; however, if there is no Adjacency_Matrix with field5 W, id8 T, and id7 H, then a Vertex with id1 T and key A must be present."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a Container with id1 T, with key A, whenever there is an Adjacency_Matrix with field5 W, with id8 A, with id7 H, whenever there is not a Adjacency_Matrix with field5 W, with id8 T, with id7 H, then we must have a Vertex with id1 T, with key A.",
            "NL": "If there is a Container with id1 T, key A, there should be an Adjacency_Matrix with field5 W, id8 A, and id7 H. If there is no Adjacency_Matrix with field5 W, id8 T, and id7 H, then there must be a Vertex with id1 T, key A."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a edge with value U, with id V, whenever there is a active with key W, whenever there is not a trivial with value V, whenever there is not a trivial with value W, whenever there is a active with key V, whenever there is a reach with field1 V, and with field2 W different from V, whenever there is a reach with field1 W, and with field2 V, whenever there is not a mvlabel with field1 W, with field2 V, with field3 M, then there must be a mvlabel with field1 W, with field2 V, with field3 P.",
            "NL": "If there is an edge of value U and id V, an active with key W is present, and there is no trivial of value V, then there is no trivial of value W and an active with key V. If there is a reach with field1 V and field2 W, then there is a reach with field1 W and field2 V, and provided W is not equal to V, there must be a mvlabel with field1 W, field2 V, and field3 P."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a edge with value U, with id V, whenever there is a active with key W, whenever there is not a trivial with value V, whenever there is not a trivial with value W, whenever there is a active with key V, whenever there is a reach with field1 V, and with field2 W different from V, whenever there is a reach with field1 W, and with field2 V, whenever there is not a mvlabel with field1 W, with field2 V, with field3 M, then there must be a mvlabel with field1 W, with field2 V, with field3 P.",
            "NL": "If there is an edge with value U and id V, an active with key W, and a reach with field1 V and field2 W, and W is not equal to V, then there must not be a trivial with value V, a trivial with value W, or a mvlabel with field1 W, field2 V, and field3 M; rather, there must be an active with key V and a mvlabel with field1 W, field2 V, and field3 P."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a edge with value U, with id V, whenever there is a active with key W, whenever there is not a trivial with value V, whenever there is not a trivial with value W, whenever there is a active with key V, whenever there is a reach with field1 V, and with field2 W different from V, whenever there is a reach with field1 W, and with field2 V, whenever there is not a mvlabel with field1 W, with field2 V, with field3 M, then there must be a mvlabel with field1 W, with field2 V, with field3 P.",
            "NL": "If there is an edge with value U and id V, an active with key W is present, and if there is not a trivial with value V, there is no trivial with value W. An active with key V is present when there is a reach with field1 V and field2 W, and a reach with field1 W and field2 V. However, if W is not equal to V, then there must be a mvlabel with field1 W, field2 V, and field3 P, but not with field3 M."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a edge with value U, with id V, whenever there is a active with key W, whenever there is not a trivial with value V, whenever there is not a trivial with value W, whenever there is a active with key V, whenever there is a reach with field1 V, and with field2 W different from V, whenever there is a reach with field1 W, and with field2 V, whenever there is not a mvlabel with field1 W, with field2 V, with field3 M, then there must be a mvlabel with field1 W, with field2 V, with field3 P.",
            "NL": "If an edge with value U and id V exists, an active with key W is present, and a trivial with value V is not, then an active with key V is there and a reach with field1 V and field2 W is present, and a reach with field1 W and field2 V is also there, provided W is not equal to V, a mvlabel with field1 W, field2 V and field3 P must exist, even if there is no mvlabel with field1 W, field2 V and field3 M."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a edge with value U, with id V, whenever there is a active with key W, whenever there is not a trivial with value V, whenever there is not a trivial with value W, whenever there is a active with key V, whenever there is a reach with field1 V, and with field2 W different from V, whenever there is a reach with field1 W, and with field2 V, whenever there is not a mvlabel with field1 W, with field2 V, with field3 M, then there must be a mvlabel with field1 W, with field2 V, with field3 P.",
            "NL": "If there is an edge with value U and id V, an active with key W, and no trivial with value V, then there will be an active with key V and a reach with field1 V and field2 W. Furthermore, if there is a reach with field1 W and field2 V, and W is not equal to V, then a mvlabel with field1 W, field2 V, and field3 P must exist."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a edge with value U, with id V, whenever there is a active with value V, whenever there is not a trivial with value V, whenever there is a reach with field1 U, with field2 W, whenever there is a vertex with value W, whenever there is not an obs_vlabel with id1 U, with id2 P, whenever there is not an obs_vlabel with id1 U, with id2 M, then there must be a reach with field1 V, with field2 W.",
            "NL": "If an edge with value U and id V is present, an active with value V exists, but there is no trivial with value V; a reach with field1 U and field2 W is present, as well as a vertex with value W; however, there is no obs_vlabel with id1 U and id2 P or id2 M, then a reach with field1 V and field2 W must be present."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a edge with value U, with id V, whenever there is a active with value V, whenever there is not a trivial with value V, whenever there is a reach with field1 U, with field2 W, whenever there is a vertex with value W, whenever there is not an obs_vlabel with id1 U, with id2 P, whenever there is not an obs_vlabel with id1 U, with id2 M, then there must be a reach with field1 V, with field2 W.",
            "NL": "If there is an edge with value U and id V, an active with value V, and no trivial with value V, a reach with field1 U and field2 W, a vertex with value W, no obs_vlabel with id1 U and id2 P, and no obs_vlabel with id1 U and id2 M, then there must be a reach with field1 V and field2 W."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a edge with value U, with id V, whenever there is a active with value V, whenever there is not a trivial with value V, whenever there is a reach with field1 U, with field2 W, whenever there is a vertex with value W, whenever there is not an obs_vlabel with id1 U, with id2 P, whenever there is not an obs_vlabel with id1 U, with id2 M, then there must be a reach with field1 V, with field2 W.",
            "NL": "If there is an edge with value U and id V, an active with value V, no trivial with value V, a reach with field1 U and field2 W, a vertex with value W, no obs_vlabel with id1 U and id2 P, and no obs_vlabel with id1 U and id2 M, then there must be a reach with field1 V and field2 W."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a edge with value U, with id V, whenever there is a active with value V, whenever there is not a trivial with value V, whenever there is a reach with field1 U, with field2 W, whenever there is a vertex with value W, whenever there is not an obs_vlabel with id1 U, with id2 P, whenever there is not an obs_vlabel with id1 U, with id2 M, then there must be a reach with field1 V, with field2 W.",
            "NL": "If there is an edge with value U and id V, an active with value V, but no trivial with value V, a reach with field1 U and field2 W, a vertex with value W, no obs_vlabel with id1 U and id2 P, and no obs_vlabel with id1 U and id2 M, then a reach with field1 V and field2 W must exist."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a edge with value U, with id V, whenever there is a active with value V, whenever there is not a trivial with value V, whenever there is a reach with field1 U, with field2 W, whenever there is a vertex with value W, whenever there is not an obs_vlabel with id1 U, with id2 P, whenever there is not an obs_vlabel with id1 U, with id2 M, then there must be a reach with field1 V, with field2 W.",
            "NL": "If there is an edge with value U and id V, an active with value V, no trivial with value V, a reach with field1 U and field2 W, a vertex with value W, no obs_vlabel with id1 U and id2 P, and no obs_vlabel with id1 U and id2 M, then a reach with field1 V and field2 W must exist."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a edge with value U, with id V, whenever there is a active with value V, whenever there is not a trivial with value V, whenever there is not a obs_vlabel with id1 U, with id2 P, whenever there is not a obs_vlabel with id1 U, with id2 M, then there must be a reach with field1 V, with field2 U.",
            "NL": "If there is an edge with value U and id V, an active with value V, and no trivial with value V, or obs_vlabel with id1 U and id2 P, or obs_vlabel with id1 U and id2 M, then there must be a reach with field1 V and field2 U."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a edge with value U, with id V, whenever there is a active with value V, whenever there is not a trivial with value V, whenever there is not a obs_vlabel with id1 U, with id2 P, whenever there is not a obs_vlabel with id1 U, with id2 M, then there must be a reach with field1 V, with field2 U.",
            "NL": "If there is an edge with value U and id V, an active with value V, and no trivial with value V, no obs_vlabel with id1 U and id2 P, and no obs_vlabel with id1 U and id2 M, then a reach with field1 V and field2 U must exist."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a edge with value U, with id V, whenever there is a active with value V, whenever there is not a trivial with value V, whenever there is not a obs_vlabel with id1 U, with id2 P, whenever there is not a obs_vlabel with id1 U, with id2 M, then there must be a reach with field1 V, with field2 U.",
            "NL": "If there is an edge with value U and id V, an active with value V, but no trivial with value V, no obs_vlabel with id1 U and id2 P, and no obs_vlabel with id1 U and id2 M, then there must be a reach with field1 V and field2 U."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a edge with value U, with id V, whenever there is a active with value V, whenever there is not a trivial with value V, whenever there is not a obs_vlabel with id1 U, with id2 P, whenever there is not a obs_vlabel with id1 U, with id2 M, then there must be a reach with field1 V, with field2 U.",
            "NL": "If there is an edge with value U and id V, an active with value V, but no trivial with value V, no obs_vlabel with id1 U and id2 P, and no obs_vlabel with id1 U and id2 M, there must be a reach with field1 V and field2 U."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a edge with value U, with id V, whenever there is a active with value V, whenever there is not a trivial with value V, whenever there is not a obs_vlabel with id1 U, with id2 P, whenever there is not a obs_vlabel with id1 U, with id2 M, then there must be a reach with field1 V, with field2 U.",
            "NL": "If there is an edge with value U and id V, and there is an active with value V, but no trivial with value V, no obs_vlabel with id1 U and id2 P, and no obs_vlabel with id1 U and id2 M, then a reach must exist with field1 V and field2 U."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a edge with value U, with id V, Whenever there is a obs_vlabel with id1 U, with id2 S, Whenever there is not a trivial with key V, Whenever there is not a input with key V, then we must have a vlabel with id1 U, with id2 S.",
            "NL": "If there is not an edge with value U and id V, nor a trivial with key V or an input with key V, then a vlabel with id1 U and id2 S must exist."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a edge with value U, with id V, Whenever there is a obs_vlabel with id1 U, with id2 S, Whenever there is not a trivial with key V, Whenever there is not a input with key V, then we must have a vlabel with id1 U, with id2 S.",
            "NL": "If there is an edge with value U and id V, an obs_vlabel with id1 U and id2 S, no trivial with key V, and no input with key V, then a vlabel with id1 U and id2 S must be present."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a edge with value U, with id V, Whenever there is a obs_vlabel with id1 U, with id2 S, Whenever there is not a trivial with key V, Whenever there is not a input with key V, then we must have a vlabel with id1 U, with id2 S.",
            "NL": "If there is no edge with value U and id V, no obs_vlabel with id1 U and id2 S, no trivial with key V, and no input with key V, then the vlabel must have id1 U and id2 S."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a edge with value U, with id V, Whenever there is a obs_vlabel with id1 U, with id2 S, Whenever there is not a trivial with key V, Whenever there is not a input with key V, then we must have a vlabel with id1 U, with id2 S.",
            "NL": "If there is an edge of value U with id V, but no trivial with key V or input with key V, then there must be an obs_vlabel with id1 U and id2 S."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a edge with value U, with id V, Whenever there is a obs_vlabel with id1 U, with id2 S, Whenever there is not a trivial with key V, Whenever there is not a input with key V, then we must have a vlabel with id1 U, with id2 S.",
            "NL": "If there is an edge with value U and id V, and an obs_vlabel with id1 U and id2 S, but no trivial with key V and no input with key V, then a vlabel with id1 U and id2 S must be present."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a edge with value U, with id V, whenever there is an active with key W, whenever there is not a trivial with value V, whenever there is not a trivial with value W, whenever there is an active with key V, whenever there is a reach with field1 V, and with field2 W different from V, whenever there is a reach with field1 W, and with field2 V, whenever there is not a mvlabel with field1 W, with field2 V, with field3 P, then there must be a mvlabel with field1 W, with field2 V, with field3 M. ",
            "NL": "If there is an edge of value U and id V, an active with key W, no trivial with value V or W, an active with key V, a reach with field1 V and field2 W (different from V), and a reach with field1 W and field2 V, but no mvlabel with field1 W, field2 V, and field3 M, then there must be a mvlabel with field1 W, field2 V, and field3 P."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a edge with value U, with id V, whenever there is an active with key W, whenever there is not a trivial with value V, whenever there is not a trivial with value W, whenever there is an active with key V, whenever there is a reach with field1 V, and with field2 W different from V, whenever there is a reach with field1 W, and with field2 V, whenever there is not a mvlabel with field1 W, with field2 V, with field3 P, then there must be a mvlabel with field1 W, with field2 V, with field3 M. ",
            "NL": "If there is an edge with value U and id V, an active with key W, but no trivial with value V or W, a reach with field1 V and field2 W (not equal to V), and no mvlabel with field1 W, field2 V, and field3 M, then there must be a mvlabel with field1 W, field2 V, and field3 P."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a edge with value U, with id V, whenever there is an active with key W, whenever there is not a trivial with value V, whenever there is not a trivial with value W, whenever there is an active with key V, whenever there is a reach with field1 V, and with field2 W different from V, whenever there is a reach with field1 W, and with field2 V, whenever there is not a mvlabel with field1 W, with field2 V, with field3 P, then there must be a mvlabel with field1 W, with field2 V, with field3 M. ",
            "NL": "If there is an edge with value U and id V, an active with key W, no trivial with value V or W, an active with key V, a reach with field1 V and field2 W that is different from V, a reach with field1 W and field2 V, but no mvlabel with field1 W, field2 V, and field3 M, then there must be a mvlabel with field1 W, field2 V, and field3 P."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a edge with value U, with id V, whenever there is an active with key W, whenever there is not a trivial with value V, whenever there is not a trivial with value W, whenever there is an active with key V, whenever there is a reach with field1 V, and with field2 W different from V, whenever there is a reach with field1 W, and with field2 V, whenever there is not a mvlabel with field1 W, with field2 V, with field3 P, then there must be a mvlabel with field1 W, with field2 V, with field3 M. ",
            "NL": "If there is an edge with value U and id V, an active with key W, no trivial with value V or W, an active with key V, a reach with field1 V and field2 W (different from V), a reach with field1 W and field2 V, but no mvlabel with field1 W, field2 V, and field3 M, then there must be a mvlabel with field1 W, field2 V, and field3 P."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a edge with value U, with id V, whenever there is an active with key W, whenever there is not a trivial with value V, whenever there is not a trivial with value W, whenever there is an active with key V, whenever there is a reach with field1 V, and with field2 W different from V, whenever there is a reach with field1 W, and with field2 V, whenever there is not a mvlabel with field1 W, with field2 V, with field3 P, then there must be a mvlabel with field1 W, with field2 V, with field3 M. ",
            "NL": "If there exists an edge with value U and id V, an active with key W, no trivial with value V or W, an active with key V, a reach with field1 V and field2 W (which is distinct from V), a reach with field1 W and field2 V, but no mvlabel with field1 W, field2 V and field3 M, then there must be a mvlabel with field1 W, field2 V and field3 P."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a edge with value U, with id V, whenever there is an active with key W, whenever there is not a trivial with value V, whenever there is not a trivial with value W, whenever there is an active with key V, whenever there is a reach with field1 V, and with field2 W different from V, whenever there is a reach with field1 W, and with field2 V, whenever there is not a mllabel with field1 W, with field2 U, with field3 V, with field4 M then there must be a mllabel with field1 W, with field2 U, with field3 V, with field4 P.",
            "NL": "If there is an edge with value U and id V, an active with key W, and no trivial with value V, there must be an active with key V, a reach with field1 V and field2 W, a reach with field1 W and field2 V, and a mllabel with field1 W, field2 U, field3 V, and field4 P, provided that W is not equal to V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a edge with value U, with id V, whenever there is an active with key W, whenever there is not a trivial with value V, whenever there is not a trivial with value W, whenever there is an active with key V, whenever there is a reach with field1 V, and with field2 W different from V, whenever there is a reach with field1 W, and with field2 V, whenever there is not a mllabel with field1 W, with field2 U, with field3 V, with field4 M then there must be a mllabel with field1 W, with field2 U, with field3 V, with field4 P.",
            "NL": "When there exists an edge with value U and id V, an active with key W is present, and when there is no trivial with value V, there is no trivial with value W. There is an active with key V, a reach with field1 V and field2 W, a reach with field1 W and field2 V, and when W is not equal to V, a mllabel with field1 W, field2 U, field3 V, and field4 P must exist."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a edge with value U, with id V, whenever there is an active with key W, whenever there is not a trivial with value V, whenever there is not a trivial with value W, whenever there is an active with key V, whenever there is a reach with field1 V, and with field2 W different from V, whenever there is a reach with field1 W, and with field2 V, whenever there is not a mllabel with field1 W, with field2 U, with field3 V, with field4 M then there must be a mllabel with field1 W, with field2 U, with field3 V, with field4 P.",
            "NL": "If there is an edge with value U and id V, and there is an active with key W, and there is not a trivial with value V, then there must be a reach with field1 W and field2 V, and a mllabel with field1 W, field2 U, field3 V, and field4 P, provided that W is not equal to V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a edge with value U, with id V, whenever there is an active with key W, whenever there is not a trivial with value V, whenever there is not a trivial with value W, whenever there is an active with key V, whenever there is a reach with field1 V, and with field2 W different from V, whenever there is a reach with field1 W, and with field2 V, whenever there is not a mllabel with field1 W, with field2 U, with field3 V, with field4 M then there must be a mllabel with field1 W, with field2 U, with field3 V, with field4 P.",
            "NL": "If there is an edge with value U and id V, and there is an active with key W, and a reach with field1 V and field2 W, and a reach with field1 W and field2 V, and W is not equal to V, but there is not a mllabel with field1 W, field2 U, field3 V, and field4 M, then a mllabel with field1 W, field2 U, field3 V, and field4 P must exist."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a edge with value U, with id V, whenever there is an active with key W, whenever there is not a trivial with value V, whenever there is not a trivial with value W, whenever there is an active with key V, whenever there is a reach with field1 V, and with field2 W different from V, whenever there is a reach with field1 W, and with field2 V, whenever there is not a mllabel with field1 W, with field2 U, with field3 V, with field4 M then there must be a mllabel with field1 W, with field2 U, with field3 V, with field4 P.",
            "NL": "If U, V, and W are not equal, and there is an edge with value U and id V, and an active with key W, and no trivial with value V, then there must be a reach with field1 V and field2 W, a reach with field1 W and field2 V, and a mllabel with field1 W, field2 U, field3 V, and field4 P."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a edge with value U, with id V, whenever there is an active with value V, whenever there is not a trivial with value V, whenever there is a reach with field1 V, with field2 W, whenever there is a vertex with value W, then there must be a reach with field1 U, with field2 W.",
            "NL": "Whenever there is an edge with value U and id V, an active with value V, no trivial with value V, and a reach with field1 V and field2 W, and a vertex with value W, then a reach must exist with field1 U and field2 W."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a edge with value U, with id V, whenever there is an active with value V, whenever there is not a trivial with value V, whenever there is a reach with field1 V, with field2 W, whenever there is a vertex with value W, then there must be a reach with field1 U, with field2 W.",
            "NL": "If there is an edge with value U and id V, an active with value V, no trivial with value V, and a reach with field1 V and field2 W, and a vertex with value W, it follows that there must be a reach with field1 U and field2 W."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a edge with value U, with id V, whenever there is an active with value V, whenever there is not a trivial with value V, whenever there is a reach with field1 V, with field2 W, whenever there is a vertex with value W, then there must be a reach with field1 U, with field2 W.",
            "NL": "If there is an edge with value U, id V, an active with value V, no trivial with value V, a reach with field1 V and field2 W, and a vertex with value W, then there must be a reach with field1 U and field2 W."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a edge with value U, with id V, whenever there is an active with value V, whenever there is not a trivial with value V, whenever there is a reach with field1 V, with field2 W, whenever there is a vertex with value W, then there must be a reach with field1 U, with field2 W.",
            "NL": "If there is an edge with value U and id V, an active with value V, no trivial with value V, a reach with field1 V and field2 W, and a vertex with value W, then a reach must also exist with field1 U and field2 W."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a edge with value U, with id V, whenever there is an active with value V, whenever there is not a trivial with value V, whenever there is a reach with field1 V, with field2 W, whenever there is a vertex with value W, then there must be a reach with field1 U, with field2 W.",
            "NL": "If there is an edge with value U and id V, an active with value V, no trivial with value V, a reach with field1 V and field2 W, and a vertex with value W, then there must be a reach with field1 U and field2 W."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a edge_pair with id1 N1, with id2 N2, with id3 N3, with id4 N4, whenever there is not a edge_pair with id1 N1, with id2 N4, with id3 N3, with id4 N2, whenever there is a compare with value N2, with id N4, whenever there is an inorder with value N1, with id N3, whenever there is not a inorder with value N2, with id N4, then we must have a crossing with id1 N1, with id2 N2, with id3 N3, with id4 N4. ",
            "NL": "If there is an edge_pair having id1 N1, id2 N2, id3 N3, and id4 N4, there cannot be an edge_pair with id1 N1, id2 N4, id3 N3, and id4 N2, and if there is a compare with value N2 and id N4, there is an inorder with value N1 and id N3, but not an inorder with value N2 and id N4, then we must have a crossing with id1 N1, id2 N2, id3 N3, and id4 N4."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a edge_pair with id1 N1, with id2 N2, with id3 N3, with id4 N4, whenever there is not a edge_pair with id1 N1, with id2 N4, with id3 N3, with id4 N2, whenever there is a compare with value N2, with id N4, whenever there is an inorder with value N1, with id N3, whenever there is not a inorder with value N2, with id N4, then we must have a crossing with id1 N1, with id2 N2, with id3 N3, with id4 N4. ",
            "NL": "If an edge_pair is identified by id1 N1, id2 N2, id3 N3 and id4 N4, and there is a compare with value N2 and id N4, an inorder with value N1 and id N3, but no inorder with value N2 and id N4, then a crossing with id1 N1, id2 N2, id3 N3 and id4 N4 must exist."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a edge_pair with id1 N1, with id2 N2, with id3 N3, with id4 N4, whenever there is not a edge_pair with id1 N1, with id2 N4, with id3 N3, with id4 N2, whenever there is a compare with value N2, with id N4, whenever there is an inorder with value N1, with id N3, whenever there is not a inorder with value N2, with id N4, then we must have a crossing with id1 N1, with id2 N2, with id3 N3, with id4 N4. ",
            "NL": "If there is an edge_pair with id1 N1, id2 N2, id3 N3, and id4 N4, but no edge_pair with id1 N1, id2 N4, id3 N3, and id4 N2, and a compare with value N2 and id N4, and an inorder with value N1 and id N3, but no inorder with value N2 and id N4, then a crossing with id1 N1, id2 N2, id3 N3, and id4 N4 must be present."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a edge_pair with id1 N1, with id2 N2, with id3 N3, with id4 N4, whenever there is not a edge_pair with id1 N1, with id2 N4, with id3 N3, with id4 N2, whenever there is a compare with value N2, with id N4, whenever there is an inorder with value N1, with id N3, whenever there is not a inorder with value N2, with id N4, then we must have a crossing with id1 N1, with id2 N2, with id3 N3, with id4 N4. ",
            "NL": "If there is an edge_pair with id1 N1, id2 N2, id3 N3, and id4 N4, then there cannot be an edge_pair with id1 N1, id2 N4, id3 N3, and id4 N2, when there is a compare with value N2 and id N4, there is an inorder with value N1 and id N3, but not an inorder with value N2 and id N4, then a crossing with id1 N1, id2 N2, id3 N3, and id4 N4 must be present."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a edge_pair with id1 N1, with id2 N2, with id3 N3, with id4 N4, whenever there is not a edge_pair with id1 N1, with id2 N4, with id3 N3, with id4 N2, whenever there is a compare with value N2, with id N4, whenever there is an inorder with value N1, with id N3, whenever there is not a inorder with value N2, with id N4, then we must have a crossing with id1 N1, with id2 N2, with id3 N3, with id4 N4. ",
            "NL": "If an edge_pair with id1 N1, id2 N2, id3 N3, and id4 N4 exists, then there cannot be an edge_pair with id1 N1, id2 N4, id3 N3, and id4 N2. If a compare with value N2 and id N4 exists, then an inorder with value N1 and id N3 must exist, but an inorder with value N2 and id N4 cannot exist. Thus, a crossing with id1 N1, id2 N2, id3 N3, and id4 N4 must occur."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a edge_pair with id1 N1, with id2 N4, with id3 N3, with id4 N2, whenever there is not a edge_pair with id1 N1, with id2 N2, with id3 N3, with id4 N4, whenever there is a compare with value N2, with id N4, whenever there is not a inorder with value N1, with id N3, whenever there is not a inorder with value N2, with id N4, then we must have a crossing with id1 N1, with id2 N4, with id3 N3, with id4 N2.",
            "NL": "If an edge pair with id1 N1, id2 N4, id3 N3, and id4 N2 exists, there cannot be an edge pair with id1 N1, id2 N2, id3 N3, and id4 N4, a compare with value N2 and id N4, an inorder with value N1 and id N3, and an inorder with value N2 and id N4. In this case, we must have a crossing with id1 N1, id2 N4, id3 N3, and id4 N2."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a edge_pair with id1 N1, with id2 N4, with id3 N3, with id4 N2, whenever there is not a edge_pair with id1 N1, with id2 N2, with id3 N3, with id4 N4, whenever there is a compare with value N2, with id N4, whenever there is not a inorder with value N1, with id N3, whenever there is not a inorder with value N2, with id N4, then we must have a crossing with id1 N1, with id2 N4, with id3 N3, with id4 N2.",
            "NL": "If there is an edge pair with id1 N1, id2 N4, id3 N3, and id4 N2, and there is not an edge pair with id1 N1, id2 N2, id3 N3, and id4 N4, along with a compare with value N2 and id N4, but there is no inorder with value N1 and id N3, or an inorder with value N2 and id N4, then a crossing with id1 N1, id2 N4, id3 N3, and id4 N2 must be present."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a edge_pair with id1 N1, with id2 N4, with id3 N3, with id4 N2, whenever there is not a edge_pair with id1 N1, with id2 N2, with id3 N3, with id4 N4, whenever there is a compare with value N2, with id N4, whenever there is not a inorder with value N1, with id N3, whenever there is not a inorder with value N2, with id N4, then we must have a crossing with id1 N1, with id2 N4, with id3 N3, with id4 N2.",
            "NL": "If there is an edge pair with ID1 N1, ID2 N4, ID3 N3, and ID4 N2, but there is no edge pair with ID1 N1, ID2 N2, ID3 N3, and ID4 N4; a compare with value N2 and ID N4; and no inorder with value N1 and ID N3, nor an inorder with value N2 and ID N4, then a crossing with ID1 N1, ID2 N4, ID3 N3, and ID4 N2 must be present."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a edge_pair with id1 N1, with id2 N4, with id3 N3, with id4 N2, whenever there is not a edge_pair with id1 N1, with id2 N2, with id3 N3, with id4 N4, whenever there is a compare with value N2, with id N4, whenever there is not a inorder with value N1, with id N3, whenever there is not a inorder with value N2, with id N4, then we must have a crossing with id1 N1, with id2 N4, with id3 N3, with id4 N2.",
            "NL": "If an edge pair of id1 N1, id2 N4, id3 N3, and id4 N2 exists, but an edge pair of id1 N1, id2 N2, id3 N3, and id4 N4 does not, and a compare of value N2 and id N4 is present, but an inorder of value N1 and id N3 is not, and an inorder of value N2 and id N4 is also not, then a crossing of id1 N1, id2 N4, id3 N3, and id4 N2 must be present."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a edge_pair with id1 N1, with id2 N4, with id3 N3, with id4 N2, whenever there is not a edge_pair with id1 N1, with id2 N2, with id3 N3, with id4 N4, whenever there is a compare with value N2, with id N4, whenever there is not a inorder with value N1, with id N3, whenever there is not a inorder with value N2, with id N4, then we must have a crossing with id1 N1, with id2 N4, with id3 N3, with id4 N2.",
            "NL": "If an edge pair exists with id1 N1, id2 N4, id3 N3, and id4 N2, but there is no edge pair with id1 N1, id2 N2, id3 N3, and id4 N4, and a compare with value N2 and id N4 exists when there is no inorder with value N1 and id N3, and there is no inorder with value N2 and id N4, then a crossing with id1 N1, id2 N4, id3 N3, and id4 N2 must be present."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a Later with vtx4 B, with field5 F, with node4 J, Whenever there is a Primary with field6 B, with vtx2 T different from N, Whenever there is not a Sign with edge4 F, Whenever there is not a Relevant with edge4 F, Whenever there is not a Superior with field6 B, with vtx2 F, with key2 I, Whenever there is a Primary with field6 F, with vtx2 N, then we must have a Begin with vtx4 B, with field5 F.",
            "NL": "Whenever there is a Begin with vtx4 B, with field5 F, and a Primary with field6 B, with vtx2 T different from N, and a Primary with field6 F, with vtx2 N, then there will not be a Later with vtx4 B, with field5 F, with node4 J, a Sign with edge4 F, or a Relevant with edge4 F, nor will there be an Superior with field6 B, with vtx2 F, with key2 I."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a Later with vtx4 B, with field5 F, with node4 J, Whenever there is a Primary with field6 B, with vtx2 T different from N, Whenever there is not a Sign with edge4 F, Whenever there is not a Relevant with edge4 F, Whenever there is not a Superior with field6 B, with vtx2 F, with key2 I, Whenever there is a Primary with field6 F, with vtx2 N, then we must have a Begin with vtx4 B, with field5 F.",
            "NL": "Whenever there is a Later with vtx4 B and field5 F, as well as a node4 J, then we must have a Primary with field6 B, vtx2 T different from N, no Sign with edge4 F, no Relevant with edge4 F, no Superior with field6 B, vtx2 F, and key2 I, and a Primary with field6 F and vtx2 N, plus a Begin with vtx4 B and field5 F."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a Later with vtx4 B, with field5 F, with node4 J, Whenever there is a Primary with field6 B, with vtx2 T different from N, Whenever there is not a Sign with edge4 F, Whenever there is not a Relevant with edge4 F, Whenever there is not a Superior with field6 B, with vtx2 F, with key2 I, Whenever there is a Primary with field6 F, with vtx2 N, then we must have a Begin with vtx4 B, with field5 F.",
            "NL": "If there is a Later with vtx4 B, field5 F, and node4 J, there must be a Primary with field6 B, vtx2 T different from N; there cannot be a Sign with edge4 F, no Relevant with edge4 F, and not an Superior with field6 B, vtx2 F, and key2 I; however, there should be a Primary with field6 F and vtx2 N, and then we must have a Begin with vtx4 B, field5 F."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a Later with vtx4 B, with field5 F, with node4 J, Whenever there is a Primary with field6 B, with vtx2 T different from N, Whenever there is not a Sign with edge4 F, Whenever there is not a Relevant with edge4 F, Whenever there is not a Superior with field6 B, with vtx2 F, with key2 I, Whenever there is a Primary with field6 F, with vtx2 N, then we must have a Begin with vtx4 B, with field5 F.",
            "NL": "If we have a Primary with field6 B, with vtx2 T different from N, and no Sign with edge4 F, or Relevant with edge4 F, or Superior with field6 B, with vtx2 F, with key2 I, but we do have a Primary with field6 F, with vtx2 N, then we must have a Begin with vtx4 B, with field5 F."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a Later with vtx4 B, with field5 F, with node4 J, Whenever there is a Primary with field6 B, with vtx2 T different from N, Whenever there is not a Sign with edge4 F, Whenever there is not a Relevant with edge4 F, Whenever there is not a Superior with field6 B, with vtx2 F, with key2 I, Whenever there is a Primary with field6 F, with vtx2 N, then we must have a Begin with vtx4 B, with field5 F.",
            "NL": "Whenever there is a Later with vtx4 B, field5 F, and node4 J, a Primary with field6 B, vtx2 T different from N, and no Sign with edge4 F or Relevant with edge4 F, nor an Superior with field6 B, vtx2 F, and key2 I, but a Primary with field6 F, vtx2 N, then we must have a Begin with vtx4 B, field5 F."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a less with field1 X, with field2 C1, with field3 Y1, with field4 C, and with field5 Y, whenever there is a less with field1 X, with field2 C, with field3 Y, with field4 C2, and with field5 Y2, then there must be a diff with field1 X, with field2 C1, with field3 Y1, with field4 C2, and with field5 Y2. ",
            "NL": "If there is a discrepancy in field1 X, field2 C1, field3 Y1, field4 C, and field5 Y between two instances where field1 X, field2 C, field3 Y, field4 C2, and field5 Y2 are the same, then there must be a difference in field1 X, field2 C1, field3 Y1, field4 C2, and field5 Y2."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a less with field1 X, with field2 C1, with field3 Y1, with field4 C, and with field5 Y, whenever there is a less with field1 X, with field2 C, with field3 Y, with field4 C2, and with field5 Y2, then there must be a diff with field1 X, with field2 C1, with field3 Y1, with field4 C2, and with field5 Y2. ",
            "NL": "If there is one instance of field1 X, field2 C1, field3 Y1, field4 C, and field5 Y, and another instance of field1 X, field2 C, field3 Y, field4 C2, and field5 Y2, then there must be a discrepancy between the two sets of field1 X, field2 C1, field3 Y1, field4 C2, and field5 Y2."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a less with field1 X, with field2 C1, with field3 Y1, with field4 C, and with field5 Y, whenever there is a less with field1 X, with field2 C, with field3 Y, with field4 C2, and with field5 Y2, then there must be a diff with field1 X, with field2 C1, with field3 Y1, with field4 C2, and with field5 Y2. ",
            "NL": "If field1 X, field2 C1, field3 Y1, field4 C, and field5 Y are different from field1 X, field2 C, field3 Y, field4 C2, and field5 Y2, then there must be a difference between field1 X, field2 C1, field3 Y1, field4 C2, and field5 Y2."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a less with field1 X, with field2 C1, with field3 Y1, with field4 C, and with field5 Y, whenever there is a less with field1 X, with field2 C, with field3 Y, with field4 C2, and with field5 Y2, then there must be a diff with field1 X, with field2 C1, with field3 Y1, with field4 C2, and with field5 Y2. ",
            "NL": "If there is a discrepancy between field1 X, field2 C1, field3 Y1, field4 C, and field5 Y, and another discrepancy between field1 X, field2 C, field3 Y, field4 C2, and field5 Y2, then there must be a contrast between field1 X, field2 C1, field3 Y1, field4 C2, and field5 Y2."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a less with field1 X, with field2 C1, with field3 Y1, with field4 C, and with field5 Y, whenever there is a less with field1 X, with field2 C, with field3 Y, with field4 C2, and with field5 Y2, then there must be a diff with field1 X, with field2 C1, with field3 Y1, with field4 C2, and with field5 Y2. ",
            "NL": "If there is a discrepancy between two sets of data, one with field1 X, field2 C1, field3 Y1, field4 C, and field5 Y, and the other with field1 X, field2 C, field3 Y, field4 C2, and field5 Y2, then the values of field1 X, field2 C1, field3 Y1, field4 C2, and field5 Y2 must differ."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a less with field1 X, with field2 C1, with field3 Y1, with field4 C2, and with field5 Y2, whenever there is not a diff with field1 X, with field2 C1, with field3 Y1, with field4 C2, and with field5 Y2, then there must be a next with field1 X, with field2 C1, with field3 Y1, with field4 C2, and with field5 Y2.",
            "NL": "If there is no difference between having field1 X, field2 C1, field3 Y1, field4 C2, and field5 Y2, then there must be a subsequent instance of field1 X, field2 C1, field3 Y1, field4 C2, and field5 Y2."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a less with field1 X, with field2 C1, with field3 Y1, with field4 C2, and with field5 Y2, whenever there is not a diff with field1 X, with field2 C1, with field3 Y1, with field4 C2, and with field5 Y2, then there must be a next with field1 X, with field2 C1, with field3 Y1, with field4 C2, and with field5 Y2.",
            "NL": "If there is no difference between a field1 X, field2 C1, field3 Y1, field4 C2, and field5 Y2, then there should be a subsequent field1 X, field2 C1, field3 Y1, field4 C2, and field5 Y2."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a less with field1 X, with field2 C1, with field3 Y1, with field4 C2, and with field5 Y2, whenever there is not a diff with field1 X, with field2 C1, with field3 Y1, with field4 C2, and with field5 Y2, then there must be a next with field1 X, with field2 C1, with field3 Y1, with field4 C2, and with field5 Y2.",
            "NL": "If there is no difference between field1 X, field2 C1, field3 Y1, field4 C2, and field5 Y2, then the next step must be to have field1 X, field2 C1, field3 Y1, field4 C2, and field5 Y2."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a less with field1 X, with field2 C1, with field3 Y1, with field4 C2, and with field5 Y2, whenever there is not a diff with field1 X, with field2 C1, with field3 Y1, with field4 C2, and with field5 Y2, then there must be a next with field1 X, with field2 C1, with field3 Y1, with field4 C2, and with field5 Y2.",
            "NL": "If there is no discrepancy between field1 X, field2 C1, field3 Y1, field4 C2, and field5 Y2, then the following must have field1 X, field2 C1, field3 Y1, field4 C2, and field5 Y2."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a less with field1 X, with field2 C1, with field3 Y1, with field4 C2, and with field5 Y2, whenever there is not a diff with field1 X, with field2 C1, with field3 Y1, with field4 C2, and with field5 Y2, then there must be a next with field1 X, with field2 C1, with field3 Y1, with field4 C2, and with field5 Y2.",
            "NL": "If there is no difference between field1 X, field2 C1, field3 Y1, field4 C2, and field5 Y2, then there must be a subsequent instance of the same with field1 X, field2 C1, field3 Y1, field4 C2, and field5 Y2."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a Link with key7 J, with id3 X, whenever there is a Secondary with vtx3 J, with id10 B, whenever there is a Comprises with vtx3 H, whenever there is not a Symbol with vtx3 B, whenever there is not a Symbol with vtx3 H, whenever there is not an Order with vtx3 B, whenever there is not an Order with vtx3 H different from B, then there must be a Spanning_Tree with id2 H, with field8 J, with vtx5 X.",
            "NL": "If there is a Link with key7 J and id3 X, a Secondary with vtx3 J and id10 B, a Comprises with vtx3 H, no Symbol with vtx3 B or vtx3 H, nor an Order with vtx3 B, and Order with vtx3 H is not equal to Order with vtx3 B, then a Spanning_Tree with id2 H, field8 J, and vtx5 X must exist."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a Link with key7 J, with id3 X, whenever there is a Secondary with vtx3 J, with id10 B, whenever there is a Comprises with vtx3 H, whenever there is not a Symbol with vtx3 B, whenever there is not a Symbol with vtx3 H, whenever there is not an Order with vtx3 B, whenever there is not an Order with vtx3 H different from B, then there must be a Spanning_Tree with id2 H, with field8 J, with vtx5 X.",
            "NL": "If there is a Link with key7 J and id3 X, there is a Secondary with vtx3 J and id10 B, a Comprises with vtx3 H, no Symbol with vtx3 B or vtx3 H, no Order with either vtx3 B or vtx3 H (where H is not equal to B), then a Spanning_Tree with id2 H, field8 J, and vtx5 X must exist."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a Link with key7 J, with id3 X, whenever there is a Secondary with vtx3 J, with id10 B, whenever there is a Comprises with vtx3 H, whenever there is not a Symbol with vtx3 B, whenever there is not a Symbol with vtx3 H, whenever there is not an Order with vtx3 B, whenever there is not an Order with vtx3 H different from B, then there must be a Spanning_Tree with id2 H, with field8 J, with vtx5 X.",
            "NL": "If there is a Link with key7 J and id3 X, a Secondary with vtx3 J and id10 B, a Comprises with vtx3 H, but no Symbol with vtx3 B or vtx3 H, and no Order with vtx3 B or vtx3 H (where H is not equal to B), then there must be a Spanning_Tree with id2 H, field8 J and vtx5 X."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a Link with key7 J, with id3 X, whenever there is a Secondary with vtx3 J, with id10 B, whenever there is a Comprises with vtx3 H, whenever there is not a Symbol with vtx3 B, whenever there is not a Symbol with vtx3 H, whenever there is not an Order with vtx3 B, whenever there is not an Order with vtx3 H different from B, then there must be a Spanning_Tree with id2 H, with field8 J, with vtx5 X.",
            "NL": "If there is a Link with key7 J and id3 X, a Secondary with vtx3 J and id10 B, a Comprises with vtx3 H, no Symbol with vtx3 B or vtx3 H, no Order with vtx3 B, and no Order with vtx3 H (where H is not equal to B), then a Spanning_Tree with id2 H, field8 J, and vtx5 X must exist."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a Link with key7 J, with id3 X, whenever there is a Secondary with vtx3 J, with id10 B, whenever there is a Comprises with vtx3 H, whenever there is not a Symbol with vtx3 B, whenever there is not a Symbol with vtx3 H, whenever there is not an Order with vtx3 B, whenever there is not an Order with vtx3 H different from B, then there must be a Spanning_Tree with id2 H, with field8 J, with vtx5 X.",
            "NL": "If there is a Link with key7 J and id3 X, a Secondary with vtx3 J and id10 B, a Comprises with vtx3 H, but no Symbol with vtx3 B or vtx3 H and no Order with vtx3 B or vtx3 H (where H is not equal to B), then a Spanning_Tree with id2 H, field8 J, and vtx5 X must be present."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a llabel with field1 U, with field2 V, with field3 M, Whenever there is a vlabel with id1 U, with id2 S, Whenever there is not a trivial with key V, Whenever there is not a input with key V, Whenever there is not a obs_elabel with id1 U, with id2 V, with id3 P, Whenever there is a vlabel with id1 V, with id2 S, then we must have a oppo with field1 U, with field2 V.",
            "NL": "If there is a llabel with field1 U, field2 V, and field3 M, a vlabel with id1 U and id2 S, no trivial with key V, no input with key V, no obs_elabel with id1 U, id2 V, and id3 P, and a vlabel with id1 V and id2 S, then there must be an oppo with field1 U and field2 V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a llabel with field1 U, with field2 V, with field3 M, Whenever there is a vlabel with id1 U, with id2 S, Whenever there is not a trivial with key V, Whenever there is not a input with key V, Whenever there is not a obs_elabel with id1 U, with id2 V, with id3 P, Whenever there is a vlabel with id1 V, with id2 S, then we must have a oppo with field1 U, with field2 V.",
            "NL": "If there is a llabel with field1 U, field2 V, and field3 M, a vlabel with id1 U and id2 S, no trivial with key V, no input with key V, and no obs_elabel with id1 U, id2 V, and id3 P, but there is a vlabel with id1 V and id2 S, then there must be an oppo with field1 U and field2 V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a llabel with field1 U, with field2 V, with field3 M, Whenever there is a vlabel with id1 U, with id2 S, Whenever there is not a trivial with key V, Whenever there is not a input with key V, Whenever there is not a obs_elabel with id1 U, with id2 V, with id3 P, Whenever there is a vlabel with id1 V, with id2 S, then we must have a oppo with field1 U, with field2 V.",
            "NL": "If there is a llabel with field1 U, field2 V, and field3 M, a vlabel with id1 U and id2 S, no trivial with key V, no input with key V, and no obs_elabel with id1 U, id2 V, and id3 P, but a vlabel with id1 V and id2 S, then there must be an oppo with field1 U and field2 V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a llabel with field1 U, with field2 V, with field3 M, Whenever there is a vlabel with id1 U, with id2 S, Whenever there is not a trivial with key V, Whenever there is not a input with key V, Whenever there is not a obs_elabel with id1 U, with id2 V, with id3 P, Whenever there is a vlabel with id1 V, with id2 S, then we must have a oppo with field1 U, with field2 V.",
            "NL": "If we find a llabel with field1 U, field2 V, and field3 M, a vlabel with id1 U and id2 S, no trivial with key V, no input with key V, and no obs_elabel with id1 U, id2 V, and id3 P, but a vlabel with id1 V and id2 S, then an oppo with field1 U and field2 V must be present."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a llabel with field1 U, with field2 V, with field3 M, Whenever there is a vlabel with id1 U, with id2 S, Whenever there is not a trivial with key V, Whenever there is not a input with key V, Whenever there is not a obs_elabel with id1 U, with id2 V, with id3 P, Whenever there is a vlabel with id1 V, with id2 S, then we must have a oppo with field1 U, with field2 V.",
            "NL": "If there is a label with field1 U, field2 V, and field3 M, and a vlabel with id1 U, id2 S, but there is no trivial having key V, no input with key V, and no obs_elabel with id1 U, id2 V, and id3 P, and a vlabel with id1 V and id2 S, then we must have an oppo with field1 U and field2 V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a llabel with field1 U, with field2 V, with field3 P, Whenever there is a vlabel with id1 U, with id2 S different from T, Whenever there is not a trivial with key V, Whenever there is not a input with key V, Whenever there is not a obs_elabel with id1 U, with id2 V, with id3 M, Whenever there is a vlabel with id1 V, with id2 T, then we must have a oppo with field1 U, with field2 V. ",
            "NL": "If there is a label with field1 U, field2 V, and field3 P, a vlabel with id1 U, id2 S not equal to T, no trivial with key V, no input with key V, no obs_elabel with id1 U, id2 V, and id3 M, and a vlabel with id1 V, id2 T, then an oppo must have field1 U and field2 V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a llabel with field1 U, with field2 V, with field3 P, Whenever there is a vlabel with id1 U, with id2 S different from T, Whenever there is not a trivial with key V, Whenever there is not a input with key V, Whenever there is not a obs_elabel with id1 U, with id2 V, with id3 M, Whenever there is a vlabel with id1 V, with id2 T, then we must have a oppo with field1 U, with field2 V. ",
            "NL": "If a label with field1 U, field2 V, and field3 P exists, and a vlabel with id1 U, id2 S, and id2 not equal to T is present, and there is no trivial with key V, no input with key V, and no obs_elabel with id1 U, id2 V, and id3 M, but there is a vlabel with id1 V and id2 T, then an oppo with field1 U and field2 V must exist."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a llabel with field1 U, with field2 V, with field3 P, Whenever there is a vlabel with id1 U, with id2 S different from T, Whenever there is not a trivial with key V, Whenever there is not a input with key V, Whenever there is not a obs_elabel with id1 U, with id2 V, with id3 M, Whenever there is a vlabel with id1 V, with id2 T, then we must have a oppo with field1 U, with field2 V. ",
            "NL": "If there is a label with field1 U, field2 V, and field3 P; a vlabel with id1 U, id2 S (which is different from T); no trivial with key V; no input with key V; no obs_elabel with id1 U, id2 V, and id3 M; and a vlabel with id1 V, id2 T, then an oppo with field1 U and field2 V must exist."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a llabel with field1 U, with field2 V, with field3 P, Whenever there is a vlabel with id1 U, with id2 S different from T, Whenever there is not a trivial with key V, Whenever there is not a input with key V, Whenever there is not a obs_elabel with id1 U, with id2 V, with id3 M, Whenever there is a vlabel with id1 V, with id2 T, then we must have a oppo with field1 U, with field2 V. ",
            "NL": "If we encounter a llabel with field1 U, field2 V, and field3 P, a vlabel with id1 U, id2 S not equal to T, no trivial with key V, no input with key V, no obs_elabel with id1 U, id2 V, and id3 M, and a vlabel with id1 V and id2 T, then we must have an oppo with field1 U and field2 V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a llabel with field1 U, with field2 V, with field3 P, Whenever there is a vlabel with id1 U, with id2 S different from T, Whenever there is not a trivial with key V, Whenever there is not a input with key V, Whenever there is not a obs_elabel with id1 U, with id2 V, with id3 M, Whenever there is a vlabel with id1 V, with id2 T, then we must have a oppo with field1 U, with field2 V. ",
            "NL": "If there is a label with field1 U, field2 V, and field3 P; id1 U, id2 S different from T for a vlabel; no trivial with key V; no input with key V; no obs_elabel with id1 U, id2 V, and id3 M; and a vlabel with id1 V and id2 T, then an oppo with field1 U and field2 V must be present."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a Load with value4 Y, whenever there is not an Ordered with fourth node Y, then there must be an Idle with node edge10 Y.",
            "NL": "If Load with value4 Y has not been Ordered with fourth node Y, then there must be an Idle with node edge10 Y."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a Load with value4 Y, whenever there is not an Ordered with fourth node Y, then there must be an Idle with node edge10 Y.",
            "NL": "If Load with value4 Y has not been Ordered with fourth node Y, then Idle with node edge10 Y must exist."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a Load with value4 Y, whenever there is not an Ordered with fourth node Y, then there must be an Idle with node edge10 Y.",
            "NL": "Whenever Load with value4 Y does not have an Order with fourth node Y, then Idle with node edge10 Y must be present."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a Load with value4 Y, whenever there is not an Ordered with fourth node Y, then there must be an Idle with node edge10 Y.",
            "NL": "If Load value4 Y has not been Ordered with fourth node Y, then Idle node edge10 Y must be present."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a Load with value4 Y, whenever there is not an Ordered with fourth node Y, then there must be an Idle with node edge10 Y.",
            "NL": "If Load with value4 Y does not have an Ordered with fourth node Y, then Idle with node edge10 Y must exist."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a manAssignsScore with id1 M, and with id2 FV1, and with id3 FV2, whenever there is an womanAssignsScore with id1 W, and with id2 FV3, and with id3 FV4, whenever there is not an nonMatch with value M, and with id W, then there must be an nonmatch with value M, with id W. ",
            "NL": "If there is a manAssignsScore with id1 M, id2 FV1, and id3 FV2, and a womanAssignsScore with id1 W, id2 FV3, and id3 FV4, but there is no match with value M and id W, then there must be a nonmatch with value M and id W."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a manAssignsScore with id1 M, and with id2 FV1, and with id3 FV2, whenever there is an womanAssignsScore with id1 W, and with id2 FV3, and with id3 FV4, whenever there is not an nonMatch with value M, and with id W, then there must be an nonmatch with value M, with id W. ",
            "NL": "If there is a man with ID1 M, ID2 FV1, and ID3 FV2, a woman with ID1 W, ID2 FV3, and ID3 FV4, and no match with value M and ID W, then there must be a non-match with value M and ID W."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a manAssignsScore with id1 M, and with id2 FV1, and with id3 FV2, whenever there is an womanAssignsScore with id1 W, and with id2 FV3, and with id3 FV4, whenever there is not an nonMatch with value M, and with id W, then there must be an nonmatch with value M, with id W. ",
            "NL": "If a manAssignsScore with id1 M, id2 FV1, and id3 FV2 is present, and a womanAssignsScore with id1 W, id2 FV3, and id3 FV4 is also present, but there is no match with value M and id W, then there must be a nonmatch with value M and id W."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a manAssignsScore with id1 M, and with id2 FV1, and with id3 FV2, whenever there is an womanAssignsScore with id1 W, and with id2 FV3, and with id3 FV4, whenever there is not an nonMatch with value M, and with id W, then there must be an nonmatch with value M, with id W. ",
            "NL": "If there is a man with ID1 M, ID2 FV1, and ID3 FV2, a woman with ID1 W, ID2 FV3, and ID3 FV4, and there is no match with value M and ID W, then there must be a non-match with value M and ID W."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a manAssignsScore with id1 M, and with id2 FV1, and with id3 FV2, whenever there is an womanAssignsScore with id1 W, and with id2 FV3, and with id3 FV4, whenever there is not an nonMatch with value M, and with id W, then there must be an nonmatch with value M, with id W. ",
            "NL": "If there is no match between a manAssignsScore with id1 M, id2 FV1, and id3 FV2 and a womanAssignsScore with id1 W, id2 FV3, and id3 FV4, then the value M and id W must be a nonmatch."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a Match with key8 K, with field I greater than 8, then there must be a Planar_Embedding with key8 K, and with field I equal to 8.",
            "NL": "Whenever there is a Match with key8 K and field I greater than 8, it must also be accompanied by a Match with key8 K and field I equal to 8."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a Match with key8 K, with field I greater than 8, then there must be a Planar_Embedding with key8 K, and with field I equal to 8.",
            "NL": "If there is a Match with key8 K and Field I greater than 8, then there must also be a Match with Field I and Field I equal to 8."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a Match with key8 K, with field I greater than 8, then there must be a Planar_Embedding with key8 K, and with field I equal to 8.",
            "NL": "If there is a Match with key8 K and field I greater than 8, it is necessary to have a Match with field I and field I equal to 8."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a Match with key8 K, with field I greater than 8, then there must be a Planar_Embedding with key8 K, and with field I equal to 8.",
            "NL": "For every instance where there is a Match with key8 K and a field I value greater than 8, there must also be a Match with field I and a field I value of 8."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a Match with key8 K, with field I greater than 8, then there must be a Planar_Embedding with key8 K, and with field I equal to 8.",
            "NL": "Whenever a Match is found with key8 K and field I greater than 8, there must also be a Match with key8 K and field I equal to 8."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a match with value M, with id FV1 then we must have jailed with value M.",
            "NL": "Once the instance with value M and id FV1 was identified, it should have been incarcerated immediately."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a match with value M, with id FV1 then we must have jailed with value M.",
            "NL": "Once a match is found between value M and id FV1, we should have immediately incarcerated the case with value M."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a match with value M, with id FV1 then we must have jailed with value M.",
            "NL": "Once we identified a match of value M with id FV1, we should have immediately incarcerated the instance with value M."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a match with value M, with id FV1 then we must have jailed with value M.",
            "NL": "Once the instance with id FV1 was identified to possess a value of M, it had to be locked up."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a match with value M, with id FV1 then we must have jailed with value M.",
            "NL": "Once the instance with id FV1 and value M was discovered, it should have been immediately incarcerated."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a Maximum_Flow with edge5 P, with edge8 I, whenever there is a Difference with edge5 P, with edge8 L not after I, then there must be a Difference with edge5 P, and with edge8 G.",
            "NL": "If there is a Maximum Flow with edge5 P and edge8 I, and the letter L is not after I, then there must be a Difference with edge5 P and edge8 G."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a Maximum_Flow with edge5 P, with edge8 I, whenever there is a Difference with edge5 P, with edge8 L not after I, then there must be a Difference with edge5 P, and with edge8 G.",
            "NL": "If there is a Maximum_Flow with edge5 P and edge8 I, but edge8 L is not after I, then there must be a Difference with edge5 P and edge8 G."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a Maximum_Flow with edge5 P, with edge8 I, whenever there is a Difference with edge5 P, with edge8 L not after I, then there must be a Difference with edge5 P, and with edge8 G.",
            "NL": "If there is a Maximum Flow with edge5 P and edge8 I, but edge8 L is not after I, then a Difference must exist between edge5 P and edge8 G."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a Maximum_Flow with edge5 P, with edge8 I, whenever there is a Difference with edge5 P, with edge8 L not after I, then there must be a Difference with edge5 P, and with edge8 G.",
            "NL": "If there is a Maximum Flow with edge5 P and edge8 I, and L is not after I, then there must be a Difference with edge5 P and edge8 G."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a Maximum_Flow with edge5 P, with edge8 I, whenever there is a Difference with edge5 P, with edge8 L not after I, then there must be a Difference with edge5 P, and with edge8 G.",
            "NL": "If there is a Maximum_Flow with edge5 P, and edge8 I, but edge8 L is not after I, then there must be a Difference with edge5 P, and edge8 G."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a Minimum with vtx6 Y, and with node7 X, whenever there is not an Has with vtx6 Y, with node7 X, then there must be an Adjacent with vtx6 Y, with node7 X.",
            "NL": "If there is no Has with vtx6 Y and node7 X, but there is a Minimum with vtx6 Y and node7 X, then an Adjacent with vtx6 Y and node7 X must exist."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a Minimum with vtx6 Y, and with node7 X, whenever there is not an Has with vtx6 Y, with node7 X, then there must be an Adjacent with vtx6 Y, with node7 X.",
            "NL": "If there is no Hash associated with vtx6 Y and node7 X, but there is a Minimum, then an Adjacent must be present with vtx6 Y and node7 X."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a Minimum with vtx6 Y, and with node7 X, whenever there is not an Has with vtx6 Y, with node7 X, then there must be an Adjacent with vtx6 Y, with node7 X.",
            "NL": "If there is no Has with vtx6 Y and node7 X in conjunction with a Minimum with vtx6 Y and node7 X, then an Adjacent with vtx6 Y and node7 X must be present."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a Minimum with vtx6 Y, and with node7 X, whenever there is not an Has with vtx6 Y, with node7 X, then there must be an Adjacent with vtx6 Y, with node7 X.",
            "NL": "If there is no Has with vtx6 Y and node7 X while there is a Minimum with the same parameters, then we must have an Adjacent with vtx6 Y and node7 X."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a Minimum with vtx6 Y, and with node7 X, whenever there is not an Has with vtx6 Y, with node7 X, then there must be an Adjacent with vtx6 Y, with node7 X.",
            "NL": "If there is no Has with vtx6 Y and node7 X, but there is a Minimum with vtx6 Y and node7 X, then an Adjacent must be present with vtx6 Y and node7 X."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a Minimum_Cut with fourth node T, with second point I, whenever there is a Perfect_Graph with fourth node T, then we must have a Employed_Edge with id7 T, with key3 I or Simple_Graph with fourth node T, with second point I. ",
            "NL": "Whenever there is a Minimum_Cut with node T at the Fourth position and I at the second point, or a Perfect_Graph with node T at the Fourth position, or a Simple_Graph with node T at the Fourth and I at the Second, there must be an Employed_Edge with id7 T and key3 I."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a Minimum_Cut with fourth node T, with second point I, whenever there is a Perfect_Graph with fourth node T, then we must have a Employed_Edge with id7 T, with key3 I or Simple_Graph with fourth node T, with second point I. ",
            "NL": "Whenever there is a Minimum_Cut with fourth node T and second point I, or a Perfect_Graph with fourth node T, or a Simple_Graph with fourth node T and second point I, there must be an Employed_Edge with id7 T and key3 I."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a Minimum_Cut with fourth node T, with second point I, whenever there is a Perfect_Graph with fourth node T, then we must have a Employed_Edge with id7 T, with key3 I or Simple_Graph with fourth node T, with second point I. ",
            "NL": "If there is a Minimum_Cut at node T with point I, or a Perfect_Graph at node T, then there must be an Employed_Edge with id7 T and key3 I, or a Simple_Graph at node T with point I."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a Minimum_Cut with fourth node T, with second point I, whenever there is a Perfect_Graph with fourth node T, then we must have a Employed_Edge with id7 T, with key3 I or Simple_Graph with fourth node T, with second point I. ",
            "NL": "Whenever fourth node T and second point I are present in a Minimum_Cut or Perfect_Graph, there must be an Employed_Edge with id7 T and key3 I, or a Simple_Graph with fourth node T and second point I."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a Minimum_Cut with fourth node T, with second point I, whenever there is a Perfect_Graph with fourth node T, then we must have a Employed_Edge with id7 T, with key3 I or Simple_Graph with fourth node T, with second point I. ",
            "NL": "Whenever there is a Minimum_Cut containing node T with point I, or a Perfect_Graph containing node T, there must be an Employed_Edge with id7 T and key3 I, or a Simple_Graph containing node T with point I."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a Minimum_Cut with id3 M, with vtx5 Y, with node8 X, with node1 C, and with value9 I, then there must be a Explore with id3 M, with vtx5 C, with node8 I.",
            "NL": "Whenever there is a Minimum_Cut with id3 M, vtx5 Y, node8 X, node1 C, and value9 I, it is necessary that there is also an Explore with id3 M, vtx5 C, and node8 I."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a Minimum_Cut with id3 M, with vtx5 Y, with node8 X, with node1 C, and with value9 I, then there must be a Explore with id3 M, with vtx5 C, with node8 I.",
            "NL": "Whenever there is a Minimum_Cut with id3 M, vtx5 Y, node8 X, node1 C, and value9 I, it must also be the case that there is an Explore with id3 M, vtx5 C, and node8 I."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a Minimum_Cut with id3 M, with vtx5 Y, with node8 X, with node1 C, and with value9 I, then there must be a Explore with id3 M, with vtx5 C, with node8 I.",
            "NL": "Whenever there is a Minimum_Cut with id3 M, vtx5 Y, node8 X, node1 C, and value9 I, it is necessary for there to be an Explore with id3 M, vtx5 C, and node8 I."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a Minimum_Cut with id3 M, with vtx5 Y, with node8 X, with node1 C, and with value9 I, then there must be a Explore with id3 M, with vtx5 C, with node8 I.",
            "NL": "When there is a Minimum_Cut with id3 M, vtx5 Y, node8 X, node1 C, and value9 I, it is necessary that there is also an Explore with id3 M, vtx5 C, and node8 I."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a Minimum_Cut with id3 M, with vtx5 Y, with node8 X, with node1 C, and with value9 I, then there must be a Explore with id3 M, with vtx5 C, with node8 I.",
            "NL": "If there is a Minimum_Cut with id3 M, vtx5 Y, node8 X, node1 C, and value9 I, then there must also be an Explore with id3 M, vtx5 C, and node8 I."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a mvlabel with field1 W, with field2 U, with field3 S different from T, whenever there is a mllabel with field1 W different from V, with field2 U, with field3 V, with field4 T, then there must be a minfl with field1 W, with field2 V, with field3 M.",
            "NL": "If the value for field1 (W) is different than the value for field3 (V) for a mllabel, and the value for field3 (S) for that mllabel is different than the value for field4 (T) for that mllabel, then there must be a minfl with field1 set to the value of W, field2 set to the value of V, and field3 set to the value of M."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a mvlabel with field1 W, with field2 U, with field3 S different from T, whenever there is a mllabel with field1 W different from V, with field2 U, with field3 V, with field4 T, then there must be a minfl with field1 W, with field2 V, with field3 M.",
            "NL": "Whenever there is a mvlabel with field1 W, field2 U, and field3 S, and a mllabel with field1 W, field2 U, field3 V, and field4 T, where W is not equal to V and S is not equal to T, there must be a minfl with field1 W, field2 V, and field3 M."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a mvlabel with field1 W, with field2 U, with field3 S different from T, whenever there is a mllabel with field1 W different from V, with field2 U, with field3 V, with field4 T, then there must be a minfl with field1 W, with field2 V, with field3 M.",
            "NL": "If a mvlabel has field1 as W, field2 as U, and field3 as S, and another mllabel has field1 as W, field2 as U, field3 as V, and field4 as T, provided that W is not equal to V and S is not equal to T, then there must be a minfl with field1 as W, field2 as V, and field3 as M."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a mvlabel with field1 W, with field2 U, with field3 S different from T, whenever there is a mllabel with field1 W different from V, with field2 U, with field3 V, with field4 T, then there must be a minfl with field1 W, with field2 V, with field3 M.",
            "NL": "If field1 W is not equal to field1 V and field3 S is not equal to field4 T of a mvlabel, then a minfl must exist with field1 W, field2 V, and field3 M."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a mvlabel with field1 W, with field2 U, with field3 S different from T, whenever there is a mllabel with field1 W different from V, with field2 U, with field3 V, with field4 T, then there must be a minfl with field1 W, with field2 V, with field3 M.",
            "NL": "If the value of field1 (W) in a mvlabel is different from the value of field1 (V) in a mllabel and the value of field3 (S) in the mvlabel is not the same as the value of field4 (T) in the mllabel, a minfl must exist with field1 equal to W, field2 equal to V, and field3 equal to M."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a mvlabel with field1 W, with field2 U, with field3 S, whenever there is a mllabel with field1 W different from V, with field2 U, with field3 V, with field4 S, then there must be a minfl with field1 W, with field2 V, with field3 P.",
            "NL": "If there is a mvlabel with field1 W, field2 U, and field3 S, and the value of W is not equal to V in a mllabel with field1 W, field2 U, field3 V, and field4 S, then a minfl must exist with field1 W, field2 V, and field3 P."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a mvlabel with field1 W, with field2 U, with field3 S, whenever there is a mllabel with field1 W different from V, with field2 U, with field3 V, with field4 S, then there must be a minfl with field1 W, with field2 V, with field3 P.",
            "NL": "If the value of field1 in the mvlabel is not equal to the value of field1 in the mllabel, and the values of field2 and field3 are the same in both labels, then there must be a minfl with field1 equal to the value of field1 in the mvlabel, field2 equal to the value of field1 in the mllabel, and field3 set to P."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a mvlabel with field1 W, with field2 U, with field3 S, whenever there is a mllabel with field1 W different from V, with field2 U, with field3 V, with field4 S, then there must be a minfl with field1 W, with field2 V, with field3 P.",
            "NL": "If field1 W is not equal to field3 V in a mvlabel with field1 W, field2 U, and field3 S, then there must be a minfl with field1 W, field2 V, and field3 P."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a mvlabel with field1 W, with field2 U, with field3 S, whenever there is a mllabel with field1 W different from V, with field2 U, with field3 V, with field4 S, then there must be a minfl with field1 W, with field2 V, with field3 P.",
            "NL": "If the value of field1 (W) is different in the mvlabel and mllabel, there must be a corresponding minfl with field1 (W), field2 (V) and field3 (P)."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a mvlabel with field1 W, with field2 U, with field3 S, whenever there is a mllabel with field1 W different from V, with field2 U, with field3 V, with field4 S, then there must be a minfl with field1 W, with field2 V, with field3 P.",
            "NL": "If the value of field1 in a mvlabel is W and fields 2 and 3 are respectively U and S, and the corresponding mllabel has field1 W, fields 2 and 3 U and V, and field4 S, but W is not equal to V, then there must be a minfl with field1 W, field2 V, and field3 P."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a next with field1 X, with field2 C1, with field3 Y1, with field4 C2, and with field5 Y2, then there must be a pred with field1 X, with field2 C1, with field3 Y1, with field4 C2, and with field5 Y2. ",
            "NL": "If field1 X, field2 C1, field3 Y1, field4 C2, and field5 Y2 are present, a prediction with the same values must be made."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a next with field1 X, with field2 C1, with field3 Y1, with field4 C2, and with field5 Y2, then there must be a pred with field1 X, with field2 C1, with field3 Y1, with field4 C2, and with field5 Y2. ",
            "NL": "If field1 is X, field2 is C1, field3 is Y1, field4 is C2, and field5 is Y2, then a prediction with the same values must be made."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a next with field1 X, with field2 C1, with field3 Y1, with field4 C2, and with field5 Y2, then there must be a pred with field1 X, with field2 C1, with field3 Y1, with field4 C2, and with field5 Y2. ",
            "NL": "If field1 is X, field2 is C1, field3 is Y1, field4 is C2, and field5 is Y2, then a prediction must be made with the same values for each field."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a next with field1 X, with field2 C1, with field3 Y1, with field4 C2, and with field5 Y2, then there must be a pred with field1 X, with field2 C1, with field3 Y1, with field4 C2, and with field5 Y2. ",
            "NL": "If field1 is X, field2 is C1, field3 is Y1, field4 is C2, and field5 is Y2, then there must be a prediction that reflects these values."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a next with field1 X, with field2 C1, with field3 Y1, with field4 C2, and with field5 Y2, then there must be a pred with field1 X, with field2 C1, with field3 Y1, with field4 C2, and with field5 Y2. ",
            "NL": "If an instance of field1 X, field2 C1, field3 Y1, field4 C2, and field5 Y2 is present, then the prediction will also include field1 X, field2 C1, field3 Y1, field4 C2, and field5 Y2."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a next with field1 X, with field2 C1, with field3 Y1, with field4 C2, and with field5 Y2, then there must be a succ with field1 X, with field2 C2, with field3 Y2.",
            "NL": "Whenever field1 is X, field2 is C1, field3 is Y1, field4 is C2, and field5 is Y2, it is necessary for there to be a success with field1 X, field2 C2, and field3 Y2."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a next with field1 X, with field2 C1, with field3 Y1, with field4 C2, and with field5 Y2, then there must be a succ with field1 X, with field2 C2, with field3 Y2.",
            "NL": "Whenever there is a next with field1 X, field2 C1, field3 Y1, field4 C2, and field5 Y2, it is necessary for there to be a success with field1 X, field2 C2, and field3 Y2."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a next with field1 X, with field2 C1, with field3 Y1, with field4 C2, and with field5 Y2, then there must be a succ with field1 X, with field2 C2, with field3 Y2.",
            "NL": "Whenever field1 X, field2 C1, field3 Y1, field4 C2, and field5 Y2 are present, there must be a success with field1 X, field2 C2, and field3 Y2."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a next with field1 X, with field2 C1, with field3 Y1, with field4 C2, and with field5 Y2, then there must be a succ with field1 X, with field2 C2, with field3 Y2.",
            "NL": "Whenever field1 X, field2 C1, field3 Y1, field4 C2, and field5 Y2 exist together, a success with field1 X, field2 C2, and field3 Y2 must also be present."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a next with field1 X, with field2 C1, with field3 Y1, with field4 C2, and with field5 Y2, then there must be a succ with field1 X, with field2 C2, with field3 Y2.",
            "NL": "Whenever field1 X, field2 C1, field3 Y1, field4 C2, and field5 Y2 are present, a successful outcome with field1 X, field2 C2, and field3 Y2 is guaranteed."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a next with value C1 , with id1 C2, whenever there is an index with value C1, and with id1 I, then there must be an index with value C2 , with id1 I+1.",
            "NL": "Whenever C1 is the value of the next, C2 is the ID1, and C1 is the value of the index, then the index with value C2 must have an ID1 of I+1."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a next with value C1 , with id1 C2, whenever there is an index with value C1, and with id1 I, then there must be an index with value C2 , with id1 I+1.",
            "NL": "If there is a next value C1 and id1 C2, as well as an index with value C1 and the same id1, then an index with value C2 and id1 I+1 must exist."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a next with value C1 , with id1 C2, whenever there is an index with value C1, and with id1 I, then there must be an index with value C2 , with id1 I+1.",
            "NL": "If C1 is the value for the next index with id1 C2, then the subsequent index must have a value of C2 and an id1 of I+1."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a next with value C1 , with id1 C2, whenever there is an index with value C1, and with id1 I, then there must be an index with value C2 , with id1 I+1.",
            "NL": "Whenever C1 is the value of the next with id1 C2, and C1 is the value of the index with id1, then we must have C2 as the value of the index with id1 I+1."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a next with value C1 , with id1 C2, whenever there is an index with value C1, and with id1 I, then there must be an index with value C2 , with id1 I+1.",
            "NL": "Whenever there is a value C1 with id1 C2 and an index with value C1 and id1 I, then there must be an index with value C2 and id1 I+1."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a node N, whenever there is not an notChosenColour with value N, with id1 C, whenever there is index with value C, and with id1 I less than or equal to N, then there must be an chosenColour with value N, with id1 C.",
            "NL": "If N is a node, I is the id1 of an index with value C, and C is the id1 of a not chosencolour with value N, and I is less than or equal to N, then a chosencolour with value N and id1 C must exist."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a node N, whenever there is not an notChosenColour with value N, with id1 C, whenever there is index with value C, and with id1 I less than or equal to N, then there must be an chosenColour with value N, with id1 C.",
            "NL": "If a node N has an index with value C and an ID of I, and a not chosen colour with value N and an ID of C, and I is less than or equal to N, then there must be a chosen colour with value N and an ID of C."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a node N, whenever there is not an notChosenColour with value N, with id1 C, whenever there is index with value C, and with id1 I less than or equal to N, then there must be an chosenColour with value N, with id1 C.",
            "NL": "If the value of id1 I is less than or equal to N, and there is a node N with an index C and id1 I as well as not chosencolour with value N and id1 C, then there must be a chosencolour with value N and id1 C."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a node N, whenever there is not an notChosenColour with value N, with id1 C, whenever there is index with value C, and with id1 I less than or equal to N, then there must be an chosenColour with value N, with id1 C.",
            "NL": "If the value of id1 I is less than or equal to N for a node N with an index with value C and id1 I, and not chosencolour with value N and id1 C, then a chosencolour with value N and id1 C must exist."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a node N, whenever there is not an notChosenColour with value N, with id1 C, whenever there is index with value C, and with id1 I less than or equal to N, then there must be an chosenColour with value N, with id1 C.",
            "NL": "If a node N exists, along with an index with value C and id1 I, where not chosencolour has a value of N and id1 C, and I is less than or equal to N, then a chosencolour must have a value of N and id1 C."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a node with edge X, whenever there is not an Clique with first node X, then there must be an nonclique with node value X.",
            "NL": "Whenever there is a node with edge X that does not form a clique with node X, there must be a non-clique with node X."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a node with edge X, whenever there is not an Clique with first node X, then there must be an nonclique with node value X.",
            "NL": "Whenever there is a node with edge X that does not belong to any clique containing node X, there must be a nonclique containing node X."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a node with edge X, whenever there is not an Clique with first node X, then there must be an nonclique with node value X.",
            "NL": "Whenever a node with edge X does not have a clique containing it, there must be a nonclique containing it."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a node with edge X, whenever there is not an Clique with first node X, then there must be an nonclique with node value X.",
            "NL": "If a node with edge X does not have a clique containing node X, then there must be a nonclique with node X."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a node with edge X, whenever there is not an Clique with first node X, then there must be an nonclique with node value X.",
            "NL": "Whenever there is a node connected by edge X without a clique including node X, there must be a non-clique containing node X."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a node with edge X, whenever there is not an nonClique with first node X, then there must be an clique with node value X.",
            "NL": "If there is not a nonclique with the first node being X, then there must be a clique with the node value of X for every node with edge X."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a node with edge X, whenever there is not an nonClique with first node X, then there must be an clique with node value X.",
            "NL": "Whenever there is a node with edge X that does not contain a nonclique with the first node being X, there must be a clique consisting of node X."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a node with edge X, whenever there is not an nonClique with first node X, then there must be an clique with node value X.",
            "NL": "If there is a node with edge X that does not have a nonclique with the first node being X, then there must be a clique with node X."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a node with edge X, whenever there is not an nonClique with first node X, then there must be an clique with node value X.",
            "NL": "If there is a node with edge X that does not have a nonclique starting with node X, then there must be a clique containing node X."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a node with edge X, whenever there is not an nonClique with first node X, then there must be an clique with node value X.",
            "NL": "Whenever there is a node with edge X that does not have a non-clique with its first node being X, then there must be a clique with the node value X."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a Non_Clique with node10 W, with id10 I, whenever there is a Weighted with field9 X, whenever there is not a Bucket with node10 I, whenever there is not a Bucket with node10 X, whenever there is a Weighted with field9 I, whenever there is an Undirected with edge4 I, and with value10 X different from I, whenever there is an Undirected with edge4 X, and with value10 I, whenever there is not a Contains with edge4 X, with value10 I, with node2 O, then there must be a Contains with edge4 X, with value10 I, with node2 U.",
            "NL": "If there is a Non_Clique with node10 W, id10 I, a Weighted with field9 X, no Bucket with node10 I or X, a Weighted with field9 I, an Undirected with edge4 I, value10 X different from I, an Undirected with edge4 X, value10 I, and no Contains with edge4 X, value10 I, node2 U, then there must be a Contains with edge4 X, value10 I, node2 O."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a Non_Clique with node10 W, with id10 I, whenever there is a Weighted with field9 X, whenever there is not a Bucket with node10 I, whenever there is not a Bucket with node10 X, whenever there is a Weighted with field9 I, whenever there is an Undirected with edge4 I, and with value10 X different from I, whenever there is an Undirected with edge4 X, and with value10 I, whenever there is not a Contains with edge4 X, with value10 I, with node2 O, then there must be a Contains with edge4 X, with value10 I, with node2 U.",
            "NL": "If there is a Non_Clique with node10 W and id10 I, a Weighted with field9 X, no Bucket with node10 I or X, a Weighted with field9 I, an Undirected with edge4 I and value10 X different from I, an Undirected with edge4 X and value10 I, but no Contains with edge4 X, value10 I, and node2 U, then there must be a Contains with edge4 X, value10 I, and node2 O."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a Non_Clique with node10 W, with id10 I, whenever there is a Weighted with field9 X, whenever there is not a Bucket with node10 I, whenever there is not a Bucket with node10 X, whenever there is a Weighted with field9 I, whenever there is an Undirected with edge4 I, and with value10 X different from I, whenever there is an Undirected with edge4 X, and with value10 I, whenever there is not a Contains with edge4 X, with value10 I, with node2 O, then there must be a Contains with edge4 X, with value10 I, with node2 U.",
            "NL": "If there is a Non_Clique with node10 W, id10 I, a Weighted with field9 X, but not a Bucket with node10 I or X, a Weighted with field9 I, an Undirected with edge4 I and value10 X that is different from I, an Undirected with edge4 X and value10 I, but not a Contains with edge4 X, value10 I, and node2 U, then there must be a Contains with edge4 X, value10 I, and node2 O."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a Non_Clique with node10 W, with id10 I, whenever there is a Weighted with field9 X, whenever there is not a Bucket with node10 I, whenever there is not a Bucket with node10 X, whenever there is a Weighted with field9 I, whenever there is an Undirected with edge4 I, and with value10 X different from I, whenever there is an Undirected with edge4 X, and with value10 I, whenever there is not a Contains with edge4 X, with value10 I, with node2 O, then there must be a Contains with edge4 X, with value10 I, with node2 U.",
            "NL": "If there is a Non_Clique with node10 W and id10 I, a Weighted with field9 X, but no Bucket with node10 I or X, a Weighted with field9 I, an Undirected with edge4 I and value10 X different from I, an Undirected with edge4 X and value10 I, but no Contains with edge4 X, value10 I, node2 U, then there must be a Contains with edge4 X, value10 I, node2 O."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a Non_Clique with node10 W, with id10 I, whenever there is a Weighted with field9 X, whenever there is not a Bucket with node10 I, whenever there is not a Bucket with node10 X, whenever there is a Weighted with field9 I, whenever there is an Undirected with edge4 I, and with value10 X different from I, whenever there is an Undirected with edge4 X, and with value10 I, whenever there is not a Contains with edge4 X, with value10 I, with node2 O, then there must be a Contains with edge4 X, with value10 I, with node2 U.",
            "NL": "If there is a Non_Clique with node10 W, having id10 I, a Weighted with field9 X, no Bucket with node10 I or X, a Weighted with field9 I, an Undirected with edge4 I and value10 X different from I, an Undirected with edge4 X and value10 I, but no Contains with edge4 X, value10 I, and node2 U, then there must be a Contains with edge4 X, value10 I, and node2 O."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a NonActive with fifth id equal to 21, whenever there is a Accomplishment with field3 Q, with node1 L, whenever there is a Remaining with field3 U, whenever there is not a Maximum_Matching with field10 L, Whenever there is not a Sign with field10 L, whenever there is not a Identifier with vtx3 Q, with field L, with key6 T, whenever there is not a Identifier with vtx3 Q, with field L, with key6 B, then we must have an Inactive with value6 Q, with vtx9 L, with value5 U. ",
            "NL": "If there is a NonActive with Fifth ID equal to 21, an Accomplishment with field3 Q and node1 L, a Remaining with field3 U, no Maximum_Matching with field10 L, no Sign with field10 L, no Identifier with vtx3 Q, field L, and key6 T, and no Identifier with vtx3 Q, field L, and key6 B, then an Inactive with value6 Q, vtx9 L, and value5 U must be present."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a NonActive with fifth id equal to 21, whenever there is a Accomplishment with field3 Q, with node1 L, whenever there is a Remaining with field3 U, whenever there is not a Maximum_Matching with field10 L, Whenever there is not a Sign with field10 L, whenever there is not a Identifier with vtx3 Q, with field L, with key6 T, whenever there is not a Identifier with vtx3 Q, with field L, with key6 B, then we must have an Inactive with value6 Q, with vtx9 L, with value5 U. ",
            "NL": "Whenever a NonActive with fifth id equal to 21 exists, an Accomplishment with field3 Q, node1 L, a Remaining with field3 U, no Maximum_Matching with field10 L, no Sign with field10 L, no Identifier with vtx3 Q, field L, key6 T, and no Identifier with vtx3 Q, field L, key6 B is present, then an Inactive with value6 Q, vtx9 L, and value5 U must be present."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a NonActive with fifth id equal to 21, whenever there is a Accomplishment with field3 Q, with node1 L, whenever there is a Remaining with field3 U, whenever there is not a Maximum_Matching with field10 L, Whenever there is not a Sign with field10 L, whenever there is not a Identifier with vtx3 Q, with field L, with key6 T, whenever there is not a Identifier with vtx3 Q, with field L, with key6 B, then we must have an Inactive with value6 Q, with vtx9 L, with value5 U. ",
            "NL": "If there is no NonActive with a fifth id equal to 21, no Accomplishment with field3 Q, node1 L, no Remaining with field3 U, no Maximum_Matching with field10 L, no Sign with field10 L, no Identifier with vtx3 Q, field L, and key6 T, and no Identifier with vtx3 Q, field L, and key6 B, then we must have an Inactive with value6 Q, vtx9 L, and value5 U."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a NonActive with fifth id equal to 21, whenever there is a Accomplishment with field3 Q, with node1 L, whenever there is a Remaining with field3 U, whenever there is not a Maximum_Matching with field10 L, Whenever there is not a Sign with field10 L, whenever there is not a Identifier with vtx3 Q, with field L, with key6 T, whenever there is not a Identifier with vtx3 Q, with field L, with key6 B, then we must have an Inactive with value6 Q, with vtx9 L, with value5 U. ",
            "NL": "If there is not a NonActive with a fifth id equal to 21, no Accomplishment with field3 Q, node1 L, no Remaining with field3 U, a Maximum_Matching with field10 L, a Sign with field10 L, an Identifier with vtx3 Q, field L, key6 T, and an Identifier with vtx3 Q, field L, key6 B, then there must be an Inactive with value6 Q, vtx9 L, and value5 U."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a NonActive with fifth id equal to 21, whenever there is a Accomplishment with field3 Q, with node1 L, whenever there is a Remaining with field3 U, whenever there is not a Maximum_Matching with field10 L, Whenever there is not a Sign with field10 L, whenever there is not a Identifier with vtx3 Q, with field L, with key6 T, whenever there is not a Identifier with vtx3 Q, with field L, with key6 B, then we must have an Inactive with value6 Q, with vtx9 L, with value5 U. ",
            "NL": "If there is no NonActive with fifth id equal to 21, no Accomplishment with field3 Q and node1 L, no Remaining with field3 U, no Maximum_Matching with field10 L, no Sign with field10 L, no Identifier with vtx3 Q, field L, and key6 T, and no Identifier with vtx3 Q, field L, and key6 B, then an Inactive with value6 Q, vtx9 L, and value5 U must exist."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a obs_vlabel with id1 U, with id2 S, whenever there is an edge with value U, with id V, whenever there is a vertex with value W, whenever there is not a trivial with value V, whenever there is not a trivial with value W, whenever there is not an input with value V, whenever there is not an input with value W different from V, then there must be a mvlabel with field1 W, with field2 U, with field3 S.",
            "NL": "Whenever there is an observation label with ID U, ID S, there is an edge with value U and ID V, a vertex with value W, and no trivial with value V or W; and when there is no input with value V, there is also no input with value W (where W does not equal V), then there must be a multi-valued label with Field1 W, Field2 U, and Field3 S."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a obs_vlabel with id1 U, with id2 S, whenever there is an edge with value U, with id V, whenever there is a vertex with value W, whenever there is not a trivial with value V, whenever there is not a trivial with value W, whenever there is not an input with value V, whenever there is not an input with value W different from V, then there must be a mvlabel with field1 W, with field2 U, with field3 S.",
            "NL": "If there is an observation label with id1 U, id2 S, an edge with value U, id V, a vertex with value W, and W is not equal to V, but there is no trivial with value V or W, and no input with value V or W, then there must be a multi-valued label with field1 W, field2 U, and field3 S."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a obs_vlabel with id1 U, with id2 S, whenever there is an edge with value U, with id V, whenever there is a vertex with value W, whenever there is not a trivial with value V, whenever there is not a trivial with value W, whenever there is not an input with value V, whenever there is not an input with value W different from V, then there must be a mvlabel with field1 W, with field2 U, with field3 S.",
            "NL": "Whenever there is an observable label with id1 U, id2 S, an edge with value U, and a vertex with value W, that is not equal to V, where there is no input with value V or W, then there must be a multivalued label with field1 W, field2 U, and field3 S."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a obs_vlabel with id1 U, with id2 S, whenever there is an edge with value U, with id V, whenever there is a vertex with value W, whenever there is not a trivial with value V, whenever there is not a trivial with value W, whenever there is not an input with value V, whenever there is not an input with value W different from V, then there must be a mvlabel with field1 W, with field2 U, with field3 S.",
            "NL": "If there is an observation label with id1 U, id2 S, an edge with value U and id V, a vertex with value W, no trivial with value V or W, no input with value V, and W is not equal to V, then there must be a multivalued label with field1 W, field2 U, and field3 S."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a obs_vlabel with id1 U, with id2 S, whenever there is an edge with value U, with id V, whenever there is a vertex with value W, whenever there is not a trivial with value V, whenever there is not a trivial with value W, whenever there is not an input with value V, whenever there is not an input with value W different from V, then there must be a mvlabel with field1 W, with field2 U, with field3 S.",
            "NL": "Whenever there is an observable label (obs_vlabel) with an id1 of U, an id2 of S, an edge with value U, a vertex with value W, no trivial with value V, and no trivial with value W, and no input with value V or W (where W is not equal to V), then there must be a multi-valued label (mvlabel) with field1 W, field2 U, and field3 S."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a Offspring with field1 Y, with edge2 W, whenever there is a Input_Data with field1 Y, with edge2 D not after W, then there must be a Input_Data with field1 Y, and with edge2 B.",
            "NL": "If there is an Offspring with field1 Y, and edge2 W, and Input_Data with field1 Y, and edge2 D where D is not after W, then there must be an Input_Data with field1 Y and edge2 B."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a Offspring with field1 Y, with edge2 W, whenever there is a Input_Data with field1 Y, with edge2 D not after W, then there must be a Input_Data with field1 Y, and with edge2 B.",
            "NL": "If field1 of an Offspring is Y, and edge2 of the Offspring is W, and edge2 of a corresponding Input_Data is not D (which must come after W), then there must be an Input_Data with field1 Y and edge2 B."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a Offspring with field1 Y, with edge2 W, whenever there is a Input_Data with field1 Y, with edge2 D not after W, then there must be a Input_Data with field1 Y, and with edge2 B.",
            "NL": "If a Input_Data with field1 Y and edge2 W exists, and it is not followed by a Input_Data with field1 Y and edge2 D, then there must be a Input_Data with field1 Y and edge2 B."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a Offspring with field1 Y, with edge2 W, whenever there is a Input_Data with field1 Y, with edge2 D not after W, then there must be a Input_Data with field1 Y, and with edge2 B.",
            "NL": "If an Offspring has field1 Y, edge2 W, and there is an Input_Data with field1 Y, edge2 D, but D does not follow W, then a Input_Data with field1 Y, and edge2 B must exist."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a Offspring with field1 Y, with edge2 W, whenever there is a Input_Data with field1 Y, with edge2 D not after W, then there must be a Input_Data with field1 Y, and with edge2 B.",
            "NL": "If an Offspring has field1 Y, edge2 W and there is an Input_Data with field1 Y, edge2 D which is not after W, a Input_Data with field1 Y and edge2 B must exist."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a oppo with field1 U, with field2 V, Whenever there is a coppo with field1 W, with field2 V, Whenever there is a ntedge with id1 W, with id2 U, with id3 V, then we must have a coppo with field1 U, with field2 V. ",
            "NL": "If there is an oppo with field1 U and field2 V, then a coppo with field1 W and field2 V, a ntedge with id1 W, id2 U, and id3 V should also exist, and a coppo with field1 U and field2 V must be present."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a oppo with field1 U, with field2 V, Whenever there is a coppo with field1 W, with field2 V, Whenever there is a ntedge with id1 W, with id2 U, with id3 V, then we must have a coppo with field1 U, with field2 V. ",
            "NL": "Whenever there is an oppo with field1 U and field2 V, then a coppo with field1 W and field2 V, as well as a ntedge with id1 W, id2 U, and id3 V must be present; the coppo must have field1 U and field2 V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a oppo with field1 U, with field2 V, Whenever there is a coppo with field1 W, with field2 V, Whenever there is a ntedge with id1 W, with id2 U, with id3 V, then we must have a coppo with field1 U, with field2 V. ",
            "NL": "If there is an oppo containing field1 U and field2 V, a coppo with field1 W and field2 V, and a ntedge with id1 W, id2 U, and id3 V, then a coppo must also have field1 U and field2 V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a oppo with field1 U, with field2 V, Whenever there is a coppo with field1 W, with field2 V, Whenever there is a ntedge with id1 W, with id2 U, with id3 V, then we must have a coppo with field1 U, with field2 V. ",
            "NL": "Whenever we encounter an oppo with field1 U and field2 V, then a coppo with field1 W and field2 V and a ntedge with id1 W, id2 U and id3 V must also exist, and so must a coppo with field1 U and field2 V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a oppo with field1 U, with field2 V, Whenever there is a coppo with field1 W, with field2 V, Whenever there is a ntedge with id1 W, with id2 U, with id3 V, then we must have a coppo with field1 U, with field2 V. ",
            "NL": "If there is an oppo with field1 U and field2 V, then there must be a coppo with field1 W and field2 V, as well as a ntedge with id1 W, id2 U, and id3 V, and a coppo with field1 U and field2 V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a oppo with field1 U, with field2 V, Whenever there is a first with field1 U, with field2 V, then we must have a coppo with field1 U, with field2 V.",
            "NL": "Whenever there is an opportunity with field1 U and field2 V, there will also be a first with the same field1 U and field2 V, and thus we must have a counterpart with field1 U and field2 V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a oppo with field1 U, with field2 V, Whenever there is a first with field1 U, with field2 V, then we must have a coppo with field1 U, with field2 V.",
            "NL": "In the presence of an opportunity with field1 U and field2 V, a first with field1 U and field2 V must always be followed by a coppo with field1 U and field2 V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a oppo with field1 U, with field2 V, Whenever there is a first with field1 U, with field2 V, then we must have a coppo with field1 U, with field2 V.",
            "NL": "Whenever there is an opportunity with field1 U and field2 V, followed by a first with the same field1 U and field2 V, then it is necessary to have a coppo with field1 U and field2 V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a oppo with field1 U, with field2 V, Whenever there is a first with field1 U, with field2 V, then we must have a coppo with field1 U, with field2 V.",
            "NL": "Whenever there is an opponent with field1 U and field2 V, then a first with the same field1 U and field2 V must also be present, followed by a copo with field1 U and field2 V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a oppo with field1 U, with field2 V, Whenever there is a first with field1 U, with field2 V, then we must have a coppo with field1 U, with field2 V.",
            "NL": "Whenever there is an opportunity with field1 U and field2 V, followed by a first with field1 U and field2 V, there must then be a coppo with field1 U and field2 V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a partition with value U, with id K, whenever there is not an existsless with id1 U, with id2 K, then we must have a reach with id1 K, and with id2 U. ",
            "NL": "If there is no partition with value U and id K, then we must have a reach with id1 K and id2 U."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a partition with value U, with id K, whenever there is not an existsless with id1 U, with id2 K, then we must have a reach with id1 K, and with id2 U. ",
            "NL": "If a partition has a value of U and an ID of K, but does not exist with IDs of U and K, respectively, then the reach must possess IDs of K and U."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a partition with value U, with id K, whenever there is not an existsless with id1 U, with id2 K, then we must have a reach with id1 K, and with id2 U. ",
            "NL": "If we have a partition with value U and id K that does not exist with id1 U and id2 K, then we must have a reach with id1 K and id2 U."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a partition with value U, with id K, whenever there is not an existsless with id1 U, with id2 K, then we must have a reach with id1 K, and with id2 U. ",
            "NL": "If we have a partition with the value U and id K, but not with id1 U and id2 K, then we must have a reach with id1 K and id2 U."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a partition with value U, with id K, whenever there is not an existsless with id1 U, with id2 K, then we must have a reach with id1 K, and with id2 U. ",
            "NL": "If there is no partition with value U and id K, but there is one with id1 U and id2 K, then we must have a reach with id1 K and id2 U."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a reach with first vtx Z, with second vtx V, whenever there is an used_edge with first vtx U, with second vtx Z, then we must have a reach with first vtx U, with second vtx V.",
            "NL": "There must be a reach between the first vertex U and second vertex V, since there is a reach between the first vertex Z and second vertex V, as well as a used_edge between the first vertex U and second vertex Z."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a reach with first vtx Z, with second vtx V, whenever there is an used_edge with first vtx U, with second vtx Z, then we must have a reach with first vtx U, with second vtx V.",
            "NL": "A reach between the first vertex U and second vertex V must exist if there is a reach between the first vertex Z and second vertex V, and a used_edge between the first vertex U and second vertex Z."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a reach with first vtx Z, with second vtx V, whenever there is an used_edge with first vtx U, with second vtx Z, then we must have a reach with first vtx U, with second vtx V.",
            "NL": "It is implied that there must be a reach between the first vertex U and second vertex V due to the existence of a reach between the first vertex Z and second vertex V as well as a used_edge between the first vertex U and second vertex Z."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a reach with first vtx Z, with second vtx V, whenever there is an used_edge with first vtx U, with second vtx Z, then we must have a reach with first vtx U, with second vtx V.",
            "NL": "The existence of a reach between vertex Z and V, together with a used_edge between U and Z, implies that there must also be a reach between U and V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a reach with first vtx Z, with second vtx V, whenever there is an used_edge with first vtx U, with second vtx Z, then we must have a reach with first vtx U, with second vtx V.",
            "NL": "The existence of a reach between vertex Z and vertex V, along with a used_edge between vertex U and vertex Z, implies that there must also be a reach between vertex U and vertex V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a reached with node X, whenever there is an edge with first node X, and with second node Y, whenever there is not an inpath with first node X, and with second node Y, then there must be an outpath with first node X, and with second node Y.",
            "NL": "An edge must exist between Node X and Node Y, even when there is no in path from Node X to Node Y and no out path from Node Y to Node X."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a reached with node X, whenever there is an edge with first node X, and with second node Y, whenever there is not an inpath with first node X, and with second node Y, then there must be an outpath with first node X, and with second node Y.",
            "NL": "A point with node X, an in-edge with first node X, and an out-edge with second node Y must be present, even if there is no in-path with first node X and with second node Y, there must be an out-path with first node X and with second node Y."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a reached with node X, whenever there is an edge with first node X, and with second node Y, whenever there is not an inpath with first node X, and with second node Y, then there must be an outpath with first node X, and with second node Y.",
            "NL": "To be valid, an in path with first node X, an out path with first node X, an edge with first node X, an edge with second node Y, and a reached point with node X must all be present, even if there is no in path with second node Y and no out path with second node Y."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a reached with node X, whenever there is an edge with first node X, and with second node Y, whenever there is not an inpath with first node X, and with second node Y, then there must be an outpath with first node X, and with second node Y.",
            "NL": "A path must exist with node X as the starting point, an edge with node X as the first node, and an edge with node Y as the second node; even if there is no in path with node X as the first node and node Y as the second node, there must be an out path with node X as the first node and node Y as the second node."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a reached with node X, whenever there is an edge with first node X, and with second node Y, whenever there is not an inpath with first node X, and with second node Y, then there must be an outpath with first node X, and with second node Y.",
            "NL": "A point with node X must be present, as well as an edge connecting node X to node Y and an edge connecting node Y to node X, even if there is no in path between X and Y, there must still be an out path between them."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a reached with node X, whenever there is an edge with first node X, and with second node Y, whenever there is not an outpath with first node X, and with second node Y, then there must be an inpath with first node X, and with second node Y. ",
            "NL": "For node X to be considered a reached point, an edge with a first node of X and an edge with a second node of Y must exist, even if there is no outpath corresponding to the first node X and the second node Y, an inpath for both the first node X and the second node Y must be present."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a reached with node X, whenever there is an edge with first node X, and with second node Y, whenever there is not an outpath with first node X, and with second node Y, then there must be an inpath with first node X, and with second node Y. ",
            "NL": "In order for a point to have been reached, an edge with node X as the first node, an edge with node Y as the second node, an inpath with node X as the first node, and an inpath with node Y as the second node must be present, even if there is no outpath with either node."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a reached with node X, whenever there is an edge with first node X, and with second node Y, whenever there is not an outpath with first node X, and with second node Y, then there must be an inpath with first node X, and with second node Y. ",
            "NL": "For a node X to be considered a reached point, there must be an edge with X as the first node, and an edge with Y as the second node, even if there is no outpath with X and Y as the first and second nodes respectively, there must be an inpath with X and Y as the first and second nodes."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a reached with node X, whenever there is an edge with first node X, and with second node Y, whenever there is not an outpath with first node X, and with second node Y, then there must be an inpath with first node X, and with second node Y. ",
            "NL": "For node X to be considered reached, there must be an edge with first node X, another edge with second node Y, and even when there are no outpaths with first node X or second node Y, there must still be an inpath with both nodes."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a reached with node X, whenever there is an edge with first node X, and with second node Y, whenever there is not an outpath with first node X, and with second node Y, then there must be an inpath with first node X, and with second node Y. ",
            "NL": "In order for a point to be reached with node X, there must be an edge with the first node X, an edge with the second node Y, and even when there is no outpath from the first node X and the second node Y, there must be an inpath from the first node X and the second node Y."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a reached with value U, whenever there is a link with id1 U, with id2 V then we must have a reached with value V.",
            "NL": "If there is a connection with id1 having a value of U and id2 having a value of V, then there must be a reach with a value of V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a reached with value U, whenever there is a link with id1 U, with id2 V then we must have a reached with value V.",
            "NL": "If there exists a reach with a value of U, and there is a connection between id1 with a value of U and id2 with a value of V, then there must be a reach with a value of V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a reached with value U, whenever there is a link with id1 U, with id2 V then we must have a reached with value V.",
            "NL": "If a link is established between two identifiers, id1 and id2, where id1 has a value of U and id2 has a value of V, then a corresponding reach with value V must be established."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a reached with value U, whenever there is a link with id1 U, with id2 V then we must have a reached with value V.",
            "NL": "If U is the value of a reached, and id1 U and id2 V are linked, then V must be the value of the reached."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a reached with value U, whenever there is a link with id1 U, with id2 V then we must have a reached with value V.",
            "NL": "If there is a link between two IDs, id1 U and id2 V, then we must have a reached value of V corresponding to the initial reached value of U."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a reached with value U, whenever there is a link with id1 V, with id2 U then we must have a reached with value V.",
            "NL": "If we have a reached with a value of U and a link with id1 V and id2 U, then we must have a reached with a value of V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a reached with value U, whenever there is a link with id1 V, with id2 U then we must have a reached with value V.",
            "NL": "If U is the value of the reached and V and U are the ids of the link, then the value of the reached must be V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a reached with value U, whenever there is a link with id1 V, with id2 U then we must have a reached with value V.",
            "NL": "If U is the value of a reached and there is a link with id1 V and id2 U, then the value of the reached must be V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a reached with value U, whenever there is a link with id1 V, with id2 U then we must have a reached with value V.",
            "NL": "If U is the value of a reached, and V is the ID of a link with ID1 and U is the ID of the same link, then the value of the reached must be V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a reached with value U, whenever there is a link with id1 V, with id2 U then we must have a reached with value V.",
            "NL": "If a link exists between id1 and id2, such that the value of id1 is U and the value of id2 is V, then a reach with value V must be present."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a Reference with id9 J, with node1 T, whenever there is an Nontrivial with first vertex J, with fifth vertex T, then we must have a Active with first vertex J, with fifth vertex T.",
            "NL": "If there is a Reference with ID 9 J and node 1 T, then whenever there is a Nontrivial with the first vertex being J and the fifth vertex being T, an Active must also exist with the first vertex being J and the fifth vertex being T."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a Reference with id9 J, with node1 T, whenever there is an Nontrivial with first vertex J, with fifth vertex T, then we must have a Active with first vertex J, with fifth vertex T.",
            "NL": "Whenever there is a Reference with id9 J and node1 T, and a Nontrivial with first vertex J and fifth vertex T, an Active with first vertex J and fifth vertex T must also be present."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a Reference with id9 J, with node1 T, whenever there is an Nontrivial with first vertex J, with fifth vertex T, then we must have a Active with first vertex J, with fifth vertex T.",
            "NL": "Whenever a Reference with id9 J and node1 T exists, an Active with first vertex J and fifth vertex T must also be present if there is a Nontrivial with first vertex J and fifth vertex T."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a Reference with id9 J, with node1 T, whenever there is an Nontrivial with first vertex J, with fifth vertex T, then we must have a Active with first vertex J, with fifth vertex T.",
            "NL": "Whenever there is a Nontrivial with first vertex J and fifth vertex T that corresponds to the Reference with id9 J and node1 T, an Active with first vertex J and fifth vertex T must also exist."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a Reference with id9 J, with node1 T, whenever there is an Nontrivial with first vertex J, with fifth vertex T, then we must have a Active with first vertex J, with fifth vertex T.",
            "NL": "Whenever there is a Nontrivial with a first vertex of id9 J and a fifth vertex of node1 T, there must be an Active with the same first vertex of id9 J and fifth vertex of node1 T."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a Rest with key3 L, Whenever there is not a NonActive with key3 L, whenever there is a Triumph with key7 M, with id9 L, Whenever there is not a Level_Vertex with id5 M, with vtx5 T, Whenever there is not a Level_Vertex with id5 M, with vtx5 Q, then we must have an Unvalued with id5 M, with vtx5 T or Unvalued with id5 M, with vtx5 Q. ",
            "NL": "Whenever there is a Rest with key3 L, there should not be a NonActive with key3 L; if there is a Triumph with key7 M and id9 L, then there should not be an Level_Vertex with id5 M and vtx5 T; if there is an Level_Vertex with id5 M and vtx5 Q, then we must have either an Unvalued with id5 M and vtx5 T or an Unvalued with id5 M and vtx5 Q."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a Rest with key3 L, Whenever there is not a NonActive with key3 L, whenever there is a Triumph with key7 M, with id9 L, Whenever there is not a Level_Vertex with id5 M, with vtx5 T, Whenever there is not a Level_Vertex with id5 M, with vtx5 Q, then we must have an Unvalued with id5 M, with vtx5 T or Unvalued with id5 M, with vtx5 Q. ",
            "NL": "If there is a Rest with key3 L, but no NonActive with key3 L, and a Triumph with key7 M and id9 L, and no Level_Vertex with id5 M and vtx5 T, or Level_Vertex with id5 M and vtx5 Q, then there must be an Unvalued with id5 M and vtx5 T or an Unvalued with id5 M and vtx5 Q."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a Rest with key3 L, Whenever there is not a NonActive with key3 L, whenever there is a Triumph with key7 M, with id9 L, Whenever there is not a Level_Vertex with id5 M, with vtx5 T, Whenever there is not a Level_Vertex with id5 M, with vtx5 Q, then we must have an Unvalued with id5 M, with vtx5 T or Unvalued with id5 M, with vtx5 Q. ",
            "NL": "If there is a Rest with key3 L, but not a NonActive with key3 L, and a Triumph with key7 M and id9 L, but not an Level_Vertex with id5 M and vtx5 T, or an Level_Vertex with id5 M and vtx5 Q, then we must have an Unvalued with either id5 M and vtx5 T, or id5 M and vtx5 Q."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a Rest with key3 L, Whenever there is not a NonActive with key3 L, whenever there is a Triumph with key7 M, with id9 L, Whenever there is not a Level_Vertex with id5 M, with vtx5 T, Whenever there is not a Level_Vertex with id5 M, with vtx5 Q, then we must have an Unvalued with id5 M, with vtx5 T or Unvalued with id5 M, with vtx5 Q. ",
            "NL": "If there is a Rest with key3 L, there cannot be a NonActive with key3 L, and if there is a Triumph with key7 M and id9 L, there cannot be a Level_Vertex with id5 M and vtx5 T, nor can there be a Level_Vertex with id5 M and vtx5 Q, so we must have an Unvalued with id5 M and vtx5 T or an Unvalued with id5 M and vtx5 Q."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a Rest with key3 L, Whenever there is not a NonActive with key3 L, whenever there is a Triumph with key7 M, with id9 L, Whenever there is not a Level_Vertex with id5 M, with vtx5 T, Whenever there is not a Level_Vertex with id5 M, with vtx5 Q, then we must have an Unvalued with id5 M, with vtx5 T or Unvalued with id5 M, with vtx5 Q. ",
            "NL": "If there is a Rest with key3 L, but no NonActive with key3 L, and a Triumph with key7 M and id9 L, not an Level_Vertex with id5 M and vtx5 T, and not an Level_Vertex with id5 M and vtx5 Q, then we must have either an Unvalued with id5 M and vtx5 T or Unvalued with id5 M and vtx5 Q."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a road with first point X, with second point Y, whenever there is a visit with first point X, then we must have a visit with second point Y.",
            "NL": "We must first visit point X, then travel along the road connecting it to point Y."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a road with first point X, with second point Y, whenever there is a visit with first point X, then we must have a visit with second point Y.",
            "NL": "We must begin our journey by visiting point X, then proceed to point Y, which is connected by a road."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a road with first point X, with second point Y, whenever there is a visit with first point X, then we must have a visit with second point Y.",
            "NL": "We must begin our journey at point X and then proceed to point Y, as there is a road that connects them."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a road with first point X, with second point Y, whenever there is a visit with first point X, then we must have a visit with second point Y.",
            "NL": "We must begin our journey at point X and then continue on to point Y, provided there is a road connecting the two."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a road with first point X, with second point Y, whenever there is a visit with first point X, then we must have a visit with second point Y.",
            "NL": "We must begin our journey by visiting point X, then continue on to point Y via the connecting road."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a road with first point X, with second point Y, whenever there is an start with first point X, then we must have a visit with second point Y.",
            "NL": "We must begin our journey at point X and then proceed to point Y, since there is a road that connects the two."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a road with first point X, with second point Y, whenever there is an start with first point X, then we must have a visit with second point Y.",
            "NL": "We must begin our journey at point X and then proceed to point Y, as there is a road connecting the two."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a road with first point X, with second point Y, whenever there is an start with first point X, then we must have a visit with second point Y.",
            "NL": "We must begin at point X and then proceed to point Y when there is a road connecting them."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a road with first point X, with second point Y, whenever there is an start with first point X, then we must have a visit with second point Y.",
            "NL": "We must begin at first point X and then proceed to second point Y when there is a road connecting the two."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a road with first point X, with second point Y, whenever there is an start with first point X, then we must have a visit with second point Y.",
            "NL": "We must begin at point X and then proceed to point Y, following the road that connects the two."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a Short with fourth point equal to 23, whenever there is a Contrast with key10 X, with node3 N, whenever there is a Weight with key10 Q, whenever there is not a Arc with vtx2 N, Whenever there is not a Longest_Path with vtx2 N, whenever there is not a Afterward with vtx9 X, with edge1 N, with key7 K, whenever there is not a Afterward with vtx9 X, with edge1 N, with key7 H, then we must have a Location with id2 X, with field1 N, with id10 Q. ",
            "NL": "If there is a Short with a fourth point equal to 23, a Contrast with key10 X and node3 N, a Weight with key10 Q, no Arc with vtx2 N, no Longest_Path with vtx2 N, no Afterward with vtx9 X, edge1 N and key7 K, and no Afterward with vtx9 X, edge1 N and key7 H, then there must be a Location with id2 X, field1 N and id10 Q."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a Short with fourth point equal to 23, whenever there is a Contrast with key10 X, with node3 N, whenever there is a Weight with key10 Q, whenever there is not a Arc with vtx2 N, Whenever there is not a Longest_Path with vtx2 N, whenever there is not a Afterward with vtx9 X, with edge1 N, with key7 K, whenever there is not a Afterward with vtx9 X, with edge1 N, with key7 H, then we must have a Location with id2 X, with field1 N, with id10 Q. ",
            "NL": "Whenever a Short has a fourth point equal to 23, a Contrast with key10 X, node3 N, a Weight with key10 Q, no Arc with vtx2 N, no Longest_Path with vtx2 N, no Afterward with vtx9 X, edge1 N, and key7 K or key7 H, then a Location with id2 X, field1 N, and id10 Q must be present."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a Short with fourth point equal to 23, whenever there is a Contrast with key10 X, with node3 N, whenever there is a Weight with key10 Q, whenever there is not a Arc with vtx2 N, Whenever there is not a Longest_Path with vtx2 N, whenever there is not a Afterward with vtx9 X, with edge1 N, with key7 K, whenever there is not a Afterward with vtx9 X, with edge1 N, with key7 H, then we must have a Location with id2 X, with field1 N, with id10 Q. ",
            "NL": "Whenever Short has a fourth point equal to 23, Contrast with key10 X and node3 N, Weight with key10 Q, no Arc with vtx2 N, no Longest_Path with vtx2 N, not Afterward with vtx9 X, edge1 N and key7 K, or Afterward with vtx9 X, edge1 N and key7 H, then Location with id2 X, field1 N and id10 Q must be present."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a Short with fourth point equal to 23, whenever there is a Contrast with key10 X, with node3 N, whenever there is a Weight with key10 Q, whenever there is not a Arc with vtx2 N, Whenever there is not a Longest_Path with vtx2 N, whenever there is not a Afterward with vtx9 X, with edge1 N, with key7 K, whenever there is not a Afterward with vtx9 X, with edge1 N, with key7 H, then we must have a Location with id2 X, with field1 N, with id10 Q. ",
            "NL": "If there is a Short with a fourth point equal to 23, a Contrast with key10 X and node3 N, a Weight with key10 Q, no Arc with vtx2 N, no Longest_Path with vtx2 N, no Afterward with vtx9 X, edge1 N and key7 K, and no Afterward with vtx9 X, edge1 N and key7 H, then we must have a Location with id2 X, field1 N and id10 Q."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a Short with fourth point equal to 23, whenever there is a Contrast with key10 X, with node3 N, whenever there is a Weight with key10 Q, whenever there is not a Arc with vtx2 N, Whenever there is not a Longest_Path with vtx2 N, whenever there is not a Afterward with vtx9 X, with edge1 N, with key7 K, whenever there is not a Afterward with vtx9 X, with edge1 N, with key7 H, then we must have a Location with id2 X, with field1 N, with id10 Q. ",
            "NL": "Whenever there is a Short with a fourth point equal to 23, Contrast with key10 X and node3 N, Weight with key10 Q, no Arc with vtx2 N, no Longest_Path with vtx2 N, no Afterward with vtx9 X, edge1 N and key7 K, and no Afterward with vtx9 X, edge1 N and key7 H, then Location with id2 X, field1 N and id10 Q must be present."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a singleton 1, then we must have a bot with fake value equal to 1.",
            "NL": "Whenever there is a single 1, we must also construct a bot with a simulated value of 1."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a singleton 1, then we must have a bot with fake value equal to 1.",
            "NL": "Whenever a singleton 1 appears, we must also generate a bot with a false value of 1."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a singleton 1, then we must have a bot with fake value equal to 1.",
            "NL": "Whenever a single 1 appears, a bot with a simulated value of 1 must be generated."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a singleton 1, then we must have a bot with fake value equal to 1.",
            "NL": "Whenever a single 1 appears, a bot must be made with a false value of 1."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a singleton 1, then we must have a bot with fake value equal to 1.",
            "NL": "Whenever there is one singleton 1, we have to generate a bot with a simulated value of 1."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a start with node X, whenever there is an edge with first node X, and with second node Y, whenever there is not an inpath with first node X, and with second node Y, then there must be an outpath with first node X, and with second node Y.",
            "NL": "An initial node X, an edge with the first node X, and an edge with the second node Y must be present, even if there is no inpath with the first node X and no inpath with the second node Y, an outpath must be provided with both the first node X and the second node Y."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a start with node X, whenever there is an edge with first node X, and with second node Y, whenever there is not an inpath with first node X, and with second node Y, then there must be an outpath with first node X, and with second node Y.",
            "NL": "In order for the start point with node X, the edge with first node X, and the edge with second node Y to be present, an outpath must be created with both first node X and second node Y, even if there is no inpath with either node."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a start with node X, whenever there is an edge with first node X, and with second node Y, whenever there is not an inpath with first node X, and with second node Y, then there must be an outpath with first node X, and with second node Y.",
            "NL": "A start node of X, an edge connected to the first node X, and an edge connected to the second node Y must be present. Even if there is no inpath with the first node X or the second node Y, an outpath must still exist with the first node X and the second node Y."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a start with node X, whenever there is an edge with first node X, and with second node Y, whenever there is not an inpath with first node X, and with second node Y, then there must be an outpath with first node X, and with second node Y.",
            "NL": "For node X to be a starting point, there must be an edge with X as the first node and an edge with Y as the second node. Even when there is no inpath with X and no inpath with Y, an outpath with X and Y must still be present."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a start with node X, whenever there is an edge with first node X, and with second node Y, whenever there is not an inpath with first node X, and with second node Y, then there must be an outpath with first node X, and with second node Y.",
            "NL": "The presence of a node X, an edge originating from node X, and an edge terminating at node Y must be established, even if there is no inpath with node X or an inpath with node Y, there must still be an outpath from node X and node Y."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a start with node X, whenever there is an edge with first node X, and with second node Y, whenever there is not an outpath with first node X, and with second node Y, then there must be an inpath with first node X, and with second node Y. ",
            "NL": "To begin, Node X and Edges with both Node X and Node Y must exist, and even when there is no Out Path from Node X and no Out Path from Node Y, there must be an In Path to both Node X and Node Y."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a start with node X, whenever there is an edge with first node X, and with second node Y, whenever there is not an outpath with first node X, and with second node Y, then there must be an inpath with first node X, and with second node Y. ",
            "NL": "In order for a start point with node X, an edge with first node X, and an edge with second node Y to be present, an inpath must be present for both first node X and second node Y, even if there is no out path with either of them."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a start with node X, whenever there is an edge with first node X, and with second node Y, whenever there is not an outpath with first node X, and with second node Y, then there must be an inpath with first node X, and with second node Y. ",
            "NL": "For node X to be a starting point, an edge with its first node must be present, and an edge with its second node Y must also be present. Even if there is no outpath with the first node X, or no outpath with the second node Y, an inpath with the first node X and the second node Y must exist."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a start with node X, whenever there is an edge with first node X, and with second node Y, whenever there is not an outpath with first node X, and with second node Y, then there must be an inpath with first node X, and with second node Y. ",
            "NL": "In order for node X to be the starting point, there must be an edge connected to it, as well as an edge connected to node Y. Even if there is no outpath from node X or node Y, there must be an inpath to both nodes."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a start with node X, whenever there is an edge with first node X, and with second node Y, whenever there is not an outpath with first node X, and with second node Y, then there must be an inpath with first node X, and with second node Y. ",
            "NL": "A node X must be present to start, and edges with nodes X and Y must be present, even when there is no out path with either node X or Y, there must be an in path with both X and Y."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a triple with field1 X, with field2 C, with field3 Y1 less than Y2, whenever there is a triple with field1 X, with field2 C, with field3 Y2, then there must be a less with field1 X, with field2 C, with field3 Y1, with field4 C, and with field5 Y2.",
            "NL": "If there is a triple containing field1 X, field2 C, and field3 Y1, and Y1 is less than the field3 of another triple containing field1 X, field2 C, and field3 Y2, then there must exist a less triple with field1 X, field2 C, field3 Y1, field4 C, and field5 Y2."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a triple with field1 X, with field2 C, with field3 Y1 less than Y2, whenever there is a triple with field1 X, with field2 C, with field3 Y2, then there must be a less with field1 X, with field2 C, with field3 Y1, with field4 C, and with field5 Y2.",
            "NL": "If there is a triple containing field1 X, field2 C, and field3 Y1 with Y1 being less than Y2, then there must be a less with field1 X, field2 C, field3 Y1, field4 C, and field5 Y2."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a triple with field1 X, with field2 C, with field3 Y1 less than Y2, whenever there is a triple with field1 X, with field2 C, with field3 Y2, then there must be a less with field1 X, with field2 C, with field3 Y1, with field4 C, and with field5 Y2.",
            "NL": "If there is a triple containing Field1 X, Field2 C, and Field3 Y1, where Y1 is less than Y2, and a triple containing Field1 X, Field2 C, and Field3 Y2, then there must be a less containing Field1 X, Field2 C, Field3 Y1, Field4 C, and Field5 Y2."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a triple with field1 X, with field2 C, with field3 Y1 less than Y2, whenever there is a triple with field1 X, with field2 C, with field3 Y2, then there must be a less with field1 X, with field2 C, with field3 Y1, with field4 C, and with field5 Y2.",
            "NL": "If there is a triple with field1 X, field2 C, and field3 Y1, where Y1 is less than Y2, and there is a triple with field1 X, field2 C, and field3 Y2, then there must be a less triple with field1 X, field2 C, field3 Y1, field4 C, and field5 Y2."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a triple with field1 X, with field2 C, with field3 Y1 less than Y2, whenever there is a triple with field1 X, with field2 C, with field3 Y2, then there must be a less with field1 X, with field2 C, with field3 Y1, with field4 C, and with field5 Y2.",
            "NL": "If field1 X, field2 C, and field3 Y1 are present in a triple, and Y1 is less than Y2, then there must be a triple with field1 X, field2 C, field3 Y1, field4 C, and field5 Y2, with Y2 being greater than Y1."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a triple with field1 X, with field2 C1 less than C2, with field3 Y1, whenever there is a triple with field1 X, with field2 C2, with field3 Y2, then there must be a less with field1 X, with field2 C1, with field3 Y1, with field4 C2, and with field5 Y2.",
            "NL": "If there is a triple containing field1 X, field2 C1, and field3 Y1, and C1 is less than a second triple with field1 X, field2 C2, and field3 Y2, then it must be true that there is a less value with field1 X, field2 C1, field3 Y1, field4 C2, and field5 Y2."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a triple with field1 X, with field2 C1 less than C2, with field3 Y1, whenever there is a triple with field1 X, with field2 C2, with field3 Y2, then there must be a less with field1 X, with field2 C1, with field3 Y1, with field4 C2, and with field5 Y2.",
            "NL": "If field2 C1 is less than C2 in a triple with field1 X, field3 Y1, then a triple must exist with field1 X, field2 C1, field3 Y1, field4 C2, and field5 Y2."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a triple with field1 X, with field2 C1 less than C2, with field3 Y1, whenever there is a triple with field1 X, with field2 C2, with field3 Y2, then there must be a less with field1 X, with field2 C1, with field3 Y1, with field4 C2, and with field5 Y2.",
            "NL": "If there is a triple with field1 X, field2 C1, and field3 Y1, where C1 is less than C2, and is followed by a triple with field1 X, field2 C2, and field3 Y2, then there must exist a less triple with field1 X, field2 C1, field3 Y1, field4 C2, and field5 Y2."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a triple with field1 X, with field2 C1 less than C2, with field3 Y1, whenever there is a triple with field1 X, with field2 C2, with field3 Y2, then there must be a less with field1 X, with field2 C1, with field3 Y1, with field4 C2, and with field5 Y2.",
            "NL": "If the value of field2 in the triple with field1 X, field2 C1, and field3 Y1 is less than that of field2 in the triple with field1 X, field2 C2, and field3 Y2, then there must be a triple with field1 X, field2 C1, field3 Y1, field4 C2, and field5 Y2 with the lesser value."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a triple with field1 X, with field2 C1 less than C2, with field3 Y1, whenever there is a triple with field1 X, with field2 C2, with field3 Y2, then there must be a less with field1 X, with field2 C1, with field3 Y1, with field4 C2, and with field5 Y2.",
            "NL": "If field2 C1 of a triple with field1 X and field3 Y1 is less than field2 C2 of a triple with field1 X and field3 Y2, then there must be a less triple with field1 X, field2 C1, field3 Y1, field4 C2, and field5 Y2."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a uedge with id1 U, with id2 V, whenever there is a partition with value U, with id Y, whenever there is a partition with value V, with id X, and with id X less than Y, then we must have a adjacent with id1 U, with id2 V, with id3 X, with id4 Y.",
            "NL": "If partition with id U has an id of Y and partition with id V has an id of X, with X being less than Y, then an adjacent must exist with id U, V, X, and Y."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a uedge with id1 U, with id2 V, whenever there is a partition with value U, with id Y, whenever there is a partition with value V, with id X, and with id X less than Y, then we must have a adjacent with id1 U, with id2 V, with id3 X, with id4 Y.",
            "NL": "If there is an edge between U and V with U's partition having an ID of Y and V's partition having an ID of X, where X is less than Y, then there must be an adjacent edge between U, V, X, and Y."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a uedge with id1 U, with id2 V, whenever there is a partition with value U, with id Y, whenever there is a partition with value V, with id X, and with id X less than Y, then we must have a adjacent with id1 U, with id2 V, with id3 X, with id4 Y.",
            "NL": "If U and V are two uedges, one having a partition with IDs U and Y, and the other having a partition with IDs V and X, where X is less than Y, then an adjacent must exist with IDs U, V, X, and Y."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a uedge with id1 U, with id2 V, whenever there is a partition with value U, with id Y, whenever there is a partition with value V, with id X, and with id X less than Y, then we must have a adjacent with id1 U, with id2 V, with id3 X, with id4 Y.",
            "NL": "If X is less than Y, then when there are two edges with IDs U and V, each one having a partition with IDs U and Y, and V and X respectively, an adjacent must be created with IDs U, V, X, and Y."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a uedge with id1 U, with id2 V, whenever there is a partition with value U, with id Y, whenever there is a partition with value V, with id X, and with id X less than Y, then we must have a adjacent with id1 U, with id2 V, with id3 X, with id4 Y.",
            "NL": "If X is less than Y and U and V have partitions with ids U,Y and V,X, respectively, then there must be an adjacency between U, V, X, and Y."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a uedge with id1 U, with id2 V, whenever there is a weight_edgewt with first vtx U, with second vtx V, with third weight W, then we must have an u_edge with id1 U, with id2 V, with id3 W.",
            "NL": "Whenever there is an edge between vertices U and V with weight W, there must be an edge with IDs U and V and weight W."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a uedge with id1 U, with id2 V, whenever there is a weight_edgewt with first vtx U, with second vtx V, with third weight W, then we must have an u_edge with id1 U, with id2 V, with id3 W.",
            "NL": "Whenever there is an edge with ID U and ID V, and an edge weight with first vertex U, second vertex V, and weight W, the same edge must exist with ID U, ID V, and weight W."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a uedge with id1 U, with id2 V, whenever there is a weight_edgewt with first vtx U, with second vtx V, with third weight W, then we must have an u_edge with id1 U, with id2 V, with id3 W.",
            "NL": "Whenever there is an edge with first vertex U, second vertex V, and weight W, there must also be an edge with the same U and V values and weight W."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a uedge with id1 U, with id2 V, whenever there is a weight_edgewt with first vtx U, with second vtx V, with third weight W, then we must have an u_edge with id1 U, with id2 V, with id3 W.",
            "NL": "Whenever there is an edge with ID U and V, and a corresponding edge weight with first vertex U, second vertex V, and weight W, the same edge must exist with ID U and V and weight W."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a uedge with id1 U, with id2 V, whenever there is a weight_edgewt with first vtx U, with second vtx V, with third weight W, then we must have an u_edge with id1 U, with id2 V, with id3 W.",
            "NL": "Whenever there is an edge between vertices U and V with weight W, there must also be an edge between the same vertices U and V with the same weight W."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a uedge with value V, with id U, whenever there is a reach with id1 K, with id2 U, whenever there is a partition with value V, with id K then we must have a reach with id1 K, with id2 V. ",
            "NL": "If we have an edge with IDs V and U, a reach with ID K, a partition with IDs V and X, then we must also have a reach with IDs K and V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a uedge with value V, with id U, whenever there is a reach with id1 K, with id2 U, whenever there is a partition with value V, with id K then we must have a reach with id1 K, with id2 V. ",
            "NL": "If there is an edge between V and U, K, U, and V with partition X, then K, V must have a reach."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a uedge with value V, with id U, whenever there is a reach with id1 K, with id2 U, whenever there is a partition with value V, with id K then we must have a reach with id1 K, with id2 V. ",
            "NL": "Whenever there is a combination of an edge with id V and id U, a reach with id K, a partition with id V and id X, then we must have a reach with id K and id V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a uedge with value V, with id U, whenever there is a reach with id1 K, with id2 U, whenever there is a partition with value V, with id K then we must have a reach with id1 K, with id2 V. ",
            "NL": "If there is a junction between V and U, with a reach of K, a partition between V and X, then K, V must have a reach."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is a uedge with value V, with id U, whenever there is a reach with id1 K, with id2 U, whenever there is a partition with value V, with id K then we must have a reach with id1 K, with id2 V. ",
            "NL": "Whenever there is an edge between V and U, and a reach between K, U, and a partition between V and X, then we must also have a reach between K and V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a vertex with value V, whenever there is not a input with value V, whenever there is not a trivial with value V, whenever there is an edge with value U, and with id V, whenever there is not a nfirst with field1 U, with field2 V, then there must be a first with field1 U, with field2 V.",
            "NL": "If there is a vertex with value V, no input with value V, no trivial with value V, an edge with value U and ID V, and no nfirst with field1 U and field2 V, then there must be a first with field1 U and field2 V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a vertex with value V, whenever there is not a input with value V, whenever there is not a trivial with value V, whenever there is an edge with value U, and with id V, whenever there is not a nfirst with field1 U, with field2 V, then there must be a first with field1 U, with field2 V.",
            "NL": "If there is a vertex with value V where there is no input with value V, no trivial with value V, an edge with value U, and an id V, but no nfirst with field1 U and field2 V, then a first with field1 U and field2 V must exist."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a vertex with value V, whenever there is not a input with value V, whenever there is not a trivial with value V, whenever there is an edge with value U, and with id V, whenever there is not a nfirst with field1 U, with field2 V, then there must be a first with field1 U, with field2 V.",
            "NL": "If there is a vertex with value V, and an edge with value U and id V, but no input with value V or nfirst with field1 U and field2 V, then there must be a first with field1 U and field2 V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a vertex with value V, whenever there is not a input with value V, whenever there is not a trivial with value V, whenever there is an edge with value U, and with id V, whenever there is not a nfirst with field1 U, with field2 V, then there must be a first with field1 U, with field2 V.",
            "NL": "If there is a vertex with value V, no input with value V, no trivial with value V, an edge with value U and ID V, but no nfirst with field1 U and field2 V, then a first with field1 U and field2 V must exist."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a vertex with value V, whenever there is not a input with value V, whenever there is not a trivial with value V, whenever there is an edge with value U, and with id V, whenever there is not a nfirst with field1 U, with field2 V, then there must be a first with field1 U, with field2 V.",
            "NL": "If there is a vertex of value V, no input of value V, no trivial of value V, an edge of value U and ID V, but no nfirst with field1 U and field2 V, then a first with field1 U and field2 V must exist."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a vertex with value V, whenever there is not a input with value V, whenever there is not a trivial with value V, whenever there is an edge with value U, and with id V, whenever there is not a nlast with field1 U, with field2 V, then there must be a last with field1 U, with field2 V.",
            "NL": "If there is a vertex with value V, no input with value V, no trivial with value V, an edge with value U and ID V, but no nlast with field1 U and field2 V, then there must be a last with field1 U and field2 V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a vertex with value V, whenever there is not a input with value V, whenever there is not a trivial with value V, whenever there is an edge with value U, and with id V, whenever there is not a nlast with field1 U, with field2 V, then there must be a last with field1 U, with field2 V.",
            "NL": "If there is a vertex with value V, no input with value V, no trivial with value V, an edge with value U and id V, and no last with field1 U and field2 V, then a last with field1 U and field2 V must exist."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a vertex with value V, whenever there is not a input with value V, whenever there is not a trivial with value V, whenever there is an edge with value U, and with id V, whenever there is not a nlast with field1 U, with field2 V, then there must be a last with field1 U, with field2 V.",
            "NL": "If there exists a vertex with value V, yet no input with the same value V, no trivial with value V, an edge with value U and ID V, and no nlast with field1 U and field2 V, then there must be a last with field1 U and field2 V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a vertex with value V, whenever there is not a input with value V, whenever there is not a trivial with value V, whenever there is an edge with value U, and with id V, whenever there is not a nlast with field1 U, with field2 V, then there must be a last with field1 U, with field2 V.",
            "NL": "If a vertex has a value V, there is no input with value V, there is no trivial with value V, and an edge with value U and ID V, but no nlast with field1 U and field2 V, then there must exist a last with field1 U and field2 V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a vertex with value V, whenever there is not a input with value V, whenever there is not a trivial with value V, whenever there is an edge with value U, and with id V, whenever there is not a nlast with field1 U, with field2 V, then there must be a last with field1 U, with field2 V.",
            "NL": "If there is a vertex with value V, no input with value V, no trivial with value V, an edge with value U and id V, and no last with field1 U and field2 V, then there must be a last with field1 U and field2 V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a vertex with value V, whenever there is not a input with value V, whenever there is not a trivial with value V, whenever there is an edge with value W less than Z, and with id V, whenever there is an edge with value U greater than Z, with id V, whenever there is an edge with value Z, with id V, then there must be a btedge with id1 W, with id2 U, with id3 V.",
            "NL": "If a vertex V exists, there is no input with value V, no trivial with value V, an edge with value W and id V, and an edge with value Z (where Z is greater than W and less than U), then there must be an edge with id1 W, id2 U, and id3 V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a vertex with value V, whenever there is not a input with value V, whenever there is not a trivial with value V, whenever there is an edge with value W less than Z, and with id V, whenever there is an edge with value U greater than Z, with id V, whenever there is an edge with value Z, with id V, then there must be a btedge with id1 W, with id2 U, with id3 V.",
            "NL": "If a vertex V exists, and an input with value V is absent, as well as a trivial with value V, but there is an edge with value W, having the same id as V, and also an edge with value Z, having the same id as V, where Z is between W and U, then there must be an edge with id1 W, id2 U, and id3 V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a vertex with value V, whenever there is not a input with value V, whenever there is not a trivial with value V, whenever there is an edge with value W less than Z, and with id V, whenever there is an edge with value U greater than Z, with id V, whenever there is an edge with value Z, with id V, then there must be a btedge with id1 W, with id2 U, with id3 V.",
            "NL": "If there is a vertex V, and an input with no value V, a trivial with no value V, an edge with value W and ID V, and an edge with value Z, where Z is greater than W and less than U, then there must be an edge with ID1 W, ID2 U, and ID3 V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a vertex with value V, whenever there is not a input with value V, whenever there is not a trivial with value V, whenever there is an edge with value W less than Z, and with id V, whenever there is an edge with value U greater than Z, with id V, whenever there is an edge with value Z, with id V, then there must be a btedge with id1 W, with id2 U, with id3 V.",
            "NL": "If a vertex V exists, there must be an input with no value V, a trivial with no value V, an edge with value W and id V, and an edge with value Z, id V, where Z is greater than W and less than U; thus, a btedge must exist with id1 W, id2 U, and id3 V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a vertex with value V, whenever there is not a input with value V, whenever there is not a trivial with value V, whenever there is an edge with value W less than Z, and with id V, whenever there is an edge with value U greater than Z, with id V, whenever there is an edge with value Z, with id V, then there must be a btedge with id1 W, with id2 U, with id3 V.",
            "NL": "Whenever there is a vertex V, there must be an edge with id1 W, id2 U, and id3 V, considering W is smaller than Z, which is the value of the edge with id V, and Z is lesser than U."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a vertex with value V, whenever there is not a input with value V, whenever there is not a trivial with value V, whenever there is not an obs_vlabel with id1 V, with id2 P, whenever there is not an obs_vlabel with id1 V, with id2 M, whenever there is an active with key W, whenever there is an edge with value V, with id W, then there must be a aedge with value V.",
            "NL": "If there is a vertex with value V, there must not be an input, trivial, or obs_vlabel with value V and id1 V and id2 P or M. Additionally, an active with key W must be present when there is an edge with value V and id W, and there must be an aedge with value V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a vertex with value V, whenever there is not a input with value V, whenever there is not a trivial with value V, whenever there is not an obs_vlabel with id1 V, with id2 P, whenever there is not an obs_vlabel with id1 V, with id2 M, whenever there is an active with key W, whenever there is an edge with value V, with id W, then there must be a aedge with value V.",
            "NL": "If a vertex has a value V, no input with value V, no trivial with value V, no obs_vlabel with id1 V and id2 P, no obs_vlabel with id1 V and id2 M, and an active with key W, then an edge with value V and id W must have an aedge with value V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a vertex with value V, whenever there is not a input with value V, whenever there is not a trivial with value V, whenever there is not an obs_vlabel with id1 V, with id2 P, whenever there is not an obs_vlabel with id1 V, with id2 M, whenever there is an active with key W, whenever there is an edge with value V, with id W, then there must be a aedge with value V.",
            "NL": "If there is a vertex with value V, no input with value V, no trivial with value V, no obs_vlabel with id1 V and id2 P, no obs_vlabel with id1 V and id2 M, an active with key W, and an edge with value V and id W, then an aedge with value V must exist."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a vertex with value V, whenever there is not a input with value V, whenever there is not a trivial with value V, whenever there is not an obs_vlabel with id1 V, with id2 P, whenever there is not an obs_vlabel with id1 V, with id2 M, whenever there is an active with key W, whenever there is an edge with value V, with id W, then there must be a aedge with value V.",
            "NL": "If there is a vertex with value V, there must not be an input, a trivial, or an obs_vlabel with id1 V and id2 P or M. Additionally, there must be an active with key W and when there is an edge with value V and id W, there must also be an aedge with the same value V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a vertex with value V, whenever there is not a input with value V, whenever there is not a trivial with value V, whenever there is not an obs_vlabel with id1 V, with id2 P, whenever there is not an obs_vlabel with id1 V, with id2 M, whenever there is an active with key W, whenever there is an edge with value V, with id W, then there must be a aedge with value V.",
            "NL": "If there is a vertex with value V, there is no input with value V, no trivial with value V, no obs_vlabel with id1 V and id2 P, no obs_vlabel with id1 V and id2 M, an active with key W, and an edge with value V and id W, then there must be an aedge with value V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a vertex with value V, whenever there is not an input V, whenever there is not an active V, then there must be an inactive with value V.",
            "NL": "If there is no input V and no active vertex with value V, then there must be an inactive vertex with value V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a vertex with value V, whenever there is not an input V, whenever there is not an active V, then there must be an inactive with value V.",
            "NL": "If a vertex with value V does not have an input or is not active, then there must be an inactive vertex with the same value V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a vertex with value V, whenever there is not an input V, whenever there is not an active V, then there must be an inactive with value V.",
            "NL": "If there is no input or active vertex with value V, then there must be an inactive vertex with value V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a vertex with value V, whenever there is not an input V, whenever there is not an active V, then there must be an inactive with value V.",
            "NL": "If there is not an input or active vertex with value V, then there must be an inactive vertex with value V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a vertex with value V, whenever there is not an input V, whenever there is not an active V, then there must be an inactive with value V.",
            "NL": "If there is not an input or active vertex with value V, then there must be an inactive vertex with the same value V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a vertex with value V, whenever there is not an input V, whenever there is not an inactive V, then there must be an active with key V.",
            "NL": "Whenever there is a vertex with value V, there must be an active key V, and not an input or inactive V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a vertex with value V, whenever there is not an input V, whenever there is not an inactive V, then there must be an active with key V.",
            "NL": "Whenever there is a vertex with value V, there must be an active vertex with key V, with no input or inactive vertex present."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a vertex with value V, whenever there is not an input V, whenever there is not an inactive V, then there must be an active with key V.",
            "NL": "Whenever a vertex has the value V, there must be an active vertex with the same key V, and there cannot be an input or inactive vertex with that value."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a vertex with value V, whenever there is not an input V, whenever there is not an inactive V, then there must be an active with key V.",
            "NL": "At any given vertex with value V, there must be an active key V, regardless of whether there is an input or inactive V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a vertex with value V, whenever there is not an input V, whenever there is not an inactive V, then there must be an active with key V.",
            "NL": "If there is a vertex with value V, there cannot be an input V, an inactive V, and so there must be an active vertex with key V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a width with value L, with id T greater than 0, then there must be a pvalue with value L, and with id T equal to 1.",
            "NL": "If there is a width L and an id T greater than 0, then the pvalue with value L and an id T of 1 is also required."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a width with value L, with id T greater than 0, then there must be a pvalue with value L, and with id T equal to 1.",
            "NL": "Whenever L is the width and T is a value greater than 0, there must also be a pvalue equal to 1 with the same width L and id T."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a width with value L, with id T greater than 0, then there must be a pvalue with value L, and with id T equal to 1.",
            "NL": "If there is a width L and an id T greater than 0, the corresponding pvalue must have a value of L and an id T equal to 1."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a width with value L, with id T greater than 0, then there must be a pvalue with value L, and with id T equal to 1.",
            "NL": "If L and T are greater than 0, there must be a pvalue with value L and an id T equaling 1."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a width with value L, with id T greater than 0, then there must be a pvalue with value L, and with id T equal to 1.",
            "NL": "If the width has a value of L and the id is greater than 0, a pvalue of L must exist with an id of 1."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a width with value L, with id T, whenever there is a pvalue with value L, with id X less than T, then there must be a pvalue with value L, and with id X+1.",
            "NL": "If there is a width of L with id T, and a corresponding pvalue of L with id X, where X is less than T, then there must be a pvalue of L with id X+1."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a width with value L, with id T, whenever there is a pvalue with value L, with id X less than T, then there must be a pvalue with value L, and with id X+1.",
            "NL": "If there is a width with value L and id T, and a pvalue with value L and id X where X is less than T, then there must also be a pvalue with value L and an id of X+1."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a width with value L, with id T, whenever there is a pvalue with value L, with id X less than T, then there must be a pvalue with value L, and with id X+1.",
            "NL": "If a width of value L and ID T exists, then a pvalue with the same value L and ID X (where X is less than T) must also exist, and there should also be a pvalue with value L and ID X+1."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a width with value L, with id T, whenever there is a pvalue with value L, with id X less than T, then there must be a pvalue with value L, and with id X+1.",
            "NL": "If there is a width of L with an ID of T, and a pvalue of L with an ID of X, where X is less than T, then there must be a pvalue with a value of L and an ID of X+1."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is a width with value L, with id T, whenever there is a pvalue with value L, with id X less than T, then there must be a pvalue with value L, and with id X+1.",
            "NL": "If there is a width with value L and id T, and a pvalue with value L and id X, where X is less than T, then a pvalue with value L and id X+1 must exist."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an active V, whenever there is a trivial V then there must be a singleton with fake value equal to 1.",
            "NL": "If a V is active and a V is trivial, a singleton with a false value of 1 must be present."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an active V, whenever there is a trivial V then there must be a singleton with fake value equal to 1.",
            "NL": "When there is an active verb and a trivial verb present, a singleton with a value of 1 must be included."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an active V, whenever there is a trivial V then there must be a singleton with fake value equal to 1.",
            "NL": "If there is an active verb and a minor verb present, a singleton with a false value of 1 must be present."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an active V, whenever there is a trivial V then there must be a singleton with fake value equal to 1.",
            "NL": "If there is an active V and a trivial V, a singleton with a fake value of 1 must be present."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an active V, whenever there is a trivial V then there must be a singleton with fake value equal to 1.",
            "NL": "If there is an active verb and a trivial verb present, then a singleton with a false value of 1 must be included."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an active with key V, Whenever there is not a trivial with key V, whenever there is an edge with value U, with id V, Whenever there is not a obs_elabel with id1 U, with id2 V, with id3 P, Whenever there is not a obs_elabel with id1 U, with id2 V, with id3 M, then we must have a llabel with field1 U, with field2 V, with field3 P or llabel with field1 U, with field2 V, with field3 M.",
            "NL": "If there is an active with key V, but no trivial with key V, an edge with value U and id V, but no obs_elabel with id1 U, id2 V, and id3 P, and no obs_elabel with id1 U, id2 V, and id3 M, then either a llabel with field1 U, field2 V, and field3 P, or a llabel with field1 U, field2 V, and field3 M must exist."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an active with key V, Whenever there is not a trivial with key V, whenever there is an edge with value U, with id V, Whenever there is not a obs_elabel with id1 U, with id2 V, with id3 P, Whenever there is not a obs_elabel with id1 U, with id2 V, with id3 M, then we must have a llabel with field1 U, with field2 V, with field3 P or llabel with field1 U, with field2 V, with field3 M.",
            "NL": "If there is an active with key V, but no trivial with key V, an edge with value U, id V, but no obs_elabel with id1 U, id2 V, id3 P, and no obs_elabel with id1 U, id2 V, id3 M, then there must be a llabel with field1 U, field2 V, field3 P, or a llabel with field1 U, field2 V, field3 M."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an active with key V, Whenever there is not a trivial with key V, whenever there is an edge with value U, with id V, Whenever there is not a obs_elabel with id1 U, with id2 V, with id3 P, Whenever there is not a obs_elabel with id1 U, with id2 V, with id3 M, then we must have a llabel with field1 U, with field2 V, with field3 P or llabel with field1 U, with field2 V, with field3 M.",
            "NL": "If there is an active with key V, but no trivial with key V, and an edge with value U, id V, but no obs_elabel with id1 U, id2 V, and id3 P, or with id1 U, id2 V, and id3 M, then there must be either an llabel with field1 U, field2 V, and field3 P, or an llabel with field1 U, field2 V, and field3 M."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an active with key V, Whenever there is not a trivial with key V, whenever there is an edge with value U, with id V, Whenever there is not a obs_elabel with id1 U, with id2 V, with id3 P, Whenever there is not a obs_elabel with id1 U, with id2 V, with id3 M, then we must have a llabel with field1 U, with field2 V, with field3 P or llabel with field1 U, with field2 V, with field3 M.",
            "NL": "If there is an active with key V, but no trivial with key V, and an edge with value U, id V, but no obs_elabel with id1 U, id2 V, id3 P, or obs_elabel with id1 U, id2 V, id3 M, then either a llabel with field1 U, field2 V, field3 P, or llabel with field1 U, field2 V, field3 M must exist."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an active with key V, Whenever there is not a trivial with key V, whenever there is an edge with value U, with id V, Whenever there is not a obs_elabel with id1 U, with id2 V, with id3 P, Whenever there is not a obs_elabel with id1 U, with id2 V, with id3 M, then we must have a llabel with field1 U, with field2 V, with field3 P or llabel with field1 U, with field2 V, with field3 M.",
            "NL": "If there is an active with key V, but no trivial with key V, and an edge with value U, with id V, and no obs_elabel with id1 U, id2 V, id3 P, or obs_elabel with id1 U, id2 V, id3 M, then we must have either a llabel with field1 U, field2 V, field3 P, or a llabel with field1 U, field2 V, field3 M."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an active with key W, whenever there is not a trivial with value V, whenever there is not a trivial with value W, whenever there is an active with key V, whenever there is a reach with field1 V, and with field2 W different from V, whenever there is a reach with field1 W, and with field2 V, whenever there is not a mvlabel with field1 W, with field2 V, with field3 M, then there must be a mvlabel with field1 W, with field2 V, with field3 P.",
            "NL": "If there is an active with key W, a reach with field1 V and field2 W, a reach with field1 W and field2 V, but not a mvlabel with field1 W, field2 V and field3 M, then a mvlabel with field1 W, field2 V and field3 P must exist."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an active with key W, whenever there is not a trivial with value V, whenever there is not a trivial with value W, whenever there is an active with key V, whenever there is a reach with field1 V, and with field2 W different from V, whenever there is a reach with field1 W, and with field2 V, whenever there is not a mvlabel with field1 W, with field2 V, with field3 M, then there must be a mvlabel with field1 W, with field2 V, with field3 P.",
            "NL": "If there is an active with key W, and a trivial with value V, a reach with field1 V and field2 W (different from V), a reach with field1 W and field2 V, but no mvlabel with field1 W, field2 V, and field3 M, then there must be a mvlabel with field1 W, field2 V, and field3 P."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an active with key W, whenever there is not a trivial with value V, whenever there is not a trivial with value W, whenever there is an active with key V, whenever there is a reach with field1 V, and with field2 W different from V, whenever there is a reach with field1 W, and with field2 V, whenever there is not a mvlabel with field1 W, with field2 V, with field3 M, then there must be a mvlabel with field1 W, with field2 V, with field3 P.",
            "NL": "If there is an active with key W, a trivial with value V, a reach with field1 V and field2 W (which is different from V), and a reach with field1 W and field2 V, but there is not a mvlabel with field1 W, field2 V, and field3 M, then a mvlabel must exist with field1 W, field2 V, and field3 P."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an active with key W, whenever there is not a trivial with value V, whenever there is not a trivial with value W, whenever there is an active with key V, whenever there is a reach with field1 V, and with field2 W different from V, whenever there is a reach with field1 W, and with field2 V, whenever there is not a mvlabel with field1 W, with field2 V, with field3 M, then there must be a mvlabel with field1 W, with field2 V, with field3 P.",
            "NL": "If there is an active with key W, a reach with field1 V and field2 W (not equal to V), a reach with field1 W and field2 V, but no mvlabel with field1 W, field2 V, and field3 M, then there must be a mvlabel with field1 W, field2 V, and field3 P."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an active with key W, whenever there is not a trivial with value V, whenever there is not a trivial with value W, whenever there is an active with key V, whenever there is a reach with field1 V, and with field2 W different from V, whenever there is a reach with field1 W, and with field2 V, whenever there is not a mvlabel with field1 W, with field2 V, with field3 M, then there must be a mvlabel with field1 W, with field2 V, with field3 P.",
            "NL": "If there is an active with key W and a reach with field1 V and field2 W that is different from V, as well as a reach with field1 W and field2 V, but no mvlabel with field1 W, field2 V, and field3 M, then a mvlabel with field1 W, field2 V, and field3 P must exist."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an active with key W, whenever there is not a trivial with value V, whenever there is not a trivial with value W, whenever there is an active with key V, whenever there is a reach with field1 V, and with field2 W different from V, whenever there is a reach with field1 W, and with field2 V, whenever there is not a mvlabel with field1 W, with field2 V, with field3 P, then there must be a mvlabel with field1 W, with field2 V, with field3 M.",
            "NL": "If W does not equal V, then when there is an active with key W and not a trivial with value V, there must be an active with key V, a reach with field1 V and field2 W, a reach with field1 W and field2 V, and a mvlabel with field1 W, field2 V, and field3 M."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an active with key W, whenever there is not a trivial with value V, whenever there is not a trivial with value W, whenever there is an active with key V, whenever there is a reach with field1 V, and with field2 W different from V, whenever there is a reach with field1 W, and with field2 V, whenever there is not a mvlabel with field1 W, with field2 V, with field3 P, then there must be a mvlabel with field1 W, with field2 V, with field3 M.",
            "NL": "If W is not equal to V, then whenever there is an active with key W and not a trivial with value V, there must be a reach with field1 V and field2 W, a reach with field1 W and field2 V, and a mvlabel with field1 W, field2 V, and field3 M, but not a mvlabel with field1 W, field2 V, and field3 P."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an active with key W, whenever there is not a trivial with value V, whenever there is not a trivial with value W, whenever there is an active with key V, whenever there is a reach with field1 V, and with field2 W different from V, whenever there is a reach with field1 W, and with field2 V, whenever there is not a mvlabel with field1 W, with field2 V, with field3 P, then there must be a mvlabel with field1 W, with field2 V, with field3 M.",
            "NL": "If W and V are not equal, and there is an active with key W, not a trivial with value V, an active with key V, a reach with field1 V and field2 W, and a reach with field1 W and field2 V, then a mvlabel with field1 W, field2 V, and field3 M must exist."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an active with key W, whenever there is not a trivial with value V, whenever there is not a trivial with value W, whenever there is an active with key V, whenever there is a reach with field1 V, and with field2 W different from V, whenever there is a reach with field1 W, and with field2 V, whenever there is not a mvlabel with field1 W, with field2 V, with field3 P, then there must be a mvlabel with field1 W, with field2 V, with field3 M.",
            "NL": "If W does not equal V, then a mvlabel must exist with field1 W, field2 V, and field3 M, provided that there is an active with key W, there is no trivial with value V, there is no trivial with value W, there is an active with key V, and there is a reach with field1 V and field2 W, as well as a reach with field1 W and field2 V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an active with key W, whenever there is not a trivial with value V, whenever there is not a trivial with value W, whenever there is an active with key V, whenever there is a reach with field1 V, and with field2 W different from V, whenever there is a reach with field1 W, and with field2 V, whenever there is not a mvlabel with field1 W, with field2 V, with field3 P, then there must be a mvlabel with field1 W, with field2 V, with field3 M.",
            "NL": "If W is not equal to V, then a mvlabel must exist with field1 equal to W, field2 equal to V, and field3 equal to M, provided that an active with key W and a trivial with value V exist, and a reach with field1 equal to V and field2 equal to W, and a reach with field1 equal to W and field2 equal to V, and a mvlabel with field1 equal to W, field2 equal to V, and field3 equal to P does not exist."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an arc with first vtx X, with second vtx Y, whenever there is a bound with first vtx X, then we must have an in_hm with id1 X, with id2 Y or out_hm with first vtx X, with second vtx Y.",
            "NL": "Whenever there is an arc connecting vertex X to vertex Y, there must be either an in_hm with ID X and ID Y, or an out_hm with first vertex X and second vertex Y."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an arc with first vtx X, with second vtx Y, whenever there is a bound with first vtx X, then we must have an in_hm with id1 X, with id2 Y or out_hm with first vtx X, with second vtx Y.",
            "NL": "Whenever an arc exists with the first vertex X and the second vertex Y, there must be either an in_hm with ID X and ID Y or an out_hm with the first vertex X and the second vertex Y if there is a bound with vertex X."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an arc with first vtx X, with second vtx Y, whenever there is a bound with first vtx X, then we must have an in_hm with id1 X, with id2 Y or out_hm with first vtx X, with second vtx Y.",
            "NL": "For every arc with the first vertex X and second vertex Y, there must be either an in_hm with ID X and ID Y or an out_hm with first vertex X and second vertex Y associated with it."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an arc with first vtx X, with second vtx Y, whenever there is a bound with first vtx X, then we must have an in_hm with id1 X, with id2 Y or out_hm with first vtx X, with second vtx Y.",
            "NL": "Whenever there is an arc beginning at vertex X, ending at vertex Y, there must be either an in_hm with IDs X and Y, or an out_hm with vertices X and Y."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an arc with first vtx X, with second vtx Y, whenever there is a bound with first vtx X, then we must have an in_hm with id1 X, with id2 Y or out_hm with first vtx X, with second vtx Y.",
            "NL": "Whenever an arc exists with vertex X as the first point and vertex Y as the second, there must be either an in_hm with IDs X and Y or an out_hm with X and Y as the first and second vertices, respectively."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an Attained with edge1 U, Whenever there is not a Unvalued with edge1 U, Whenever there is not a NonInitial with edge9 U, with key8 E, Whenever there is not a NonInitial with edge9 U, with key8 L, then we must have an Attained with edge9 U, with key8 E or Attained with edge9 U, with key8 L.",
            "NL": "If an Attained with edge1 U is present, a Unvalued with edge1 U is not, nor is there a NonInitial with edge9 U and key8 E; however, if there is a NonInitial with edge9 U and key8 L, then either an Attained with edge9 U and key8 E or Attained with edge9 U and key8 L must be present."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an Attained with edge1 U, Whenever there is not a Unvalued with edge1 U, Whenever there is not a NonInitial with edge9 U, with key8 E, Whenever there is not a NonInitial with edge9 U, with key8 L, then we must have an Attained with edge9 U, with key8 E or Attained with edge9 U, with key8 L.",
            "NL": "If there is an Attained with edge1 U but not a Unvalued with edge1 U, and there is no NonInitial with edge9 U and key8 E, but there is a NonInitial with edge9 U and key8 L, then we must have an Attained with edge9 U, either with key8 E or key8 L."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an Attained with edge1 U, Whenever there is not a Unvalued with edge1 U, Whenever there is not a NonInitial with edge9 U, with key8 E, Whenever there is not a NonInitial with edge9 U, with key8 L, then we must have an Attained with edge9 U, with key8 E or Attained with edge9 U, with key8 L.",
            "NL": "If there is an Attained with edge1 U, there is not a Unvalued with edge1 U, no NonInitial with edge9 U, key8 E, and no NonInitial with edge9 U, key8 L, then we must have either an Attained with edge9 U, key8 E or an Attained with edge9 U, key8 L."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an Attained with edge1 U, Whenever there is not a Unvalued with edge1 U, Whenever there is not a NonInitial with edge9 U, with key8 E, Whenever there is not a NonInitial with edge9 U, with key8 L, then we must have an Attained with edge9 U, with key8 E or Attained with edge9 U, with key8 L.",
            "NL": "Whenever an Attained with edge1 U is present, there cannot be a Unvalued with edge1 U, nor a NonInitial with edge9 U, with key8 E. However, if there is a NonInitial with edge9 U, with key8 L, then we must have either an Attained with edge9 U, with key8 E or an Attained with edge9 U, with key8 L."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an Attained with edge1 U, Whenever there is not a Unvalued with edge1 U, Whenever there is not a NonInitial with edge9 U, with key8 E, Whenever there is not a NonInitial with edge9 U, with key8 L, then we must have an Attained with edge9 U, with key8 E or Attained with edge9 U, with key8 L.",
            "NL": "If an Attained with edge1 U exists, a Unvalued with edge1 U does not, and a NonInitial with edge9 U, with key8 E or L, does not, then an Attained with edge9 U, with key8 E or L must be present."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an Bridge with key5 R, and with vtx4 Y, then there must be an Major with key5 R. ",
            "NL": "Whenever there is a Bridge with the key5 R and vtx4 Y, a Major with the key5 R must also be present."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an Bridge with key5 R, and with vtx4 Y, then there must be an Major with key5 R. ",
            "NL": "Whenever a Bridge with the key5 R and vtx4 Y is present, a Major with the key5 R must also be there."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an Bridge with key5 R, and with vtx4 Y, then there must be an Major with key5 R. ",
            "NL": "Whenever a Bridge with key5 R and vtx4 Y is present, a Major with key5 R must also be present."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an Bridge with key5 R, and with vtx4 Y, then there must be an Major with key5 R. ",
            "NL": "Whenever there is a Bridge with the key5 R and vtx4 Y, there must also be a Major with the key5 R present."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an Bridge with key5 R, and with vtx4 Y, then there must be an Major with key5 R. ",
            "NL": "Whenever a Bridge of key5 R and vtx4 Y is present, a Major of key5 R is also required."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an ChosenColour with value NN, with id1 C, whenever there is a link with value NN, with id1 N greater than NN, then there must be an notchosenColour with value N, with id1 C.",
            "NL": "If the value of NN is less than N, then it is not possible to have a chosencolour with a value of N and an id1 of C."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an ChosenColour with value NN, with id1 C, whenever there is a link with value NN, with id1 N greater than NN, then there must be an notchosenColour with value N, with id1 C.",
            "NL": "If the value of NN is less than N, then there cannot be a chosen colour with a value of N and an id1 of C."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an ChosenColour with value NN, with id1 C, whenever there is a link with value NN, with id1 N greater than NN, then there must be an notchosenColour with value N, with id1 C.",
            "NL": "If NN is less than N, then there cannot be a chosen colour with value NN and id1 C, while there is a link with value N and id1 N."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an ChosenColour with value NN, with id1 C, whenever there is a link with value NN, with id1 N greater than NN, then there must be an notchosenColour with value N, with id1 C.",
            "NL": "If the value of NN is less than N, then there cannot be a chosen colour with value N and ID1 C."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an ChosenColour with value NN, with id1 C, whenever there is a link with value NN, with id1 N greater than NN, then there must be an notchosenColour with value N, with id1 C.",
            "NL": "If NN is less than N, then there cannot be a chosen colour with value NN and id1 C, since there is already a link with value NN and id1 N."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an Cliquesize with key9 S, whenever there is not an Edge with key9 S, whenever there is an Adjacency_List with key9 C, with key2 S, whenever there is not an Examine with key9 C, with key2 S, then there must be a Assign with key9 S.",
            "NL": "If there is a Cliquesize V, an Adjacency_List with key9 C, and key2 S but no Edge with key9 S, and no Examine with id1 U and id2 V, then a Assign with key9 S must exist."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an Cliquesize with key9 S, whenever there is not an Edge with key9 S, whenever there is an Adjacency_List with key9 C, with key2 S, whenever there is not an Examine with key9 C, with key2 S, then there must be a Assign with key9 S.",
            "NL": "If there is a Cliquesize V, an Adjacency_List with key9 C, and key2 S, but no Edge with key9 S, nor an Examine with id1 U and id2 V, then a Assign with key9 S must exist."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an Cliquesize with key9 S, whenever there is not an Edge with key9 S, whenever there is an Adjacency_List with key9 C, with key2 S, whenever there is not an Examine with key9 C, with key2 S, then there must be a Assign with key9 S.",
            "NL": "If there is no Edge with key9 S, no Examine with id1 U and id2 V, and a Cliquesize V and Adjacency_List with key9 C, then there must be an Assign with key9 S."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an Cliquesize with key9 S, whenever there is not an Edge with key9 S, whenever there is an Adjacency_List with key9 C, with key2 S, whenever there is not an Examine with key9 C, with key2 S, then there must be a Assign with key9 S.",
            "NL": "If there is a Cliquesize V, an Adjacency_List with key9 C, and key2 S, but no Edge with key9 S, and no Examine with id1 U and id2 V, then a Assign with key9 S must exist."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an Cliquesize with key9 S, whenever there is not an Edge with key9 S, whenever there is an Adjacency_List with key9 C, with key2 S, whenever there is not an Examine with key9 C, with key2 S, then there must be a Assign with key9 S.",
            "NL": "If there is no Edge with key9 S, no Examine with id1 U and id2 V, and there is a Cliquesize V and Adjacency_List with key9 C, then there must be an Assign with key9 S."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an colour with value C2, whenever there is an colour with id C1 less than C2, then we must have a colours with value C1 , with id1 C2. ",
            "NL": "Whenever C1 is a color with a lower value than C2, both colors must be present with the id of C1 and the value of C2."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an colour with value C2, whenever there is an colour with id C1 less than C2, then we must have a colours with value C1 , with id1 C2. ",
            "NL": "Whenever colour C1 has a value that is always less than colour C2, we must have colours with id1 and value C2, as well as colours with value C1."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an colour with value C2, whenever there is an colour with id C1 less than C2, then we must have a colours with value C1 , with id1 C2. ",
            "NL": "Whenever C1 is less than C2, we must have colours with value C1 and id C2."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an colour with value C2, whenever there is an colour with id C1 less than C2, then we must have a colours with value C1 , with id1 C2. ",
            "NL": "Whenever there is a colour with ID C1 and value C1, and another colour with ID C2 and value C2, where C1 is always less than C2, we must have colours with value C2 and ID C1."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an colour with value C2, whenever there is an colour with id C1 less than C2, then we must have a colours with value C1 , with id1 C2. ",
            "NL": "Whenever the value of colour C1 is less than colour C2, we must have colours with id C1 and value C2."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an colours with value C1, and with id1 C2, whenever there is not an notnext with value C1 , with id1 C2, then there must be an next with value C1 , with id1 C2.",
            "NL": "If a colors has a value of C1, id1 of C2, and there is no notnext with a value of C1 and id1 of C2, then it is necessary to have a next with a value of C1 and id1 of C2."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an colours with value C1, and with id1 C2, whenever there is not an notnext with value C1 , with id1 C2, then there must be an next with value C1 , with id1 C2.",
            "NL": "If C1 is the value and C2 is the ID for a color, and there is no next with those values, then a next must be created with C1 as the value and C2 as the ID."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an colours with value C1, and with id1 C2, whenever there is not an notnext with value C1 , with id1 C2, then there must be an next with value C1 , with id1 C2.",
            "NL": "If there is a colour with value C1, and ID1 C2, but no notnext with those values, then a next with value C1 and ID1 C2 must be present."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an colours with value C1, and with id1 C2, whenever there is not an notnext with value C1 , with id1 C2, then there must be an next with value C1 , with id1 C2.",
            "NL": "If there is a colour with value C1 and ID1 C2 and no notnext with the same value and ID, then we must have a next with value C1 and ID1 C2."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an colours with value C1, and with id1 C2, whenever there is not an notnext with value C1 , with id1 C2, then there must be an next with value C1 , with id1 C2.",
            "NL": "If there is a colour with value C1, ID1 C2, and no notnext with value C1, ID1 C2, then a next with value C1 and ID1 C2 must be present."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an edge with first vtx V1, with second vtx V2, then we must have an In with first vtx V1, with second vtx V2 or no_In with first vtx V1, and with second vtx V2.",
            "NL": "If there is an edge between vertex V1 and vertex V2, then either there is an In between them or there is no_In between them."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an edge with first vtx V1, with second vtx V2, then we must have an In with first vtx V1, with second vtx V2 or no_In with first vtx V1, and with second vtx V2.",
            "NL": "If there is an edge between vertex V1 and vertex V2, there must either be an In or a no_In between the two vertices."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an edge with first vtx V1, with second vtx V2, then we must have an In with first vtx V1, with second vtx V2 or no_In with first vtx V1, and with second vtx V2.",
            "NL": "If there is an edge between vertex V1 and vertex V2, then there must either be an In or a no_In between the two vertices."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an edge with first vtx V1, with second vtx V2, then we must have an In with first vtx V1, with second vtx V2 or no_In with first vtx V1, and with second vtx V2.",
            "NL": "If there is an edge between vertex V1 and vertex V2, either an In or a no_In must exist between them."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an edge with first vtx V1, with second vtx V2, then we must have an In with first vtx V1, with second vtx V2 or no_In with first vtx V1, and with second vtx V2.",
            "NL": "If there is an edge connecting vertex V1 and vertex V2, then either an In must exist between them or a no_In must be present."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an edge with first vtx X, with second vtx Y, then we must have an inPath with first vtx X, with second vtx Y or outPath with first vtx X, with second vtx Y.",
            "NL": "Once an edge is established between vertex X and vertex Y, either an inPath or an outPath must be created between the two vertices."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an edge with first vtx X, with second vtx Y, then we must have an inPath with first vtx X, with second vtx Y or outPath with first vtx X, with second vtx Y.",
            "NL": "Once there is a connection between vertex X and vertex Y, either an inPath or an outPath must be established between the two."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an edge with first vtx X, with second vtx Y, then we must have an inPath with first vtx X, with second vtx Y or outPath with first vtx X, with second vtx Y.",
            "NL": "If there is a connection between vertex X and Y, then there must be either an inPath from X to Y, or an outPath from X to Y."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an edge with first vtx X, with second vtx Y, then we must have an inPath with first vtx X, with second vtx Y or outPath with first vtx X, with second vtx Y.",
            "NL": "Once there is a connection between vertex X and Y, either an inPath or an outPath must exist between the two vertices."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an edge with first vtx X, with second vtx Y, then we must have an inPath with first vtx X, with second vtx Y or outPath with first vtx X, with second vtx Y.",
            "NL": "If there is a connection between vertex X and vertex Y, an inPath or outPath must be established between the two vertices."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an edge with value N1, with id N2, whenever there is an in_layer with value L1 less than L2, with id N1, whenever there is an in_layer with value L2, with id N2, then we must have an edge_layer with id1 L1, with id2 L2, with id3 N1, with id4 N2.",
            "NL": "Whenever an edge of value N1 and id N2 is present, an in_layer of value L1, less than L2, and id N1 must exist; likewise, when an in_layer of value L2 and id N2 exists, an edge_layer with id1 L1, id2 L2, id3 N1, and id4 N2 must be present."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an edge with value N1, with id N2, whenever there is an in_layer with value L1 less than L2, with id N1, whenever there is an in_layer with value L2, with id N2, then we must have an edge_layer with id1 L1, with id2 L2, with id3 N1, with id4 N2.",
            "NL": "For every edge with value N1 and id N2, there must be an in_layer with value L1, less than L2, and id N1; and for every in_layer with value L2 and id N2, there must be an edge_layer with ids L1, L2, N1, and N2."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an edge with value N1, with id N2, whenever there is an in_layer with value L1 less than L2, with id N1, whenever there is an in_layer with value L2, with id N2, then we must have an edge_layer with id1 L1, with id2 L2, with id3 N1, with id4 N2.",
            "NL": "Whenever an edge with value N1 and id N2 is present, there will be an in_layer with value L1 less than L2, id N1, and when an in_layer with value L2 and id N2 exists, an edge_layer with ids L1, L2, N1, and N2 must be present."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an edge with value N1, with id N2, whenever there is an in_layer with value L1 less than L2, with id N1, whenever there is an in_layer with value L2, with id N2, then we must have an edge_layer with id1 L1, with id2 L2, with id3 N1, with id4 N2.",
            "NL": "Whenever an edge with value N1 and id N2 is present, there must be an in_layer of value L1 less than L2, with the same id N1. Conversely, whenever an in_layer of value L2 with id N2 is present, there must be an edge_layer with ids L1, L2, N1, and N2."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an edge with value N1, with id N2, whenever there is an in_layer with value L1 less than L2, with id N1, whenever there is an in_layer with value L2, with id N2, then we must have an edge_layer with id1 L1, with id2 L2, with id3 N1, with id4 N2.",
            "NL": "Whenever an edge is detected with value N1 and id N2, an in_layer with value L1 less than L2 and id N1 must be present, and if an in_layer with value L2 and id N2 is found, an edge_layer with ids L1, L2, N1, and N2 must exist."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an edge with value U, with id V, whenever there is a active with value V, whenever there is not a trivial with value V, then there must be a reach with field1 U, with field2 V.",
            "NL": "If U is the value of an edge with ID V, and there are no trivial values of V, then there must be a reach with field1 U and field2 V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an edge with value U, with id V, whenever there is a active with value V, whenever there is not a trivial with value V, then there must be a reach with field1 U, with field2 V.",
            "NL": "If there is an edge with value U and id V, an active with value V, and no trivial with value V, then a reach must exist with field1 U and field2 V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an edge with value U, with id V, whenever there is a active with value V, whenever there is not a trivial with value V, then there must be a reach with field1 U, with field2 V.",
            "NL": "If there is an edge with a value of U and an ID of V, and there is an active with a value of V but no trivial with a value of V, then there must be a reach with field1 U and field2 V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an edge with value U, with id V, whenever there is a active with value V, whenever there is not a trivial with value V, then there must be a reach with field1 U, with field2 V.",
            "NL": "If value U is present in an edge, id V is active, and value V is not trivial, there must be a reach with field1 U and field2 V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an edge with value U, with id V, whenever there is a active with value V, whenever there is not a trivial with value V, then there must be a reach with field1 U, with field2 V.",
            "NL": "If U is the value of an edge with an ID of V, there is an active with the same value and no trivial value of V, then there must be a reach with field1 set to U and field2 set to V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an edge with value U, with id V, whenever there is an active with key W, whenever there is not a trivial with value V, whenever there is not a trivial with value W, whenever there is an active with key V, whenever there is a reach with field1 V, and with field2 W different from V, whenever there is a reach with field1 W, and with field2 V, whenever there is not a mllabel with field1 W, with field2 U, with field3 V, with field4 P then there must be a mllabel with field1 W, with field2 U, with field3 V, with field4 M. ",
            "NL": "If W is not equal to V, and there is an edge with value U and id V, an active with key W, and a reach with field1 V and field2 W, and a reach with field1 W and field2 V, but there is no trivial with value V or W, and no mllabel with field1 W, field2 U, field3 V, and field4 P, then there must be a mllabel with field1 W, field2 U, field3 V, and field4 M."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an edge with value U, with id V, whenever there is an active with key W, whenever there is not a trivial with value V, whenever there is not a trivial with value W, whenever there is an active with key V, whenever there is a reach with field1 V, and with field2 W different from V, whenever there is a reach with field1 W, and with field2 V, whenever there is not a mllabel with field1 W, with field2 U, with field3 V, with field4 P then there must be a mllabel with field1 W, with field2 U, with field3 V, with field4 M. ",
            "NL": "If W is not equal to V, and there is an edge with value U and id V, an active with key W, a reach with field1 V and field2 W, and a reach with field1 W and field2 V, but no trivial with value V or W, and no mllabel with field1 W, field2 U, field3 V, and field4 P, then there must be a mllabel with field1 W, field2 U, field3 V, and field4 M."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an edge with value U, with id V, whenever there is an active with key W, whenever there is not a trivial with value V, whenever there is not a trivial with value W, whenever there is an active with key V, whenever there is a reach with field1 V, and with field2 W different from V, whenever there is a reach with field1 W, and with field2 V, whenever there is not a mllabel with field1 W, with field2 U, with field3 V, with field4 P then there must be a mllabel with field1 W, with field2 U, with field3 V, with field4 M. ",
            "NL": "If U, V and W are all different values, and W is not equal to V, then a mllabel must exist with field1 W, with field2 U, with field3 V, and with field4 M, despite there being no trivial with value V, an active with key W, a reach with field1 V and field2 W, and a reach with field1 W and field2 V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an edge with value U, with id V, whenever there is an active with key W, whenever there is not a trivial with value V, whenever there is not a trivial with value W, whenever there is an active with key V, whenever there is a reach with field1 V, and with field2 W different from V, whenever there is a reach with field1 W, and with field2 V, whenever there is not a mllabel with field1 W, with field2 U, with field3 V, with field4 P then there must be a mllabel with field1 W, with field2 U, with field3 V, with field4 M. ",
            "NL": "If an edge with value U and id V exists, an active with key W is present, a trivial with value V does not exist, a trivial with value W does not exist, an active with key V is present, a reach with field1 V and field2 W is present, a reach with field1 W and field2 V is present, and W is not equal to V, then a mllabel with field1 W, field2 U, field3 V, and field4 M must be present."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an edge with value U, with id V, whenever there is an active with key W, whenever there is not a trivial with value V, whenever there is not a trivial with value W, whenever there is an active with key V, whenever there is a reach with field1 V, and with field2 W different from V, whenever there is a reach with field1 W, and with field2 V, whenever there is not a mllabel with field1 W, with field2 U, with field3 V, with field4 P then there must be a mllabel with field1 W, with field2 U, with field3 V, with field4 M. ",
            "NL": "If W does not equal V, and an edge exists with value U and id V, then there must be an active with key W, a reach with field1 V and field2 W, and a mllabel with field1 W, field2 U, field3 V, and field4 M; there cannot be a trivial with values V or W."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an edge with value U, with id V, whenever there is an obs_elabel with id1 U, with id2 V, with id3 M, whenever there is not an obs_elabel with id1 U, with id2 V, with id3 P, whenever there is an obs_vlabel with id1 U, with id2 S, whenever there is an obs_vlabel with id1 V, with id2 S then there must be a diff with value U, with id V.",
            "NL": "If there is an edge with value U and id V, an obs_elabel with id1 U, id2 V, and id3 M, but not an obs_elabel with id1 U, id2 V, and id3 P, and an obs_vlabel with id1 U and id2 S, as well as an obs_vlabel with id1 V and id2 S, then a difference with value U and id V must exist."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an edge with value U, with id V, whenever there is an obs_elabel with id1 U, with id2 V, with id3 M, whenever there is not an obs_elabel with id1 U, with id2 V, with id3 P, whenever there is an obs_vlabel with id1 U, with id2 S, whenever there is an obs_vlabel with id1 V, with id2 S then there must be a diff with value U, with id V.",
            "NL": "If there is an edge of value U and id V, an obs_elabel of id1 U, id2 V, and id3 M, but not an obs_elabel of id1 U, id2 V, and id3 P, as well as obs_vlabel of id1 U and id2 S, and an obs_vlabel of id1 V and id2 S, then a difference with value U and id V must exist."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an edge with value U, with id V, whenever there is an obs_elabel with id1 U, with id2 V, with id3 M, whenever there is not an obs_elabel with id1 U, with id2 V, with id3 P, whenever there is an obs_vlabel with id1 U, with id2 S, whenever there is an obs_vlabel with id1 V, with id2 S then there must be a diff with value U, with id V.",
            "NL": "If there is an edge with value U and id V, an obs_elabel with id1 U, id2 V and id3 M, but not an obs_elabel with id1 U, id2 V and id3 P, as well as an obs_vlabel with id1 U and id2 S, and an obs_vlabel with id1 V and id2 S, then there has to be a difference with value U and id V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an edge with value U, with id V, whenever there is an obs_elabel with id1 U, with id2 V, with id3 M, whenever there is not an obs_elabel with id1 U, with id2 V, with id3 P, whenever there is an obs_vlabel with id1 U, with id2 S, whenever there is an obs_vlabel with id1 V, with id2 S then there must be a diff with value U, with id V.",
            "NL": "If there is an edge with value U and id V, then there must be an obs_elabel with id1 U, id2 V, and id3 M, but not one with id1 U, id2 V, and id3 P, as well as an obs_vlabel with id1 U and id2 S, and another obs_vlabel with id1 V and id2 S, which would necessitate a difference with value U and id V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an edge with value U, with id V, whenever there is an obs_elabel with id1 U, with id2 V, with id3 M, whenever there is not an obs_elabel with id1 U, with id2 V, with id3 P, whenever there is an obs_vlabel with id1 U, with id2 S, whenever there is an obs_vlabel with id1 V, with id2 S then there must be a diff with value U, with id V.",
            "NL": "If there is an edge with value U and id V, an obs_elabel with id1 U, id2 V, and id3 M, but no obs_elabel with id1 U, id2 V, and id3 P, as well as an obs_vlabel with id1 U and id2 S, and an obs_vlabel with id1 V and id2 S, then there must be a difference with value U and id V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an edge with value U, with id V, whenever there is an obs_elabel with id1 U, with id2 V, with id3 P, whenever there is not an obs_elabel with id1 U, with id2 V, with id3 M, whenever there is an obs_vlabel with id1 U, with id2 S different from T, whenever there is an obs_vlabel with id1 V, with id2 T then there must be a diff with value U, with id V.",
            "NL": "If there is an edge with value U and id V, there is an obs_elabel with id1 U, id2 V, and id3 P, but not an obs_elabel with id1 U, id2 V, and id3 M, an obs_vlabel with id1 U and id2 S, and an obs_vlabel with id1 V and id2 T where S is not equal to T, then there must be a difference with value U and id V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an edge with value U, with id V, whenever there is an obs_elabel with id1 U, with id2 V, with id3 P, whenever there is not an obs_elabel with id1 U, with id2 V, with id3 M, whenever there is an obs_vlabel with id1 U, with id2 S different from T, whenever there is an obs_vlabel with id1 V, with id2 T then there must be a diff with value U, with id V.",
            "NL": "If there is an edge with value U and id V, an obs_elabel with id1 U, id2 V, and id3 P, but no obs_elabel with id1 U, id2 V, and id3 M, plus an obs_vlabel with id1 U and id2 S, and an obs_vlabel with id1 V and id2 T, and S is not equal to T, then there must be a difference with value U and id V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an edge with value U, with id V, whenever there is an obs_elabel with id1 U, with id2 V, with id3 P, whenever there is not an obs_elabel with id1 U, with id2 V, with id3 M, whenever there is an obs_vlabel with id1 U, with id2 S different from T, whenever there is an obs_vlabel with id1 V, with id2 T then there must be a diff with value U, with id V.",
            "NL": "If there is an edge with value U and id V, there is an obs_elabel with id1 U, id2 V, and id3 P, but not an obs_elabel with id1 U, id2 V, and id3 M, as well as an obs_vlabel with id1 U and id2 S, and an obs_vlabel with id1 V and id2 T, and S is not equal to T, then there must be a difference with value U and id V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an edge with value U, with id V, whenever there is an obs_elabel with id1 U, with id2 V, with id3 P, whenever there is not an obs_elabel with id1 U, with id2 V, with id3 M, whenever there is an obs_vlabel with id1 U, with id2 S different from T, whenever there is an obs_vlabel with id1 V, with id2 T then there must be a diff with value U, with id V.",
            "NL": "If there is an edge with value U and id V, an obs_elabel with id1 U, id2 V, and id3 P, but not an obs_elabel with id1 U, id2 V, and id3 M, and two obs_vlabel with id1 U and id2 S, and id1 V and id2 T, where S is not equal to T, then there must be a difference with value U and id V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an edge with value U, with id V, whenever there is an obs_elabel with id1 U, with id2 V, with id3 P, whenever there is not an obs_elabel with id1 U, with id2 V, with id3 M, whenever there is an obs_vlabel with id1 U, with id2 S different from T, whenever there is an obs_vlabel with id1 V, with id2 T then there must be a diff with value U, with id V.",
            "NL": "If there exists an edge with value U and id V, then an obs_elabel with id1 U, id2 V, and id3 P must be present, whereas an obs_elabel with id1 U, id2 V, and id3 M must not be present. Additionally, an obs_vlabel with id1 U and id2 S, as well as an obs_vlabel with id1 V and id2 T must exist, where S is not equal to T. In this case, there must be a difference with value U and id V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an edge with value U, with id V, Whenever there is an obs_elabel with id1 U, with id2 V, with id3 S, Whenever there is not a trivial with key V, Whenever there is not a input with key V, then we must have a llabel with field1 U, with field2 V, with field3 S. ",
            "NL": "If there is an edge with value U and id V, there will be an obs_elabel with id1 U, id2 V, and id3 S; however, there is no trivial with key V or input with key V, so a llabel with field1 U, field2 V, and field3 S must be present."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an edge with value U, with id V, Whenever there is an obs_elabel with id1 U, with id2 V, with id3 S, Whenever there is not a trivial with key V, Whenever there is not a input with key V, then we must have a llabel with field1 U, with field2 V, with field3 S. ",
            "NL": "If there is an edge with value U and id V, an obs_elabel with id1 U, id2 V, and id3 S, no trivial with key V, and no input with key V, then there must be a llabel with field1 U, field2 V, and field3 S."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an edge with value U, with id V, Whenever there is an obs_elabel with id1 U, with id2 V, with id3 S, Whenever there is not a trivial with key V, Whenever there is not a input with key V, then we must have a llabel with field1 U, with field2 V, with field3 S. ",
            "NL": "If there is an edge with value U and id V, an obs_elabel with id1 U, id2 V, and id3 S, no trivial with key V, and no input with key V, then a llabel must exist with field1 U, field2 V, and field3 S."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an edge with value U, with id V, Whenever there is an obs_elabel with id1 U, with id2 V, with id3 S, Whenever there is not a trivial with key V, Whenever there is not a input with key V, then we must have a llabel with field1 U, with field2 V, with field3 S. ",
            "NL": "If an edge with value U and id V exists, its corresponding obs_elabel will have id1 U, id2 V, and id3 S; there is no trivial with key V, nor any input with key V; thus, a llabel must be present with field1 U, field2 V, and field3 S."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an edge with value U, with id V, Whenever there is an obs_elabel with id1 U, with id2 V, with id3 S, Whenever there is not a trivial with key V, Whenever there is not a input with key V, then we must have a llabel with field1 U, with field2 V, with field3 S. ",
            "NL": "If there is an edge with value U and id V, an obs_elabel with id1 U, id2 V, and id3 S, no trivial with key V, and no input with key V, then a llabel with field1 U, field2 V, and field3 S must exist."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an edge with value V, with id V1, whenever there is an obs_elabel with id1 V, with id2 V1, with id3 M, whenever there is not an obs_elabel with id1 V, with id2 V1, with id3 P, then there must be a diff with value V, with id V1.",
            "NL": "If there is an edge with value V and id V1, an obs_elabel with id1 V, id2 V1, and id3 M, but there is no obs_elabel with id1 V, id2 V1, and id3 P, then there must be a difference with value V and id V1."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an edge with value V, with id V1, whenever there is an obs_elabel with id1 V, with id2 V1, with id3 M, whenever there is not an obs_elabel with id1 V, with id2 V1, with id3 P, then there must be a diff with value V, with id V1.",
            "NL": "If there is an edge with value V and ID V1, an obs_elabel with ID1 V, ID2 V1, and ID3 M, but there is not an obs_elabel with ID1 V, ID2 V1, and ID3 P, then there must be a difference with value V and ID V1."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an edge with value V, with id V1, whenever there is an obs_elabel with id1 V, with id2 V1, with id3 M, whenever there is not an obs_elabel with id1 V, with id2 V1, with id3 P, then there must be a diff with value V, with id V1.",
            "NL": "If there is no obs_elabel with id1 V, id2 V1 and id3 P, but there is an edge with value V and id V1, as well as an obs_elabel with id1 V, id2 V1 and id3 M, then there must be a difference with value V and id V1."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an edge with value V, with id V1, whenever there is an obs_elabel with id1 V, with id2 V1, with id3 M, whenever there is not an obs_elabel with id1 V, with id2 V1, with id3 P, then there must be a diff with value V, with id V1.",
            "NL": "If there is an edge with value V and ID V1, an obs_elabel with ID1 V, ID2 V1, and ID3 M, but there is not an obs_elabel with ID1 V, ID2 V1, and ID3 P, then a difference with value V and ID V1 must exist."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an edge with value V, with id V1, whenever there is an obs_elabel with id1 V, with id2 V1, with id3 M, whenever there is not an obs_elabel with id1 V, with id2 V1, with id3 P, then there must be a diff with value V, with id V1.",
            "NL": "If there is an edge with value V, with id V1, obs_elabel with id1 V, with id2 V1, and id3 M, but there is no obs_elabel with id1 V, with id2 V1, and id3 P, then there must be a difference with value V, with id V1."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an edge_layer with id1 L1, with id2 L2, with id3 N1 less than N3, with id4 N2 different from N4, whenever there is an edge_layer with id1 L1, with id2 L2, with id3 N3, with id4 N4, then we must have a edge_pair with id1 N1, with id2 N2, with id3 N3, with id4 N4. ",
            "NL": "If L1, L2, N1, and N2 are specified, and N1 is less than N3 and N2 is not equal to N4, then an edge_pair with the ids N1, N2, N3, and N4 must be present."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an edge_layer with id1 L1, with id2 L2, with id3 N1 less than N3, with id4 N2 different from N4, whenever there is an edge_layer with id1 L1, with id2 L2, with id3 N3, with id4 N4, then we must have a edge_pair with id1 N1, with id2 N2, with id3 N3, with id4 N4. ",
            "NL": "If there is an edge_layer with id1 L1, id2 L2, id3 N1, and id4 N2, and a separate edge_layer with id1 L1, id2 L2, id3 N3, and id4 N4, where N1 is less than N3 and N2 is not equal to N4, an edge_pair with id1 N1, id2 N2, id3 N3, and id4 N4 must be present."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an edge_layer with id1 L1, with id2 L2, with id3 N1 less than N3, with id4 N2 different from N4, whenever there is an edge_layer with id1 L1, with id2 L2, with id3 N3, with id4 N4, then we must have a edge_pair with id1 N1, with id2 N2, with id3 N3, with id4 N4. ",
            "NL": "If there is an edge_layer with id1 L1, id2 L2, id3 N1, and id4 N2, and another edge_layer with id1 L1, id2 L2, id3 N3, and id4 N4, where N1 is less than N3 and N2 is not equal to N4, then an edge_pair with id1 N1, id2 N2, id3 N3, and id4 N4 must be present."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an edge_layer with id1 L1, with id2 L2, with id3 N1 less than N3, with id4 N2 different from N4, whenever there is an edge_layer with id1 L1, with id2 L2, with id3 N3, with id4 N4, then we must have a edge_pair with id1 N1, with id2 N2, with id3 N3, with id4 N4. ",
            "NL": "If there is an edge_layer with id1 L1, id2 L2, id3 N1, and id4 N2 where N1 is less than N3 and N2 is not equal to N4, and another edge_layer with id1 L1, id2 L2, id3 N3, and id4 N4, then an edge_pair with id1 N1, id2 N2, id3 N3, and id4 N4 must exist."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an edge_layer with id1 L1, with id2 L2, with id3 N1 less than N3, with id4 N2 different from N4, whenever there is an edge_layer with id1 L1, with id2 L2, with id3 N3, with id4 N4, then we must have a edge_pair with id1 N1, with id2 N2, with id3 N3, with id4 N4. ",
            "NL": "If L1 and L2 are present, and N1 is less than N3 and N2 is different than N4, then an edge_pair with id1 N1, id2 N2, id3 N3, and id4 N4 must exist."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an edge_pair with id1 N1, with id2 N2, with id3 N3, with id4 N4, then we must have a edge_paired with value N2, with id N4.",
            "NL": "Whenever there is an edge_pair with id1 N1, id2 N2, id3 N3, and id4 N4, then there must also be an edge_pair with value N2 and id N4."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an edge_pair with id1 N1, with id2 N2, with id3 N3, with id4 N4, then we must have a edge_paired with value N2, with id N4.",
            "NL": "Whenever an edge_pair is composed of id1 = N1, id2 = N2, id3 = N3, and id4 = N4, then the corresponding edge_pair should have value N2 and id N4."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an edge_pair with id1 N1, with id2 N2, with id3 N3, with id4 N4, then we must have a edge_paired with value N2, with id N4.",
            "NL": "Whenever there is an edge_pair with id1 N1 and id2 N2, and another edge_pair with id3 N3 and id4 N4, then we must have an edge_pair with value N2 and id N4."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an edge_pair with id1 N1, with id2 N2, with id3 N3, with id4 N4, then we must have a edge_paired with value N2, with id N4.",
            "NL": "If there is an edge_pair with id1 N1, id2 N2, id3 N3, and id4 N4, then there must be an edge_pair with value N2 and id N4."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an edge_pair with id1 N1, with id2 N2, with id3 N3, with id4 N4, then we must have a edge_paired with value N2, with id N4.",
            "NL": "Whenever there is an edge_pair with id1 N1 and id2 N2, as well as an edge_pair with id3 N3 and id4 N4, then there must also be an edge_pair with value N2 and id N4."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an edge_pair with id1 N1, with id2 N2, with id3 N3, with id4 N4, whenever there is not a edge_pair with id1 N1, with id2 N4, with id3 N3, with id4 N2, whenever there is a compare with value N2, with id N4, whenever there is a inorder with value N2, with id N4, whenever there is not a inorder with value N1, with id N3, then we must have a crossing with id1 N1, with id2 N2, with id3 N3, with id4 N4. ",
            "NL": "If there is an edge pair with id1 N1, id2 N2, id3 N3, and id4 N4, but there is not an edge pair with id1 N1, id2 N4, id3 N3, and id4 N2, and there is a compare with value N2 and id N4, and an inorder with value N2 and id N4, but there is not an inorder with value N1 and id N3, then a crossing with id1 N1, id2 N2, id3 N3, and id4 N4 must exist."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an edge_pair with id1 N1, with id2 N2, with id3 N3, with id4 N4, whenever there is not a edge_pair with id1 N1, with id2 N4, with id3 N3, with id4 N2, whenever there is a compare with value N2, with id N4, whenever there is a inorder with value N2, with id N4, whenever there is not a inorder with value N1, with id N3, then we must have a crossing with id1 N1, with id2 N2, with id3 N3, with id4 N4. ",
            "NL": "If there is not an edge pair with id1 N1, id2 N4, id3 N3, and id4 N2, and there is a compare with value N2 and id N4, an inorder with value N2 and id N4, but no inorder with value N1 and id N3, then we must have a crossing with id1 N1, id2 N2, id3 N3, and id4 N4."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an edge_pair with id1 N1, with id2 N2, with id3 N3, with id4 N4, whenever there is not a edge_pair with id1 N1, with id2 N4, with id3 N3, with id4 N2, whenever there is a compare with value N2, with id N4, whenever there is a inorder with value N2, with id N4, whenever there is not a inorder with value N1, with id N3, then we must have a crossing with id1 N1, with id2 N2, with id3 N3, with id4 N4. ",
            "NL": "If there is an edge pair with id1 N1, id2 N2, id3 N3, and id4 N4, but no edge pair with id1 N1, id2 N4, id3 N3, and id4 N2, and a compare with value N2 and id N4, an inorder with value N2 and id N4, but no inorder with value N1 and id N3, then a crossing with id1 N1, id2 N2, id3 N3, and id4 N4 must be present."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an edge_pair with id1 N1, with id2 N2, with id3 N3, with id4 N4, whenever there is not a edge_pair with id1 N1, with id2 N4, with id3 N3, with id4 N2, whenever there is a compare with value N2, with id N4, whenever there is a inorder with value N2, with id N4, whenever there is not a inorder with value N1, with id N3, then we must have a crossing with id1 N1, with id2 N2, with id3 N3, with id4 N4. ",
            "NL": "If there is an edge pair with id1 N1, id2 N2, id3 N3, and id4 N4, but there is not an edge pair with id1 N1, id2 N4, id3 N3, and id4 N2, and there is a compare with value N2 and id N4, an inorder with value N2 and id N4, but not an inorder with value N1 and id N3, then we must have a crossing with id1 N1, id2 N2, id3 N3, and id4 N4."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an edge_pair with id1 N1, with id2 N2, with id3 N3, with id4 N4, whenever there is not a edge_pair with id1 N1, with id2 N4, with id3 N3, with id4 N2, whenever there is a compare with value N2, with id N4, whenever there is a inorder with value N2, with id N4, whenever there is not a inorder with value N1, with id N3, then we must have a crossing with id1 N1, with id2 N2, with id3 N3, with id4 N4. ",
            "NL": "If there is an edge pair with id1 N1, id2 N2, id3 N3, and id4 N4, but not an edge pair with id1 N1, id2 N4, id3 N3, and id4 N2, and a compare with value N2 and id N4, but not an inorder with value N1 and id N3, then a crossing with id1 N1, id2 N2, id3 N3, and id4 N4 must exist."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an edge_pair with id1 N1, with id2 N4, with id3 N3, with id4 N2, whenever there is not a edge_pair with id1 N1, with id2 N2, with id3 N3, with id4 N4, whenever there is a compare with value N2, with id N4, whenever there is an inorder with value N1, with id N3, whenever there is an inorder with value N1, with id N4, then we must have a crossing with id1 N1, with id2 N4, with id3 N3, with id4 N2.",
            "NL": "If an edge_pair with id1 N1, id2 N4, id3 N3, and id4 N2 exists and an edge_pair with id1 N1, id2 N2, id3 N3, and id4 N4 does not exist, and a compare with value N2 and id N4 as well as an inorder with value N1 and id N3 exist, then an inorder with value N1 and id N4 must also exist and a crossing with id1 N1, id2 N4, id3 N3, and id4 N2 must be present."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an edge_pair with id1 N1, with id2 N4, with id3 N3, with id4 N2, whenever there is not a edge_pair with id1 N1, with id2 N2, with id3 N3, with id4 N4, whenever there is a compare with value N2, with id N4, whenever there is an inorder with value N1, with id N3, whenever there is an inorder with value N1, with id N4, then we must have a crossing with id1 N1, with id2 N4, with id3 N3, with id4 N2.",
            "NL": "If there is an edge_pair with id1 N1, id2 N4, id3 N3, and id4 N2, but no edge_pair with id1 N1, id2 N2, id3 N3, and id4 N4, and a compare with value N2 and id N4, and an inorder with value N1 and id N3, then there must be an inorder with value N1 and id N4, and a crossing with id1 N1, id2 N4, id3 N3, and id4 N2."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an edge_pair with id1 N1, with id2 N4, with id3 N3, with id4 N2, whenever there is not a edge_pair with id1 N1, with id2 N2, with id3 N3, with id4 N4, whenever there is a compare with value N2, with id N4, whenever there is an inorder with value N1, with id N3, whenever there is an inorder with value N1, with id N4, then we must have a crossing with id1 N1, with id2 N4, with id3 N3, with id4 N2.",
            "NL": "If there is an edge_pair with id1 N1, id2 N4, id3 N3, and id4 N2, but not an edge_pair with id1 N1, id2 N2, id3 N3, and id4 N4, and a compare with value N2 and id N4, and an inorder with value N1 and id N3, then we should expect an inorder with value N1 and id N4, followed by a crossing with id1 N1, id2 N4, id3 N3, and id4 N2."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an edge_pair with id1 N1, with id2 N4, with id3 N3, with id4 N2, whenever there is not a edge_pair with id1 N1, with id2 N2, with id3 N3, with id4 N4, whenever there is a compare with value N2, with id N4, whenever there is an inorder with value N1, with id N3, whenever there is an inorder with value N1, with id N4, then we must have a crossing with id1 N1, with id2 N4, with id3 N3, with id4 N2.",
            "NL": "If there is an edge_pair with id1 N1, id2 N4, id3 N3, and id4 N2, but not an edge_pair with id1 N1, id2 N2, id3 N3, and id4 N4, and there is a compare with value N2 and id N4, and an inorder with value N1 and id N3, then there must be an inorder with value N1 and id N4, and a crossing with id1 N1, id2 N4, id3 N3, and id4 N2."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an edge_pair with id1 N1, with id2 N4, with id3 N3, with id4 N2, whenever there is not a edge_pair with id1 N1, with id2 N2, with id3 N3, with id4 N4, whenever there is a compare with value N2, with id N4, whenever there is an inorder with value N1, with id N3, whenever there is an inorder with value N1, with id N4, then we must have a crossing with id1 N1, with id2 N4, with id3 N3, with id4 N2.",
            "NL": "If there is an edge_pair with id1 N1, id2 N4, id3 N3, and id4 N2 but not an edge_pair with id1 N1, id2 N2, id3 N3, and id4 N4, and a compare with value N2 and id N4, and an inorder with value N1 and id N3, then there must be an inorder with value N1 and id N4, and a crossing with id1 N1, id2 N4, id3 N3, and id4 N2."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an edge_paired with value N2 less than N4, with id N4, then we must have a compare with value N2, with id N4.",
            "NL": "If N2 is less than N4 for an edge paired with value N2 and id N4, we must compare it to value N2 and id N4."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an edge_paired with value N2 less than N4, with id N4, then we must have a compare with value N2, with id N4.",
            "NL": "If N2 is less than N4 for an edge paired with value N2 and id N4, we must compare it to the same value N2 and id N4."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an edge_paired with value N2 less than N4, with id N4, then we must have a compare with value N2, with id N4.",
            "NL": "Whenever an edge is paired with a value N2 and an id N4, where N2 is less than N4, we must compare it to the same value N2 and id N4."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an edge_paired with value N2 less than N4, with id N4, then we must have a compare with value N2, with id N4.",
            "NL": "Whenever value N2 with id N4 is paired with an edge, and N2 is less than N4, we must compare it to value N2 with id N4."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an edge_paired with value N2 less than N4, with id N4, then we must have a compare with value N2, with id N4.",
            "NL": "Whenever there is an edge paired with value N2 and id N4, where N2 is less than N4, we must compare it to value N2 and id N4."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an edge_paired with value N2, with id N4 less than N2, then we must have a compare with value N4, with id N2.",
            "NL": "When N4 is less than N2 and an edge is paired with value N2 and id N4, a comparison of value N4 and id N2 must be conducted."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an edge_paired with value N2, with id N4 less than N2, then we must have a compare with value N4, with id N2.",
            "NL": "Whenever N4 is less than N2 for an edge paired with value N2 and id N4, a comparison with value N4 and id N2 must be done."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an edge_paired with value N2, with id N4 less than N2, then we must have a compare with value N4, with id N2.",
            "NL": "If N4 is less than N2 and there is an edge paired with the value N2 and id N4, a comparison with the value N4 and id N2 must be conducted."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an edge_paired with value N2, with id N4 less than N2, then we must have a compare with value N4, with id N2.",
            "NL": "When the value of N2 is paired with an edge, and the value of N4 is less than N2, it is necessary to compare the value of N4 with the id of N2."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an edge_paired with value N2, with id N4 less than N2, then we must have a compare with value N4, with id N2.",
            "NL": "It is necessary to compare value N4 with id N2 when there is an edge paired with value N2 and id N4, with N4 being less than N2."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an Embedding with vtx1 L, with value8 Y, whenever there is a Level_Vertex with vtx1 L, and with value8 N, then there must be an Flow_Network with value C2, with value8 K. ",
            "NL": "If vtx1 L has an Embedding with value8 Y and a Level_Vertex with value8 N, then a Flow_Network must be present with value C2 and value8 K."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an Embedding with vtx1 L, with value8 Y, whenever there is a Level_Vertex with vtx1 L, and with value8 N, then there must be an Flow_Network with value C2, with value8 K. ",
            "NL": "If vtx1 L has a value8 Y in an Embedding and a Level_Vertex with vtx1 L has a value8 N, then a Flow_Network must have a value C2 and a value8 K."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an Embedding with vtx1 L, with value8 Y, whenever there is a Level_Vertex with vtx1 L, and with value8 N, then there must be an Flow_Network with value C2, with value8 K. ",
            "NL": "If vtx1 L has an Embedding with value8 Y, and a Level_Vertex with value8 N, then the corresponding Flow_Network must have value C2 and value8 K."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an Embedding with vtx1 L, with value8 Y, whenever there is a Level_Vertex with vtx1 L, and with value8 N, then there must be an Flow_Network with value C2, with value8 K. ",
            "NL": "If there is an Embedding with vtx1 L and value8 Y, and a Level_Vertex with vtx1 L and value8 N, then a Flow_Network must be present with value C2 and value8 K."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an Embedding with vtx1 L, with value8 Y, whenever there is a Level_Vertex with vtx1 L, and with value8 N, then there must be an Flow_Network with value C2, with value8 K. ",
            "NL": "If vtx1 L has an Embedding with value8 Y and a Level_Vertex with value8 N, then the Flow_Network must have values C2 and K."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an Engaged with value2 J, whenever there is not an Cross with value2 J, then there must be an Out_HamiltonianCycle with value2 J , with id1 equal to 48.",
            "NL": "If value2 is J and there is no Cross colour with the same value for C1, then an Out_HamiltonianCycle with value2 J must exist, where id1 is equal to 48."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an Engaged with value2 J, whenever there is not an Cross with value2 J, then there must be an Out_HamiltonianCycle with value2 J , with id1 equal to 48.",
            "NL": "If there is no Cross colour with the same value for C1 and the Engaged has a value2 J, then the Out_HamiltonianCycle with value2 J must have id1 equal to 48."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an Engaged with value2 J, whenever there is not an Cross with value2 J, then there must be an Out_HamiltonianCycle with value2 J , with id1 equal to 48.",
            "NL": "If Engaged has a value of 2J and there exists no Cross colour with the same value for C1, then an Out_HamiltonianCycle with a value of 2J must exist where id1 is equal to 48."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an Engaged with value2 J, whenever there is not an Cross with value2 J, then there must be an Out_HamiltonianCycle with value2 J , with id1 equal to 48.",
            "NL": "If there is an Engaged with value2 J and no Cross colour has the same value for C1, then an Out_HamiltonianCycle with value2 J must exist, where id1 is equal to 48."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an Engaged with value2 J, whenever there is not an Cross with value2 J, then there must be an Out_HamiltonianCycle with value2 J , with id1 equal to 48.",
            "NL": "If an Engaged value2 J is present and there is no Cross colour with the same value for C1, then an Out_HamiltonianCycle with value2 J must exist where id1 is equal to 48."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an Eulerian_Graph with third id O, with first vertex E, then we must have a Later with third id O, with first vertex E or Shade with third id O, with first vertex E.",
            "NL": "Once an Eulerian_Graph is established between third id O and first vertex E, a Later or Shade must be created between third id O and first vertex E."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an Eulerian_Graph with third id O, with first vertex E, then we must have a Later with third id O, with first vertex E or Shade with third id O, with first vertex E.",
            "NL": "When an Eulerian Graph is established between third id O and first vertex E, it is necessary to either have a Later connection between third id O and first vertex E, or a Shade connection between third id O and first vertex E."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an Eulerian_Graph with third id O, with first vertex E, then we must have a Later with third id O, with first vertex E or Shade with third id O, with first vertex E.",
            "NL": "Once a connection is established between the third node O and the first node E via an Eulerian Graph, either a Later or a Shade must be formed between the third node O and the first node E."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an Eulerian_Graph with third id O, with first vertex E, then we must have a Later with third id O, with first vertex E or Shade with third id O, with first vertex E.",
            "NL": "Once an Eulerian_Graph is established between third id O and first vertex E, either a Later or Shade must be constructed between the third id O and the first vertex E."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an Eulerian_Graph with third id O, with first vertex E, then we must have a Later with third id O, with first vertex E or Shade with third id O, with first vertex E.",
            "NL": "Once a connection is established between vertex E and node O via an Eulerian Graph, either a Later or Shade must be established between vertex E and node O."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an Extra with edge9 B, whenever there is not a Accomplishment with edge9 B, whenever there is not a Initiate with edge9 B, whenever there is an External_Group with edge9 Z at most E, and with key B, whenever there is an External_Group with value U greater than Z, with key B, whenever there is an External_Group with value Z, with key B, then there must be a Suggestion with value1 Z, with key10 F, with id5 B.",
            "NL": "If edge9 B is present and edge9 E is greater than or equal to edge9 Z and at most F, then there must be a Suggestion with value1 Z, key10 F, and id5 B."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an Extra with edge9 B, whenever there is not a Accomplishment with edge9 B, whenever there is not a Initiate with edge9 B, whenever there is an External_Group with edge9 Z at most E, and with key B, whenever there is an External_Group with value U greater than Z, with key B, whenever there is an External_Group with value Z, with key B, then there must be a Suggestion with value1 Z, with key10 F, with id5 B.",
            "NL": "If there is an Extra B, then there must be an External_Group with edge9 Z and key B, as well as an External_Group with edge9 E and key B, where E is greater than Z and at most F. This implies that there is a Suggestion with value1 Z, key10 F, and id5 B."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an Extra with edge9 B, whenever there is not a Accomplishment with edge9 B, whenever there is not a Initiate with edge9 B, whenever there is an External_Group with edge9 Z at most E, and with key B, whenever there is an External_Group with value U greater than Z, with key B, whenever there is an External_Group with value Z, with key B, then there must be a Suggestion with value1 Z, with key10 F, with id5 B.",
            "NL": "If there is an Extra B, then there must be an External_Group with edge9 Z, with key B, as well as an External_Group with edge9 E, with key B, since E is greater than or equal to Z and at most F. Consequently, there would be a Suggestion with value1 Z, with key10 F, and id5 B."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an Extra with edge9 B, whenever there is not a Accomplishment with edge9 B, whenever there is not a Initiate with edge9 B, whenever there is an External_Group with edge9 Z at most E, and with key B, whenever there is an External_Group with value U greater than Z, with key B, whenever there is an External_Group with value Z, with key B, then there must be a Suggestion with value1 Z, with key10 F, with id5 B.",
            "NL": "If edge9 B is present, no Achievement can be made, however if edge9 Z and edge9 E are present with key B, and E is higher than Z and no more than F, then a Proposal with value1 Z, key10 F, and id5 B is necessary."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an Extra with edge9 B, whenever there is not a Accomplishment with edge9 B, whenever there is not a Initiate with edge9 B, whenever there is an External_Group with edge9 Z at most E, and with key B, whenever there is an External_Group with value U greater than Z, with key B, whenever there is an External_Group with value Z, with key B, then there must be a Suggestion with value1 Z, with key10 F, with id5 B.",
            "NL": "If edge9 B is present, no Accomplishment can be achieved, however, if edge9 Z and edge9 E are both present, with key B, and E is greater than Z but not greater than F, then a Suggestion with value1 Z, key10 F, and id5 B must be suggested."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an Extra with id10 F, with id5 Y, with edge3 J not after A, with field6 C different from T, whenever there is an Extra with id10 F, with id5 Y, with edge3 A, with field6 T, then we must have an Employed_Edge with id10 J, with id5 C, with edge3 A, with field6 T.",
            "NL": "If there is an Extra with id10 F, id5 Y, edge3 A, and field6 T, and an Extra with id10 F, id5 Y, edge3 J, and field6 C, where J is not after A and C is not equal to T, then there must be an Employed_Edge with id10 J, id5 C, edge3 A, and field6 T."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an Extra with id10 F, with id5 Y, with edge3 J not after A, with field6 C different from T, whenever there is an Extra with id10 F, with id5 Y, with edge3 A, with field6 T, then we must have an Employed_Edge with id10 J, with id5 C, with edge3 A, with field6 T.",
            "NL": "If id10 F, id5 Y, edge3 J, and field6 C are present, and J is not after A and C is not equal to T, then we must have an Employed_Edge with id10 J, id5 C, edge3 A, and field6 T."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an Extra with id10 F, with id5 Y, with edge3 J not after A, with field6 C different from T, whenever there is an Extra with id10 F, with id5 Y, with edge3 A, with field6 T, then we must have an Employed_Edge with id10 J, with id5 C, with edge3 A, with field6 T.",
            "NL": "If there is an Extra with id10 F, id5 Y, edge3 J, and field6 C, as well as an Extra with id10 F, id5 Y, edge3 A, and field6 T, and J is not after A and C is not equal to T, then there must be an Employed_Edge with id10 J, id5 C, edge3 A, and field6 T."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an Extra with id10 F, with id5 Y, with edge3 J not after A, with field6 C different from T, whenever there is an Extra with id10 F, with id5 Y, with edge3 A, with field6 T, then we must have an Employed_Edge with id10 J, with id5 C, with edge3 A, with field6 T.",
            "NL": "Whenever there is an Extra with an id of 10F, 5Y, 3A, and 6T, and an Extra with an id of 10F, 5Y, 3J, and 6C, where J is not after A and C is not equal to T, then an Employed_Edge with an id of 10J, 5C, 3A, and 6T must be present."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an Extra with id10 F, with id5 Y, with edge3 J not after A, with field6 C different from T, whenever there is an Extra with id10 F, with id5 Y, with edge3 A, with field6 T, then we must have an Employed_Edge with id10 J, with id5 C, with edge3 A, with field6 T.",
            "NL": "If there is an Extra with id10 F, id5 Y, edge3 J, and field6 C, and if there is another Extra with id10 F, id5 Y, edge3 A, and field6 T, but J is not after A and C is not equal to T, then an Employed_Edge with id10 J, id5 C, edge3 A, and field6 T must exist."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an In_Hamiltonian with field8 M, with id3 B, with vtx1 L, with key S, whenever there is not a In_Hamiltonian with field8 M, with id3 S, with vtx1 L, with key B, whenever there is a Independent_Set with edge10 B, with vtx S, whenever there is a Important with edge10 B, with vtx S, whenever there is not a Important with edge10 M, with vtx L, then we must have a NotFirst with field8 M, with id3 B, with vtx1 L, with key S.",
            "NL": "When there is an In_Hamiltonian with field8 M, id3 B, vtx1 L, and key S, there will not be an In_Hamiltonian with field8 M, id3 S, vtx1 L, and key B. If there is an Independent_Set with edge10 B, vtx S, then there will be an Important with edge10 B, vtx S, but there will not be an Important with edge10 M, vtx L. Therefore, we must have a NotFirst with field8 M, id3 B, vtx1 L, and key S."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an In_Hamiltonian with field8 M, with id3 B, with vtx1 L, with key S, whenever there is not a In_Hamiltonian with field8 M, with id3 S, with vtx1 L, with key B, whenever there is a Independent_Set with edge10 B, with vtx S, whenever there is a Important with edge10 B, with vtx S, whenever there is not a Important with edge10 M, with vtx L, then we must have a NotFirst with field8 M, with id3 B, with vtx1 L, with key S.",
            "NL": "When there is an In_Hamiltonian with field8 M, id3 B, vtx1 L, and key S, there is not an In_Hamiltonian with field8 M, id3 S, vtx1 L, and key B; and if there is an Independent_Set with edge10 B, vtx S, then there is an Important with edge10 B, vtx S, but not an Important with edge10 M, vtx L, then we must have a NotFirst with field8 M, id3 B, vtx1 L, and key S."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an In_Hamiltonian with field8 M, with id3 B, with vtx1 L, with key S, whenever there is not a In_Hamiltonian with field8 M, with id3 S, with vtx1 L, with key B, whenever there is a Independent_Set with edge10 B, with vtx S, whenever there is a Important with edge10 B, with vtx S, whenever there is not a Important with edge10 M, with vtx L, then we must have a NotFirst with field8 M, with id3 B, with vtx1 L, with key S.",
            "NL": "When there is an In_Hamiltonian with field8 M, id3 B, vtx1 L, and key S, there is not an In_Hamiltonian with field8 M, id3 S, vtx1 L, and key B; and when there is an Independent_Set with edge10 B, vtx S, there is an Important with edge10 B, vtx S, but there is not an Important with edge10 M, vtx L, then we must have a NotFirst with field8 M, id3 B, vtx1 L, and key S."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an In_Hamiltonian with field8 M, with id3 B, with vtx1 L, with key S, whenever there is not a In_Hamiltonian with field8 M, with id3 S, with vtx1 L, with key B, whenever there is a Independent_Set with edge10 B, with vtx S, whenever there is a Important with edge10 B, with vtx S, whenever there is not a Important with edge10 M, with vtx L, then we must have a NotFirst with field8 M, with id3 B, with vtx1 L, with key S.",
            "NL": "When there is an In_Hamiltonian with field8 M, with id3 B, with vtx1 L, and with key S, there cannot be an In_Hamiltonian with field8 M, with id3 S, with vtx1 L, and with key B. However, if there is an Independent_Set with edge10 B, and with vtx S, then there must be an Important with edge10 B, and with vtx S, but there cannot be an Important with edge10 M, and with vtx L. Therefore, we must have a NotFirst with field8 M, with id3 B, with vtx1 L, and with key S."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an In_Hamiltonian with field8 M, with id3 B, with vtx1 L, with key S, whenever there is not a In_Hamiltonian with field8 M, with id3 S, with vtx1 L, with key B, whenever there is a Independent_Set with edge10 B, with vtx S, whenever there is a Important with edge10 B, with vtx S, whenever there is not a Important with edge10 M, with vtx L, then we must have a NotFirst with field8 M, with id3 B, with vtx1 L, with key S.",
            "NL": "When there is an In_Hamiltonian with field8 M, id3 B, vtx1 L, and key S, there will not be an In_Hamiltonian with field8 M, id3 S, vtx1 L, and key B; and if there is an Independent_Set with edge10 B, vtx S, then there will be an Important with edge10 B, vtx S, but there will not be an Important with edge10 M, vtx L. In this case, we must have a NotFirst with field8 M, id3 B, vtx1 L, and key S."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an in_hm with id1 X, with id2 Y, whenever there is an edge with first vtx X, with second vtx Y, then we must have a hc with first vtx X, with second vtx Y.",
            "NL": "If there is an in_hm with ID X and ID Y, then for every edge with the first vertex being X and the second vertex being Y, there must be a hc with X as the first vertex and Y as the second vertex."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an in_hm with id1 X, with id2 Y, whenever there is an edge with first vtx X, with second vtx Y, then we must have a hc with first vtx X, with second vtx Y.",
            "NL": "If there is an in_hm with id X and id Y, then there must be a hc with first vertex X and second vertex Y for any edge that has X as its first vertex and Y as its second vertex."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an in_hm with id1 X, with id2 Y, whenever there is an edge with first vtx X, with second vtx Y, then we must have a hc with first vtx X, with second vtx Y.",
            "NL": "When an in_hm with id X and id Y exists, any edge with X as its first vertex and Y as its second vertex must also have a corresponding hc with X as its first vertex and Y as its second vertex."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an in_hm with id1 X, with id2 Y, whenever there is an edge with first vtx X, with second vtx Y, then we must have a hc with first vtx X, with second vtx Y.",
            "NL": "If there is an in_hm with ID X and ID Y, then any edge with X as the first vertex and Y as the second vertex must have a corresponding hc with X as the first vertex and Y as the second vertex."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an in_hm with id1 X, with id2 Y, whenever there is an edge with first vtx X, with second vtx Y, then we must have a hc with first vtx X, with second vtx Y.",
            "NL": "Whenever there is an in_hm with id X and id Y, an edge with first vertex X and second vertex Y must be accompanied by a hc with first vertex X and second vertex Y."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an in_hm with id1 Y, with id2 X, whenever there is an edge with first vtx X, with second vtx Y, then we must have a hc with first vtx X, with second vtx Y.",
            "NL": "When there is an edge with first vertex id X and second vertex id Y, there must be a hc with first vertex X and second vertex Y, provided there is an in_hm with id Y and id X."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an in_hm with id1 Y, with id2 X, whenever there is an edge with first vtx X, with second vtx Y, then we must have a hc with first vtx X, with second vtx Y.",
            "NL": "Whenever there is an edge with the first vertex being ID X and the second vertex being ID Y, there must be a hc with the same first and second vertex."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an in_hm with id1 Y, with id2 X, whenever there is an edge with first vtx X, with second vtx Y, then we must have a hc with first vtx X, with second vtx Y.",
            "NL": "Whenever there is an in_hm with id X and an edge with first vertex X and second vertex Y, there must be a hc with first vertex X and second vertex Y."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an in_hm with id1 Y, with id2 X, whenever there is an edge with first vtx X, with second vtx Y, then we must have a hc with first vtx X, with second vtx Y.",
            "NL": "Whenever an in_hm with id X is present, and there is an edge with first vertex X and second vertex Y, then there must be a hc with first vertex X and second vertex Y."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an in_hm with id1 Y, with id2 X, whenever there is an edge with first vtx X, with second vtx Y, then we must have a hc with first vtx X, with second vtx Y.",
            "NL": "Whenever there is an edge with its first vertex being ID X and its second vertex being ID Y, there must be a corresponding in_hm with ID X and a hc with its first vertex being ID X and its second vertex being ID Y."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an in_hm with id2 Y then we must have a reached with value Y.",
            "NL": "Whenever Y is an in_hm, X must be a vertex that is reached."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an in_hm with id2 Y then we must have a reached with value Y.",
            "NL": "Whenever there is an in-home with ID Y, there must be a graph with vertex X being reached."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an in_hm with id2 Y then we must have a reached with value Y.",
            "NL": "Whenever a graph with vertex X contains an edge with id Y, it must be reached."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an in_hm with id2 Y then we must have a reached with value Y.",
            "NL": "Whenever there is an in_hm containing vertex X, there must be an edge connecting it to vertex Y."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an in_hm with id2 Y then we must have a reached with value Y.",
            "NL": "Whenever id Y is associated with an in_hm, vertex X must be reached."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an in_layer with value L, with id N, whenever there is a width with value L, with id T greater than 0, whenever there is not a gt with id1 L, with id2 N, with id3 P equal to 1, then there must be a position with value N, and with id X equal to 1.",
            "NL": "If an in_layer with value L and id N has a width with value L and id T greater than 0, but there is no GT with id1 L, id2 N, and id3 P equal to 1, then there must be a position with value N and id X set to 1."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an in_layer with value L, with id N, whenever there is a width with value L, with id T greater than 0, whenever there is not a gt with id1 L, with id2 N, with id3 P equal to 1, then there must be a position with value N, and with id X equal to 1.",
            "NL": "If there is an in_layer with value L and id N, and a width with value L and id T greater than 0, but there is not a GT with id1 L, id2 N, and id3 P equal to 1, then there must be a position with value N and id X equal to 1."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an in_layer with value L, with id N, whenever there is a width with value L, with id T greater than 0, whenever there is not a gt with id1 L, with id2 N, with id3 P equal to 1, then there must be a position with value N, and with id X equal to 1.",
            "NL": "If an in_layer with value L and id N has a width with value L and id T greater than 0, but there is no GT with id1 L, id2 N, and id3 P equal to 1, then there must be a position with value N and id X equal to 1."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an in_layer with value L, with id N, whenever there is a width with value L, with id T greater than 0, whenever there is not a gt with id1 L, with id2 N, with id3 P equal to 1, then there must be a position with value N, and with id X equal to 1.",
            "NL": "If there is an in_layer with value L and id N, and the width with value L and id T is greater than 0, but there is no GT with id1 L, id2 N, and id3 P equal to 1, then there must be a position with value N and id X equal to 1."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an in_layer with value L, with id N, whenever there is a width with value L, with id T greater than 0, whenever there is not a gt with id1 L, with id2 N, with id3 P equal to 1, then there must be a position with value N, and with id X equal to 1.",
            "NL": "If there is an in_layer with value L and id N, and a width with value L, id T greater than 0, but there is not a GT with id1 L, id2 N, and id3 P equal to 1, then there must be a position with value N and id X set to 1."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an Independent_Set with key6 R, whenever there is not a Inactive with id3 L, whenever there is not a Inactive with id3 R, whenever there is an Independent_Set with key6 L, whenever there is a Tree with node2 L, and with value7 R different from L, whenever there is a Tree with node2 R, and with value7 L, whenever there is not a Bridge with node2 R, with value7 L, with field H, then there must be a Bridge with node2 R, with value7 L, with field K.",
            "NL": "If there is an Independent_Set with key6 R, there is no Inactive with id3 L or R, an Independent_Set with key6 L, a Tree with node2 L and value7 R that is not L, a Tree with node2 R and value7 L, and no Bridge with node2 R, value7 L, and field H, then a Bridge with node2 R, value7 L, and field K must exist."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an Independent_Set with key6 R, whenever there is not a Inactive with id3 L, whenever there is not a Inactive with id3 R, whenever there is an Independent_Set with key6 L, whenever there is a Tree with node2 L, and with value7 R different from L, whenever there is a Tree with node2 R, and with value7 L, whenever there is not a Bridge with node2 R, with value7 L, with field H, then there must be a Bridge with node2 R, with value7 L, with field K.",
            "NL": "If there is an Independent_Set with key6 R, there is not a Inactive with id3 L, there is an Independent_Set with key6 L, there is a Tree with node2 L, and with value7 R different from L, there is a Tree with node2 R, and with value7 L, but no Bridge with node2 R, with value7 L, with field H, then there must be a Bridge with node2 R, with value7 L, with field K."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an Independent_Set with key6 R, whenever there is not a Inactive with id3 L, whenever there is not a Inactive with id3 R, whenever there is an Independent_Set with key6 L, whenever there is a Tree with node2 L, and with value7 R different from L, whenever there is a Tree with node2 R, and with value7 L, whenever there is not a Bridge with node2 R, with value7 L, with field H, then there must be a Bridge with node2 R, with value7 L, with field K.",
            "NL": "If there is an Independent_Set with key6 R, there is no Inactive with id3 L or R, an Independent_Set with key6 L, a Tree with node2 L and value7 R that is distinct from L, a Tree with node2 R and value7 L, and no Bridge with node2 R, value7 L, and field H, then there must be a Bridge with node2 R, value7 L, and field K."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an Independent_Set with key6 R, whenever there is not a Inactive with id3 L, whenever there is not a Inactive with id3 R, whenever there is an Independent_Set with key6 L, whenever there is a Tree with node2 L, and with value7 R different from L, whenever there is a Tree with node2 R, and with value7 L, whenever there is not a Bridge with node2 R, with value7 L, with field H, then there must be a Bridge with node2 R, with value7 L, with field K.",
            "NL": "If there is an Independent_Set with key6 R, there is no Inactive with id3 L or R, an Independent_Set with key6 L, a Tree with node2 L and value7 R that is different from L, and a Tree with node2 R and value7 L, but not a Bridge with node2 R, value7 L, and field H, then there must be a Bridge with node2 R, value7 L, and field K."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an Independent_Set with key6 R, whenever there is not a Inactive with id3 L, whenever there is not a Inactive with id3 R, whenever there is an Independent_Set with key6 L, whenever there is a Tree with node2 L, and with value7 R different from L, whenever there is a Tree with node2 R, and with value7 L, whenever there is not a Bridge with node2 R, with value7 L, with field H, then there must be a Bridge with node2 R, with value7 L, with field K.",
            "NL": "If there is an Independent_Set with key6 R, but not a Inactive with id3 L or R, and there is an Independent_Set with key6 L, a Tree with node2 L and value7 R that is not L, a Tree with node2 R and value7 L, but not a Bridge with node2 R, value7 L, and field H, then there must be a Bridge with node2 R, value7 L, and field K."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an Indication with edge3 J, with value10 M, whenever there is a Last with edge3 M, whenever there is not a Lead with edge3 M, then there must be a Parent_Edge with value4 J, with id4 M.",
            "NL": "If an Indication with edge3 J and value10 M exists, a Last with edge3 M is present, but no Lead with edge3 M is present, then a Parent_Edge with value4 J and id4 M must be present."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an Indication with edge3 J, with value10 M, whenever there is a Last with edge3 M, whenever there is not a Lead with edge3 M, then there must be a Parent_Edge with value4 J, with id4 M.",
            "NL": "If there is an Indication with edge3 J and value10 M, but there is not a Last with edge3 M or a Lead with edge3 M, then the Parent_Edge must have a value of 4 J and an id4 M."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an Indication with edge3 J, with value10 M, whenever there is a Last with edge3 M, whenever there is not a Lead with edge3 M, then there must be a Parent_Edge with value4 J, with id4 M.",
            "NL": "If there is an Indication with edge3 J and value10 M, a Last with edge3 M, but not a Lead with edge3 M, then the Parent_Edge has a value of 4 J and an id of 4 M."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an Indication with edge3 J, with value10 M, whenever there is a Last with edge3 M, whenever there is not a Lead with edge3 M, then there must be a Parent_Edge with value4 J, with id4 M.",
            "NL": "If there is an Edge3 J Indication with a value of 10 M, there is a Last Edge3 M, but no Lead Edge3 M, then there must be a Parent_Edge with a value of 4 J and an ID of 4 M."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an Indication with edge3 J, with value10 M, whenever there is a Last with edge3 M, whenever there is not a Lead with edge3 M, then there must be a Parent_Edge with value4 J, with id4 M.",
            "NL": "If there is an Indication with edge3 J, with value10 M, and a Last with edge3 M, but no Lead with edge3 M, then a Parent_Edge with value4 J and id4 M must be present."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an inpath with second node X, then there must be a reached with node X.",
            "NL": "Whenever there is an inpath with a second node X, a reached node X must exist."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an inpath with second node X, then there must be a reached with node X.",
            "NL": "Whenever there is an inpath with a second node X, a node X that has been reached must be present."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an inpath with second node X, then there must be a reached with node X.",
            "NL": "Whenever an inpath has node X as its second node, a reached node X must be present."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an inpath with second node X, then there must be a reached with node X.",
            "NL": "Whenever there is an inpath with second node X, node X must be present."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an inpath with second node X, then there must be a reached with node X.",
            "NL": "Whenever there is an inpath with a second node X, node X must be present."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an Investigate with key10 S, with key8 U, whenever there is a Complete with edge5 S, with field9 I, whenever there is a Directed with edge5 J, whenever there is not a Hint with edge5 I, whenever there is not a Hint with edge5 J, whenever there is not an Arc with edge5 I, whenever there is not an Arc with edge5 J different from I, then there must be a Initiate with node7 J, with id2 S, with vtx U.",
            "NL": "If there is an Investigate with key10 S and key8 U, there must be a Complete with edge5 S and field9 I, a Directed with edge5 J, no Hint with edge5 I or J, no Arc with edge5 I or J (where J is not equal to I), and a Initiate with node7 J, id2 S, and vtx U."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an Investigate with key10 S, with key8 U, whenever there is a Complete with edge5 S, with field9 I, whenever there is a Directed with edge5 J, whenever there is not a Hint with edge5 I, whenever there is not a Hint with edge5 J, whenever there is not an Arc with edge5 I, whenever there is not an Arc with edge5 J different from I, then there must be a Initiate with node7 J, with id2 S, with vtx U.",
            "NL": "When there is an Investigate with key10 S and key8 U, and there is a Complete with edge5 S and field9 I, as well as a Directed with edge5 J, but no Hint with edge5 I or edge5 J, or an Arc with edge5 I or J where J is not equal to I, then there must be an Initiate with node7 J, id2 S, and vtx U."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an Investigate with key10 S, with key8 U, whenever there is a Complete with edge5 S, with field9 I, whenever there is a Directed with edge5 J, whenever there is not a Hint with edge5 I, whenever there is not a Hint with edge5 J, whenever there is not an Arc with edge5 I, whenever there is not an Arc with edge5 J different from I, then there must be a Initiate with node7 J, with id2 S, with vtx U.",
            "NL": "Whenever there is an Investigate with key10 S and key8 U, a Complete with edge5 S and field9 I, a Directed with edge5 J, but no Hint with edge5 I or J, or an Arc with edge5 I or J (where J is not equal to I), then a Initiate with node7 J, id2 S, and vtx U must be present."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an Investigate with key10 S, with key8 U, whenever there is a Complete with edge5 S, with field9 I, whenever there is a Directed with edge5 J, whenever there is not a Hint with edge5 I, whenever there is not a Hint with edge5 J, whenever there is not an Arc with edge5 I, whenever there is not an Arc with edge5 J different from I, then there must be a Initiate with node7 J, with id2 S, with vtx U.",
            "NL": "If there is an Investigate with key10 S and key8 U, there must be a Complete with edge5 S and field9 I, a Directed with edge5 J, but no Hint with edge5 I or edge5 J. Moreover, if there is no Arc with edge5 I, and J is not equal to I, then there must be an Initiate with node7 J, id2 S, and vtx U."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an Investigate with key10 S, with key8 U, whenever there is a Complete with edge5 S, with field9 I, whenever there is a Directed with edge5 J, whenever there is not a Hint with edge5 I, whenever there is not a Hint with edge5 J, whenever there is not an Arc with edge5 I, whenever there is not an Arc with edge5 J different from I, then there must be a Initiate with node7 J, with id2 S, with vtx U.",
            "NL": "If there is an Investigate with key10 S and key8 U, then there must be a Complete with edge5 S and field9 I, a Directed with edge5 J, but no Hint with either edge5 I or edge5 J, and no Arc with either edge5 I or edge5 J, where J is not equal to I, and there must be an Initiate with node7 J, id2 S, and vtx U."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an Irrelevant with second point J, with first vertex M, whenever there is an Unpaired with second point J, then we must have a NotFirst with value J, with vtx4 M or Passive with second point J, with first vertex M. ",
            "NL": "Whenever there is an Irrelevant with second point J and first vertex M, or an Unpaired with second point J, there must be a NotFirst with value J and vtx4 M, or a Passive with second point J and first vertex M."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an Irrelevant with second point J, with first vertex M, whenever there is an Unpaired with second point J, then we must have a NotFirst with value J, with vtx4 M or Passive with second point J, with first vertex M. ",
            "NL": "Whenever there is an Irrelevant with second point J and first vertex M, or an Unpaired with second point J, then there must be a NotFirst with value J and vtx4 M, or a Passive with second point J and first vertex M."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an Irrelevant with second point J, with first vertex M, whenever there is an Unpaired with second point J, then we must have a NotFirst with value J, with vtx4 M or Passive with second point J, with first vertex M. ",
            "NL": "Whenever there is an Irrelevant and an Unpaired with second point J, and first vertex M, there must also be a NotFirst with the same value of J, with vtx4 M, or a Passive with second point J and first vertex M."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an Irrelevant with second point J, with first vertex M, whenever there is an Unpaired with second point J, then we must have a NotFirst with value J, with vtx4 M or Passive with second point J, with first vertex M. ",
            "NL": "If there is an Irrelevant with second point J and first vertex M, then there must be either a NotFirst with value J, vtx4 M, or a Passive with second point J and first vertex M."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an Irrelevant with second point J, with first vertex M, whenever there is an Unpaired with second point J, then we must have a NotFirst with value J, with vtx4 M or Passive with second point J, with first vertex M. ",
            "NL": "Whenever an Irrelevant with second point J and first vertex M, an Unpaired with second point J, NotFirst with value J and vtx4 M, or a Passive with second point J and first vertex M is present, it must be accounted for."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an Lacking with vtx5 M, with id9 D, whenever there is a Hint with value R less than G, with id9 M, whenever there is a Hint with vtx5 G, with id9 D, then we must have an Accomplishment with value8 R, with id2 G, with node7 M, with field2 D.",
            "NL": "Whenever there is a Lacking with vtx5 M and id9 D, there is a Hint with value R less than G and id9 M; and when there is a Hint with vtx5 G and id9 D, an Accomplishment with value8 R, id2 G, node7 M, and field2 D must be present."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an Lacking with vtx5 M, with id9 D, whenever there is a Hint with value R less than G, with id9 M, whenever there is a Hint with vtx5 G, with id9 D, then we must have an Accomplishment with value8 R, with id2 G, with node7 M, with field2 D.",
            "NL": "Whenever a Lacking with vtx5 M, id9 D appears, a Hint with value R lower than G, id9 M, follows and when a Hint with vtx5 G, id9 D is present, an Accomplishment with value8 R, id2 G, node7 M, and field2 D is required."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an Lacking with vtx5 M, with id9 D, whenever there is a Hint with value R less than G, with id9 M, whenever there is a Hint with vtx5 G, with id9 D, then we must have an Accomplishment with value8 R, with id2 G, with node7 M, with field2 D.",
            "NL": "Whenever there is a Lacking with vtx5 M and id9 D, there is a Hint with value R that is less than G, with id9 M, and when there is a Hint with vtx5 G and id9 D, we must have an Accomplishment with value8 R, id2 G, node7 M, and field2 D."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an Lacking with vtx5 M, with id9 D, whenever there is a Hint with value R less than G, with id9 M, whenever there is a Hint with vtx5 G, with id9 D, then we must have an Accomplishment with value8 R, with id2 G, with node7 M, with field2 D.",
            "NL": "Whenever there is a Lacking with vtx5 M, id9 D, there is a Hint with value R less than G, id9 M, and when there is a Hint with vtx5 G, id9 D, we must have an Accomplishment with value8 R, id2 G, node7 M, and field2 D."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an Lacking with vtx5 M, with id9 D, whenever there is a Hint with value R less than G, with id9 M, whenever there is a Hint with vtx5 G, with id9 D, then we must have an Accomplishment with value8 R, with id2 G, with node7 M, with field2 D.",
            "NL": "Whenever there is an absence of vtx5M with id9D, a clue with value R less than G and id9M is present, and if there is a hint of vtx5G with id9D, then we must have an achievement of value8R, id2G, node7M, and field2D."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an Launch with value10 O, with vtx C, whenever there is a Module with vtx5 O, with key1 C, with value1 D, whenever there is not an Module with vtx5 O, with key1 C, with value1 Y, whenever there is a Weight with vtx5 O, with key1 E different from H, whenever there is a Weight with vtx5 C, with key1 H then there must be a Out_Hamiltonian_Tour with value10 O, with vtx C.",
            "NL": "If there is a Launch with value 10 O and vtx C, a Module with vtx5 O, key1 C, and value1 D, but not a Module with vtx5 O, key1 C, and value1 Y, a Weight with vtx5 O and key1 E, and a Weight with vtx5 C, key1 H, and vtx E is not equal to H, then an Out_Hamiltonian_Tour with value 10 O and vtx C must exist."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an Launch with value10 O, with vtx C, whenever there is a Module with vtx5 O, with key1 C, with value1 D, whenever there is not an Module with vtx5 O, with key1 C, with value1 Y, whenever there is a Weight with vtx5 O, with key1 E different from H, whenever there is a Weight with vtx5 C, with key1 H then there must be a Out_Hamiltonian_Tour with value10 O, with vtx C.",
            "NL": "If there is a Launch with value10 O and vtx C, there must be a Module with vtx5 O, key1 C, and value1 D; however, there cannot be a Module with vtx5 O, key1 C, and value1 Y, and there must be a Weight with vtx5 O and key1 E, as well as a Weight with vtx5 C and key1 H where vtx E is not equal to H, in order for there to be an Out_Hamiltonian_Tour with value10 O and vtx C."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an Launch with value10 O, with vtx C, whenever there is a Module with vtx5 O, with key1 C, with value1 D, whenever there is not an Module with vtx5 O, with key1 C, with value1 Y, whenever there is a Weight with vtx5 O, with key1 E different from H, whenever there is a Weight with vtx5 C, with key1 H then there must be a Out_Hamiltonian_Tour with value10 O, with vtx C.",
            "NL": "If the Launch has a value of 10 O with vtx C, and there is a Module with vtx5 O, key1 C, and value1 D, but not a Module with vtx5 O, key1 C, and value1 Y, a Weight with vtx5 O, and key1 E, and a Weight with vtx5 C, and key1 H, where vtx E is not equal to H, then there must be an Out_Hamiltonian_Tour with value10 O, and vtx C."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an Launch with value10 O, with vtx C, whenever there is a Module with vtx5 O, with key1 C, with value1 D, whenever there is not an Module with vtx5 O, with key1 C, with value1 Y, whenever there is a Weight with vtx5 O, with key1 E different from H, whenever there is a Weight with vtx5 C, with key1 H then there must be a Out_Hamiltonian_Tour with value10 O, with vtx C.",
            "NL": "If there exists a Launch with value10 O and vtx C, then there must be a Module with vtx5 O, key1 C and value1 D; however, there is not an Module with vtx5 O, key1 C and value1 Y, but a Weight with vtx5 O and key1 E, and a Weight with vtx5 C and key1 H, where vtx E is not equal to H, thus, a Out_Hamiltonian_Tour with value10 O and vtx C must be present."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an Launch with value10 O, with vtx C, whenever there is a Module with vtx5 O, with key1 C, with value1 D, whenever there is not an Module with vtx5 O, with key1 C, with value1 Y, whenever there is a Weight with vtx5 O, with key1 E different from H, whenever there is a Weight with vtx5 C, with key1 H then there must be a Out_Hamiltonian_Tour with value10 O, with vtx C.",
            "NL": "If there is a Launch with value10 O and vtx C, then there is a Module with vtx5 O, key1 C, and value1 D, but not with value1 Y; and a Weight with vtx5 O and key1 E, as well as a Weight with vtx5 C and key1 H, where vtx E is not equal to H, then there must be an Out_Hamiltonian_Tour with value10 O and vtx C."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an manAssignsScore with id1 M, and with id2 FV1, and with id3 FV2, whenever there is a womanAssignsScore with id1 W, and with id2 FV3, and with id3 FV4, whenever there is not an nonMatch with value M, and with id W, then there must be an match with value M, with id W.",
            "NL": "If there is not a nonMatch with value M and ID W when a manAssignsScore with ID1 M, ID2 FV1, and ID3 FV2, and a womanAssignsScore with ID1 W, ID2 FV3, and ID3 FV4, then a match with value M and ID W must exist."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an manAssignsScore with id1 M, and with id2 FV1, and with id3 FV2, whenever there is a womanAssignsScore with id1 W, and with id2 FV3, and with id3 FV4, whenever there is not an nonMatch with value M, and with id W, then there must be an match with value M, with id W.",
            "NL": "If there is a man with ID1 M, ID2 FV1, and ID3 FV2, a woman with ID1 W, ID2 FV3, and ID3 FV4, and there is not a nonMatch with value M and ID W, there must be a match with value M and ID W."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an manAssignsScore with id1 M, and with id2 FV1, and with id3 FV2, whenever there is a womanAssignsScore with id1 W, and with id2 FV3, and with id3 FV4, whenever there is not an nonMatch with value M, and with id W, then there must be an match with value M, with id W.",
            "NL": "If there is no nonMatch between a manAssignsScore with ids M, FV1, and FV2, and a womanAssignsScore with ids W, FV3, and FV4, then there must be a match with value M and id W."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an manAssignsScore with id1 M, and with id2 FV1, and with id3 FV2, whenever there is a womanAssignsScore with id1 W, and with id2 FV3, and with id3 FV4, whenever there is not an nonMatch with value M, and with id W, then there must be an match with value M, with id W.",
            "NL": "If there is a manAssignsScore with id1 M, id2 FV1, and id3 FV2, a womanAssignsScore with id1 W, id2 FV3, and id3 FV4, and no nonMatch with value M and id W, then there must be a match with value M, and id W."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an manAssignsScore with id1 M, and with id2 FV1, and with id3 FV2, whenever there is a womanAssignsScore with id1 W, and with id2 FV3, and with id3 FV4, whenever there is not an nonMatch with value M, and with id W, then there must be an match with value M, with id W.",
            "NL": "If there is a man with ID1 M, ID2 FV1, and ID3 FV2, a woman with ID1 W, ID2 FV3, and ID3 FV4, and there is no non-match with value M and ID W, then there must be a match with value M and ID W."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an Matching with key3 T, whenever there is not an Parent T, whenever there is not an Outgoing T, then there must be an Clique with vtx4 T.",
            "NL": "Whenever there is a Matching with key3 T, there is no Parent T, nor an Outgoing T, and thus a Clique with vtx4 T must be present."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an Matching with key3 T, whenever there is not an Parent T, whenever there is not an Outgoing T, then there must be an Clique with vtx4 T.",
            "NL": "If key3 T is present, Parent T and Outgoing T will not be, and Clique with vtx4 T must be instead."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an Matching with key3 T, whenever there is not an Parent T, whenever there is not an Outgoing T, then there must be an Clique with vtx4 T.",
            "NL": "Whenever key3 T is present, there is no Parent T, no Outgoing T, and thus a Clique with vtx4 T must exist."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an Matching with key3 T, whenever there is not an Parent T, whenever there is not an Outgoing T, then there must be an Clique with vtx4 T.",
            "NL": "If key3T is present, ParentT and OutgoingT will not be present, so there must be a Clique with vtx4T."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an Matching with key3 T, whenever there is not an Parent T, whenever there is not an Outgoing T, then there must be an Clique with vtx4 T.",
            "NL": "If there is no Parent T and no Outgoing T present during a Matching with key3 T, then a Clique with vtx4 T must exist."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an obs_vlabel with id1 V, with id2 S, whenever there is a vertex with value W, whenever there is not a trivial with value V, whenever there is not a trivial with value W, whenever there is not an input with value V, whenever there is not an input with value W different from V, then there must be a mvlabel with field1 W, with field2 V, with field3 S. ",
            "NL": "If the values of W and V are not equal, and there is an obs_vlabel with id1 V and id2 S, a vertex with value W, no trivial with values V or W, and no input with values V or W, then there must be a mvlabel with field1 W, field2 V, and field3 S."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an obs_vlabel with id1 V, with id2 S, whenever there is a vertex with value W, whenever there is not a trivial with value V, whenever there is not a trivial with value W, whenever there is not an input with value V, whenever there is not an input with value W different from V, then there must be a mvlabel with field1 W, with field2 V, with field3 S. ",
            "NL": "If there is an obs_vlabel with id1 V, with id2 S, and W is not equal to V, but there is no trivial with value V, no trivial with value W, no input with value V, and no input with value W, then there must be a mvlabel with field1 W, field2 V, and field3 S."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an obs_vlabel with id1 V, with id2 S, whenever there is a vertex with value W, whenever there is not a trivial with value V, whenever there is not a trivial with value W, whenever there is not an input with value V, whenever there is not an input with value W different from V, then there must be a mvlabel with field1 W, with field2 V, with field3 S. ",
            "NL": "If a vertex with value W exists, and there is an obs_vlabel with id1 V, id2 S, where W is not equal to V, but there is no trivial with value V or W, nor an input with value V or W, then a mvlabel must have field1 W, field2 V, and field3 S."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an obs_vlabel with id1 V, with id2 S, whenever there is a vertex with value W, whenever there is not a trivial with value V, whenever there is not a trivial with value W, whenever there is not an input with value V, whenever there is not an input with value W different from V, then there must be a mvlabel with field1 W, with field2 V, with field3 S. ",
            "NL": "If W and V are not equal, and there is an obs_vlabel with id1 V and id2 S, then there must be a vertex with value W, but not a trivial with value V, not a trivial with value W, not an input with value V, and not an input with value W. Furthermore, there must be a mvlabel with field1 W, field2 V, and field3 S."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an obs_vlabel with id1 V, with id2 S, whenever there is a vertex with value W, whenever there is not a trivial with value V, whenever there is not a trivial with value W, whenever there is not an input with value V, whenever there is not an input with value W different from V, then there must be a mvlabel with field1 W, with field2 V, with field3 S. ",
            "NL": "If an obs_vlabel with id1 V and id2 S exists, a vertex with value W is present, and neither a trivial with value V nor a trivial with value W, nor an input with value V nor an input with value W (where W is not equal to V) exists, then there must be a mvlabel with field1 W, field2 V, and field3 S."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an OutDegree with second id V, and with third node Y then we must have a Subposition with second id V, and with third node Y.",
            "NL": "If there is an OutDegree connection between the second id V and the third node Y, then there must be a Subposition between them."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an OutDegree with second id V, and with third node Y then we must have a Subposition with second id V, and with third node Y.",
            "NL": "If there is an OutDegree connection between the second id V and the third node Y, then a Subposition must exist between the second id V and the third node Y."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an OutDegree with second id V, and with third node Y then we must have a Subposition with second id V, and with third node Y.",
            "NL": "If there is a connection between the second identifier V and the third node Y, there must be a relationship between the second identifier V and the third node Y."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an OutDegree with second id V, and with third node Y then we must have a Subposition with second id V, and with third node Y.",
            "NL": "If there is a connection from the second id V to the third node Y, then there must be a relationship between the second id V and the third node Y."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an OutDegree with second id V, and with third node Y then we must have a Subposition with second id V, and with third node Y.",
            "NL": "If there is a connection between the second id V and the third node Y, there must be a relationship between the second id V and the third node Y."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an Pair_of_Nodes with id7 J, with field3 L, whenever there is an Eulerian_Circuit with id7 J, with field3 T greater than J, then there must be an NonPlanar with id7 T, with id7 L.",
            "NL": "If J is less than T and there is a Pair_of_Nodes with id7 J and field3 L, as well as an Eulerian_Circuit with id7 J and field3 T, then it is necessary for there to be a NonPlanar with id7 T and id7 L."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an Pair_of_Nodes with id7 J, with field3 L, whenever there is an Eulerian_Circuit with id7 J, with field3 T greater than J, then there must be an NonPlanar with id7 T, with id7 L.",
            "NL": "If J is less than T and there is a Pair_of_Nodes with id7 J, field3 L, and a Eulerian_Circuit with id7 J and field3 T, then a NonPlanar must have id7 T and id7 L."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an Pair_of_Nodes with id7 J, with field3 L, whenever there is an Eulerian_Circuit with id7 J, with field3 T greater than J, then there must be an NonPlanar with id7 T, with id7 L.",
            "NL": "If the id7 J of a Pair_of_Nodes has field3 L and the id7 J of an Eulerian_Circuit has field3 T, and J is smaller than T, then there must be a NonPlanar with id7 T and id7 L."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an Pair_of_Nodes with id7 J, with field3 L, whenever there is an Eulerian_Circuit with id7 J, with field3 T greater than J, then there must be an NonPlanar with id7 T, with id7 L.",
            "NL": "If a Pair_of_Nodes with id7 J has field3 L, and a Eulerian_Circuit with id7 J has field3 T, where J is less than T, then it is necessary for a NonPlanar with id7 T and id7 L to exist."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an Pair_of_Nodes with id7 J, with field3 L, whenever there is an Eulerian_Circuit with id7 J, with field3 T greater than J, then there must be an NonPlanar with id7 T, with id7 L.",
            "NL": "If there is a Pair_of_Nodes with id7 J, field3 L, and an Eulerian_Circuit with id7 J, field3 T, and J is less than T, then it is necessary for there to be a NonPlanar with id7 T and id7 L."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an partition with value U, with id K, whenever there is an partition with value V, with id K, whenever there is a vtx with id V, and with id V less than U, then we must have an existsless with id1 U, with id2 K.",
            "NL": "If a vtx id V is less than U and there are partitions with values U and K and V and K, respectively, then it is necessary to have an existsless with id1 U and id2 K."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an partition with value U, with id K, whenever there is an partition with value V, with id K, whenever there is a vtx with id V, and with id V less than U, then we must have an existsless with id1 U, with id2 K.",
            "NL": "If id V is less than U and there are two partitions with value U and id K, and another with value V and id K, and a vtx id V, then there must be an existsless with id1 U, id2 K."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an partition with value U, with id K, whenever there is an partition with value V, with id K, whenever there is a vtx with id V, and with id V less than U, then we must have an existsless with id1 U, with id2 K.",
            "NL": "If id V is less than U and there is a partition with value U and id K, as well as a partition with value V and id K, and a vtx id V, then an existsless with id1 U, id2 K must exist."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an partition with value U, with id K, whenever there is an partition with value V, with id K, whenever there is a vtx with id V, and with id V less than U, then we must have an existsless with id1 U, with id2 K.",
            "NL": "If id V is less than U, and there is a partition with value U and id K, and another partition with value V and id K, and a vtx id V, then there must be an existsless with id1 U, id2 K."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an partition with value U, with id K, whenever there is an partition with value V, with id K, whenever there is a vtx with id V, and with id V less than U, then we must have an existsless with id1 U, with id2 K.",
            "NL": "If the vertex ID V is less than U and there are two partitions with values U and V and ID K, then there must be an existsless with ID1 U and ID2 K."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an reach with first vtx U, and with second vtx V then we must have a reached with value V.",
            "NL": "When there is a connection between vertex U and vertex V, we need to have an edge with the value V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an reach with first vtx U, and with second vtx V then we must have a reached with value V.",
            "NL": "When there is a connection between the first vertex U and the second vertex V, we need to set a value of V for the connection."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an reach with first vtx U, and with second vtx V then we must have a reached with value V.",
            "NL": "When a connection exists between vertex U and vertex V, we need to have a link with the value of V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an reach with first vtx U, and with second vtx V then we must have a reached with value V.",
            "NL": "When there is a connection between vertex U and vertex V, we need to assign a value of V to the connection."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an reach with first vtx U, and with second vtx V then we must have a reached with value V.",
            "NL": "When there is a connection between vertex U and vertex V, we need to establish a link with a value of V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an uedge with id1 U, with id2 V, whenever there is a partition with value U, with id X, whenever there is a partition with value V, with id Y, and with id Y greater than X, then we must have a adjacent with id1 U, with id2 V, with id3 X, with id4 Y.",
            "NL": "If U and V are two uedges with partition id X (where X is less than Y) for U and Y for V, then there must be an adjacent with ids U, V, X, and Y."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an uedge with id1 U, with id2 V, whenever there is a partition with value U, with id X, whenever there is a partition with value V, with id Y, and with id Y greater than X, then we must have a adjacent with id1 U, with id2 V, with id3 X, with id4 Y.",
            "NL": "If U and V are two edges with partitions X and Y respectively, where X is less than Y, then the adjacent must include U, V, X, and Y."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an uedge with id1 U, with id2 V, whenever there is a partition with value U, with id X, whenever there is a partition with value V, with id Y, and with id Y greater than X, then we must have a adjacent with id1 U, with id2 V, with id3 X, with id4 Y.",
            "NL": "If U and V are uedges with partitions X (less than Y) and Y respectively, then there must be an adjacent with ids U, V, X, and Y."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an uedge with id1 U, with id2 V, whenever there is a partition with value U, with id X, whenever there is a partition with value V, with id Y, and with id Y greater than X, then we must have a adjacent with id1 U, with id2 V, with id3 X, with id4 Y.",
            "NL": "If U and V are two edges with partitions X and Y respectively, where X is less than Y, then they must have an adjacent with IDs U, V, X, and Y."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an uedge with id1 U, with id2 V, whenever there is a partition with value U, with id X, whenever there is a partition with value V, with id Y, and with id Y greater than X, then we must have a adjacent with id1 U, with id2 V, with id3 X, with id4 Y.",
            "NL": "If id X is less than id Y and there is an edge between ids U and V, with a partition having id U and X and another partition having id V and Y, then an adjacent edge must exist with ids U, V, X, and Y."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an uedge with id1 U, with id2 V, whenever there is an weight_edgewt with first vtx V, with second vtx U, with third weight W, then we must have an u_edge with id1 U, with id2 V, with id3 W.",
            "NL": "For any undirected edge with id U and id V, having a weight W with the first vertex being V and the second vertex being U, there must be an associated undirected edge with id U, id V, and weight W."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an uedge with id1 U, with id2 V, whenever there is an weight_edgewt with first vtx V, with second vtx U, with third weight W, then we must have an u_edge with id1 U, with id2 V, with id3 W.",
            "NL": "Whenever there is an undirected edge with id U and id V, and an edge weight with weight W, having first vertex V and second vertex U, there must also be an undirected edge with id U, id V, and weight W."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an uedge with id1 U, with id2 V, whenever there is an weight_edgewt with first vtx V, with second vtx U, with third weight W, then we must have an u_edge with id1 U, with id2 V, with id3 W.",
            "NL": "Whenever there is an undirected edge with id U and id V, and an edge weight of weight W, with the first vertex being V and the second vertex being U, there must also be an undirected edge with id U, id V, and weight W."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an uedge with id1 U, with id2 V, whenever there is an weight_edgewt with first vtx V, with second vtx U, with third weight W, then we must have an u_edge with id1 U, with id2 V, with id3 W.",
            "NL": "There must be an undirected edge with id U, id V, and weight W whenever there is an edge with first vertex V and second vertex U."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an uedge with id1 U, with id2 V, whenever there is an weight_edgewt with first vtx V, with second vtx U, with third weight W, then we must have an u_edge with id1 U, with id2 V, with id3 W.",
            "NL": "For every undirected edge with id U and id V, and an edge weight with weight W, having the first vertex V and the second vertex U, there must be an undirected edge with id U, id V, and weight W."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an uedge with value U, with id V, whenever there is a reach with id1 K, with id2 U, whenever there is a partition with value V, with id K then we must have a reach with id1 K, with id2 V. ",
            "NL": "If U and V are the ids of an edge, K is the id of a reach with U, and X is the id of a partition with V, then K, V must also have a reach."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an uedge with value U, with id V, whenever there is a reach with id1 K, with id2 U, whenever there is a partition with value V, with id K then we must have a reach with id1 K, with id2 V. ",
            "NL": "Whenever we have an edge with ids U and V, and a reach with id K associated with id U, as well as a partition with ids V and X, then we must also have a reach with id K and id V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an uedge with value U, with id V, whenever there is a reach with id1 K, with id2 U, whenever there is a partition with value V, with id K then we must have a reach with id1 K, with id2 V. ",
            "NL": "Whenever U and V are both edges, with K as their reach and V and X as their partitions, then K, V must have a reach."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an uedge with value U, with id V, whenever there is a reach with id1 K, with id2 U, whenever there is a partition with value V, with id K then we must have a reach with id1 K, with id2 V. ",
            "NL": "If there is an edge with U and V IDs, and a reach with K ID, U and V partitions, then the reach must have K, V IDs."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an uedge with value U, with id V, whenever there is a reach with id1 K, with id2 U, whenever there is a partition with value V, with id K then we must have a reach with id1 K, with id2 V. ",
            "NL": "If there is a junction with IDs U and V, having a reach with ID K, a partition with IDs V and X, then there must be a reach with ID K and V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an Unmatch with edge2 Q, with node5 J, whenever there is a Separate with edge2 Q, with node5 S greater than Q, then there must be an Point with edge2 S, with edge2 J.",
            "NL": "If edge2 Q is less than edge2 S and node5 J does not match node5 S, then edge2 S must be pointed to and edge2 J must be connected."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an Unmatch with edge2 Q, with node5 J, whenever there is a Separate with edge2 Q, with node5 S greater than Q, then there must be an Point with edge2 S, with edge2 J.",
            "NL": "If Q is less than S and there is an Unmatch with edge2 Q and node5 J, as well as a Separate with edge2 Q and node5 S, then there must be a Point with edge2 S and node5 J."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an Unmatch with edge2 Q, with node5 J, whenever there is a Separate with edge2 Q, with node5 S greater than Q, then there must be an Point with edge2 S, with edge2 J.",
            "NL": "If Q is lower than S, then there must be a Point with edge2 S and edge2 J when there is an Unmatch with edge2 Q and node5 J, and a Separate with edge2 Q and node5 S."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an Unmatch with edge2 Q, with node5 J, whenever there is a Separate with edge2 Q, with node5 S greater than Q, then there must be an Point with edge2 S, with edge2 J.",
            "NL": "If Q is less than S and there is an Unmatch with edge2 Q, node5 J, and a Separate with edge2 Q and node5 S, then there must be a Point with edge2 S and edge2 J."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an Unmatch with edge2 Q, with node5 J, whenever there is a Separate with edge2 Q, with node5 S greater than Q, then there must be an Point with edge2 S, with edge2 J.",
            "NL": "If Q is less than S and there is an Unmatch between edge2 Q and node5 J, as well as a Separation between edge2 Q and node5 S, then there must be a Point between edge2 S and edge2 J."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an used_edge with first vtx U, and with second vtx V then we must have a reach with first vtx U, and with second vtx V.",
            "NL": "If there is an existing connection between vertex U and vertex V, then there must be a path between them."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an used_edge with first vtx U, and with second vtx V then we must have a reach with first vtx U, and with second vtx V.",
            "NL": "If there is a connection between the first vertex U and the second vertex V, there must be a path between the two."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an used_edge with first vtx U, and with second vtx V then we must have a reach with first vtx U, and with second vtx V.",
            "NL": "When there is a connection between the first vertex U and the second vertex V, there must be a path between the first vertex U and the second vertex V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an used_edge with first vtx U, and with second vtx V then we must have a reach with first vtx U, and with second vtx V.",
            "NL": "When there is a connection between vertex U and vertex V, there must be a path between them."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "Whenever there is an used_edge with first vtx U, and with second vtx V then we must have a reach with first vtx U, and with second vtx V.",
            "NL": "There must be a connection between the first vertex U and the second vertex V if there is an existing edge between them."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an vertex with value V, whenever there is not an input V, whenever there is an active W with key W different from V, whenever there is a trivial W then there must be an inactive with value V.",
            "NL": "If a vertex has value V, and an active with key W exists, where V is not equal to W, then there must be an inactive with value V if a trivial W is present."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an vertex with value V, whenever there is not an input V, whenever there is an active W with key W different from V, whenever there is a trivial W then there must be an inactive with value V.",
            "NL": "If there is a vertex with value V and an active with key W, where V is not equal to W, then there must be an inactive with value V and a trivial W."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an vertex with value V, whenever there is not an input V, whenever there is an active W with key W different from V, whenever there is a trivial W then there must be an inactive with value V.",
            "NL": "If a vertex is not equal to the key W and has a value V, then an active with key W must exist, and an inactive with value V must also exist in the case of a trivial W."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an vertex with value V, whenever there is not an input V, whenever there is an active W with key W different from V, whenever there is a trivial W then there must be an inactive with value V.",
            "NL": "If the vertex has a value of V and the input is not V, then there will be an active with key W if V is not equal to W; however, if W is trivial, then there must be an inactive with value V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an vertex with value V, whenever there is not an input V, whenever there is an active W with key W different from V, whenever there is a trivial W then there must be an inactive with value V.",
            "NL": "If a vertex has a value V and there is an active with key W where V is not equal to W, then there must be an inactive with value V and a trivial W."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an vertex with value V, whenever there is not an input with value V, whenever there is not an nontriv with value V, then there must be a trivial with value V. ",
            "NL": "If there is a vertex V for which there is no input with value V and no nontrivial output with value V, then there must be a trivial output with value V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an vertex with value V, whenever there is not an input with value V, whenever there is not an nontriv with value V, then there must be a trivial with value V. ",
            "NL": "If there is no input with value V for a given vertex V, and no nontrivial with value V, then there must be a trivial with value V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an vertex with value V, whenever there is not an input with value V, whenever there is not an nontriv with value V, then there must be a trivial with value V. ",
            "NL": "If there is a vertex V for which there is no input with value V and no nontrivial with value V, then there must be a trivial with value V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an vertex with value V, whenever there is not an input with value V, whenever there is not an nontriv with value V, then there must be a trivial with value V. ",
            "NL": "If there is a vertex V and no input with a value of V, and there is not a non-trivial solution with a value of V, then there must be a trivial solution with a value of V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is an vertex with value V, whenever there is not an input with value V, whenever there is not an nontriv with value V, then there must be a trivial with value V. ",
            "NL": "If there is a vertex V which does not have an input of value V, and there is no non-trivial output of value V, then the output of value V must be trivial."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is ntedge with id1 W, with id2 U, with id3 V, then there must be a nfirst with field1 U, with field2 V.",
            "NL": "Whenever there is a ntedge with id1 W, id2 U, and id3 V, there must be a nfirst with field1 U and field2 V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is ntedge with id1 W, with id2 U, with id3 V, then there must be a nfirst with field1 U, with field2 V.",
            "NL": "Whenever there is a ntedge with id1 W, id2 U, and id3 V, there must exist a nfirst with field1 U and field2 V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is ntedge with id1 W, with id2 U, with id3 V, then there must be a nfirst with field1 U, with field2 V.",
            "NL": "Whenever there is a ntedge with id1 W, id2 U, and id3 V, the nfirst must have field1 U and field2 V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is ntedge with id1 W, with id2 U, with id3 V, then there must be a nfirst with field1 U, with field2 V.",
            "NL": "Whenever a ntedge with id1 W, id2 U, and id3 V exists, there must be a nfirst with field1 U and field2 V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is ntedge with id1 W, with id2 U, with id3 V, then there must be a nfirst with field1 U, with field2 V.",
            "NL": "Whenever there is a ntedge with id1 W, id2 U, and id3 V, it must be accompanied by a nfirst with field1 U and field2 V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is ntedge with id1 W, with id2 U, with id3 V, then there must be a nlast with field1 W, with field2 V.",
            "NL": "Whenever there is a ntedge with id1 W, id2 U, and id3 V, there must be a nlast with field1 W and field2 V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is ntedge with id1 W, with id2 U, with id3 V, then there must be a nlast with field1 W, with field2 V.",
            "NL": "Whenever there is a ntedge with ids W, U, and V, there must be a nlast with field1 W and field2 V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is ntedge with id1 W, with id2 U, with id3 V, then there must be a nlast with field1 W, with field2 V.",
            "NL": "Whenever there is a ntedge with id1 W, id2 U, and id3 V, a nlast with field1 W and field2 V must be present."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is ntedge with id1 W, with id2 U, with id3 V, then there must be a nlast with field1 W, with field2 V.",
            "NL": "Whenever there is a ntedge with ids W, U, and V, there must be a nlast with fields W and V."
        },
        {
            "Category": "Definition Whenever",
            "CNL": "whenever there is ntedge with id1 W, with id2 U, with id3 V, then there must be a nlast with field1 W, with field2 V.",
            "NL": "Whenever a ntedge with ids W, U, and V exists, there must be a nlast with field1 W and field2 V."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that E is not after W, whenever there is an Initial with fourth id E, whenever there is an Initial with fourth id W, whenever there is not Tree with id5 E, and with node7 W, whenever there is not Tree with id5 W, and with node7 E.",
            "NL": "There is a prohibition against having a Initial with fourth id E and a Initial with fourth id W, there is not an Tree with id5 E, with node7 W, and not an Tree with id5 W, with node7 E. "
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that F is not after Q, whenever there is a Trivial with second point F, whenever there is a Trivial with second point Q, whenever there is not Last with vtx3 F, and with node2 Q, whenever there is not Last with vtx3 Q, and with node2 F.",
            "NL": "There is a prohibition against having a Trivial with second point F and a Trivial with second point Q, there is not an Last with vtx3 F, with node2 Q, and not an Last with vtx3 Q, with node2 F. "
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that G is at most Z, whenever there is a Sub_Index with third node G, whenever there is a Sub_Index with third node Z, whenever there is not Color with key3 G, and with key9 Z, whenever there is not Color with key3 Z, and with key9 G.",
            "NL": "There is a prohibition against having a Sub_Index with third node G and a Sub_Index with third node Z, there is not an Color with key3 G, with key9 Z, and not an Color with key3 Z, with key9 G. "
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that N is not after F, whenever there is an Triplet with third node N, whenever there is an Triplet with third node F, whenever there is not Unmatched with node6 N, and with field4 F, whenever there is not Unmatched with node6 F, and with field4 N.",
            "NL": "There is a prohibition against having a Triplet with third node N and a Triplet with third node F, there is not an Unmatched with node6 N, with field4 F, and not an Unmatched with node6 F, with field4 N. "
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that O is at most X, whenever there is a Hamiltonian_Graph with fifth node O, whenever there is a Hamiltonian_Graph with fifth node X, whenever there is not Center with field3 O, and with id3 X, whenever there is not Center with field3 X, and with id3 O.",
            "NL": "There is a prohibition against having a Hamiltonian_Graph with fifth node O and a Hamiltonian_Graph with fifth node X, there is not an Center with field3 O, with id3 X, and not an Center with field3 X, with id3 O. "
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that Q is not after F, whenever there is an Lead with fifth vertex Q, whenever there is an Lead with fifth vertex F, whenever there is not Indication with id3 Q, and with node1 F, whenever there is not Indication with id3 F, and with node1 Q.",
            "NL": "There is a prohibition against having a Lead with fifth vertex Q and a Lead with fifth vertex F, there is not an Indication with id3 Q, with node1 F, and not an Indication with id3 F, with node1 Q. "
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that S is not after G, whenever there is a Hamiltonian_Graph with fifth node S, whenever there is a Hamiltonian_Graph with fifth node G, whenever there is not Dyed with value4 S, and with id6 G, whenever there is not Dyed with value4 G, and with id6 S.",
            "NL": "There is a prohibition against having a Hamiltonian_Graph with fifth node S and a Hamiltonian_Graph with fifth node G, there is not an Dyed with value4 S, with id6 G, and not an Dyed with value4 G, with id6 S. "
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of edge4 K of Element with edge6 B, with edge4 K is equal to 1, whenever there is a Clique B.",
            "NL": "Every time there is a Clique B, the number of Element with edge4 K has to be greater than 1, regardless of the Element edge6 B, and edge4 K."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of edge4 Y of Unpaired with id5 G, with edge4 Y is equal to 17, such that there is Investigate with id5 Y, with edge4 G, whenever there is an Inactive with id5 W, with edge4 Q, whenever there is a Sequence with edge9 W, with vtx2 Q, with node7 G, whenever there is not a NonPlanar with id5 G, with edge4 equal to 15.",
            "NL": "It is prohibited that the number of edge4 Y of Unpaired with id5 G, with edge4 Y, is equal to 17, such that there is an Investigate with id5 Y, with edge4 G, there is an Inactive with id5 W, with edge4 Q, there is a Sequence with edge9 W, with vtx2 Q, with node7 G, whenever there is not a NonPlanar with id5 G, with edge4 equal to 15."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of edge5 Z of Visit with node8 Z, with edge5 H is equal to 0, whenever there is a Directed_Graph H.",
            "NL": "As long as there is a Directed_Graph H, the number of edge5 Z of the Visit with node8 Z is equal to 0."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of field2 L of Functioning with id2 W, with field2 L is equal to 41, such that there is Initiate with id2 L, with field2 W, whenever there is a Variation with id2 J, with field2 O, whenever there is a Maximum with node8 J, with edge10 O, with vtx1 W, whenever there is not a Incoming with id2 W, with field2 equal to 1.",
            "NL": "It is prohibited that the number of field2 L of Functioning with id2 W, with field2 L, is equal to 41, such that there is an Initiate with id2 L, with field2 W, there is a Variation with id2 J, with field2 O, there is a Maximum with node8 J, with edge10 O, with vtx1 W, whenever there is not a Incoming with id2 W, with field2 equal to 1."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of field2 T of Sublist with node6 N, with field2 T is equal to 1, whenever there is a Chromatic_Number N.",
            "NL": "Every time there is a Chromatic_Number N, the number of Sublist with field2 T has to be greater than 1, regardless of the Sublist node6 N, and field2 T."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of field3 E of Node with vtx3 E, with field3 I is equal to 0, whenever there is an Adjacency_List I.",
            "NL": "As long as there is an Adjacency_List I, the number of field3 E of the Node with vtx3 E is equal to 0."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of field6 A of Elabel with field6 A, with key Z is different from 1, whenever there is a field6 Z.",
            "NL": "It is prohibited that the number of field6 A of Elabel with field6 A and field6 Z may differ from 1 whenever there is field6 Z in the cycle."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of field8 G of NonActive with field8 G, with node3 B is different from 1, whenever there is a field8 B.",
            "NL": "It is prohibited that the number of field8 G of NonActive with field8 G and field8 B may differ from 1 whenever there is field8 B in the cycle."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of field8 I of Undirected with field3 I, with field8 Y is equal to 0, whenever there is a Tone Y.",
            "NL": "As long as there is a Tone Y, the number of field8 I of the Undirected with field3 I is equal to 0."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of id1 V of Bridge with vtx10 O, with id1 V is equal to 1, whenever there is a Inspect O.",
            "NL": "Every time there is an Inspect O, the number of Bridge with id1 V has to be greater than 1, regardless of the Bridge vtx10 O, and id1 V."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of id2 T of Chromatic_Number with id2 T, with node1 Z is different from 1, whenever there is an id2 Z.",
            "NL": "It is prohibited that the number of id2 T of Chromatic_Number with id2 T and id2 Z may differ from 1 whenever there is id2 Z in the cycle."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of id3 H of Radius with edge9 U, with id3 H is different from 1, whenever there is a edge9 U. ",
            "NL": "It is prohibited that the number of id3 H of Radius with edge9 U and id3 H may differ from 1 whenever there is an edge9 U in the cycle. "
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of id6 C of Secondary with id6 C, with edge5 X is different from 1, whenever there is a id6 X.",
            "NL": "It is prohibited that the number of id6 C of Secondary with id6 C and id6 X may differ from 1 whenever there is id6 X in the cycle."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of id6 K of Connection with key3 Q, with id6 K is different from 1, whenever there is a key3 Q. ",
            "NL": "It is prohibited that the number of id6 K of Connection with key3 Q and id6 K may differ from 1 whenever there is a key3 Q in the cycle. "
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of id7 G of Radius with id7 G, with value3 U is different from 1, whenever there is a id7 U.",
            "NL": "It is prohibited that the number of id7 G of Radius with id7 G and id7 U may differ from 1 whenever there is id7 U in the cycle."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of id7 Z of Out_HamiltonianCycle with id7 Z, with value4 G is different from 1, whenever there is a id7 G.",
            "NL": "It is prohibited that the number of id7 Z of Out_HamiltonianCycle with id7 Z and id7 G may differ from 1 whenever there is id7 G in the cycle."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of id9 D of Painted with key9 X, with id9 D is equal to 6, such that there is InDegree with key9 D, with id9 X, whenever there is a Maximal with key9 C, with id9 V, whenever there is a Width with node C, with id1 V, with field1 X, whenever there is not a Member with key9 X, with id9 equal to 32.",
            "NL": "It is prohibited that the number of id9 D of Painted with key9 X, with id9 D, is equal to 6, such that there is an InDegree with key9 D, with id9 X, there is a Maximal with key9 C, with id9 V, there is a Width with node C, with id1 V, with field1 X, whenever there is not a Member with key9 X, with id9 equal to 32."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of id9 Y of Trail with value3 A, with id9 Y is different from 1, whenever there is a value3 A. ",
            "NL": "It is prohibited that the number of id9 Y of Trail with value3 A and id9 Y may differ from 1 whenever there is a value3 A in the cycle. "
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of key W of Tone with key4 O, with key W is different from 1, whenever there is a key4 O. ",
            "NL": "It is prohibited that the number of key W of Tone with key4 O and key W may differ from 1 whenever there is a key4 O in the cycle. "
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of key1 J of Insignificant with key3 Q, with key1 J is equal to 21, such that there is Location with key3 J, with key1 Q, whenever there is a Primary with key3 E, with key1 Y, whenever there is a Achievement with id9 E, with vtx2 Y, with value9 Q, whenever there is not a Concluding with key3 Q, with key1 equal to 47.",
            "NL": "It is prohibited that the number of key1 J of Insignificant with key3 Q, with key1 J, is equal to 21, such that there is a Location with key3 J, with key1 Q, there is a Primary with key3 E, with key1 Y, there is an Achievement with id9 E, with vtx2 Y, with value9 Q, whenever there is not a Concluding with key3 Q, with key1 equal to 47."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of key4 A of Path with key6 A, with key4 K is equal to 0, whenever there is a Painted K.",
            "NL": "As long as there is a Painted K, the number of key4 A of the Path with key6 A is equal to 0."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of key4 M of Line_Graph with id9 C, with key4 M is equal to 1, whenever there is a Eulerian_Graph C.",
            "NL": "Every time there is an Eulerian_Graph C, the number of Line_Graph with key4 M has to be greater than 1, regardless of the Line_Graph id9 C, and key4 M."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of key9 Z of Individual with key9 Z, with edge8 N is different from 1, whenever there is a key9 N.",
            "NL": "It is prohibited that the number of key9 Z of Individual with key9 Z and key9 N may differ from 1 whenever there is key9 N in the cycle."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of node10 S of Perfect_Graph with node1 S, with node10 R is equal to 0, whenever there is a Clue R.",
            "NL": "As long as there is a Clue R, the number of node10 S of the Perfect_Graph with node1 S is equal to 0."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of node4 J of Trapped with key10 E, with node4 J is equal to 1, whenever there is a Data E.",
            "NL": "Every time there is a Data E, the number of Trapped with node4 J has to be greater than 1, regardless of the Trapped key10 E, and node4 J."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of node8 W of Complicated with node4 W, with node8 Q is equal to 0, whenever there is an Elabel Q.",
            "NL": "As long as there is an Elabel Q, the number of node8 W of the Complicated with node4 W is equal to 0."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of value9 E of Face with vtx10 P, with value9 E is equal to 9, such that there is Subposition with vtx10 E, with value9 P, whenever there is a Painted with vtx10 X, with value9 J, whenever there is a Incidence_Matrix with key X, with id9 J, with key9 P, whenever there is not a Planar_Graph with vtx10 P, with value9 equal to 29.",
            "NL": "It is prohibited that the number of value9 E of Face with vtx10 P, with value9 E, is equal to 9, such that there is a Subposition with vtx10 E, with value9 P, there is a Painted with vtx10 X, with value9 J, there is an Incidence_Matrix with key X, with id9 J, with key9 P, whenever there is not a Planar_Graph with vtx10 P, with value9 equal to 29."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of vtx1 V of Indication with vtx1 V, with value1 L is different from 1, whenever there is a vtx1 L.",
            "NL": "It is prohibited that the number of vtx1 V of Indication with vtx1 V and vtx1 L may differ from 1 whenever there is vtx1 L in the cycle."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of vtx4 Y of Comprises with vtx4 Y, with edge10 F is different from 1, whenever there is a vtx4 F.",
            "NL": "It is prohibited that the number of vtx4 Y of Comprises with vtx4 Y and vtx4 F may differ from 1 whenever there is vtx4 F in the cycle."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of vtx5 G of Wanting with vtx5 G, with vtx2 P is different from 1, whenever there is a vtx5 P.",
            "NL": "It is prohibited that the number of vtx5 G of Wanting with vtx5 G and vtx5 P may differ from 1 whenever there is vtx5 P in the cycle."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Chart with node3 Z, whenever there is not a Subposition with vtx10 Z, whenever there is not an Duo with value10 Z, with edge3 P, whenever there is not an Duo with value10 Z, with edge3 L, whenever there is not a Unmatch with vtx10 Z.",
            "NL": "It is prohibited that there is a Chart with node3 Z, when there is not a Subposition with vtx10 Z, when there is not an Duo with value10 Z, with edge3 P, when there is not an Duo with value10 Z, with edge3 L, when there is not an Unmatch with vtx10 Z."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Clique E, whenever there is a Achievement with first point G, with fifth point E.",
            "NL": "It is prohibited that there should be a Clique E, whenever there is an Achievement with first point G, and fifth point E."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Compare with edge L, with vtx7 I, whenever there is a Centrality with edge L, with vtx7 C at most I, whenever there is a NonClustering with value P at most C.",
            "NL": "As a result, it is prohibited that there be a Centrality with edge L, with vtx7 C lesser than I, whenever there is a NonClustering with value P at most C, whenever there is a Compare with edge L, with vtx7 I."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Connection with node2 A, with id8 U, whenever there is a Remaining with node2 A, with id8 G at most U, whenever there is a Pair_of_Nodes with value Z at most G.",
            "NL": "As a result, it is prohibited that there be a Remaining with node2 A, with id8 G lesser than U, whenever there is a Pair_of_Nodes with value Z at most G, whenever there is a Connection with node2 A, with id8 U."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Cut with value R, whenever there is not a Edge_Pairing with id9 R, whenever there is not an Compartment with value3 R, with node2 P, whenever there is not an Compartment with value3 R, with node2 Z, whenever there is not a Base with id9 R.",
            "NL": "It is prohibited that there is a Cut with value R, when there is not a Edge_Pairing with id9 R, when there is not an Compartment with value3 R, with node2 P, when there is not an Compartment with value3 R, with node2 Z, when there is not an Base with id9 R."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Depth_Vertex with node4 T, with id L, whenever there is an In_HamiltonianCycle with node4 T, with id W at most A, whenever there is an OutDegree with node4 L, with id A.",
            "NL": "There is a prohibition against there being an Depth_Vertex with node4 T, with id L, whenever there is an In_HamiltonianCycle with node4 T, with id W, where W is at most A, whenever there is an OutDegree with node4 L, with id A."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Dominating_Set with id9 Z, whenever there is Dominating_Set with id9 N, whenever there is not a Maximum_Flow with vtx2 Z, whenever there is not a Maximum_Flow with vtx2 N different from Z, whenever there is a Directed_Graph with field6 N, with key9 Z, with edge8 I, whenever there is not a Below_Threshold with field6 N, with key9 Z, with edge8 I. ",
            "NL": "It is prohibited that there is a Dominating_Set with id9 Z, there is Dominating_Set with id9 N, there is not a Maximum_Flow with vtx2 Z, there is not a Maximum_Flow with vtx2 N, there is a Directed_Graph with field6 N, with key9 Z, with edge8 I, where W is not equal to Z, whenever there is not a Below_Threshold with field6 N, with key9 Z, with edge8 I."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Dyed with key1 X, whenever there is not a Less with key1 X, whenever there is not a Significant with key1 X.",
            "NL": "There is a prohibition that there is a Dyed with key1 X whenever there is not a Less with key1 X, whenever there is not a Significant with key1 X."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Eulerian_Path with node M, whenever there is Eulerian_Path with node L, whenever there is not a Individual with id4 M, whenever there is not a Individual with id4 L different from M, whenever there is an Input with node2 L, with vtx1 M, with node5 D, whenever there is not a Inpath with node2 L, with vtx1 M, with node5 D. ",
            "NL": "It is prohibited that there is an Eulerian_Path with node M, there is Eulerian_Path with node L, there is not a Individual with id4 M, there is not a Individual with id4 L, there is an Input with node2 L, with vtx1 M, with node5 D, where W is not equal to M, whenever there is not a Inpath with node2 L, with vtx1 M, with node5 D."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Final with edge4 U, whenever there is not a Unweighted with edge U, whenever there is not an Bucket with value10 U, with value3 B, whenever there is not an Bucket with value10 U, with value3 J, whenever there is not a Statistical_Significance with edge U.",
            "NL": "It is prohibited that there is a Final with edge4 U, when there is not a Unweighted with edge U, when there is not an Bucket with value10 U, with value3 B, when there is not an Bucket with value10 U, with value3 J, when there is not an Statistical_Significance with edge U."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Fine with vtx C, whenever there is not a Short with vtx C, whenever there is not a Subsequent with vtx C.",
            "NL": "There is a prohibition that there is a Fine with vtx C whenever there is not a Short with vtx C, whenever there is not a Subsequent with vtx C."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Following with vtx6 W, with value9 S, whenever there is a Related with vtx6 W, with value9 T not after S, whenever there is a Spanning_Tree with value E not after T.",
            "NL": "As a result, it is prohibited that there be a Related with vtx6 W, with value9 T lesser than S, whenever there is a Spanning_Tree with value E not after T, whenever there is a Following with vtx6 W, with value9 S."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Hamiltonian_Graph with key4 V, whenever there is not a Incorporates with key4 V, whenever there is not a Inspect with key4 V.",
            "NL": "There is a prohibition that there is a Hamiltonian_Graph with key4 V whenever there is not a Incorporates with key4 V, whenever there is not a Inspect with key4 V."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Hierarchy with field8 C, whenever there is Hierarchy with field8 U, whenever there is not a Radius with id4 C, whenever there is not a Radius with id4 U different from C, whenever there is an Edge_Level with edge6 U, with key C, with vtx9 E, whenever there is not a Edge_Label with edge6 U, with key C, with vtx9 E. ",
            "NL": "It is prohibited that there is a Hierarchy with field8 C, there is Hierarchy with field8 U, there is not a Radius with id4 C, there is not a Radius with id4 U, there is an Edge_Level with edge6 U, with key C, with vtx9 E, where W is not equal to C, whenever there is not a Edge_Label with edge6 U, with key C, with vtx9 E."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Incidence A, whenever there is a Maximum with fourth point V, with fifth node A.",
            "NL": "It is prohibited that there should be a Incidence A, whenever there is a Maximum with fourth point V, and fifth node A."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Individual with node1 N, whenever there is not a Difference with node1 N, whenever there is not a IngoingPath with node1 N.",
            "NL": "There is a prohibition that there is an Individual with node1 N whenever there is not a Difference with node1 N, whenever there is not a IngoingPath with node1 N."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Launch with edge9 H, whenever there is not a Forest with value7 H, whenever there is a Launch with edge9 O, whenever there is not a Forest with value7 O, whenever there is not a Twosome with key6 H, with edge9 O. ",
            "NL": "There is a prohibition that there is a Launch with the edge9 H, when there is no Forest with value7 H, when there is a Launch with the edge9 O, when there is no Forest with value7 O, when there is not a Twosome with key6 H, when there is not a Twosome with edge9 O."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Less with node3 A, whenever there is not a Additional with node2 A, whenever there is a Less with node3 F, whenever there is not a Additional with node2 F, whenever there is not a Contains with node6 A, with node3 F. ",
            "NL": "There is a prohibition that there is a Less with the node3 A, when there is no Additional with node2 A, when there is a Less with the node3 F, when there is no Additional with node2 F, when there is not a Contains with node6 A, when there is not a Contains with node3 F."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Line_Graph with value9 S, whenever there is not a Enumeration with key S, whenever there is a Line_Graph with value9 J, whenever there is not a Enumeration with key J, whenever there is not a Directed_Graph with node3 S, with value9 J. ",
            "NL": "There is a prohibition that there is a Line_Graph with the value9 S, when there is no Enumeration with key S, when there is a Line_Graph with the value9 J, when there is no Enumeration with key J, when there is not a Directed_Graph with node3 S, when there is not a Directed_Graph with value9 J."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Linked with fifth vertex B, with first point A, whenever there is a Linked with fifth vertex B, with first point U different from A.",
            "NL": "It is prohibited to establish an Linked with fifth vertex B and first point U whenever there is a Linked with fifth vertex B and first point A, where U is not equal to A. "
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Mark with key3 I, whenever there is not a Unimportant with key3 I, whenever there is not a Connection with key3 I.",
            "NL": "There is a prohibition that there is a Mark with key3 I whenever there is not a Unimportant with key3 I, whenever there is not a Connection with key3 I."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Marker with value3 L, whenever there is not a Inpath with value3 L, whenever there is not a Succeeding with value3 L.",
            "NL": "There is a prohibition that there is a Marker with value3 L whenever there is not a Inpath with value3 L, whenever there is not a Succeeding with value3 L."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Maximum_Flow with edge8 S, whenever there is Maximum_Flow with edge8 M, whenever there is not a Active with key6 S, whenever there is not a Active with key6 M different from S, whenever there is a Non_Clique with node M, with field S, with vtx3 F, whenever there is not a NonSubsequent with node M, with field S, with vtx3 F. ",
            "NL": "It is prohibited that there is a Maximum_Flow with edge8 S, there is Maximum_Flow with edge8 M, there is not a Active with key6 S, there is not a Active with key6 M, there is a Non_Clique with node M, with field S, with vtx3 F, where W is not equal to S, whenever there is not a NonSubsequent with node M, with field S, with vtx3 F."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a NotFirst with field7 M, with edge10 S, whenever there is a Periphery with field7 M, with edge10 U not after S, whenever there is a NonGrouping with value F not after U.",
            "NL": "As a result, it is prohibited that there be a Periphery with field7 M, with edge10 U lesser than S, whenever there is a NonGrouping with value F not after U, whenever there is a NotFirst with field7 M, with edge10 S."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Operative with node2 C, whenever there is not a Symbol with node2 C, whenever there is not a Label with node2 C.",
            "NL": "There is a prohibition that there is an Operative with node2 C whenever there is not a Symbol with node2 C, whenever there is not a Label with node2 C."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a OutgoingRoute with edge6 N, whenever there is not a Vertex with edge6 N, whenever there is not a Relevant with edge6 N.",
            "NL": "There is a prohibition that there is an OutgoingRoute with edge6 N whenever there is not a Vertex with edge6 N, whenever there is not a Relevant with edge6 N."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Partition with edge7 R, with edge5 B, whenever there is a P_Value with edge7 R, with edge5 Q not after B, whenever there is a Parent_Edge with value J not after Q.",
            "NL": "As a result, it is prohibited that there be a P_Value with edge7 R, with edge5 Q lesser than B, whenever there is a Parent_Edge with value J not after Q, whenever there is a Partition with edge7 R, with edge5 B."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Partition with vtx10 M, whenever there is not a Location with id9 M, whenever there is not an NonGrouping with edge M, with value3 Y, whenever there is not an NonGrouping with edge M, with value3 J, whenever there is not a Maximum_Flow with id9 M.",
            "NL": "It is prohibited that there is a Partition with vtx10 M, when there is not a Location with id9 M, when there is not an NonGrouping with edge M, with value3 Y, when there is not an NonGrouping with edge M, with value3 J, when there is not an Maximum_Flow with id9 M."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Probability_Value with id9 C, whenever there is not a Statistical_Significance with node1 C, whenever there is a Probability_Value with id9 R, whenever there is not a Statistical_Significance with node1 R, whenever there is not a Initiate with value2 C, with id9 R. ",
            "NL": "There is a prohibition that there is a Probability_Value with the id9 C, when there is no Statistical_Significance with node1 C, when there is a Probability_Value with the id9 R, when there is no Statistical_Significance with node1 R, when there is not a Initiate with value2 C, when there is not a Initiate with id9 R."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Projection with fifth point V different from N, with third node A, whenever there is a Projection with fifth point N, with third node A.",
            "NL": "It is prohibited to establish an Projection with fifth point N and third node A whenever there is a Projection with fifth point V and third node A, where N is not equal to V."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Significant with value7 V, with vtx3 R, whenever there is an Attained with value7 V, with vtx3 U at most R, whenever there is a Span with value Y at most U.",
            "NL": "As a result, it is prohibited that there be a Attained with value7 V, with vtx3 U lesser than R, whenever there is a Span with value Y at most U, whenever there is a Significant with value7 V, with vtx3 R."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Single with value2 M, with node8 G, whenever there is a Count with value2 M, with node8 T not after B, whenever there is a Dynamic with value2 G, with node8 B.",
            "NL": "There is a prohibition against there being an Single with value2 M, with node8 G, whenever there is a Count with value2 M, with node8 T, where T is not after B, whenever there is a Dynamic with value2 G, with node8 B."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Size_of_Clique with field3 T, with edge9 N, whenever there is a Tint with field3 T, with edge9 S at most Q, whenever there is a Probability_Value with field3 N, with edge9 Q.",
            "NL": "There is a prohibition against there being an Size_of_Clique with field3 T, with edge9 N, whenever there is a Tint with field3 T, with edge9 S, where S is at most Q, whenever there is a Probability_Value with field3 N, with edge9 Q."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Start with key4 I, whenever there is not a Isomorphism with value10 I, whenever there is a Start with key4 X, whenever there is not a Isomorphism with value10 X, whenever there is not a Layer with field6 I, with key4 X. ",
            "NL": "There is a prohibition that there is a Start with the key4 I, when there is no Isomorphism with value10 I, when there is a Start with the key4 X, when there is no Isomorphism with value10 X, when there is not a Layer with field6 I, when there is not a Layer with key4 X."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Sub_Index Q, whenever there is a Prevailing with first id D, with first node Q.",
            "NL": "It is prohibited that there should be a Sub_Index Q, whenever there is a Prevailing with first id D, and first node Q."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Subordinate with field3 X, whenever there is not a Incidence with field5 X, whenever there is not an Functioning with edge7 X, with node3 Z, whenever there is not an Functioning with edge7 X, with node3 U, whenever there is not a Non_Clique with field5 X.",
            "NL": "It is prohibited that there is a Subordinate with field3 X, when there is not a Incidence with field5 X, when there is not an Functioning with edge7 X, with node3 Z, when there is not an Functioning with edge7 X, with node3 U, when there is not an Non_Clique with field5 X."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Success Q, whenever there is a Base with fourth vertex V, with first node Q.",
            "NL": "It is prohibited that there should be a Success Q, whenever there is a Base with fourth vertex V, and first node Q."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Superior with edge2 Y, whenever there is not a Route with edge2 Y, whenever there is not a Eulerian_Path with edge2 Y.",
            "NL": "There is a prohibition that there is a Superior with edge2 Y whenever there is not a Route with edge2 Y, whenever there is not a Eulerian_Path with edge2 Y."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Tag with edge9 A, whenever there is Tag with edge9 D, whenever there is not a Punishment with id4 A, whenever there is not a Punishment with id4 D different from A, whenever there is an OutDegree with value5 D, with edge A, with value3 Y, whenever there is not a Refused with value5 D, with edge A, with value3 Y. ",
            "NL": "It is prohibited that there is a Tag with edge9 A, there is Tag with edge9 D, there is not a Punishment with id4 A, there is not a Punishment with id4 D, there is an OutDegree with value5 D, with edge A, with value3 Y, where W is not equal to A, whenever there is not a Refused with value5 D, with edge A, with value3 Y."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Tag with value1 B, whenever there is not a Sequence with id4 B, whenever there is a Tag with value1 O, whenever there is not a Sequence with id4 O, whenever there is not a Explore with id7 B, with value1 O. ",
            "NL": "There is a prohibition that there is a Tag with the value1 B, when there is no Sequence with id4 B, when there is a Tag with the value1 O, when there is no Sequence with id4 O, when there is not a Explore with id7 B, when there is not a Explore with value1 O."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Tree with fourth id R, with fourth point Y, whenever there is a Tree with fourth id R, with fourth point T different from Y.",
            "NL": "It is prohibited to establish an Tree with fourth id R and fourth point T whenever there is a Tree with fourth id R and fourth point Y, where T is not equal to Y. "
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Triple with vtx Y, with edge4 W, whenever there is a Duo with vtx Y, with edge4 T at most W, whenever there is a Punishment with value A at most T.",
            "NL": "As a result, it is prohibited that there be a Duo with vtx Y, with edge4 T lesser than W, whenever there is a Punishment with value A at most T, whenever there is a Triple with vtx Y, with edge4 W."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Triplet with key1 T, whenever there is Triplet with key1 X, whenever there is not a NonCohesive with value8 T, whenever there is not a NonCohesive with value8 X different from T, whenever there is a Sanction with vtx X, with key8 T, with edge9 U, whenever there is not a Has with vtx X, with key8 T, with edge9 U. ",
            "NL": "It is prohibited that there is a Triplet with key1 T, there is Triplet with key1 X, there is not a NonCohesive with value8 T, there is not a NonCohesive with value8 X, there is a Sanction with vtx X, with key8 T, with edge9 U, where W is not equal to T, whenever there is not a Has with vtx X, with key8 T, with edge9 U."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Valency with fifth id J different from D, with third point F, whenever there is a Valency with fifth id D, with third point F.",
            "NL": "It is prohibited to establish an Valency with fifth id D and third point F whenever there is a Valency with fifth id J and third point F, where D is not equal to J."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Valency with third node L, with second vertex A, whenever there is a Valency with third node L, with second vertex X different from A.",
            "NL": "It is prohibited to establish an Valency with third node L and second vertex X whenever there is a Valency with third node L and second vertex A, where X is not equal to A. "
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Visit with node2 Z, with value2 N, whenever there is a Directed_Graph with node2 Z, with value2 O at most N, whenever there is a Breadth with value I at most O.",
            "NL": "As a result, it is prohibited that there be a Directed_Graph with node2 Z, with value2 O lesser than N, whenever there is a Breadth with value I at most O, whenever there is a Visit with node2 Z, with value2 N."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Visit with node7 V, whenever there is not a Singleton with node V, whenever there is not an Unit with field7 V, with edge6 M, whenever there is not an Unit with field7 V, with edge6 U, whenever there is not a Three_Nodes with node V.",
            "NL": "It is prohibited that there is a Visit with node7 V, when there is not a Singleton with node V, when there is not an Unit with field7 V, with edge6 M, when there is not an Unit with field7 V, with edge6 U, when there is not an Three_Nodes with node V."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Weight with vtx9 N, whenever there is not a Major with node9 N, whenever there is not an Eulerian_Circuit with id7 N, with key8 X, whenever there is not an Eulerian_Circuit with id7 N, with key8 P, whenever there is not a Edge_Level with node9 N.",
            "NL": "It is prohibited that there is a Weight with vtx9 N, when there is not a Major with node9 N, when there is not an Eulerian_Circuit with id7 N, with key8 X, when there is not an Eulerian_Circuit with id7 N, with key8 P, when there is not an Edge_Level with node9 N."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is Accomplishment with value7 C.",
            "NL": "It is forbidden to have an Accomplishment with value7 C."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is Allocate with field6 B, with key5 D.",
            "NL": "As a result, it is not allowed to have an Allocate with field6 B, with key5 D."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Ancestor with fourth id F, with fifth id C, whenever there is an Ancestor with fourth id F, with fifth id G different from C.",
            "NL": "It is prohibited to establish an Ancestor with fourth id F and fifth id G whenever there is an Ancestor with fourth id F and fifth id C, where G is not equal to C. "
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Arc with fifth point H different from X, with second point V, whenever there is an Arc with fifth point X, with second point V.",
            "NL": "It is prohibited to establish an Arc with fifth point X and second point V whenever there is an Arc with fifth point H and second point V, where X is not equal to H."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Assign with fourth point U, with second point K, whenever there is an Assign with fourth point U, with second point X different from K.",
            "NL": "It is prohibited to establish an Assign with fourth point U and second point X whenever there is an Assign with fourth point U and second point K, where X is not equal to K. "
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Edge_Label with key5 Z, whenever there is not a Cliquesize with key5 Z, whenever there is not a Degree with key5 Z.",
            "NL": "There is a prohibition that there is an Edge_Label with key5 Z whenever there is not a Cliquesize with key5 Z, whenever there is not a Degree with key5 Z."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Elabel W, whenever there is a Following with first id E, with second point W.",
            "NL": "It is prohibited that there should be a Elabel W, whenever there is a Following with first id E, and second point W."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Engaged with value1 N, whenever there is Engaged with value1 U, whenever there is not a Offspring with value7 N, whenever there is not a Offspring with value7 U different from N, whenever there is a Contains with field U, with vtx1 N, with edge Y, whenever there is not a Individual with field U, with vtx1 N, with edge Y. ",
            "NL": "It is prohibited that there is an Engaged with value1 N, there is Engaged with value1 U, there is not a Offspring with value7 N, there is not a Offspring with value7 U, there is a Contains with field U, with vtx1 N, with edge Y, where W is not equal to N, whenever there is not a Individual with field U, with vtx1 N, with edge Y."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an External_Group with edge9 R, whenever there is not a Unmatched with edge9 R, whenever there is not a Active with edge9 R.",
            "NL": "There is a prohibition that there is an External_Group with edge9 R whenever there is not a Unmatched with edge9 R, whenever there is not a Active with edge9 R."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Incidence_Matrix with key4 F, whenever there is not a Suggestion with id2 F, whenever there is an Incidence_Matrix with key4 V, whenever there is not a Suggestion with id2 V, whenever there is not a Auxiliary with field5 F, with key4 V. ",
            "NL": "There is a prohibition that there is an Incidence_Matrix with the key4 F, when there is no Suggestion with id2 F, when there is an Incidence_Matrix with the key4 V, when there is no Suggestion with id2 V, when there is not a Auxiliary with field5 F, when there is not a Auxiliary with key4 V."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Incoming with value10 A, whenever there is not a Reached with node5 A, whenever there is not an Following with id10 A, with edge3 J, whenever there is not an Following with id10 A, with edge3 W, whenever there is not a Commence with node5 A.",
            "NL": "It is prohibited that there is an Incoming with value10 A, when there is not a Reached with node5 A, when there is not an Following with id10 A, with edge3 J, when there is not an Following with id10 A, with edge3 W, when there is not an Commence with node5 A."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an IncomingPath with field8 Q, whenever there is not a Chosencolour with field8 Q, whenever there is not a Fewer with field8 Q.",
            "NL": "There is a prohibition that there is an IncomingPath with field8 Q whenever there is not a Chosencolour with field8 Q, whenever there is not a Fewer with field8 Q."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Inorder N, whenever there is a Probability_Value with second node S, with first vertex N.",
            "NL": "It is prohibited that there should be a Inorder N, whenever there is a Probability_Value with second node S, and first vertex N."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Level_Vertex with fourth id F, with third id R, whenever there is a Level_Vertex with fourth id F, with third id O different from R.",
            "NL": "It is prohibited to establish an Level_Vertex with fourth id F and third id O whenever there is a Level_Vertex with fourth id F and third id R, where O is not equal to R. "
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an NonOriented with fifth point K, with fourth id X, whenever there is a NonOriented with fifth point K, with fourth id D different from X.",
            "NL": "It is prohibited to establish an NonOriented with fifth point K and fourth id D whenever there is a NonOriented with fifth point K and fourth id X, where D is not equal to X. "
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Outpath with fourth point J, with first vertex O, whenever there is a Outpath with fourth point J, with first vertex E different from O.",
            "NL": "It is prohibited to establish an Outpath with fourth point J and first vertex E whenever there is an Outpath with fourth point J and first vertex O, where E is not equal to O. "
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Ultimate with value9 P, whenever there is not a Residual_Graph with edge9 P, whenever there is not an Out with key7 P, with edge1 L, whenever there is not an Out with key7 P, with edge1 V, whenever there is not a Contrast with edge9 P.",
            "NL": "It is prohibited that there is an Ultimate with value9 P, when there is not a Residual_Graph with edge9 P, when there is not an Out with key7 P, with edge1 L, when there is not an Out with key7 P, with edge1 V, when there is not an Contrast with edge9 P."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Undirected with id3 E, whenever there is not a Inactive with id3 E, whenever there is not a Longest_Path with id3 E.",
            "NL": "There is a prohibition that there is an Undirected with id3 E whenever there is not a Inactive with id3 E, whenever there is not a Longest_Path with id3 E."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Unmatch with edge2 K, whenever there is not a Nontrivial with edge2 K, whenever there is not a Maximum with edge2 K.",
            "NL": "There is a prohibition that there is an Unmatch with edge2 K whenever there is not a Nontrivial with edge2 K, whenever there is not a Maximum with edge2 K."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Unweighted with node1 T, whenever there is not a Matching with node1 T, whenever there is not a Circuit with node1 T.",
            "NL": "There is a prohibition that there is an Unweighted with node1 T whenever there is not a Matching with node1 T, whenever there is not a Circuit with node1 T."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is Check with id7 G, with value G. ",
            "NL": "The existence of Check with id7 G and with value G is prohibited."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is Degree_Sequence with id6 E.",
            "NL": "It is forbidden to have a Degree_Sequence with id6 E."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is Edge_Pairing with id9 R, with vtx4 V.",
            "NL": "As a result, it is not allowed to have an Edge_Pairing with id9 R, with vtx4 V."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is Embedding with key6 R.",
            "NL": "It is forbidden to have an Embedding with key6 R."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is Following with id U, with id7 U. ",
            "NL": "The existence of Following with id U and with id7 U is prohibited."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is Has with node9 C.",
            "NL": "It is forbidden to have a Has with node9 C."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is Input with edge5 J, with value Y.",
            "NL": "As a result, it is not allowed to have an Input with edge5 J, with value Y."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is Out_Hamiltonian_Tour with node2 H, with vtx4 H. ",
            "NL": "The existence of Out_Hamiltonian_Tour with node2 H and with vtx4 H is prohibited."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is P_Value with node5 E.",
            "NL": "It is forbidden to have a P_Value with node5 E."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is Probability_Value with field3 J.",
            "NL": "It is forbidden to have a Probability_Value with field3 J."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is Shade with node4 K.",
            "NL": "It is forbidden to have a Shade with node4 K."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is Start with id6 L, with value4 P.",
            "NL": "As a result, it is not allowed to have a Start with id6 L, with value4 P."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is Sub_Index with value1 L, with id9 X.",
            "NL": "As a result, it is not allowed to have a Sub_Index with value1 L, with id9 X."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is Tally with field3 B.",
            "NL": "It is forbidden to have a Tally with field3 B."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is Unconnected with field8 H.",
            "NL": "It is forbidden to have an Unconnected with field8 H."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when edge J is In_Hamiltonian_Tour then edge J is not Project.",
            "NL": "There is a prohibition against not Project edge J when edge J is In_Hamiltonian_Tour."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when edge5 G is not Individual edge5 G then vtx10 M is Allocate and also edge5 M is Allocate, where G is at most M.",
            "NL": "In the case of edge5 G and M that are not Individual, edge5 G can be an Allocate and edge5 M can be an Allocate, where G is at most M."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when field2 Q is not Inorder field2 Q then edge1 U is Unimportant and also field2 U is Unimportant, where Q is at most U.",
            "NL": "In the case of field2 Q and U that are not Inorder, field2 Q can be an Unimportant and field2 U can be an Unimportant, where Q is at most U."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when field3 Q is not Diameter field3 Q then id10 P is Minor and also field3 P is Minor, where Q is not after P.",
            "NL": "In the case of field3 Q and P that are not Diameter, field3 Q can be a Minor and field3 P can be a Minor, where Q is not after P."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when id2 X is Below_Threshold then id2 X is not Enumeration.",
            "NL": "There is a prohibition against not Enumeration id2 X when id2 X is Below_Threshold."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when id8 Q is not Trivial id8 Q then field1 H is In_Layer and also id8 H is In_Layer, where Q is at most H.",
            "NL": "In the case of id8 Q and H that are not Trivial, id8 Q can be an In_Layer and id8 H can be an In_Layer, where Q is at most H."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when id9 X is not Accomplishment id9 X then value6 R is Pair and also id9 R is Pair, where X is not after R.",
            "NL": "In the case of id9 X and R that are not Accomplishment, id9 X can be a Pair and id9 R can be a Pair, where X is not after R."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when key J is Line_Graph key V then key J is Line_Graph Location K and also key V is Line_Graph Location K, where J is not after V.",
            "NL": "There is a prohibition that when key J Line_Graph to key V, key J is also Line_Graph to Location K and key V is also Line_Graph to Location K, where J is not after V."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when key10 Z is Lacking key10 Y then key10 Z is Lacking Unarrowed H and also key10 Y is Lacking Unarrowed H, where Z is at most Y.",
            "NL": "There is a prohibition that when key10 Z Lacking to key10 Y, key10 Z is also Lacking to Unarrowed H and key10 Y is also Lacking to Unarrowed H, where Z is at most Y."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when key5 E is not Nfirst key5 E then value6 F is Periphery and also key5 F is Periphery, where E is not after F.",
            "NL": "In the case of key5 E and F that are not Nfirst, key5 E can be a Periphery and key5 F can be a Periphery, where E is not after F."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when key5 R is Edge_Paired then key5 R is not Denied.",
            "NL": "There is a prohibition against not Denied key5 R when key5 R is Edge_Paired."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when key8 V is not Cross key8 V then value1 S is Employed_Edge and also key8 S is Employed_Edge, where V is at most S.",
            "NL": "In the case of key8 V and S that are not Cross, key8 V can be an Employed_Edge and key8 S can be an Employed_Edge, where V is at most S."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when node8 Q is Eulerian_Path node8 M then node8 Q is Eulerian_Path Bridge C and also node8 M is Eulerian_Path Bridge C, where Q is not after M.",
            "NL": "There is a prohibition that when node8 Q Eulerian_Path to node8 M, node8 Q is also Eulerian_Path to Bridge C and node8 M is also Eulerian_Path to Bridge C, where Q is not after M."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when value10 T is not Atom value10 T then vtx1 X is NotFirst and also value10 X is NotFirst, where T is at most X.",
            "NL": "In the case of value10 T and X that are not Atom, value10 T can be a NotFirst and value10 X can be a NotFirst, where T is at most X."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when value7 R is not Subposition value7 R then key2 O is Clue and also value7 O is Clue, where R is at most O.",
            "NL": "In the case of value7 R and O that are not Subposition, value7 R can be a Clue and value7 O can be a Clue, where R is at most O."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when vtx2 W is not Cycle_Basis vtx2 W then vtx10 O is Unweighted and also vtx2 O is Unweighted, where W is not after O.",
            "NL": "In the case of vtx2 W and O that are not Cycle_Basis, vtx2 W can be an Unweighted and vtx2 O can be an Unweighted, where W is not after O."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when vtx4 I is Planar_Graph vtx4 U then vtx4 I is Planar_Graph Additional E and also vtx4 U is Planar_Graph Additional E, where I is not after U.",
            "NL": "There is a prohibition that when vtx4 I Planar_Graph to vtx4 U, vtx4 I is also Planar_Graph to Additional E and vtx4 U is also Planar_Graph to Additional E, where I is not after U."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that X is at most U, whenever there is a Triple with third vertex X, whenever there is a Triple with third vertex U, whenever there is not Out with field7 X, and with vtx6 U, whenever there is not Out with field7 U, and with vtx6 X.",
            "NL": "There is a prohibition against having a Triple with third vertex X and a Triple with third vertex U, there is not an Out with field7 X, with vtx6 U, and not an Out with field7 U, with vtx6 X. "
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of id L of asgn with value L, with id X is equal to 0, whenever there is a haschild X.",
            "NL": "As long as there is a haschild X, the number of id L of the asgn with value L is equal to 0."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of id Y of aux with value R, with id Y is equal to 0, such that there is member with value Y, with id R, whenever there is a in with value C, with id X, whenever there is a rest with id1 C, with id2 X, with id3 R, whenever there is not a cliquesize with value R, with id equal to 1.",
            "NL": "It is prohibited that the number of id Y of aux with value R, with id Y, is equal to 0, such that there is a member with value Y, with id R, there is an IN with value C, with id X, there is a rest with id1 C, with id2 X, with id3 R, whenever there is not a cliquesize with value R, with id equal to 1."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of id Y of edge with value X, with id Y is equal to 1, whenever there is a node X. ",
            "NL": "Every time there is a node X, the number of edges with id Y has to be greater than 1, regardless of the edge value X, and id Y."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of id1 X of in_hm with id1 X, with id2 Y is different from 1, whenever there is a vtx Y.",
            "NL": "It is prohibited that the number of id X of in_hm with id X and id Y may differ from 1 whenever there is a vertex Y in the cycle."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of id2 Y of in_hm with id1 X, with id2 Y is different from 1, whenever there is a vtx X.",
            "NL": "It is prohibited that the number of id Y of in_hm with id X and id Y may differ from 1 whenever there is a vertex X in the cycle."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a order with value X, with id Y, whenever there is a tran with value X, with id Z less than Y, whenever there is a Atomcnt with value N less than Z. ",
            "NL": "As a result, it is prohibited that there be a trans with value X, with ID Z lesser than Y, whenever there is an Atomcnt with value N less than Z, whenever there is an order with value X, with ID Y."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a start Y, whenever there is an inPath with first vtx X, with second vtx Y.",
            "NL": "It is prohibited that there should be a start Y, whenever there is an inPath with first vertex X, and second vertex Y."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a vertex with node X, whenever there is not a reached with node X, whenever there is not a start with node X.",
            "NL": "There is a prohibition that there is a vertex with node X whenever there is not a reached with node X, whenever there is not a start with node X."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an active with key V, whenever there is active with key W, whenever there is not a trivial with value V, whenever there is not a trivial with value W different from V, whenever there is a mvlabel with field1 W, with field2 V, with field3 S, whenever there is not a minfl with field1 W, with field2 V, with field3 S.",
            "NL": "It is prohibited that there is an active with key V, there is active with key W, there is not a trivial with value V, there is not a trivial with value W, there is a mvlabel with field1 W, with field2 V, with field3 S, where W is not equal to V, whenever there is not a minfl with field1 W, with field2 V, with field3 S."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an active with key V, whenever there is not a trivial with value V, whenever there is an active with key W, whenever there is not a trivial with value W, whenever there is not a reach with field1 V, with field2 W.",
            "NL": "There is a prohibition that there is an active with the key V, when there is no trivial with value V, when there is an active with the key W, when there is no trivial with value W, when there is not a reach with field1 V, when there is not a reach with field2 W."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an active with key V, whenever there is not a trivial with value V, whenever there is not an obs_vlabel with id1 V, with id2 P, whenever there is not an obs_vlabel with id1 V, with id2 M, whenever there is not a aedge with value V.",
            "NL": " It is prohibited that there is an active with key V, when there is not a trivial with value V, when there is not an obs_vlabel with id1 V, with id2 P, when there is not an obs_vlabel with id1 V, with id2 M, when there is not an aedge with value V."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an inPath with first vtx X, with second vtx Y1, whenever there is an inPath with first vtx X, with second vtx Y different from Y1.",
            "NL": "It is prohibited to establish an inPath with first vertex X and second vertex Y whenever there is an inPath with first vertex X and second vertex Y1, where Y is not equal to Y1."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an inPath with first vtx X1 different from X, with second vtx Y, whenever there is a inPath with first vtx X, with second vtx Y. ",
            "NL": "It is prohibited to establish an inPath with first vertex X and second vertex Y whenever there is an inPath with first vertex X1 and second vertex Y, where X is not equal to X1."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an order with value X, with id Y, whenever there is a tran with value X, with id Z less than W, whenever there is a mtrans with value Y, with id W.",
            "NL": "There is a prohibition against there being an order with value X, with id Y, whenever there is a trans with value X, with id Z, where Z is less than W, whenever there is a mtrans with value Y, with id W."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is no_reached with vertex X.",
            "NL": "It is forbidden to have a no_reach with vertex X."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is r with id V, with id1 V.",
            "NL": "The existence of r with id V and with id1 V is prohibited."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is r with id X, with id2 X1.",
            "NL": "As a result, it is not allowed to have a r with id X, with id2 X1."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when node U is link node V then node U is link color C and also node V is link color C, where U is less than V.",
            "NL": "There is a prohibition that when node U links to node V, node U is also linked to color C and node V is also linked to color C, where U is less than V."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when node X is not uedge node Y then node X is clique and also node Y is clique, where X is less than Y.",
            "NL": "In the case of nodes X and Y that are not undirected, node X can be a clique and node Y can be a clique, where X is less than Y."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when vtx U is dom then vtx U is not reached.",
            "NL": "There is a prohibition against not reaching vertex U when vertex U is dominant."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when vtx U is Vtx then vtx U is not In.",
            "NL": "There is a prohibition that vertex U is not Inn when vertex U is the vertex."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that X is less than Y, whenever there is an clique with first node X, whenever there is an clique with first node Y, whenever there is not edge with id1 X, and with id2 Y, whenever there is not edge with id1 Y, and with id2 X.",
            "NL": "There is a prohibition against having a clique with first node X and a clique with first node Y, there is not an edge with id1 X, with id2 Y, and not an edge with id1 Y, with id2 X, considering X is less than Y."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "A asgn is identified by an value, and by an id. It is prohibited that the number of id L of asgn with value L, with id X is equal to 0, whenever there is a haschild X.",
            "NL": "If X has a child, the asgn with the id L will have a value of 0."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "A asgn is identified by an value, and by an id. It is prohibited that the number of id L of asgn with value L, with id X is equal to 0, whenever there is a haschild X.",
            "NL": "If X has a child, the asgn with value L will have an id of 0."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "A asgn is identified by an value, and by an id. It is prohibited that the number of id L of asgn with value L, with id X is equal to 0, whenever there is a haschild X.",
            "NL": "The value of asgn with id L will be 0 if there is a haschild X."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "A asgn is identified by an value, and by an id. It is prohibited that the number of id L of asgn with value L, with id X is equal to 0, whenever there is a haschild X.",
            "NL": "For asgn with value L, the id L will be equal to 0 if there is a haschild X."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "A asgn is identified by an value, and by an id. It is prohibited that the number of id L of asgn with value L, with id X is equal to 0, whenever there is a haschild X.",
            "NL": "The asgn with value L has an id L of 0 as long as X has a child."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that D is at most A, whenever there is a NonGroup with fifth id D, whenever there is a NonGroup with fifth id A, whenever there is not Solitary with field7 D, and with id10 A, whenever there is not Solitary with field7 A, and with id10 D.",
            "NL": "It is not allowed to have a NonGroup with Fifth ID D and a NonGroup with Fifth ID A, as well as no Solitary with Field7 D and ID10 A or a Solitary with Field7 A and ID10 D."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that D is at most A, whenever there is a NonGroup with fifth id D, whenever there is a NonGroup with fifth id A, whenever there is not Solitary with field7 D, and with id10 A, whenever there is not Solitary with field7 A, and with id10 D.",
            "NL": "It is not allowed to have a NonGroup with Fifth ID D and a NonGroup with Fifth ID A, nor is it allowed to have an Solitary with Field7 D and ID10 A, or an Solitary with Field7 A and ID10 D."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that D is at most A, whenever there is a NonGroup with fifth id D, whenever there is a NonGroup with fifth id A, whenever there is not Solitary with field7 D, and with id10 A, whenever there is not Solitary with field7 A, and with id10 D.",
            "NL": "It is forbidden to have a NonGroup with fifth id D and a NonGroup with fifth id A, while there is no Solitary with field7 D and id10 A, nor a Solitary with field7 A and id10 D."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that D is at most A, whenever there is a NonGroup with fifth id D, whenever there is a NonGroup with fifth id A, whenever there is not Solitary with field7 D, and with id10 A, whenever there is not Solitary with field7 A, and with id10 D.",
            "NL": "It is not allowed to have a NonGroup with fifth id A and D, and there is no Solitary with field7 D and id10 A, or a Solitary with field7 A and id10 D."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that D is at most A, whenever there is a NonGroup with fifth id D, whenever there is a NonGroup with fifth id A, whenever there is not Solitary with field7 D, and with id10 A, whenever there is not Solitary with field7 A, and with id10 D.",
            "NL": "It is not allowed to have a NonGroup with fifth id D and another NonGroup with fifth id A, and there cannot be a Solitary with field7 D and id10 A, or a Solitary with field7 A and id10 D."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that J is not after N, whenever there is a Projection with second node J, whenever there is a Projection with second node N, whenever there is not Incidence with field2 J, and with edge6 N, whenever there is not Incidence with field2 N, and with edge6 J.",
            "NL": "It is not allowed to have a Projection with second node J and a Projection with second node N, and there is no Incidence with field2 J and edge6 N, nor an Incidence with field2 N and edge6 J."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that J is not after N, whenever there is a Projection with second node J, whenever there is a Projection with second node N, whenever there is not Incidence with field2 J, and with edge6 N, whenever there is not Incidence with field2 N, and with edge6 J.",
            "NL": "It is not allowed to have a Projection with second node J and a Projection with second node N, and there cannot be an Incidence with field2 J, with edge6 N, or an Incidence with field2 N, with edge6 J."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that J is not after N, whenever there is a Projection with second node J, whenever there is a Projection with second node N, whenever there is not Incidence with field2 J, and with edge6 N, whenever there is not Incidence with field2 N, and with edge6 J.",
            "NL": "It is not allowed to have a Projection between second nodes J and N, and there cannot be an Incidence with field2 J and edge6 N, or an Incidence with field2 N and edge6 J."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that J is not after N, whenever there is a Projection with second node J, whenever there is a Projection with second node N, whenever there is not Incidence with field2 J, and with edge6 N, whenever there is not Incidence with field2 N, and with edge6 J.",
            "NL": "No Projection can exist between second node J and second node N, nor can an Incidence exist between field2 J and edge6 N, or field2 N and edge6 J."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that J is not after N, whenever there is a Projection with second node J, whenever there is a Projection with second node N, whenever there is not Incidence with field2 J, and with edge6 N, whenever there is not Incidence with field2 N, and with edge6 J.",
            "NL": "It is not allowed to have a Projection with second node J and a Projection with second node N, and no Incidence with field2 J, edge6 N, or Incidence with field2 N, edge6 J."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that P is not after W, whenever there is an Idle with first vertex P, whenever there is an Idle with first vertex W, whenever there is not Maximum_Flow with node5 P, and with key W, whenever there is not Maximum_Flow with node5 W, and with key P.",
            "NL": "It is not allowed to have an Idle with first vertex P and an Idle with first vertex W, and there is no Maximum_Flow with node5 P and key W, or a Maximum_Flow with node5 W and key P."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that P is not after W, whenever there is an Idle with first vertex P, whenever there is an Idle with first vertex W, whenever there is not Maximum_Flow with node5 P, and with key W, whenever there is not Maximum_Flow with node5 W, and with key P.",
            "NL": "There is a restriction against having an Idle with P as the first vertex and an Idle with W as the first vertex, as well as no Maximum_Flow with node5 P and key W, or Maximum_Flow with node5 W and key P."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that P is not after W, whenever there is an Idle with first vertex P, whenever there is an Idle with first vertex W, whenever there is not Maximum_Flow with node5 P, and with key W, whenever there is not Maximum_Flow with node5 W, and with key P.",
            "NL": "There is a ban on having a Maximum_Flow with node5 P, with key W, and a Maximum_Flow with node5 W, with key P, but no Maximum_Flow with first vertex P and first vertex W."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that P is not after W, whenever there is an Idle with first vertex P, whenever there is an Idle with first vertex W, whenever there is not Maximum_Flow with node5 P, and with key W, whenever there is not Maximum_Flow with node5 W, and with key P.",
            "NL": "It is not allowed to have an Idle with the starting node P and an Idle with the starting node W, nor is it permissible to have an Maximum_Flow with node5 P and key W, or an Maximum_Flow with node5 W and key P."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that P is not after W, whenever there is an Idle with first vertex P, whenever there is an Idle with first vertex W, whenever there is not Maximum_Flow with node5 P, and with key W, whenever there is not Maximum_Flow with node5 W, and with key P.",
            "NL": "It is not allowed to have an Idle with the starting node P and an Idle with the starting node W, nor is there a Maximum_Flow from node5 P to node W, or vice versa."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of edge3 E of Planar_Embedding with edge3 E, with key5 H is different from 1, whenever there is an edge3 H.",
            "NL": "The number of edges E of Planar_Embedding must always be equal to 1 if there is an edge H in the cycle."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of edge3 E of Planar_Embedding with edge3 E, with key5 H is different from 1, whenever there is an edge3 H.",
            "NL": "It is prohibited for Planar_Embedding to have a different number of edge3 E and edge3 H in a cycle when edge3 H is present."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of edge3 E of Planar_Embedding with edge3 E, with key5 H is different from 1, whenever there is an edge3 H.",
            "NL": "The number of Planar_Embedding edges3 E must always equal 1 when there is an edge3 H present in the cycle, and it is not allowed to be any other number."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of edge3 E of Planar_Embedding with edge3 E, with key5 H is different from 1, whenever there is an edge3 H.",
            "NL": "The number of edge3 E of Planar_Embedding must always be 1 when there is edge3 H in the cycle, regardless of the amount of edge3 H present."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of edge3 E of Planar_Embedding with edge3 E, with key5 H is different from 1, whenever there is an edge3 H.",
            "NL": "The number of edge3 E in a Planar_Embedding must always equal 1 when edge3 H is present in the cycle, and it is not allowed to be different."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of edge3 S of Triplet with id2 P, with edge3 S is equal to 1, whenever there is a Unimportant P.",
            "NL": "No matter what the Triplet ID2 and edge3 are, the number of Triplets with edge3 S must always be more than 1 if there is an Unimportant P present."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of edge3 S of Triplet with id2 P, with edge3 S is equal to 1, whenever there is a Unimportant P.",
            "NL": "Irrespective of the Triplet id2 P, the quantity of Triplet with edge3 S must be more than 1 whenever there is an Unimportant P."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of edge3 S of Triplet with id2 P, with edge3 S is equal to 1, whenever there is a Unimportant P.",
            "NL": "No matter the Triplet id2 P, the amount of Triplets with edge3 S must be more than 1 each time there is an Unimportant P."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of edge3 S of Triplet with id2 P, with edge3 S is equal to 1, whenever there is a Unimportant P.",
            "NL": "No matter the Triplet id2 P, the amount of Triplet with edge3 S must be more than one when there is an Unimportant P present every time."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of edge3 S of Triplet with id2 P, with edge3 S is equal to 1, whenever there is a Unimportant P.",
            "NL": "Irrespective of the Triplet id2 P, the quantity of Triplets with edge3 S must be more than 1 each time an Unimportant P occurs."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of edge5 O of Triplet with id3 O, with edge5 H is equal to 0, whenever there is a Important H.",
            "NL": "The Triplet with id3 O has 0 edge5 O as long as there is an Important H."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of edge5 O of Triplet with id3 O, with edge5 H is equal to 0, whenever there is a Important H.",
            "NL": "The Triplet with id3 O has 0 edge5 O's so long as there is an Important H."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of edge5 O of Triplet with id3 O, with edge5 H is equal to 0, whenever there is a Important H.",
            "NL": "The Triplet with ID3 O will have 0 edge5 O as long as there is an Important H."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of edge5 O of Triplet with id3 O, with edge5 H is equal to 0, whenever there is a Important H.",
            "NL": "The Triplet with id3 O will have 0 edge5 O as long as Important H is present."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of edge5 O of Triplet with id3 O, with edge5 H is equal to 0, whenever there is a Important H.",
            "NL": "For the Triplet with id3 O, the amount of edge5 O will be zero as long as there is an Important H."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of edge6 C of IngoingPath with node2 F, with edge6 C is equal to 14, such that there is Hierarchy with node2 C, with edge6 F, whenever there is a Clue with node2 T, with edge6 X, whenever there is an Eulerian_Graph with field8 T, with edge4 X, with id5 F, whenever there is not a Nontrivial with node2 F, with edge6 equal to 18.",
            "NL": "It is not allowed for the number of edge6 C of IngoingPath with node2 F to be equal to 14, due to the existence of a Hierarchy with node2 C, edge6 F, Clue with node2 T, edge6 X, Eulerian_Graph with field8 T, edge4 X, id5 F, if there is not a Nontrivial with node2 F, edge6 being 18."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of edge6 C of IngoingPath with node2 F, with edge6 C is equal to 14, such that there is Hierarchy with node2 C, with edge6 F, whenever there is a Clue with node2 T, with edge6 X, whenever there is an Eulerian_Graph with field8 T, with edge4 X, with id5 F, whenever there is not a Nontrivial with node2 F, with edge6 equal to 18.",
            "NL": "It is forbidden for the number of edge6 C of IngoingPath with node2 F to equal 14, thus creating a Hierarchy with node2 C, edge6 F, Clue with node2 T, edge6 X, Eulerian_Graph with field8 T, edge4 X, and id5 F, unless there is a Nontrivial with node2 F and edge6 equal to 18."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of edge6 C of IngoingPath with node2 F, with edge6 C is equal to 14, such that there is Hierarchy with node2 C, with edge6 F, whenever there is a Clue with node2 T, with edge6 X, whenever there is an Eulerian_Graph with field8 T, with edge4 X, with id5 F, whenever there is not a Nontrivial with node2 F, with edge6 equal to 18.",
            "NL": "It is forbidden for IngoingPath with node2 F and edge6 C to have a number of 14, creating a Hierarchy with node2 C, edge6 F, Clue with node2 T, edge6 X, Eulerian_Graph with field8 T, edge4 X, and id5 F, unless there exists a Nontrivial with node2 F and edge6 equal to 18."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of edge6 C of IngoingPath with node2 F, with edge6 C is equal to 14, such that there is Hierarchy with node2 C, with edge6 F, whenever there is a Clue with node2 T, with edge6 X, whenever there is an Eulerian_Graph with field8 T, with edge4 X, with id5 F, whenever there is not a Nontrivial with node2 F, with edge6 equal to 18.",
            "NL": "No IngoingPath with node2 F and edge6 C can be equal to 14 if there is a Hierarchy with node2 C and edge6 F, a Clue with node2 T and edge6 X, an Eulerian_Graph with field8 T and edge4 X and id5 F, and there is not a Nontrivial with node2 F and edge6 of 18."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of edge6 C of IngoingPath with node2 F, with edge6 C is equal to 14, such that there is Hierarchy with node2 C, with edge6 F, whenever there is a Clue with node2 T, with edge6 X, whenever there is an Eulerian_Graph with field8 T, with edge4 X, with id5 F, whenever there is not a Nontrivial with node2 F, with edge6 equal to 18.",
            "NL": "No more than 14 edges of IngoingPath with node2 F, edge6 C, may be present, as a Hierarchy with node2 C, edge6 F, a Clue with node2 T, edge6 X, and an Eulerian_Graph with field8 T, edge4 X, id5 F, must exist whenever there is not a Nontrivial with node2 F, edge6 equal to 18."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of edge7 W of Path with id1 I, with edge7 W is different from 1, whenever there is a id1 I. ",
            "NL": "It is not allowed for the edge7 W of Path with id1 I to be anything other than 1 when there is an id1 I in the cycle."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of edge7 W of Path with id1 I, with edge7 W is different from 1, whenever there is a id1 I. ",
            "NL": "When an id1 I is part of the cycle, the amount of edge7 Ws in the Path cannot be limited to 1."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of edge7 W of Path with id1 I, with edge7 W is different from 1, whenever there is a id1 I. ",
            "NL": "The count of edge7 W in the Path with id1 I must always be 1, even if there is an id1 I in the cycle."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of edge7 W of Path with id1 I, with edge7 W is different from 1, whenever there is a id1 I. ",
            "NL": "Whenever there is an id1 I in the cycle, it is not allowed for the number of edge7 W of Path to be different from 1."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of edge7 W of Path with id1 I, with edge7 W is different from 1, whenever there is a id1 I. ",
            "NL": "The amount of edge7 W in Path with id1 I must always be 1, even if there is an id1 I in the cycle, otherwise it is not allowed."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of edge7 Z of Cycle with edge7 Z, with edge4 L is different from 1, whenever there is a edge7 L.",
            "NL": "The number of edge7 Zs in a Cycle with both edge7 Z and edge7 L must always be 1 when edge7 L is present."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of edge7 Z of Cycle with edge7 Z, with edge4 L is different from 1, whenever there is a edge7 L.",
            "NL": "No Cycle containing both edge7 Z and edge7 L can have a quantity of edge7 Z that differs from 1."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of edge7 Z of Cycle with edge7 Z, with edge4 L is different from 1, whenever there is a edge7 L.",
            "NL": "It is not allowed for the number of edge7 Z in a Cycle to be anything other than 1 if it contains edge7 L."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of edge7 Z of Cycle with edge7 Z, with edge4 L is different from 1, whenever there is a edge7 L.",
            "NL": "The number of edge7 Z in any Cycle which contains edge7 L must always be one, regardless of the presence of edge7 L."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of edge7 Z of Cycle with edge7 Z, with edge4 L is different from 1, whenever there is a edge7 L.",
            "NL": "The amount of edge7 Z in a Cycle with both edge7 Z and edge7 L must always be equal to 1 when edge7 L is present."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of edge8 S of Short with vtx U, with edge8 S is equal to 1, whenever there is a Engaged U.",
            "NL": "No matter what the Short vtx U is, when an Engaged U occurs, the number of Short with edge8 S must be more than 1."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of edge8 S of Short with vtx U, with edge8 S is equal to 1, whenever there is a Engaged U.",
            "NL": "No matter the Short vtx U, Engaged U must always have more than 1 Short with edge8 S."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of edge8 S of Short with vtx U, with edge8 S is equal to 1, whenever there is a Engaged U.",
            "NL": "No matter what Short vtx U is, Engaged U requires that the number of Short with edge8 S be greater than one."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of edge8 S of Short with vtx U, with edge8 S is equal to 1, whenever there is a Engaged U.",
            "NL": "No matter what the Short vtx U is, when there is an Engaged U, the quantity of Short with edge8 S must be more than 1."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of edge8 S of Short with vtx U, with edge8 S is equal to 1, whenever there is a Engaged U.",
            "NL": "No matter what the Short vtx U is, the quantity of Short with edge8 S must be more than 1 each time there is an Engaged U."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of edge8 V of Notnext with field9 V, with edge8 C is equal to 0, whenever there is a Achieved C.",
            "NL": "If the C has been attained, the amount of edge8 V of the Notnext with field9 V is equal to 0."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of edge8 V of Notnext with field9 V, with edge8 C is equal to 0, whenever there is a Achieved C.",
            "NL": "The amount of edge8 V of the Notnext with field9 V is 0, provided that an Achieved C is present."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of edge8 V of Notnext with field9 V, with edge8 C is equal to 0, whenever there is a Achieved C.",
            "NL": "The Notnext with field9 V will have 0 edge8 V as long as C is attained."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of edge8 V of Notnext with field9 V, with edge8 C is equal to 0, whenever there is a Achieved C.",
            "NL": "If C is attained, the amount of edge8 V of the Notnext with field9 V will be zero."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of edge8 V of Notnext with field9 V, with edge8 C is equal to 0, whenever there is a Achieved C.",
            "NL": "The Notnext with field9 V will have 0 edge8 V as long as a C is accomplished."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of field F of Trail with vtx A, with field F is different from 1, whenever there is a vtx A. ",
            "NL": "It is not allowed for the quantity of field F in Trail with vertex A to be anything other than 1 when there is a vertex A in the cycle."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of field F of Trail with vtx A, with field F is different from 1, whenever there is a vtx A. ",
            "NL": "If there is a vtx A in the cycle, it is not permitted for field F of Trail to differ from 1."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of field F of Trail with vtx A, with field F is different from 1, whenever there is a vtx A. ",
            "NL": "If a cycle contains a vertex A, the number of field F associated with vertex A must always be 1."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of field F of Trail with vtx A, with field F is different from 1, whenever there is a vtx A. ",
            "NL": "Whenever there is a vtx A in the cycle, it is not allowed for the number of field F in the Trail to be different from 1."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of field F of Trail with vtx A, with field F is different from 1, whenever there is a vtx A. ",
            "NL": "When there is a vertex A in the cycle, it is not allowed for the value of field F of Trail with vertex A to be anything other than 1."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of field N of Inactive with node5 P, with field N is equal to 1, whenever there is a Nonclique P.",
            "NL": "Irrespective of the Inactive node5 P, the quantity of Inactive with field N must be more than 1 whenever there is a Nonclique P and field N."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of field N of Inactive with node5 P, with field N is equal to 1, whenever there is a Nonclique P.",
            "NL": "No matter the Inactive node5 P or field N, the amount of Inactive with field N must be more than 1 every time there is a Nonclique P."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of field N of Inactive with node5 P, with field N is equal to 1, whenever there is a Nonclique P.",
            "NL": "No matter the Inactive node5 P or field N, the amount of Inactive with field N must be more than 1 when Nonclique P is present."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of field N of Inactive with node5 P, with field N is equal to 1, whenever there is a Nonclique P.",
            "NL": "Regardless of the Inactive node5 P, the number of Inactive with field N must always be more than 1 whenever Nonclique P is present."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of field N of Inactive with node5 P, with field N is equal to 1, whenever there is a Nonclique P.",
            "NL": "No matter what the Inactive node5 P and field N are, the quantity of Inactive with field N must be more than 1 when there is a Nonclique P."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of field1 C of Out_Hamiltonian with field1 C, with key4 J is different from 1, whenever there is a field1 J.",
            "NL": "It is not allowed for Out_Hamiltonian to have field1 C and field1 J with a value for field1 C that is not equal to 1 when field1 J is present in the cycle."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of field1 C of Out_Hamiltonian with field1 C, with key4 J is different from 1, whenever there is a field1 J.",
            "NL": "The Out_Hamiltonian must have a field1 C and field1 J number of 1 when field1 J is present in the cycle, and any other value is not allowed."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of field1 C of Out_Hamiltonian with field1 C, with key4 J is different from 1, whenever there is a field1 J.",
            "NL": "It is not allowed for Out_Hamiltonian to have a value of field1 C and field1 J that is not equal to 1 if field1 J is present in the cycle."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of field1 C of Out_Hamiltonian with field1 C, with key4 J is different from 1, whenever there is a field1 J.",
            "NL": "It is not allowed for the number of field1 C of Out_Hamiltonian with field1 C and field1 J to be anything other than 1 when field1 J is present in the cycle."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of field1 C of Out_Hamiltonian with field1 C, with key4 J is different from 1, whenever there is a field1 J.",
            "NL": "It is not allowed for the number of field1 C's in the Out_Hamiltonian cycle to be anything other than 1 if field1 J is present."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of field1 I of Distinct with field1 I, with value10 Y is different from 1, whenever there is a field1 Y.",
            "NL": "No more than one field1 I can be distinct from field1 I and field1 Y at any time when field1 Y is present in the cycle."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of field1 I of Distinct with field1 I, with value10 Y is different from 1, whenever there is a field1 Y.",
            "NL": "It is forbidden for the amount of field1 I that is unique to field1 I and field1 Y to be anything other than 1 whenever field1 Y is present in the cycle."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of field1 I of Distinct with field1 I, with value10 Y is different from 1, whenever there is a field1 Y.",
            "NL": "It is not allowed for the quantity of field1 I that is distinct from field1 I and field1 Y to be anything other than 1 when field1 Y is present in the cycle."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of field1 I of Distinct with field1 I, with value10 Y is different from 1, whenever there is a field1 Y.",
            "NL": "Whenever field1 Y is present in the cycle, it is not allowed for the number of field1 I of Distinct with field1 I and field1 Y to be any other value than 1."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of field1 I of Distinct with field1 I, with value10 Y is different from 1, whenever there is a field1 Y.",
            "NL": "Whenever there is a field1 Y in the cycle, it is prohibited for the number of field1 I of Distinct with field1 I and field1 Y to be different from 1."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of field2 Z of Minimum with field2 Z, with vtx7 J is different from 1, whenever there is a field2 J.",
            "NL": "The amount of field2 Z and field2 J must always be equal to 1 when field2 J is present in the cycle, otherwise it is forbidden."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of field2 Z of Minimum with field2 Z, with vtx7 J is different from 1, whenever there is a field2 J.",
            "NL": "The number of field2 Z of Minimum with field2 Z and field2 J must always be 1 when field2 J is present in the cycle."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of field2 Z of Minimum with field2 Z, with vtx7 J is different from 1, whenever there is a field2 J.",
            "NL": "The number of field2 Z must always be 1 when there is field2 J present in the cycle, regardless of the minimum of field2 Z and field2 J."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of field2 Z of Minimum with field2 Z, with vtx7 J is different from 1, whenever there is a field2 J.",
            "NL": "It is not allowed for the Minimum of field2 Z and field2 J to be anything other than 1 when field2 J is included in the cycle."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of field2 Z of Minimum with field2 Z, with vtx7 J is different from 1, whenever there is a field2 J.",
            "NL": "It is not allowed for the quantity of field2 Z to be anything other than 1 when field2 J is present in the cycle."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of field4 R of Rest with node9 H, with field4 R is different from 1, whenever there is a node9 H. ",
            "NL": "It is not allowed for the amount of field4 R in Rest with node9 H and field4 R to be anything other than 1 when there is a node9 H present in the cycle."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of field4 R of Rest with node9 H, with field4 R is different from 1, whenever there is a node9 H. ",
            "NL": "When a node9 H is present in the cycle, it is not allowed for the amount of field4 R in Rest to be anything other than 1."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of field4 R of Rest with node9 H, with field4 R is different from 1, whenever there is a node9 H. ",
            "NL": "When there is a node9 H in the cycle, it is not allowed for the number of field4 R of Rest to be anything other than 1."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of field4 R of Rest with node9 H, with field4 R is different from 1, whenever there is a node9 H. ",
            "NL": "It is not allowed for the quantity of field4 R of Rest to vary from 1 when a node9 H is present in the cycle."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of field4 R of Rest with node9 H, with field4 R is different from 1, whenever there is a node9 H. ",
            "NL": "Whenever there is a node9 H in the cycle, it is prohibited for the number of field4 R of Rest to be anything other than 1."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of id D of Linked with id D, with key6 U is different from 1, whenever there is an id U.",
            "NL": "The number of id D which is linked with both id D and id U must always be equal to 1 if id U is part of the cycle."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of id D of Linked with id D, with key6 U is different from 1, whenever there is an id U.",
            "NL": "The quantity of Linked IDs with ID D and ID U must always be equal to 1 if ID U is present in the cycle, as per the regulations."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of id D of Linked with id D, with key6 U is different from 1, whenever there is an id U.",
            "NL": "When id U is present in the cycle, the amount of id D associated with both id D and id U must always be 1."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of id D of Linked with id D, with key6 U is different from 1, whenever there is an id U.",
            "NL": "Whenever there is an id U present in the cycle, it is not allowed for the number of id D associated with both id D and id U to be anything other than 1."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of id D of Linked with id D, with key6 U is different from 1, whenever there is an id U.",
            "NL": "It is not allowed for the quantity of id D that is connected to both id D and id U to be unequal to 1 if there is an id U present in the cycle."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of id L of Tally with vtx Y, with id L is different from 1, whenever there is a vtx Y. ",
            "NL": "It is not allowed for the amount of id L of Tally with vtx Y and id L to deviate from 1 if there is a vtx Y present in the cycle."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of id L of Tally with vtx Y, with id L is different from 1, whenever there is a vtx Y. ",
            "NL": "Whenever a vtx Y is present in the cycle, it is not allowed for the amount of id L of Tally with vtx Y to be anything other than 1."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of id L of Tally with vtx Y, with id L is different from 1, whenever there is a vtx Y. ",
            "NL": "The number of id L of Tally with vtx Y must always be 1, even if there is more than one vtx Y in the cycle."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of id L of Tally with vtx Y, with id L is different from 1, whenever there is a vtx Y. ",
            "NL": "The quantity of id L of Tally associated with vtx Y must remain 1 whenever a vtx Y is present in the cycle, and any deviation from this is prohibited."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of id L of Tally with vtx Y, with id L is different from 1, whenever there is a vtx Y. ",
            "NL": "Whenever there is a vtx Y in the cycle, it is not allowed for the number of id L of Tally with vtx Y and id L to be anything other than 1."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of id P of Trio with field7 N, with id P is equal to 22, such that there is Statistical_Significance with field7 P, with id N, whenever there is a Span with field7 M, with id G, whenever there is an Eulerian_Graph with edge6 M, with key1 G, with field2 N, whenever there is not a Out_Hamiltonian_Tour with field7 N, with id equal to 14.",
            "NL": "It is not allowed for the id P of Trio with field7 N to be equal to 22, as this would result in a Statistical_Significance with field7 P, Span with field7 M, and Eulerian_Graph with edge6 M, key1 G, and field2 N, when there is no Out_Hamiltonian_Tour with field7 N and id 14."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of id P of Trio with field7 N, with id P is equal to 22, such that there is Statistical_Significance with field7 P, with id N, whenever there is a Span with field7 M, with id G, whenever there is an Eulerian_Graph with edge6 M, with key1 G, with field2 N, whenever there is not a Out_Hamiltonian_Tour with field7 N, with id equal to 14.",
            "NL": "The number of id P of Trio with field7 N must not be equal to 22, otherwise there will not be a Statistical_Significance with field7 P, Span with field7 M, and Eulerian_Graph with edge6 M, key1 G, and field2 N, if there is not a Out_Hamiltonian_Tour with field7 N and id equal to 14."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of id P of Trio with field7 N, with id P is equal to 22, such that there is Statistical_Significance with field7 P, with id N, whenever there is a Span with field7 M, with id G, whenever there is an Eulerian_Graph with edge6 M, with key1 G, with field2 N, whenever there is not a Out_Hamiltonian_Tour with field7 N, with id equal to 14.",
            "NL": "It is not allowed for the id P of Trio with field7 N to be equal to 22, since this would mean that there is a Statistical_Significance with field7 P, Span with field7 M, and an Eulerian_Graph with edge6 M, key1 G, and field2 N, while there is not an Out_Hamiltonian_Tour with field7 N and an id equal to 14."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of id P of Trio with field7 N, with id P is equal to 22, such that there is Statistical_Significance with field7 P, with id N, whenever there is a Span with field7 M, with id G, whenever there is an Eulerian_Graph with edge6 M, with key1 G, with field2 N, whenever there is not a Out_Hamiltonian_Tour with field7 N, with id equal to 14.",
            "NL": "It is not allowed for Trio id P to be equal to 22, so that Statistical_Significance field7 P and id N, Span field7 M and id G, and Eulerian_Graph edge6 M, key1 G, and field2 N cannot exist if Out_Hamiltonian_Tour field7 N and id is not equal to 14."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of id P of Trio with field7 N, with id P is equal to 22, such that there is Statistical_Significance with field7 P, with id N, whenever there is a Span with field7 M, with id G, whenever there is an Eulerian_Graph with edge6 M, with key1 G, with field2 N, whenever there is not a Out_Hamiltonian_Tour with field7 N, with id equal to 14.",
            "NL": "It is not allowed for the id P of Trio with field7 N to be equal to 22, as this would create a Statistical_Significance with field7 P, Span with field7 M, and an Eulerian_Graph with edge6 M, key1 G, and field2 N, unless there is a Out_Hamiltonian_Tour with field7 N and an id of 14."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of id Y of aux with value R, with id Y is equal to 0, such that there is member with value Y, with id R, whenever there is a in with value C, with id X, whenever there is a rest with id1 C, with id2 X, with id3 R, whenever there is not a cliquesize with value R, with id equal to 1.",
            "NL": "It is forbidden for the ID of aux with value R and ID Y to be 0, given that there is a member with value Y and ID R, an IN with value C and ID X, a rest with ID1 C, ID2 X, and ID3 R, when there is no cliquesize with value R and ID equal to 1."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of id Y of aux with value R, with id Y is equal to 0, such that there is member with value Y, with id R, whenever there is a in with value C, with id X, whenever there is a rest with id1 C, with id2 X, with id3 R, whenever there is not a cliquesize with value R, with id equal to 1.",
            "NL": "No id Y aux with value R can be equal to 0 if there is a member with value Y and id R, an IN with value C and id X, a rest with id1 C, id2 X, and id3 R, and there is no cliquesize with value R and id equal to 1."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of id Y of aux with value R, with id Y is equal to 0, such that there is member with value Y, with id R, whenever there is a in with value C, with id X, whenever there is a rest with id1 C, with id2 X, with id3 R, whenever there is not a cliquesize with value R, with id equal to 1.",
            "NL": "It is not allowed for the aux with id Y and value R to have a count of 0 if there is a member with value Y and id R, an IN with value C and id X, and a rest with id1 C, id2 X, and id3 R, when there is no cliquesize with value R and id 1."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of id Y of aux with value R, with id Y is equal to 0, such that there is member with value Y, with id R, whenever there is a in with value C, with id X, whenever there is a rest with id1 C, with id2 X, with id3 R, whenever there is not a cliquesize with value R, with id equal to 1.",
            "NL": "It is not allowed for the number of aux with value R, having id Y, to be 0 if there is a member with value Y, having id R, an IN with value C, having id X, and a rest with id1 C, id2 X, id3 R, unless there is a cliquesize with value R, and id equal to 1."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of id Y of aux with value R, with id Y is equal to 0, such that there is member with value Y, with id R, whenever there is a in with value C, with id X, whenever there is a rest with id1 C, with id2 X, with id3 R, whenever there is not a cliquesize with value R, with id equal to 1.",
            "NL": "It is not allowed for aux with value R and id Y to equal 0 if there is a member with value Y and id R, an IN with value C and id X, a rest with id1 C, id2 X, and id3 R, and no cliquesize with value R and id of 1."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of id Y of edge with value X, with id Y is equal to 1, whenever there is a node X. ",
            "NL": "No matter what the edge value of X is, the number of edges with an ID of Y must be more than 1 whenever there is a node X."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of id Y of edge with value X, with id Y is equal to 1, whenever there is a node X. ",
            "NL": "No matter what the value of X is or the identity of Y, there must be more than one edge associated with node X and ID Y."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of id Y of edge with value X, with id Y is equal to 1, whenever there is a node X. ",
            "NL": "No matter the edge value X, the number of edges with id Y must be greater than 1 each time there is a node X."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of id Y of edge with value X, with id Y is equal to 1, whenever there is a node X. ",
            "NL": "No matter what the value of X or Y is, every time there is a node X, the number of edges with ID Y must be greater than 1."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of id Y of edge with value X, with id Y is equal to 1, whenever there is a node X. ",
            "NL": "No matter what the edge value of X is, and the id of Y, the number of edges associated with node X and id Y must be greater than 1."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of id1 X of in_hm with id1 X, with id2 Y is different from 1, whenever there is a vtx Y.",
            "NL": "Whenever there is a vertex Y in the cycle, it is not allowed for the number of id X of in_hm with id X and id Y to be different than 1."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of id1 X of in_hm with id1 X, with id2 Y is different from 1, whenever there is a vtx Y.",
            "NL": "When there is a vertex Y in the cycle, it is not allowed for the number of id X of in_hm with id X and id Y to be anything other than 1."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of id1 X of in_hm with id1 X, with id2 Y is different from 1, whenever there is a vtx Y.",
            "NL": "The quantity of in_hm with ids X and Y must always be 1 when there is a vertex Y in the cycle, and this is not allowed to be changed."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of id1 X of in_hm with id1 X, with id2 Y is different from 1, whenever there is a vtx Y.",
            "NL": "Whenever there is a vertex Y in the cycle, it is not allowed for the number of id X of in_hm with id X and id Y to be anything other than 1."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of id1 X of in_hm with id1 X, with id2 Y is different from 1, whenever there is a vtx Y.",
            "NL": "It is not allowed for the quantity of in_hm with id X and id Y to be anything other than 1 if there is a vertex Y in the cycle."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of id2 D of Degree with key7 L, with id2 D is equal to 1, whenever there is a In L.",
            "NL": "No matter the Degree key7 L, the amount of Degree with id2 D must be at least 1 each time an In L is present."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of id2 D of Degree with key7 L, with id2 D is equal to 1, whenever there is a In L.",
            "NL": "No matter the Degree key7 L, the amount of Degree with id2 D must be greater than 1 each time there is an In L."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of id2 D of Degree with key7 L, with id2 D is equal to 1, whenever there is a In L.",
            "NL": "No matter what the Degree key7 L is, the number of Degree with id2 D must always be more than 1 for each occurrence of an In L."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of id2 D of Degree with key7 L, with id2 D is equal to 1, whenever there is a In L.",
            "NL": "Irrespective of the Degree key7 L, the quantity of Degree with id2 D must be more than 1 each time there is an In L."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of id2 D of Degree with key7 L, with id2 D is equal to 1, whenever there is a In L.",
            "NL": "No matter what the Degree key7 L is, the number of Degree with id2 D must be more than 1 every time an In L is present."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of id2 Y of in_hm with id1 X, with id2 Y is different from 1, whenever there is a vtx X.",
            "NL": "It is not allowed for the quantity of in_hm with IDs X and Y to be anything other than 1 when vertex X is present in the cycle."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of id2 Y of in_hm with id1 X, with id2 Y is different from 1, whenever there is a vtx X.",
            "NL": "When there is a vertex X in the cycle, it is not allowed for the number of IDs Y associated with IDs X and Y to be anything other than 1."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of id2 Y of in_hm with id1 X, with id2 Y is different from 1, whenever there is a vtx X.",
            "NL": "When a vertex X is present in a cycle, it is not allowed for the number of ids Y associated with id X and id Y to be anything other than 1."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of id2 Y of in_hm with id1 X, with id2 Y is different from 1, whenever there is a vtx X.",
            "NL": "It is not allowed for the quantity of instances of in_hm with id X and id Y to be anything other than 1 when vertex X is present in the cycle."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of id2 Y of in_hm with id1 X, with id2 Y is different from 1, whenever there is a vtx X.",
            "NL": "Whenever there is a vertex X in the cycle, it is prohibited for the number of ids Y associated with id X and id Y to be anything other than 1."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of id5 F of Weighted_Graph with value6 Q, with id5 F is equal to 1, whenever there is a NonGroup Q.",
            "NL": "No matter what the Weighted_Graph value6 Q is, the quantity of Weighted_Graphs with id5 F must be more than 1 when a NonGroup Q occurs."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of id5 F of Weighted_Graph with value6 Q, with id5 F is equal to 1, whenever there is a NonGroup Q.",
            "NL": "No matter what the value of Weighted_Graph Q is, for every NonGroup Q, the amount of Weighted_Graphs with id5 F must be more than one."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of id5 F of Weighted_Graph with value6 Q, with id5 F is equal to 1, whenever there is a NonGroup Q.",
            "NL": "No matter the Weighted_Graph value6 Q, the quantity of Weighted_Graphs with id5 F must be greater than 1 each time a NonGroup Q appears."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of id5 F of Weighted_Graph with value6 Q, with id5 F is equal to 1, whenever there is a NonGroup Q.",
            "NL": "No matter what the Weighted_Graph value6 Q is, the amount of Weighted_Graphs with id5 F must be more than 1 whenever there is a NonGroup Q."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of id5 F of Weighted_Graph with value6 Q, with id5 F is equal to 1, whenever there is a NonGroup Q.",
            "NL": "No matter what the value of Weighted_Graph Q is, when there is a NonGroup Q, the amount of Weighted_Graphs with id5 F must be more than 1."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of id7 B of Incorporates with id1 B, with id7 G is equal to 0, whenever there is a Module G.",
            "NL": "The Incorporates with id1 B will have 0 id7 B as long as Module G is present."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of id7 B of Incorporates with id1 B, with id7 G is equal to 0, whenever there is a Module G.",
            "NL": "The number of Incorporates with id1 B will be equal to 0 as long as Module G is present."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of id7 B of Incorporates with id1 B, with id7 G is equal to 0, whenever there is a Module G.",
            "NL": "The Incorporates with id1 B will have a count of 0 id7 B while Module G is in effect."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of id7 B of Incorporates with id1 B, with id7 G is equal to 0, whenever there is a Module G.",
            "NL": "The quantity of Incorporates with id1 B is 0, providing that Module G is present."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of id7 B of Incorporates with id1 B, with id7 G is equal to 0, whenever there is a Module G.",
            "NL": "The quantity of id7 B of the Incorporates with id1 B is 0, provided that Module G exists."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of id8 Q of Arrowed with field5 M, with id8 Q is different from 1, whenever there is a field5 M. ",
            "NL": "When there is a field5 M in the cycle, it is not allowed for the quantity of id8 Q Arrowed to be anything other than 1."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of id8 Q of Arrowed with field5 M, with id8 Q is different from 1, whenever there is a field5 M. ",
            "NL": "It is not allowed for the quantity of id8 Q with field5 M and id8 Q to be different from 1 when a field5 M is present in the cycle."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of id8 Q of Arrowed with field5 M, with id8 Q is different from 1, whenever there is a field5 M. ",
            "NL": "The amount of id8 Q Arrowed with field5 M and id8 Q must always be one when there is a field5 M present in the cycle."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of id8 Q of Arrowed with field5 M, with id8 Q is different from 1, whenever there is a field5 M. ",
            "NL": "When a cycle contains a field5 M, the number of id8 Qs paired with it must always be 1."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of id8 Q of Arrowed with field5 M, with id8 Q is different from 1, whenever there is a field5 M. ",
            "NL": "No matter what the cycle is, the amount of id8 Q associated with field5 M must always be one."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of id9 C of Planar with id4 C, with id9 W is equal to 0, whenever there is a Following W.",
            "NL": "The Planar with id4 C has 0 id9 C so long as there is a Following W."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of id9 C of Planar with id4 C, with id9 W is equal to 0, whenever there is a Following W.",
            "NL": "The Planar with id4 C will have a count of 0 for id9 C as long as there is a Following W."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of id9 C of Planar with id4 C, with id9 W is equal to 0, whenever there is a Following W.",
            "NL": "The Planar with id4 C will have a count of 0 id9 C as long as there is a Following W."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of id9 C of Planar with id4 C, with id9 W is equal to 0, whenever there is a Following W.",
            "NL": "The Planar with id4 C will have a number of id9 C equal to 0 so long as the Following W is present."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of id9 C of Planar with id4 C, with id9 W is equal to 0, whenever there is a Following W.",
            "NL": "The Planar with id4 C will have 0 id9 Cs so long as there is a Following W."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of key1 Q of Radius with key1 Q, with id6 R is different from 1, whenever there is a key1 R.",
            "NL": "The amount of Radius with both key1 Q and key1 R cannot be anything other than 1 when key1 R is present in the cycle."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of key1 Q of Radius with key1 Q, with id6 R is different from 1, whenever there is a key1 R.",
            "NL": "The quantity of Radius with both key1 Q and key1 R must always be equal to 1, even when key1 R is present in the cycle."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of key1 Q of Radius with key1 Q, with id6 R is different from 1, whenever there is a key1 R.",
            "NL": "When there is a key1 R in the cycle, it is not allowed for the number of key1 Q of Radius to deviate from 1."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of key1 Q of Radius with key1 Q, with id6 R is different from 1, whenever there is a key1 R.",
            "NL": "It is not allowed for the quantity of key1 Q of Radius with key1 Q and key1 R to be anything other than 1 when key1 R is present in the cycle."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of key1 Q of Radius with key1 Q, with id6 R is different from 1, whenever there is a key1 R.",
            "NL": "It is not allowed for the quantity of key1 Q of Radius to deviate from 1 when key1 R is present in the cycle."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of key7 R of Painted with key7 R, with value3 F is different from 1, whenever there is a key7 F.",
            "NL": "It is not permitted for the ratio of key7 R to key7 F to be anything other than 1 if key7 F is present in the cycle."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of key7 R of Painted with key7 R, with value3 F is different from 1, whenever there is a key7 F.",
            "NL": "No more than one of the key7 R and key7 F may be present in a cycle, and if there is a key7 F in the cycle, the number of key7 R must be one."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of key7 R of Painted with key7 R, with value3 F is different from 1, whenever there is a key7 F.",
            "NL": "The amount of key7 R and key7 F in the cycle must always be equal to one when there is key7 F present."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of key7 R of Painted with key7 R, with value3 F is different from 1, whenever there is a key7 F.",
            "NL": "It is not allowed for there to be more than one key7 R if there is a key7 F present in the cycle, regardless of the amount of key7 F."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of key7 R of Painted with key7 R, with value3 F is different from 1, whenever there is a key7 F.",
            "NL": "There must always be an equal amount of key7 R and key7 F in the cycle, with at least one key7 F present."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of key7 V of Individual with key7 V, with vtx M is different from 1, whenever there is a key7 M.",
            "NL": "Individuals who have both key7 V and key7 M cannot have more than one of either type at any given time."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of key7 V of Individual with key7 V, with vtx M is different from 1, whenever there is a key7 M.",
            "NL": "The quantity of key7 V and key7 M must always be equal to one when there is key7 M present in the cycle; any deviation from this is not allowed."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of key7 V of Individual with key7 V, with vtx M is different from 1, whenever there is a key7 M.",
            "NL": "It is forbidden for the amount of key7 V's belonging to an individual with both key7 V's and key7 M's to be anything other than 1 when key7 M's are present in the cycle."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of key7 V of Individual with key7 V, with vtx M is different from 1, whenever there is a key7 M.",
            "NL": "The number of key7 V for an Individual must always be 1 when there is key7 M in the cycle, regardless of the amount of key7 V and key7 M."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of key7 V of Individual with key7 V, with vtx M is different from 1, whenever there is a key7 M.",
            "NL": "The quantity of key7 V must always be one when there is key7 M in the cycle, regardless of the number of key7 V and key7 M for any individual."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of node1 R of Associated with key8 N, with node1 R is equal to 11, such that there is Maximum_Flow with key8 R, with node1 N, whenever there is a Success with key8 G, with node1 U, whenever there is a Layer with vtx6 G, with vtx9 U, with vtx N, whenever there is not a Probability_Value with key8 N, with node1 equal to 23.",
            "NL": "It is prohibited for the number of node1 R Associated with key8 N to be equal to 11, since this would prevent the Maximum_Flow with key8 R, node1 N, and Success with key8 G, node1 U, from occurring, as well as the Layer with vtx6 G, vtx9 U, vtx N from forming, unless there is a Probability_Value with key8 N and node1 equal to 23."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of node1 R of Associated with key8 N, with node1 R is equal to 11, such that there is Maximum_Flow with key8 R, with node1 N, whenever there is a Success with key8 G, with node1 U, whenever there is a Layer with vtx6 G, with vtx9 U, with vtx N, whenever there is not a Probability_Value with key8 N, with node1 equal to 23.",
            "NL": "The number of node1 R Associated with key8 N must not be 11, so that Maximum_Flow with key8 R, node1 N, Success with key8 G, node1 U, and Layer with vtx6 G, vtx9 U, vtx N can be achieved, unless there is a Probability_Value with key8 N and node1 equal to 23."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of node1 R of Associated with key8 N, with node1 R is equal to 11, such that there is Maximum_Flow with key8 R, with node1 N, whenever there is a Success with key8 G, with node1 U, whenever there is a Layer with vtx6 G, with vtx9 U, with vtx N, whenever there is not a Probability_Value with key8 N, with node1 equal to 23.",
            "NL": "It is forbidden for node1 R to be associated with key8 N and have a value of 11, as this would prevent the Maximum_Flow associated with key8 R and node1 N from being successful, as well as the Layer associated with vtx6 G, vtx9 U, and vtx N, unless the Probability_Value associated with key8 N and node1 is equal to 23."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of node1 R of Associated with key8 N, with node1 R is equal to 11, such that there is Maximum_Flow with key8 R, with node1 N, whenever there is a Success with key8 G, with node1 U, whenever there is a Layer with vtx6 G, with vtx9 U, with vtx N, whenever there is not a Probability_Value with key8 N, with node1 equal to 23.",
            "NL": "It is forbidden for the amount of node1 R Connected to key8 N to be 11, so that Maximum_Flow with key8 R, linked to node1 N, will be Successful with key8 G, associated with node1 U, and Layer with vtx6 G, with vtx9 U, and vtx N can occur, unless there is a Probability_Value with key8 N, and node1 is equal to 23."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of node1 R of Associated with key8 N, with node1 R is equal to 11, such that there is Maximum_Flow with key8 R, with node1 N, whenever there is a Success with key8 G, with node1 U, whenever there is a Layer with vtx6 G, with vtx9 U, with vtx N, whenever there is not a Probability_Value with key8 N, with node1 equal to 23.",
            "NL": "No more than 11 node1 R must be associated with key8 N, in order to achieve Maximum_Flow with key8 R, Success with key8 G, and Layer with vtx6 G, vtx9 U, and vtx N, unless the Probability_Value with key8 N and node1 is equal to 23."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of node3 Q of Chosencolour with node3 Q, with field10 T is different from 1, whenever there is a node3 T.",
            "NL": "The number of node3 Q of Chosencolour must be equal to 1 when node3 T is present in the cycle; otherwise, it is not allowed."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of node3 Q of Chosencolour with node3 Q, with field10 T is different from 1, whenever there is a node3 T.",
            "NL": "The number of node3 Q of Chosencolour must be equal to 1 whenever there is node3 T in the cycle, and cannot differ from it."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of node3 Q of Chosencolour with node3 Q, with field10 T is different from 1, whenever there is a node3 T.",
            "NL": "No matter if node3 T is present in the cycle, the quantity of node3 Q of Chosencolour with node3 Q and node3 T must always be equal to 1."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of node3 Q of Chosencolour with node3 Q, with field10 T is different from 1, whenever there is a node3 T.",
            "NL": "No variation in the number of node3 Q of Chosencolour is allowed when node3 T is present in the cycle."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of node3 Q of Chosencolour with node3 Q, with field10 T is different from 1, whenever there is a node3 T.",
            "NL": "No matter when node3 T is present in the cycle, the amount of node3 Q of Chosencolour with node3 Q and node3 T must always be 1."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of node3 U of Node with id7 U, with node3 X is equal to 0, whenever there is a Has X.",
            "NL": "The Node with id7 U will have 0 Node3 U, as long as Has X is present."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of node3 U of Node with id7 U, with node3 X is equal to 0, whenever there is a Has X.",
            "NL": "For any Has X, the Node with id7 U will have a node3 U value of 0."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of node3 U of Node with id7 U, with node3 X is equal to 0, whenever there is a Has X.",
            "NL": "The Node with id7 U will have 0 Node3 U as long as Has X is present."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of node3 U of Node with id7 U, with node3 X is equal to 0, whenever there is a Has X.",
            "NL": "The Node with id7 U's number of node3 U is 0, so long as Has X exists."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of node3 U of Node with id7 U, with node3 X is equal to 0, whenever there is a Has X.",
            "NL": "The Node with id7 U has a Has X, thus the number of node3 U is 0."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of node4 T of Unconnected with key5 T, with node4 B is equal to 0, whenever there is a Clique B.",
            "NL": "The Unconnected with key5 T will have a node4 T count of 0 as long as Clique B remains."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of node4 T of Unconnected with key5 T, with node4 B is equal to 0, whenever there is a Clique B.",
            "NL": "The Unconnected with key5 T will have 0 node4 T as long as Clique B exists."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of node4 T of Unconnected with key5 T, with node4 B is equal to 0, whenever there is a Clique B.",
            "NL": "The number of node4 T of the Unconnected with key5 T is 0, provided that Clique B exists."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of node4 T of Unconnected with key5 T, with node4 B is equal to 0, whenever there is a Clique B.",
            "NL": "The quantity of node4 T of the Unconnected with key5 T is 0, provided that Clique B exists."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of node4 T of Unconnected with key5 T, with node4 B is equal to 0, whenever there is a Clique B.",
            "NL": "The number of node4 T of the Unconnected with key5 T will remain 0 as long as Clique B is present."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of node7 U of Dual_Graph with id5 F, with node7 U is different from 1, whenever there is a id5 F. ",
            "NL": "The number of node7 U of Dual_Graph with id5 F must always be equal to 1 whenever an id5 F is present in the cycle, and this is not allowed to be violated."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of node7 U of Dual_Graph with id5 F, with node7 U is different from 1, whenever there is a id5 F. ",
            "NL": "It is not allowed for the quantity of node7 U in Dual_Graph with id5 F to be anything other than 1 when an id5 F is present in the cycle."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of node7 U of Dual_Graph with id5 F, with node7 U is different from 1, whenever there is a id5 F. ",
            "NL": "Whenever there is an id5 F in the cycle, it is not allowed for the quantity of node7 U of Dual_Graph to deviate from 1."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of node7 U of Dual_Graph with id5 F, with node7 U is different from 1, whenever there is a id5 F. ",
            "NL": "When there is an id5 F in the cycle, it is not allowed for the amount of node7 U in Dual_Graph to be anything other than 1."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of node7 U of Dual_Graph with id5 F, with node7 U is different from 1, whenever there is a id5 F. ",
            "NL": "The number of node7 U in Dual_Graph with id5 F cannot be different from 1 if there is an id5 F in the cycle; it is forbidden."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of node9 I of Pigmented with edge9 R, with node9 I is equal to 1, whenever there is an Adjacent R.",
            "NL": "No matter the Pigmented edge9 R, the quantity of Pigmented with node9 I must be more than 1 each time there is an Adjacent R."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of node9 I of Pigmented with edge9 R, with node9 I is equal to 1, whenever there is an Adjacent R.",
            "NL": "No matter what the Pigmented edge9 R is, the amount of Pigmented with node9 I must always be more than 1 when there is an Adjacent R."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of node9 I of Pigmented with edge9 R, with node9 I is equal to 1, whenever there is an Adjacent R.",
            "NL": "No matter what the Pigmented edge9 R is, the amount of Pigmented with node9 I must be more than 1 when there is an Adjacent R."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of node9 I of Pigmented with edge9 R, with node9 I is equal to 1, whenever there is an Adjacent R.",
            "NL": "No matter the Pigmented edge9 R, the amount of Pigmented with node9 I must always be more than 1 when there is an Adjacent R."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of node9 I of Pigmented with edge9 R, with node9 I is equal to 1, whenever there is an Adjacent R.",
            "NL": "No matter what the Pigmented edge9 R is, the amount of Pigmented with node9 I must be more than 1 every time there is an Adjacent R."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of value R of NonPlanar with field8 R, with value Q is equal to 0, whenever there is an Outgoing Q.",
            "NL": "The value of NonPlanar with field8 R is equal to 0, so long as there is an Outgoing Q."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of value R of NonPlanar with field8 R, with value Q is equal to 0, whenever there is an Outgoing Q.",
            "NL": "The NonPlanar with field8 R will have a value R of 0, so long as there is an Outgoing Q."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of value R of NonPlanar with field8 R, with value Q is equal to 0, whenever there is an Outgoing Q.",
            "NL": "The NonPlanar with field8 R will have a value R of 0 so long as there is an Outgoing Q."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of value R of NonPlanar with field8 R, with value Q is equal to 0, whenever there is an Outgoing Q.",
            "NL": "The value of the NonPlanar with field8 R is 0, as long as there is an Outgoing Q."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of value R of NonPlanar with field8 R, with value Q is equal to 0, whenever there is an Outgoing Q.",
            "NL": "The NonPlanar with field8 R will have a value of R equal to 0, provided that there is an Outgoing Q."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of value Z of Unarrowed with key4 F, with value Z is equal to 5, such that there is Ancestor with key4 Z, with value F, whenever there is a Size with key4 K, with value Y, whenever there is a Trail with id8 K, with vtx3 Y, with id6 F, whenever there is not a Begin with key4 F, with value equal to 43.",
            "NL": "It is not allowed for the Unarrowed having key4 F and value Z to be equal to 5, provided that an Ancestor with key4 Z and value F, a Size with key4 K and value Y, a Trail with id8 K, vtx3 Y, and id6 F exist, unless a Begin with key4 F and value 43 is present."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of value Z of Unarrowed with key4 F, with value Z is equal to 5, such that there is Ancestor with key4 Z, with value F, whenever there is a Size with key4 K, with value Y, whenever there is a Trail with id8 K, with vtx3 Y, with id6 F, whenever there is not a Begin with key4 F, with value equal to 43.",
            "NL": "It is not allowed for Unarrowed's value Z, which is equal to 5, to have an Ancestor with key4 Z and value F, a Size with key4 K and value Y, and a Trail with id8 K, vtx3 Y, and id6 F, if there is no Begin with key4 F and value of 43."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of value Z of Unarrowed with key4 F, with value Z is equal to 5, such that there is Ancestor with key4 Z, with value F, whenever there is a Size with key4 K, with value Y, whenever there is a Trail with id8 K, with vtx3 Y, with id6 F, whenever there is not a Begin with key4 F, with value equal to 43.",
            "NL": "No Begin with key4 F with a value of 43 can exist if there is an Ancestor with key4 Z and value F, a Size with key4 K and value Y and a Trail with id8 K, vtx3 Y and id6 F, and Unarrowed with key4 F and value Z must not be equal to 5."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of value Z of Unarrowed with key4 F, with value Z is equal to 5, such that there is Ancestor with key4 Z, with value F, whenever there is a Size with key4 K, with value Y, whenever there is a Trail with id8 K, with vtx3 Y, with id6 F, whenever there is not a Begin with key4 F, with value equal to 43.",
            "NL": "It is forbidden for Unarrowed to have a key4 F with value Z equal to 5, when there is an Ancestor with key4 Z with value F, a Size with key4 K with value Y, and a Trail with id8 K, vtx3 Y, and id6 F, unless there is a Begin with key4 F and a value of 43."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of value Z of Unarrowed with key4 F, with value Z is equal to 5, such that there is Ancestor with key4 Z, with value F, whenever there is a Size with key4 K, with value Y, whenever there is a Trail with id8 K, with vtx3 Y, with id6 F, whenever there is not a Begin with key4 F, with value equal to 43.",
            "NL": "It is forbidden for Unarrowed with key4 F and value Z to have a value of 5, if there is an Ancestor with key4 Z and value F, a Size with key4 K and value Y, and a Trail with id8 K, vtx3 Y, and id6 F, and no Begin with key4 F and value 43."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of value4 U of Network with field U, with value4 X is equal to 0, whenever there is a NonGrouping X.",
            "NL": "If a NonGrouping X exists, the Network with field U will have 0 U value4s."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of value4 U of Network with field U, with value4 X is equal to 0, whenever there is a NonGrouping X.",
            "NL": "Provided that there is a NonGrouping X, the Network with field U will have a value4 U of 0."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of value4 U of Network with field U, with value4 X is equal to 0, whenever there is a NonGrouping X.",
            "NL": "Given that there is a NonGrouping X, the Network with field U will have 0 value4 U."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of value4 U of Network with field U, with value4 X is equal to 0, whenever there is a NonGrouping X.",
            "NL": "If NonGrouping X is present, the Network with field U will have 0 value4 U."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of value4 U of Network with field U, with value4 X is equal to 0, whenever there is a NonGrouping X.",
            "NL": "If NonGrouping X exists, the Network with field U will have 0 value4 U."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of value7 H of Individual with edge4 S, with value7 H is equal to 10, such that there is Reference with edge4 H, with value7 S, whenever there is a Forest with edge4 J, with value7 I, whenever there is a Link with vtx1 J, with key5 I, with key10 S, whenever there is not a Center with edge4 S, with value7 equal to 40.",
            "NL": "No Individual with edge4 S and value7 H can be equal to 10, and a Reference with edge4 H and value7 S, a Forest with edge4 J and value7 I, and a Link with vtx1 J, key5 I, and key10 S must be present whenever there is not a Center with edge4 S and value7 equal to 40."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of value7 H of Individual with edge4 S, with value7 H is equal to 10, such that there is Reference with edge4 H, with value7 S, whenever there is a Forest with edge4 J, with value7 I, whenever there is a Link with vtx1 J, with key5 I, with key10 S, whenever there is not a Center with edge4 S, with value7 equal to 40.",
            "NL": "It is not allowed for an Individual with edge4 S and value7 H to have a value7 H of 10, when there is a Reference with edge4 H and value7 S, a Forest with edge4 J and value7 I, a Link with vtx1 J, key5 I and key10 S, but not a Center with edge4 S and a value7 of 40."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of value7 H of Individual with edge4 S, with value7 H is equal to 10, such that there is Reference with edge4 H, with value7 S, whenever there is a Forest with edge4 J, with value7 I, whenever there is a Link with vtx1 J, with key5 I, with key10 S, whenever there is not a Center with edge4 S, with value7 equal to 40.",
            "NL": "No individual with an edge4 S and a value7 H of 10 is allowed; however, if there is a Reference with an edge4 H, a value7 S, a Forest with an edge4 J, a value7 I, a Link with a vtx1 J, a key5 I, and a key10 S, then there can be no Center with an edge4 S and a value7 equal to 40."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of value7 H of Individual with edge4 S, with value7 H is equal to 10, such that there is Reference with edge4 H, with value7 S, whenever there is a Forest with edge4 J, with value7 I, whenever there is a Link with vtx1 J, with key5 I, with key10 S, whenever there is not a Center with edge4 S, with value7 equal to 40.",
            "NL": "It is not allowed for an Individual with edge4 S and value7 H to be equal to 10, unless there is a Reference with edge4 H and value7 S, a Forest with edge4 J and value7 I, a Link with vtx1 J, key5 I, and key10 S, and no Center with edge4 S and value7 of 40."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of value7 H of Individual with edge4 S, with value7 H is equal to 10, such that there is Reference with edge4 H, with value7 S, whenever there is a Forest with edge4 J, with value7 I, whenever there is a Link with vtx1 J, with key5 I, with key10 S, whenever there is not a Center with edge4 S, with value7 equal to 40.",
            "NL": "It is forbidden for any Individual with edge4 S and value7 H to be equal to 10, except when there is a Reference with edge4 H and value7 S, a Forest with edge4 J and value7 I, a Link with vtx1 J, key5 I and key10 S, and no Center with edge4 S and value7 of 40."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of value7 H of Walk with edge3 X, with value7 H is different from 1, whenever there is a edge3 X. ",
            "NL": "The number of value7 Hs in a cycle with an edge3 X must always be 1, regardless of the number of edge3 Xs present."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of value7 H of Walk with edge3 X, with value7 H is different from 1, whenever there is a edge3 X. ",
            "NL": "When an edge3 X is present in the cycle, the number of value7 H of Walk must not be different from 1."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of value7 H of Walk with edge3 X, with value7 H is different from 1, whenever there is a edge3 X. ",
            "NL": "When there is an edge3 X in the cycle, the amount of value7 H of Walk with edge3 X must always remain at 1."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of value7 H of Walk with edge3 X, with value7 H is different from 1, whenever there is a edge3 X. ",
            "NL": "The amount of value7 H that can be used in a cycle with edge3 X must always be 1, and cannot be any other number."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of value7 H of Walk with edge3 X, with value7 H is different from 1, whenever there is a edge3 X. ",
            "NL": "It is not allowed for the number of Walk with edge3 X and value7 H to be anything other than 1 if an edge3 X is present in the cycle."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of value9 G of Dyed with id5 P, with value9 G is equal to 1, whenever there is a NonSubsequent P.",
            "NL": "Irrespective of the Dyed id5 P, there must be more than one Dyed with value9 G whenever there is a NonSubsequent P, no matter what."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of value9 G of Dyed with id5 P, with value9 G is equal to 1, whenever there is a NonSubsequent P.",
            "NL": "No matter the Dyed id5 P, the number of Dyed with value9 G must always be more than 1 each time there is a NonSubsequent P."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of value9 G of Dyed with id5 P, with value9 G is equal to 1, whenever there is a NonSubsequent P.",
            "NL": "No matter the Dyed id5 P, the amount of Dyed with value9 G must always be more than 1 when there is a NonSubsequent P present."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of value9 G of Dyed with id5 P, with value9 G is equal to 1, whenever there is a NonSubsequent P.",
            "NL": "No matter the Dyed id5 P, the amount of Dyed with value9 G must be more than 1 when there is a NonSubsequent P present, regardless of the value9 G."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of value9 G of Dyed with id5 P, with value9 G is equal to 1, whenever there is a NonSubsequent P.",
            "NL": "Regardless of the Dyed id5 P, the amount of Dyed with value9 G must be more than 1 whenever there is a NonSubsequent P present."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of value9 G of Triad with id3 Q, with value9 G is different from 1, whenever there is a id3 Q. ",
            "NL": "When there is an id3 Q in the cycle, it is not allowed for the amount of value9 G of Triad to be anything other than 1."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of value9 G of Triad with id3 Q, with value9 G is different from 1, whenever there is a id3 Q. ",
            "NL": "It is not allowed for the value9 G of Triad with id3 Q to be anything other than 1 when it is in the cycle."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of value9 G of Triad with id3 Q, with value9 G is different from 1, whenever there is a id3 Q. ",
            "NL": "Whenever an id3 Q is present in the cycle, it is forbidden for the number of value9 G of Triad to be anything other than 1."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of value9 G of Triad with id3 Q, with value9 G is different from 1, whenever there is a id3 Q. ",
            "NL": "If there is an id3 Q in the cycle, it is not allowed for the amount of value9 G of Triad to be anything other than 1."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of value9 G of Triad with id3 Q, with value9 G is different from 1, whenever there is a id3 Q. ",
            "NL": "The value9 G of any Triad with id3 Q must remain at 1, regardless of the cycle in which it is found."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of value9 P of Below_Threshold with value5 K, with value9 P is different from 1, whenever there is a value5 K. ",
            "NL": "It is not allowed for the amount of value9 P Below_Threshold with value5 K and value9 P to be anything other than 1 when a value5 K is present in the cycle."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of value9 P of Below_Threshold with value5 K, with value9 P is different from 1, whenever there is a value5 K. ",
            "NL": "It is not allowed for the amount of value9 P with value5 K and value9 P to be anything other than 1 when a value5 K is present in the cycle."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of value9 P of Below_Threshold with value5 K, with value9 P is different from 1, whenever there is a value5 K. ",
            "NL": "It is not allowed for the amount of value9 P to be different than 1 when there is a value5 K in the cycle, no matter if it is Below_Threshold or value5 K."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of value9 P of Below_Threshold with value5 K, with value9 P is different from 1, whenever there is a value5 K. ",
            "NL": "The amount of value9 P with value5 K and value9 P must be one at all times when value5 K is present in the cycle, and cannot be any other number."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of value9 P of Below_Threshold with value5 K, with value9 P is different from 1, whenever there is a value5 K. ",
            "NL": "The number of value9 P of Below_Threshold with value5 K and value9 P must always be 1 whenever there is a value5 K in the cycle, and this is not allowed to be changed."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of value9 Q of Graph with value9 Q, with node4 Y is different from 1, whenever there is a value9 Y.",
            "NL": "It is not allowed for the number of value9 Q to be anything other than 1 when there is value9 Y present in the cycle on a Graph with value9 Q and value9 Y."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of value9 Q of Graph with value9 Q, with node4 Y is different from 1, whenever there is a value9 Y.",
            "NL": "Whenever there is value9 Y in the cycle, it is not allowed for the number of value9 Q in the Graph to deviate from 1."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of value9 Q of Graph with value9 Q, with node4 Y is different from 1, whenever there is a value9 Y.",
            "NL": "The number of times value9 Q appears in a cycle with both value9 Q and value9 Y must always be 1 if value9 Y is present."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of value9 Q of Graph with value9 Q, with node4 Y is different from 1, whenever there is a value9 Y.",
            "NL": "The amount of value9 Q in a cycle containing value9 Y must always be equal to 1."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of value9 Q of Graph with value9 Q, with node4 Y is different from 1, whenever there is a value9 Y.",
            "NL": "It is not allowed for the occurrence of value9 Q to differ from 1 in any cycle that contains value9 Y."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of vtx J of Selected_Color with edge2 C, with vtx J is equal to 37, such that there is Connected with edge2 J, with vtx C, whenever there is a Simple_Graph with edge2 L, with vtx Q, whenever there is a Size with edge L, with node5 Q, with vtx4 C, whenever there is not a Clique with edge2 C, with vtx equal to 16.",
            "NL": "It is forbidden for vtx J of Selected_Color with edge2 C to be equal to 37 when Connected with edge2 J, Simple_Graph with edge2 L, and Size with edge L, node5 Q, and vtx4 C, are not a Clique with edge2 C and vtx equal to 16."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of vtx J of Selected_Color with edge2 C, with vtx J is equal to 37, such that there is Connected with edge2 J, with vtx C, whenever there is a Simple_Graph with edge2 L, with vtx Q, whenever there is a Size with edge L, with node5 Q, with vtx4 C, whenever there is not a Clique with edge2 C, with vtx equal to 16.",
            "NL": "It is not allowed for the number of vertices, J, of Selected_Color connected to edge2 C, to be 37, such that there is a Simple_Graph connected to edge2 J, with vertex Q, that has a Size connected to edge L, with node5 Q, with vtx4 C, unless there is a Clique connected to edge2 C, with a number of vertices equal to 16."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of vtx J of Selected_Color with edge2 C, with vtx J is equal to 37, such that there is Connected with edge2 J, with vtx C, whenever there is a Simple_Graph with edge2 L, with vtx Q, whenever there is a Size with edge L, with node5 Q, with vtx4 C, whenever there is not a Clique with edge2 C, with vtx equal to 16.",
            "NL": "The number of vtx J of Selected_Color with edge2 C cannot be equal to 37, otherwise there will not be a Connected with edge2 J, a Simple_Graph with edge2 L, a Size with edge L, node5 Q, vtx4 C, and a Clique with edge2 C, with vtx equal to 16."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of vtx J of Selected_Color with edge2 C, with vtx J is equal to 37, such that there is Connected with edge2 J, with vtx C, whenever there is a Simple_Graph with edge2 L, with vtx Q, whenever there is a Size with edge L, with node5 Q, with vtx4 C, whenever there is not a Clique with edge2 C, with vtx equal to 16.",
            "NL": "It is not allowed for the number of vertices (vtx) J of Selected_Color, connected by edge2 C, to be equal to 37, such that there is not a Simple_Graph, with edge2 L connected to vtx Q, with a Size of node5 Q and vtx4 C, and without a Clique, connected by edge2 C, with a vtx of 16."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of vtx J of Selected_Color with edge2 C, with vtx J is equal to 37, such that there is Connected with edge2 J, with vtx C, whenever there is a Simple_Graph with edge2 L, with vtx Q, whenever there is a Size with edge L, with node5 Q, with vtx4 C, whenever there is not a Clique with edge2 C, with vtx equal to 16.",
            "NL": "It is forbidden for Selected_Color vtx J, Connected edge2 J, Simple_Graph edge2 L, Size edge L, and node5 Q with vtx4 C to have a total of 37 when the Clique edge2 C and vtx is not equal to 16."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of vtx1 M of Subordinate with vtx5 F, with vtx1 M is equal to 1, whenever there is an Outpath F.",
            "NL": "No matter how many Subordinate vtx5 F there are, the number of Subordinate with vtx1 M must be more than 1 whenever an Outpath F is present."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of vtx1 M of Subordinate with vtx5 F, with vtx1 M is equal to 1, whenever there is an Outpath F.",
            "NL": "Regardless of the Subordinate vtx5 F, the amount of Subordinate with vtx1 M must always be more than 1 whenever there is an Outpath F."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of vtx1 M of Subordinate with vtx5 F, with vtx1 M is equal to 1, whenever there is an Outpath F.",
            "NL": "No matter what the Subordinate vtx5 F and vtx1 M are, the quantity of Subordinate with vtx1 M must always be more than 1 when there is an Outpath F."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of vtx1 M of Subordinate with vtx5 F, with vtx1 M is equal to 1, whenever there is an Outpath F.",
            "NL": "Regardless of the Subordinate vtx5 F, the amount of Subordinate with vtx1 M must always be more than 1 whenever an Outpath F occurs."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of vtx1 M of Subordinate with vtx5 F, with vtx1 M is equal to 1, whenever there is an Outpath F.",
            "NL": "No matter what the Subordinate vtx5 F and vtx1 M is, the quantity of Subordinate with vtx1 M must be more than 1 whenever there is an Outpath F."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of vtx1 U of Enumeration with vtx5 U, with vtx1 Z is equal to 0, whenever there is a Subsequently Z.",
            "NL": "The Enumeration with vtx5 U will have a total of 0 vtx1 U, provided that there is a Subsequently Z."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of vtx1 U of Enumeration with vtx5 U, with vtx1 Z is equal to 0, whenever there is a Subsequently Z.",
            "NL": "The number of vtx1 U of the Enumeration with vtx5 U is 0, provided that a Subsequently Z exists."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of vtx1 U of Enumeration with vtx5 U, with vtx1 Z is equal to 0, whenever there is a Subsequently Z.",
            "NL": "The Enumeration with vtx5 U will have 0 vtx1 U as long as there is a Subsequently Z."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of vtx1 U of Enumeration with vtx5 U, with vtx1 Z is equal to 0, whenever there is a Subsequently Z.",
            "NL": "The amount of vtx1 U in the Enumeration when vtx5 U is present will always be 0, so long as a Subsequently Z exists."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of vtx1 U of Enumeration with vtx5 U, with vtx1 Z is equal to 0, whenever there is a Subsequently Z.",
            "NL": "The Enumeration with vtx5 U has a total of 0 vtx1 U if there is a Subsequently Z."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of vtx10 N of NonActive with edge G, with vtx10 N is equal to 1, whenever there is a Walk G.",
            "NL": "For every occurrence of Walk G, the NonActive with vtx10 N must be more than 1, regardless of the NonActive edge G and vtx10 N."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of vtx10 N of NonActive with edge G, with vtx10 N is equal to 1, whenever there is a Walk G.",
            "NL": "No matter the NonActive edge G and vtx10 N, the amount of NonActive with vtx10 N must be more than 1 every time there is a Walk G."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of vtx10 N of NonActive with edge G, with vtx10 N is equal to 1, whenever there is a Walk G.",
            "NL": "No matter what the NonActive edge G and vtx10 N are, the quantity of NonActive with vtx10 N must be more than 1 each time there is a Walk G."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of vtx10 N of NonActive with edge G, with vtx10 N is equal to 1, whenever there is a Walk G.",
            "NL": "No matter the NonActive edge G and vtx10 N, there must be more than 1 NonActive with vtx10 N whenever there is a Walk G."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of vtx10 N of NonActive with edge G, with vtx10 N is equal to 1, whenever there is a Walk G.",
            "NL": "No matter the NonActive edge G and vtx10 N, the number of NonActive with vtx10 N must be more than 1 when there is a Walk G."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of vtx2 Q of Load with node8 F, with vtx2 Q is equal to 1, whenever there is a Allocate F.",
            "NL": "No matter what the Load node8 F is, the Load with vtx2 Q must be more than 1 whenever there is an Allocate F."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of vtx2 Q of Load with node8 F, with vtx2 Q is equal to 1, whenever there is a Allocate F.",
            "NL": "No matter the Load node8 F, when Allocate F occurs, the vtx2 Q count must be higher than 1."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of vtx2 Q of Load with node8 F, with vtx2 Q is equal to 1, whenever there is a Allocate F.",
            "NL": "No matter how many Load nodes8 F there are, when Allocate F is present, the amount of Load with vtx2 Q must be more than 1."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of vtx2 Q of Load with node8 F, with vtx2 Q is equal to 1, whenever there is a Allocate F.",
            "NL": "No matter what the Load node8 F is, when there is an Allocate F, the amount of Load with vtx2 Q must be more than 1."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of vtx2 Q of Load with node8 F, with vtx2 Q is equal to 1, whenever there is a Allocate F.",
            "NL": "Regardless of the Load node8 F, the amount of Load with vtx2 Q must be more than 1 whenever an Allocate F occurs."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of vtx2 R of Achievement with edge3 B, with vtx2 R is equal to 1, such that there is Root with edge3 R, with vtx2 B, whenever there is a Begin with edge3 Z, with vtx2 Y, whenever there is a Incorporates with field Z, with key4 Y, with edge1 B, whenever there is not a Reached with edge3 B, with vtx2 equal to 23.",
            "NL": "No more than one vtx2 R of Achievement with edge3 B is allowed, with a Root with edge3 R and vtx2 B, a Begin with edge3 Z and vtx2 Y, and an Incorporates with field Z, key4 Y and edge1 B; however, if there is not a Reached with edge3 B and vtx2 equal to 23, this is not applicable."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of vtx2 R of Achievement with edge3 B, with vtx2 R is equal to 1, such that there is Root with edge3 R, with vtx2 B, whenever there is a Begin with edge3 Z, with vtx2 Y, whenever there is a Incorporates with field Z, with key4 Y, with edge1 B, whenever there is not a Reached with edge3 B, with vtx2 equal to 23.",
            "NL": "It is not allowed for the quantity of vtx2 R of Achievement with edge3 B, with vtx2 R, to be equal to 1, provided that a Root with edge3 R, with vtx2 B, a Begin with edge3 Z, and vtx2 Y exist, and an Incorporates with field Z, key4 Y, edge1 B is present; so long as there is no Reached with edge3 B, with vtx2 equal to 23."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of vtx2 R of Achievement with edge3 B, with vtx2 R is equal to 1, such that there is Root with edge3 R, with vtx2 B, whenever there is a Begin with edge3 Z, with vtx2 Y, whenever there is a Incorporates with field Z, with key4 Y, with edge1 B, whenever there is not a Reached with edge3 B, with vtx2 equal to 23.",
            "NL": "It is forbidden for the Achievement with edge3 B, vtx2 R to be equal to 1, in which case there must be a Root with edge3 R, vtx2 B, a Begin with edge3 Z, vtx2 Y, and an Incorporates with field Z, key4 Y, edge1 B; unless there is a Reached with edge3 B, vtx2 equal to 23."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of vtx2 R of Achievement with edge3 B, with vtx2 R is equal to 1, such that there is Root with edge3 R, with vtx2 B, whenever there is a Begin with edge3 Z, with vtx2 Y, whenever there is a Incorporates with field Z, with key4 Y, with edge1 B, whenever there is not a Reached with edge3 B, with vtx2 equal to 23.",
            "NL": "It is not allowed for the number of vertices (vtx2) with edge3 B and vtx2 R to be equal to 1, so that there is a Root with edge3 R, a Begin with edge3 Z, and an Incorporates with field Z, key4 Y, and edge1 B when there is no Reached with edge3 B and vtx2 equal to 23."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of vtx2 R of Achievement with edge3 B, with vtx2 R is equal to 1, such that there is Root with edge3 R, with vtx2 B, whenever there is a Begin with edge3 Z, with vtx2 Y, whenever there is a Incorporates with field Z, with key4 Y, with edge1 B, whenever there is not a Reached with edge3 B, with vtx2 equal to 23.",
            "NL": "The configuration of vtx2 R of Achievement with edge3 B must not be equal to 1, provided that there is a Root with edge3 R, vtx2 B, Begin with edge3 Z, vtx2 Y, and Incorporates with field Z, key4 Y, and edge1 B, but if there is not a Reached with edge3 B and vtx2 equal to 23, then the requirement does not apply."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of vtx4 J of Dendrogram with key7 I, with vtx4 J is equal to 45, such that there is IngoingPath with key7 J, with vtx4 I, whenever there is a NonForemost with key7 W, with vtx4 Q, whenever there is a NonGroup with id10 W, with node1 Q, with value3 I, whenever there is not a Divide with key7 I, with vtx4 equal to 4.",
            "NL": "It is forbidden that the quantity of vtx4 J for Dendrogram with key7 I is set to 45, if there is an IngoingPath with key7 J and vtx4 I, a NonForemost with key7 W and vtx4 Q, a NonGroup with id10 W, node1 Q, and value3 I, and no Divide with key7 I and vtx4 equal to 4."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of vtx4 J of Dendrogram with key7 I, with vtx4 J is equal to 45, such that there is IngoingPath with key7 J, with vtx4 I, whenever there is a NonForemost with key7 W, with vtx4 Q, whenever there is a NonGroup with id10 W, with node1 Q, with value3 I, whenever there is not a Divide with key7 I, with vtx4 equal to 4.",
            "NL": "The number of vtx4 J of Dendrogram with key7 I must not be equal to 45, and if there is an IngoingPath with key7 J, vtx4 I, a NonForemost with key7 W, vtx4 Q, and a NonGroup with id10 W, node1 Q, and value3 I, then there can not be a Divide with key7 I and vtx4 equal to 4."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of vtx4 J of Dendrogram with key7 I, with vtx4 J is equal to 45, such that there is IngoingPath with key7 J, with vtx4 I, whenever there is a NonForemost with key7 W, with vtx4 Q, whenever there is a NonGroup with id10 W, with node1 Q, with value3 I, whenever there is not a Divide with key7 I, with vtx4 equal to 4.",
            "NL": "It is prohibited for the number of vtx4 J of Dendrogram with key7 I to be equal to 45 if there is an IngoingPath with key7 J, a NonForemost with key7 W, a NonGroup with id10 W, node1 Q, and value3 I, and no Divide with key7 I and vtx4 equal to 4."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of vtx4 J of Dendrogram with key7 I, with vtx4 J is equal to 45, such that there is IngoingPath with key7 J, with vtx4 I, whenever there is a NonForemost with key7 W, with vtx4 Q, whenever there is a NonGroup with id10 W, with node1 Q, with value3 I, whenever there is not a Divide with key7 I, with vtx4 equal to 4.",
            "NL": "It is not allowed that the number of vtx4 J associated with Dendrogram key7 I is 45, while there is an IngoingPath with key7 J and vtx4 I, a NonForemost with key7 W and vtx4 Q, and a NonGroup with id10 W, node1 Q, and value3 I, unless there is a Divide with key7 I and vtx4 of 4."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of vtx4 J of Dendrogram with key7 I, with vtx4 J is equal to 45, such that there is IngoingPath with key7 J, with vtx4 I, whenever there is a NonForemost with key7 W, with vtx4 Q, whenever there is a NonGroup with id10 W, with node1 Q, with value3 I, whenever there is not a Divide with key7 I, with vtx4 equal to 4.",
            "NL": "It is forbidden for the number of vtx4 J of Dendrogram with key7 I to be equal to 45, provided that there is an IngoingPath with key7 J, vtx4 I, a NonForemost with key7 W, vtx4 Q, a NonGroup with id10 W, node1 Q, value3 I, and no Divide with key7 I and vtx4 equaling 4."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of vtx4 Q of Atom with id7 Q, with vtx4 T is equal to 0, whenever there is a NonInitial T.",
            "NL": "The number of vtx4 Q of the Atom with id7 Q will always be 0, provided there is a NonInitial T present."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of vtx4 Q of Atom with id7 Q, with vtx4 T is equal to 0, whenever there is a NonInitial T.",
            "NL": "For the Atom with id7, the number of vtx4 Q is equal to 0 provided that there is a NonInitial T."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of vtx4 Q of Atom with id7 Q, with vtx4 T is equal to 0, whenever there is a NonInitial T.",
            "NL": "The Atom with id7 Q will have 0 vtx4 Q if there is a NonInitial T present."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of vtx4 Q of Atom with id7 Q, with vtx4 T is equal to 0, whenever there is a NonInitial T.",
            "NL": "The Atom with id7 Q will have 0 vtx4 Q as long as there is a NonInitial T."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of vtx4 Q of Atom with id7 Q, with vtx4 T is equal to 0, whenever there is a NonInitial T.",
            "NL": "The Atom with id7 Q has 0 vtx4 Q as long as there is a NonInitial T."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of vtx5 B of Degree_Sequence with vtx5 B, with id3 Y is different from 1, whenever there is a vtx5 Y.",
            "NL": "It is not allowed for the quantity of vtx5 B in the Degree_Sequence to be anything other than 1 when there is vtx5 Y in the cycle."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of vtx5 B of Degree_Sequence with vtx5 B, with id3 Y is different from 1, whenever there is a vtx5 Y.",
            "NL": "It is forbidden for the count of vtx5 B in a Degree_Sequence to be anything other than 1 when vtx5 Y is present in the cycle."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of vtx5 B of Degree_Sequence with vtx5 B, with id3 Y is different from 1, whenever there is a vtx5 Y.",
            "NL": "Whenever there is vtx5 Y in the cycle, it is not allowed for the number of vtx5 B of Degree_Sequence with vtx5 B and vtx5 Y to be anything other than 1."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of vtx5 B of Degree_Sequence with vtx5 B, with id3 Y is different from 1, whenever there is a vtx5 Y.",
            "NL": "If there is a vtx5 Y in the cycle, it is not allowed for the number of vtx5 B of Degree_Sequence with vtx5 B and vtx5 Y to be anything other than 1."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of vtx5 B of Degree_Sequence with vtx5 B, with id3 Y is different from 1, whenever there is a vtx5 Y.",
            "NL": "If there is a vtx5 Y in the cycle, it is not allowed for the count of vtx5 B in the Degree_Sequence to be anything other than 1."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of vtx5 S of Partition with value7 S, with vtx5 H is equal to 0, whenever there is a Cycle_Basis H.",
            "NL": "For any Cycle_Basis H, the quantity of vtx5 S associated with the Partition with value7 S is zero."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of vtx5 S of Partition with value7 S, with vtx5 H is equal to 0, whenever there is a Cycle_Basis H.",
            "NL": "The Partition with value7 S has 0 vtx5 S, provided that a Cycle_Basis H exists."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of vtx5 S of Partition with value7 S, with vtx5 H is equal to 0, whenever there is a Cycle_Basis H.",
            "NL": "The number of vtx5 S of the Partition with value7 S is equal to 0, provided that Cycle_Basis H exists."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of vtx5 S of Partition with value7 S, with vtx5 H is equal to 0, whenever there is a Cycle_Basis H.",
            "NL": "The Partition with value7 S will have 0 vtx5 S so long as there is a Cycle_Basis H."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of vtx5 S of Partition with value7 S, with vtx5 H is equal to 0, whenever there is a Cycle_Basis H.",
            "NL": "For the Partition with value7 S, the number of vtx5 S is 0 provided that Cycle_Basis H is present."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of vtx9 V of Trio with edge7 D, with vtx9 V is equal to 1, whenever there is a Incoming_Level D.",
            "NL": "Irrespective of the Trio edge7 D and vtx9 V, the quantity of Trio with vtx9 V must be more than 1 whenever there is an Incoming_Level D."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of vtx9 V of Trio with edge7 D, with vtx9 V is equal to 1, whenever there is a Incoming_Level D.",
            "NL": "No matter the Trio edge7 D and vtx9 V, each Incoming_Level D must have a minimum of one Trio with vtx9 V."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of vtx9 V of Trio with edge7 D, with vtx9 V is equal to 1, whenever there is a Incoming_Level D.",
            "NL": "No matter the Trio edge7 D and vtx9 V, the quantity of Trio with vtx9 V must be more than 1 when there is an Incoming_Level D."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of vtx9 V of Trio with edge7 D, with vtx9 V is equal to 1, whenever there is a Incoming_Level D.",
            "NL": "No matter the amount of Trio edge7 D and vtx9 V, a minimum of one has to be present each time an Incoming_Level D is imminent."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that the number of vtx9 V of Trio with edge7 D, with vtx9 V is equal to 1, whenever there is a Incoming_Level D.",
            "NL": "No matter the Trio edge7 D and vtx9 V, the amount of Trios with vtx9 V must always be more than 1 when there is an Incoming_Level D."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a active with key V, whenever there is active with key W, whenever there is not a trivial with value V, whenever there is not a trivial with value W different from V, whenever there is a mvlabel with field1 W, with field2 V, with field3 S, whenever there is not a minfl with field1 W, with field2 V, with field3 S.",
            "NL": "It is prohibited to have an active with key V, an active with key W, a trivial with value V, a trivial with value W, a mvlabel with field1 W, field2 V, field3 S, where W does not equal V, unless there is a minfl with field1 W, field2 V, field3 S."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a active with key V, whenever there is active with key W, whenever there is not a trivial with value V, whenever there is not a trivial with value W different from V, whenever there is a mvlabel with field1 W, with field2 V, with field3 S, whenever there is not a minfl with field1 W, with field2 V, with field3 S.",
            "NL": "It is forbidden for there to be an active key V, an active key W, a trivial value V, a trivial value W, a mvlabel with field1 W, field2 V, and field3 S, provided that W is not equal to V, and there is not a minfl with field1 W, field2 V, and field3 S."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a active with key V, whenever there is active with key W, whenever there is not a trivial with value V, whenever there is not a trivial with value W different from V, whenever there is a mvlabel with field1 W, with field2 V, with field3 S, whenever there is not a minfl with field1 W, with field2 V, with field3 S.",
            "NL": "It is not allowed to have an active with key V, an active with key W, a trivial with value V, a trivial with value W, a mvlabel with field1 W, field2 V, and field3 S, when W is not equal to V, unless there is a minfl with field1 W, field2 V, and field3 S."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a active with key V, whenever there is active with key W, whenever there is not a trivial with value V, whenever there is not a trivial with value W different from V, whenever there is a mvlabel with field1 W, with field2 V, with field3 S, whenever there is not a minfl with field1 W, with field2 V, with field3 S.",
            "NL": "No active with key V or W, no trivial with values V or W, and no minfl with field1 W, field2 V, and field3 S is allowed, unless W is not equal to V and a mvlabel with field1 W, field2 V, and field3 S is present."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a active with key V, whenever there is active with key W, whenever there is not a trivial with value V, whenever there is not a trivial with value W different from V, whenever there is a mvlabel with field1 W, with field2 V, with field3 S, whenever there is not a minfl with field1 W, with field2 V, with field3 S.",
            "NL": "It is prohibited to have an active with key V, an active with key W, a trivial with value V, a trivial with value W, a mvlabel with field1 W, field2 V, and field3 S, where W is not equal to V, if there is not a minfl with field1 W, field2 V, and field3 S."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a active with key V, whenever there is not a trivial with value V, whenever there is not an obs_vlabel with id1 V, with id2 P, whenever there is not an obs_vlabel with id1 V, with id2 M, whenever there is not a aedge with value V.",
            "NL": "It is not allowed for an active with key V to exist if there is no trivial with value V, no obs_vlabel with id1 V and id2 P, no obs_vlabel with id1 V and id2 M, or no aedge with value V."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a active with key V, whenever there is not a trivial with value V, whenever there is not an obs_vlabel with id1 V, with id2 P, whenever there is not an obs_vlabel with id1 V, with id2 M, whenever there is not a aedge with value V.",
            "NL": "When there is not an active with key V, a trivial with value V, an obs_vlabel with id1 V and id2 P, an obs_vlabel with id1 V and id2 M, or an aedge with value V, it is prohibited."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a active with key V, whenever there is not a trivial with value V, whenever there is not an obs_vlabel with id1 V, with id2 P, whenever there is not an obs_vlabel with id1 V, with id2 M, whenever there is not a aedge with value V.",
            "NL": "It is forbidden to have an active with key V when there is no trivial with value V, no obs_vlabel with id1 V and id2 P, no obs_vlabel with id1 V and id2 M, and no aedge with value V."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a active with key V, whenever there is not a trivial with value V, whenever there is not an obs_vlabel with id1 V, with id2 P, whenever there is not an obs_vlabel with id1 V, with id2 M, whenever there is not a aedge with value V.",
            "NL": "No active with key V is allowed unless there is a trivial with value V, an obs_vlabel with id1 V and id2 P, an obs_vlabel with id1 V and id2 M, and an aedge with value V."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a active with key V, whenever there is not a trivial with value V, whenever there is not an obs_vlabel with id1 V, with id2 P, whenever there is not an obs_vlabel with id1 V, with id2 M, whenever there is not a aedge with value V.",
            "NL": "Active with key V is not allowed if there is no trivial with value V, no obs_vlabel with id1 V and id2 P, no obs_vlabel with id1 V and id2 M, and no aedge with value V."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Begin with vtx L, whenever there is not a Launch with value10 L, whenever there is a Begin with vtx Z, whenever there is not a Launch with value10 Z, whenever there is not a Count with node6 L, with vtx Z. ",
            "NL": "If there is no Launch with value10 L, then there must be a Begin with the vtx L; likewise, if there is no Launch with value10 Z, then there must be a Begin with the vtx Z. Furthermore, if there is not a Count with node6 L, then there must not be a Count with vtx Z."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Begin with vtx L, whenever there is not a Launch with value10 L, whenever there is a Begin with vtx Z, whenever there is not a Launch with value10 Z, whenever there is not a Count with node6 L, with vtx Z. ",
            "NL": "If there is no Launch with value10 L, there must be a Begin with the vtx L; if there is no Launch with value10 Z, there must be a Begin with the vtx Z; if there is not a Count with node6 L, there must not be a Count with vtx Z."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Begin with vtx L, whenever there is not a Launch with value10 L, whenever there is a Begin with vtx Z, whenever there is not a Launch with value10 Z, whenever there is not a Count with node6 L, with vtx Z. ",
            "NL": "If there is no Launch with value10 L, then Begin with the vtx L; likewise, if there is no Launch with value10 Z, then Begin with the vtx Z; and if there is not a Count with node6 L or a Count with vtx Z, then there is a prohibition."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Begin with vtx L, whenever there is not a Launch with value10 L, whenever there is a Begin with vtx Z, whenever there is not a Launch with value10 Z, whenever there is not a Count with node6 L, with vtx Z. ",
            "NL": "If there is no Launch with value10 L, the Begin with the vtx L is prohibited, and if there is no Launch with value10 Z, the Begin with the vtx Z is prohibited. Additionally, if there is not a Count with node6 L, the Begin with the vtx L is not allowed, and if there is not a Count with vtx Z, the Begin with the vtx Z is not allowed."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Begin with vtx L, whenever there is not a Launch with value10 L, whenever there is a Begin with vtx Z, whenever there is not a Launch with value10 Z, whenever there is not a Count with node6 L, with vtx Z. ",
            "NL": "If there is no Launch with a value of 10 associated with vertex L, then there is no Begin associated with vertex L; similarly, if there is no Launch with a value of 10 associated with vertex Z, then there is no Begin associated with vertex Z. Additionally, if there is no Count associated with node 6, then there is no Count associated with vertex Z."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Child with vtx10 M, whenever there is not a Controlling with id8 M, whenever there is a Child with vtx10 B, whenever there is not a Controlling with id8 B, whenever there is not a Painted with value10 M, with vtx10 B. ",
            "NL": "It is forbidden for a Child to have a vtx10 M if there is no Controlling with id8 M, and it is also prohibited for a Child to have a vtx10 B if there is no Controlling with id8 B, as well as for a Painted with value10 M and a Painted with vtx10 B."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Child with vtx10 M, whenever there is not a Controlling with id8 M, whenever there is a Child with vtx10 B, whenever there is not a Controlling with id8 B, whenever there is not a Painted with value10 M, with vtx10 B. ",
            "NL": "It is prohibited to have a Child with VTX10 M if there is no Control with ID8 M, and it is forbidden to have a Child with VTX10 B if there is no Control with ID8 B. Additionally, it is not allowed to have a Painted with value10 M or a Painted with VTX10 B."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Child with vtx10 M, whenever there is not a Controlling with id8 M, whenever there is a Child with vtx10 B, whenever there is not a Controlling with id8 B, whenever there is not a Painted with value10 M, with vtx10 B. ",
            "NL": "When there is a Child with a vtx10 M and no Controlling with an id8 M, or a Child with a vtx10 B and no Controlling with an id8 B, but no Painted with a value10 M or vtx10 B, there is a prohibition."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Child with vtx10 M, whenever there is not a Controlling with id8 M, whenever there is a Child with vtx10 B, whenever there is not a Controlling with id8 B, whenever there is not a Painted with value10 M, with vtx10 B. ",
            "NL": "There is a rule that when there is a Child with vtx10 M and no Controlling with id8 M, or a Child with vtx10 B and no Controlling with id8 B, or no Painted with value10 M and no Painted with vtx10 B, they must not be present together."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Child with vtx10 M, whenever there is not a Controlling with id8 M, whenever there is a Child with vtx10 B, whenever there is not a Controlling with id8 B, whenever there is not a Painted with value10 M, with vtx10 B. ",
            "NL": "If there is a Child with vtx10 M, Controlling with id8 M must be present; likewise, if there is a Child with vtx10 B, Controlling with id8 B must be present. Additionally, Painted with value10 M and Painted with vtx10 B must not be present."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Contains with id1 Y, with edge5 K, whenever there is a Subsequent with id1 Y, with edge5 C at most K, whenever there is a Start with value L at most C.",
            "NL": "Whenever there is a Start with value L at most C and a Contains with id1 Y and edge5 K, it is prohibited to have a Subsequent with id1 Y and edge5 C that is less than K."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Contains with id1 Y, with edge5 K, whenever there is a Subsequent with id1 Y, with edge5 C at most K, whenever there is a Start with value L at most C.",
            "NL": "Whenever there is a Start with value L at most C, and a Contains with id1 Y, and edge5 K, it is prohibited for there to be a Subsequent with id1 Y, and edge5 C that is lesser than K."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Contains with id1 Y, with edge5 K, whenever there is a Subsequent with id1 Y, with edge5 C at most K, whenever there is a Start with value L at most C.",
            "NL": "Whenever there is a Start with value L at most C and a Contains with id1 Y and edge5 K, it is prohibited for there to be a Subsequent with id1 Y and edge5 C less than K."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Contains with id1 Y, with edge5 K, whenever there is a Subsequent with id1 Y, with edge5 C at most K, whenever there is a Start with value L at most C.",
            "NL": "It is forbidden for there to be a Subsequent with id1 Y, with edge5 C lower than K, if there is a Start with value L no higher than C, and a Contains with id1 Y, with edge5 K."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Contains with id1 Y, with edge5 K, whenever there is a Subsequent with id1 Y, with edge5 C at most K, whenever there is a Start with value L at most C.",
            "NL": "Whenever there is a Start with value L at most C and a Contains with id1 Y and edge5 K, it is prohibited for there to be a Subsequent with id1 Y and edge5 C that is less than K."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Data with id W, whenever there is Data with id R, whenever there is not a Initial with vtx5 W, whenever there is not a Initial with vtx5 R different from W, whenever there is an InDegree with field6 R, with value4 W, with field5 G, whenever there is not a Predominant with field6 R, with value4 W, with field5 G. ",
            "NL": "It is forbidden to have a Data with id W, a Data with id R, an Initial with vtx5 W, an Initial with vtx5 R, an InDegree with field6 R, value4 W, and field5 G, if W is not equal to W, and there is no Predominant with field6 R, value4 W, and field5 G."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Data with id W, whenever there is Data with id R, whenever there is not a Initial with vtx5 W, whenever there is not a Initial with vtx5 R different from W, whenever there is an InDegree with field6 R, with value4 W, with field5 G, whenever there is not a Predominant with field6 R, with value4 W, with field5 G. ",
            "NL": "No Data with id W, Data with id R, Initial with vtx5 W, Initial with vtx5 R, InDegree with field6 R, value4 W, and field5 G shall exist, where W does not equal W, unless there is a Predominant with field6 R, value4 W, and field5 G."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Data with id W, whenever there is Data with id R, whenever there is not a Initial with vtx5 W, whenever there is not a Initial with vtx5 R different from W, whenever there is an InDegree with field6 R, with value4 W, with field5 G, whenever there is not a Predominant with field6 R, with value4 W, with field5 G. ",
            "NL": "It is prohibited that there is a Data with id W, a Data with id R, an Initial with vtx5 W, an Initial with vtx5 R, an InDegree with field6 R, value4 W, and field5 G, where W is not equal to R, unless there is a Predominant with field6 R, value4 W, and field5 G."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Data with id W, whenever there is Data with id R, whenever there is not a Initial with vtx5 W, whenever there is not a Initial with vtx5 R different from W, whenever there is an InDegree with field6 R, with value4 W, with field5 G, whenever there is not a Predominant with field6 R, with value4 W, with field5 G. ",
            "NL": "It is forbidden to have a Data with id W, a Data with id R, an Initial with vtx5 W, an Initial with vtx5 R, an InDegree with field6 R, value4 W, and field5 G, where W is not equal to W, unless there is a Predominant with field6 R, value4 W, and field5 G."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Data with id W, whenever there is Data with id R, whenever there is not a Initial with vtx5 W, whenever there is not a Initial with vtx5 R different from W, whenever there is an InDegree with field6 R, with value4 W, with field5 G, whenever there is not a Predominant with field6 R, with value4 W, with field5 G. ",
            "NL": "It is forbidden to have a Data with id W, a Data with id R, an Initial with vtx5 W, an Initial with vtx5 R, an InDegree with field6 R, value4 W, field5 G, when W is not equal to W, and there is no Predominant with field6 R, value4 W, field5 G."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Difference with node3 C, whenever there is not a LessThanExists with id3 C, whenever there is a Difference with node3 T, whenever there is not a LessThanExists with id3 T, whenever there is not a Indication with field C, with node3 T. ",
            "NL": "If there is no LessThanExists with id3 C and a Difference with the node3 C, or no LessThanExists with id3 T and a Difference with the node3 T, and there is no Indication with field C or node3 T, then there is a prohibition."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Difference with node3 C, whenever there is not a LessThanExists with id3 C, whenever there is a Difference with node3 T, whenever there is not a LessThanExists with id3 T, whenever there is not a Indication with field C, with node3 T. ",
            "NL": "If there is no LessThanExists with id3 C and a Difference with node3 T, and no Indication with field C or node3 T, then there is a prohibition in place."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Difference with node3 C, whenever there is not a LessThanExists with id3 C, whenever there is a Difference with node3 T, whenever there is not a LessThanExists with id3 T, whenever there is not a Indication with field C, with node3 T. ",
            "NL": "If there is no LessThanExists with id3 C and a Difference with node3 T, and there is no Indication with field C or node3 T, then there is a prohibition."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Difference with node3 C, whenever there is not a LessThanExists with id3 C, whenever there is a Difference with node3 T, whenever there is not a LessThanExists with id3 T, whenever there is not a Indication with field C, with node3 T. ",
            "NL": "If there is no LessThanExists with id3 C and no Difference with node3 T, and there is no Indication with field C or node3 T, then a prohibition is in place."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Difference with node3 C, whenever there is not a LessThanExists with id3 C, whenever there is a Difference with node3 T, whenever there is not a LessThanExists with id3 T, whenever there is not a Indication with field C, with node3 T. ",
            "NL": "If there is a Difference between node3 C and node3 T, and there is no LessThanExists with id3 C or id3 T, and there is no Indication with field C or node3 T, then there is a prohibition in place."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Dynamic with value10 Q, with field3 K, whenever there is a Launch with value10 Q, with field3 N not after K, whenever there is a Minus with value X not after N.",
            "NL": "Whenever there is a Minus with value X not after N and a Dynamic with value10 Q, with field3 K, it is forbidden to have a Launch with value10 Q, with field3 N less than K."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Dynamic with value10 Q, with field3 K, whenever there is a Launch with value10 Q, with field3 N not after K, whenever there is a Minus with value X not after N.",
            "NL": "Whenever there is a Dynamic with value 10Q and field3 K, it is prohibited to have a Launch with value 10Q and field3 N less than K, unless there is a Minus with value X that is not after N."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Dynamic with value10 Q, with field3 K, whenever there is a Launch with value10 Q, with field3 N not after K, whenever there is a Minus with value X not after N.",
            "NL": "Whenever there is a Dynamic with value 10Q, with field 3K, it is prohibited to have a Launch with value 10Q, with field 3N lower than K, if there is a Minus with value X not after N."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Dynamic with value10 Q, with field3 K, whenever there is a Launch with value10 Q, with field3 N not after K, whenever there is a Minus with value X not after N.",
            "NL": "Whenever there is a Dynamic with value10 Q and field3 K, it is prohibited to have a Launch with value10 Q and field3 N that is lesser than K if there is a Minus with value X not after N."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Dynamic with value10 Q, with field3 K, whenever there is a Launch with value10 Q, with field3 N not after K, whenever there is a Minus with value X not after N.",
            "NL": "It is forbidden to have a Launch of 10 Q with field3 N less than K if there is a Minus of value X not after N and a Dynamic of 10 Q with field3 K."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Embedding with node6 I, whenever there is not a Route with node6 I, whenever there is not a Full with node6 I.",
            "NL": "Whenever there is not a Route or Full with node6 I, a prohibition is in place that an Embedding cannot exist."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Embedding with node6 I, whenever there is not a Route with node6 I, whenever there is not a Full with node6 I.",
            "NL": "When there is no Route or Full involving node6 I, there must not be an Embedding of node6 I."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Embedding with node6 I, whenever there is not a Route with node6 I, whenever there is not a Full with node6 I.",
            "NL": "If there is no Route or Full with node6 I, then no Embedding with node6 I is allowed."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Embedding with node6 I, whenever there is not a Route with node6 I, whenever there is not a Full with node6 I.",
            "NL": "No Embedding should be made with node6 I unless there is a Route and a Full with node6 I present."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Embedding with node6 I, whenever there is not a Route with node6 I, whenever there is not a Full with node6 I.",
            "NL": "If there is no Route or Full with node6 I, then an Embedding must not be present."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Following with field5 E, whenever there is not a Non_Clique with field5 E, whenever there is not a Maximal with field5 E.",
            "NL": "Whenever there is not a Non-Clique or Maximal with Field5 E, there is a prohibition in place."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Following with field5 E, whenever there is not a Non_Clique with field5 E, whenever there is not a Maximal with field5 E.",
            "NL": "Whenever there is not a Non_Clique or a Maximal with field5 E, there is a prohibition in place."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Following with field5 E, whenever there is not a Non_Clique with field5 E, whenever there is not a Maximal with field5 E.",
            "NL": "If there is no Non_Clique or Maximal with field5 E, then a prohibition must be followed."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Following with field5 E, whenever there is not a Non_Clique with field5 E, whenever there is not a Maximal with field5 E.",
            "NL": "Whenever there is not a Non_Clique or a Maximal with field5 E, there is a prohibition that there must be a Following with field5 E."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Following with field5 E, whenever there is not a Non_Clique with field5 E, whenever there is not a Maximal with field5 E.",
            "NL": "If there is no Non_Clique or Maximal with field5 E, a prohibition is in place that requires a Following with field5 E."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Following with node5 X, whenever there is not a Planar with node5 X, whenever there is not a Trio with node5 X.",
            "NL": "If there is not a Planar or Trio with node5 X, it is prohibited to have a Following with node5 X."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Following with node5 X, whenever there is not a Planar with node5 X, whenever there is not a Trio with node5 X.",
            "NL": "When Planar or Trio is not present with node5 X, a prohibition is in effect."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Following with node5 X, whenever there is not a Planar with node5 X, whenever there is not a Trio with node5 X.",
            "NL": "If there is no Planar or Trio with node5 X, there is a prohibition in place."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Following with node5 X, whenever there is not a Planar with node5 X, whenever there is not a Trio with node5 X.",
            "NL": "Whenever there is no Planar or Trio with Node5 X, there is a prohibition in effect."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Following with node5 X, whenever there is not a Planar with node5 X, whenever there is not a Trio with node5 X.",
            "NL": "Whenever there is not a Planar or Trio with node5 X, there is a prohibition in place."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Hint with key5 J, whenever there is not a Level with edge6 J, whenever there is not an Signal with vtx4 J, with field5 A, whenever there is not an Signal with vtx4 J, with field5 P, whenever there is not a Individual with edge6 J.",
            "NL": "It is prohibited to have a Hint with key5 J, if there is no Level with edge6 J, no Signal with vtx4 J, and field5 A, or no Signal with vtx4 J, and field5 P, and no Individual with edge6 J."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Hint with key5 J, whenever there is not a Level with edge6 J, whenever there is not an Signal with vtx4 J, with field5 A, whenever there is not an Signal with vtx4 J, with field5 P, whenever there is not a Individual with edge6 J.",
            "NL": "It is forbidden to have a Hint with key5 J, if there is no Level with edge6 J, and no Signal with vtx4 J, field5 A, and no Signal with vtx4 J, field5 P, if there is no Individual with edge6 J."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Hint with key5 J, whenever there is not a Level with edge6 J, whenever there is not an Signal with vtx4 J, with field5 A, whenever there is not an Signal with vtx4 J, with field5 P, whenever there is not a Individual with edge6 J.",
            "NL": "It is forbidden to have a Hint with key5 J if there is no Level with edge6 J, no Signal with vtx4 J and field5 A, and no Signal with vtx4 J and field5 P, or no Individual with edge6 J."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Hint with key5 J, whenever there is not a Level with edge6 J, whenever there is not an Signal with vtx4 J, with field5 A, whenever there is not an Signal with vtx4 J, with field5 P, whenever there is not a Individual with edge6 J.",
            "NL": "It is forbidden to have a Hint with key5 J if there is no Level with edge6 J, or no Signal with vtx4 J and field5 A, or no Signal with vtx4 J and field5 P, or no Individual with edge6 J."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Hint with key5 J, whenever there is not a Level with edge6 J, whenever there is not an Signal with vtx4 J, with field5 A, whenever there is not an Signal with vtx4 J, with field5 P, whenever there is not a Individual with edge6 J.",
            "NL": "It is prohibited to have a Hint with key5 J, when there is no Level with edge6 J, or an Signal with vtx4 J, with field5 A, or an Signal with vtx4 J, with field5 P, or an Individual with edge6 J."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a In_Hamiltonian_Tour with vtx4 U, with value7 D, whenever there is a Predominant with vtx4 U, with value7 M at most D, whenever there is a Cell with value I at most M.",
            "NL": "Whenever there is a Cell with value I at most M and an In_Hamiltonian_Tour with vtx4 U and value7 D, it is prohibited for there to be a Predominant with vtx4 U and value7 M that is lesser than D."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a In_Hamiltonian_Tour with vtx4 U, with value7 D, whenever there is a Predominant with vtx4 U, with value7 M at most D, whenever there is a Cell with value I at most M.",
            "NL": "It is prohibited for there to be a Predominant with vtx4 U, with value7 M lower than D, if there is a Cell with value I no higher than M, and an In_Hamiltonian_Tour with vtx4 U, with value7 D present."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a In_Hamiltonian_Tour with vtx4 U, with value7 D, whenever there is a Predominant with vtx4 U, with value7 M at most D, whenever there is a Cell with value I at most M.",
            "NL": "Whenever there is an In_Hamiltonian_Tour with vtx4 U, with value7 D, and a Cell with value I at most M, it is prohibited for there to be a Predominant with vtx4 U, with value7 M less than D."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a In_Hamiltonian_Tour with vtx4 U, with value7 D, whenever there is a Predominant with vtx4 U, with value7 M at most D, whenever there is a Cell with value I at most M.",
            "NL": "It is forbidden for there to be a Predominant with vtx4 U, with value7 M lower than D, if there is a Cell with value I no greater than M, and when there is an In_Hamiltonian_Tour with vtx4 U, with value7 D."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a In_Hamiltonian_Tour with vtx4 U, with value7 D, whenever there is a Predominant with vtx4 U, with value7 M at most D, whenever there is a Cell with value I at most M.",
            "NL": "It is forbidden to have a Predominant with vtx4 U and value7 M that is less than D when there is a Cell with value I of no more than M and an In_Hamiltonian_Tour with vtx4 U and value7 D."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a IncomingPath S, whenever there is a Dynamic with fourth node T, with third vertex S.",
            "NL": "It is not allowed for an IncomingPath S to exist when there is a Dynamic with fourth node T and third vertex S."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a IncomingPath S, whenever there is a Dynamic with fourth node T, with third vertex S.",
            "NL": "It is forbidden for there to be an IncomingPath S if there is a Dynamic with fourth node T and third vertex S."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a IncomingPath S, whenever there is a Dynamic with fourth node T, with third vertex S.",
            "NL": "It is forbidden for an IncomingPath S to exist when there is a Dynamic with fourth node T and third vertex S."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a IncomingPath S, whenever there is a Dynamic with fourth node T, with third vertex S.",
            "NL": "It is prohibited for there to be an IncomingPath S when there is a Dynamic with fourth node T and third vertex S."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a IncomingPath S, whenever there is a Dynamic with fourth node T, with third vertex S.",
            "NL": "When a Dynamic is present with fourth node T and third vertex S, it is not allowed for an IncomingPath S to exist."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Irrelevant with edge9 I, whenever there is not a Compare with id9 I, whenever there is not an Edge_Paired with node8 I, with edge2 A, whenever there is not an Edge_Paired with node8 I, with edge2 O, whenever there is not a IngoingPath with id9 I.",
            "NL": "It is prohibited to have an Irrelevant with edge9 I when there is no Compare with id9 I, Edge_Paired with node8 I and edge2 A, Edge_Paired with node8 I and edge2 O, or IngoingPath with id9 I."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Irrelevant with edge9 I, whenever there is not a Compare with id9 I, whenever there is not an Edge_Paired with node8 I, with edge2 A, whenever there is not an Edge_Paired with node8 I, with edge2 O, whenever there is not a IngoingPath with id9 I.",
            "NL": "It is forbidden to have an Irrelevant with edge9 I when there is no Compare with id9 I, no Edge_Paired with node8 I with edge2 A, no Edge_Paired with node8 I with edge2 O, and no IngoingPath with id9 I."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Irrelevant with edge9 I, whenever there is not a Compare with id9 I, whenever there is not an Edge_Paired with node8 I, with edge2 A, whenever there is not an Edge_Paired with node8 I, with edge2 O, whenever there is not a IngoingPath with id9 I.",
            "NL": "It is not allowed to have an Irrelevant with edge9 I when there is no Compare with id9 I, an Edge_Paired with node8 I and edge2 A when there is no Edge_Paired with node8 I and edge2 O, or an IngoingPath with id9 I."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Irrelevant with edge9 I, whenever there is not a Compare with id9 I, whenever there is not an Edge_Paired with node8 I, with edge2 A, whenever there is not an Edge_Paired with node8 I, with edge2 O, whenever there is not a IngoingPath with id9 I.",
            "NL": "It is forbidden to have an Irrelevant with edge9 I when there is no Compare with id9 I, and to have an Edge_Paired with node8 I with edge2 A when there is no Edge_Paired with node8 I with edge2 O, and to have an IngoingPath with id9 I when there is none."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Irrelevant with edge9 I, whenever there is not a Compare with id9 I, whenever there is not an Edge_Paired with node8 I, with edge2 A, whenever there is not an Edge_Paired with node8 I, with edge2 O, whenever there is not a IngoingPath with id9 I.",
            "NL": "No Irrelevant with edge9 I is allowed if there is no Compare with id9 I, no Edge_Paired with node8 I and edge2 A, no Edge_Paired with node8 I and edge2 O, and no IngoingPath with id9 I."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Later with edge3 W, whenever there is not a Allocate with id1 W, whenever there is not an Related with node3 W, with value8 X, whenever there is not an Related with node3 W, with value8 Q, whenever there is not a Sole with id1 W.",
            "NL": "It is prohibited to have a Later with edge3 W when there is not an Allocate with id1 W, an Related with node3 W, value8 X, an Related with node3 W, value8 Q, or an Sole with id1 W."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Later with edge3 W, whenever there is not a Allocate with id1 W, whenever there is not an Related with node3 W, with value8 X, whenever there is not an Related with node3 W, with value8 Q, whenever there is not a Sole with id1 W.",
            "NL": "When there is no Allocate with id1 W, no Related with node3 W, value8 X, no Related with node3 W, value8 Q, and no Sole with id1 W, it is prohibited to have a Later with edge3 W."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Later with edge3 W, whenever there is not a Allocate with id1 W, whenever there is not an Related with node3 W, with value8 X, whenever there is not an Related with node3 W, with value8 Q, whenever there is not a Sole with id1 W.",
            "NL": "It is prohibited to have a Later with edge3 W when there is no Allocate with id1 W, or no Related with node3 W, value8 X, or no Related with node3 W, value8 Q, or no Sole with id1 W."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Later with edge3 W, whenever there is not a Allocate with id1 W, whenever there is not an Related with node3 W, with value8 X, whenever there is not an Related with node3 W, with value8 Q, whenever there is not a Sole with id1 W.",
            "NL": "It is prohibited to have a Later with edge3 W when there is no Allocate with id1 W, no Related with node3 W and value8 X, no Related with node3 W and value8 Q, and no Sole with id1 W."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Later with edge3 W, whenever there is not a Allocate with id1 W, whenever there is not an Related with node3 W, with value8 X, whenever there is not an Related with node3 W, with value8 Q, whenever there is not a Sole with id1 W.",
            "NL": "It is not allowed to have a Later with edge3 W if there is no Allocate with id1 W, no Related with node3 W and value8 X, no Related with node3 W and value8 Q, and no Sole with id1 W."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Layer with id5 J, with field10 N, whenever there is a Edge_Pair with id5 J, with field10 F not after S, whenever there is a Symbol with id5 N, with field10 S.",
            "NL": "Whenever there is an Edge_Pair with id5 J, with field10 F, where F is not after S, and a Symbol with id5 N, with field10 S, it is prohibited for there to be a Layer with id5 J, with field10 N."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Layer with id5 J, with field10 N, whenever there is a Edge_Pair with id5 J, with field10 F not after S, whenever there is a Symbol with id5 N, with field10 S.",
            "NL": "No Layer with id5 J and field10 N should be allowed if there is an Edge_Pair with id5 J and field10 F that is not after S, and if there is a Symbol with id5 N and field10 S."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Layer with id5 J, with field10 N, whenever there is a Edge_Pair with id5 J, with field10 F not after S, whenever there is a Symbol with id5 N, with field10 S.",
            "NL": "No Layer with id5 J and field10 N can exist if there is an Edge_Pair with id5 J, field10 F, and F is not after S, and there is a Symbol with id5 N and field10 S."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Layer with id5 J, with field10 N, whenever there is a Edge_Pair with id5 J, with field10 F not after S, whenever there is a Symbol with id5 N, with field10 S.",
            "NL": "Whenever an Edge_Pair with id5 J, field10 F exists, where F is not after S, and there is a Symbol with id5 N, field10 S, a prohibition is in place to prevent the creation of a Layer with id5 J, field10 N."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Layer with id5 J, with field10 N, whenever there is a Edge_Pair with id5 J, with field10 F not after S, whenever there is a Symbol with id5 N, with field10 S.",
            "NL": "Whenever there is an Edge_Pair with id5 J, field10 F, and a Symbol with id5 N, field10 S, where F is not after S, it is prohibited for there to be a Layer with id5 J, field10 N."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Line_Graph with value9 M, with key3 U, whenever there is a Location with value9 M, with key3 Z not after C, whenever there is a Pair_of_Nodes with value9 U, with key3 C.",
            "NL": "No Line_Graph with value9 M and key3 U is allowed to exist when there is a Location with value9 M, key3 Z, and Z is not after C, and a Pair_of_Nodes with value9 U, and key3 C."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Line_Graph with value9 M, with key3 U, whenever there is a Location with value9 M, with key3 Z not after C, whenever there is a Pair_of_Nodes with value9 U, with key3 C.",
            "NL": "Whenever there is a Pair_of_Nodes with value9 U, with key3 C and a Location with value9 M, with key3 Z, where Z is not after C, there is a prohibition against there being a Line_Graph with value9 M, with key3 U."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Line_Graph with value9 M, with key3 U, whenever there is a Location with value9 M, with key3 Z not after C, whenever there is a Pair_of_Nodes with value9 U, with key3 C.",
            "NL": "Whenever there is a Location with value9 M, with key3 Z, where Z is not after C, and also a Pair_of_Nodes with value9 U, with key3 C, there is a prohibition against having a Line_Graph with value9 M, with key3 U."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Line_Graph with value9 M, with key3 U, whenever there is a Location with value9 M, with key3 Z not after C, whenever there is a Pair_of_Nodes with value9 U, with key3 C.",
            "NL": "Whenever there is a Location with value9 M, with key3 Z, where Z is not after C and a Pair_of_Nodes with value9 U, with key3 C, there is a prohibition against having an Line_Graph with value9 M, with key3 U."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Line_Graph with value9 M, with key3 U, whenever there is a Location with value9 M, with key3 Z not after C, whenever there is a Pair_of_Nodes with value9 U, with key3 C.",
            "NL": "Whenever there is a Location with value9 M, with key3 Z, where Z is not after C, and a Pair_of_Nodes with value9 U, with key3 C, it is prohibited to have a Line_Graph with value9 M, with key3 U."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Lone with vtx2 G, whenever there is not a Tone with id9 G, whenever there is a Lone with vtx2 I, whenever there is not a Tone with id9 I, whenever there is not a Selected_Color with id6 G, with vtx2 I. ",
            "NL": "When there is a Lone with vtx2 G, but no Tone with id9 G; and when there is a Lone with vtx2 I, but no Tone with id9 I; and when there is no Selected_Color with id6 G, and no Selected_Color with vtx2 I, then there is a prohibition."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Lone with vtx2 G, whenever there is not a Tone with id9 G, whenever there is a Lone with vtx2 I, whenever there is not a Tone with id9 I, whenever there is not a Selected_Color with id6 G, with vtx2 I. ",
            "NL": "When there is a Lone with vtx2 G, but not with id9 G, and a Lone with vtx2 I, but not with id9 I, and no Selected_Color with id6 G or vtx2 I, there is a prohibition in place."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Lone with vtx2 G, whenever there is not a Tone with id9 G, whenever there is a Lone with vtx2 I, whenever there is not a Tone with id9 I, whenever there is not a Selected_Color with id6 G, with vtx2 I. ",
            "NL": "When there is a Lone with vtx2 G, but no Tone with id9 G; and when there is a Lone with vtx2 I, but no Tone with id9 I; and when there is not a Selected_Color with id6 G, and when there is not a Selected_Color with vtx2 I, there is a prohibition in place."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Lone with vtx2 G, whenever there is not a Tone with id9 G, whenever there is a Lone with vtx2 I, whenever there is not a Tone with id9 I, whenever there is not a Selected_Color with id6 G, with vtx2 I. ",
            "NL": "If there is no Tone with ID9 G, there is a prohibition of having a Lone with VTX2 G; similarly, if there is no Tone with ID9 I, there is a prohibition of having a Lone with VTX2 I; additionally, if there is not a Selected_Color with ID6 G or VTX2 I, there is also a prohibition."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Lone with vtx2 G, whenever there is not a Tone with id9 G, whenever there is a Lone with vtx2 I, whenever there is not a Tone with id9 I, whenever there is not a Selected_Color with id6 G, with vtx2 I. ",
            "NL": "If there is no Tone with ID9 G, there is a prohibition on having a Lone with VTX2 G. Likewise, if there is no Tone with ID9 I, there is a prohibition on having a Lone with VTX2 I. Additionally, if there is not a Selected_Color with ID6 G or VTX2 I, then there is a prohibition in place."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Member with vtx3 J, with edge8 V, whenever there is a Dynamic with vtx3 J, with edge8 M at most V, whenever there is a Graph_Coloring with value G at most M.",
            "NL": "Whenever there is a Member with vtx3 J and edge8 V, it is not allowed to have a Dynamic with vtx3 J and edge8 M that is less than V if there is a Graph_Coloring with value G that is at most M."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Member with vtx3 J, with edge8 V, whenever there is a Dynamic with vtx3 J, with edge8 M at most V, whenever there is a Graph_Coloring with value G at most M.",
            "NL": "Whenever there is a Member with vtx3 J and edge8 V, it is forbidden for there to be a Dynamic with vtx3 J and edge8 M less than V if a Graph_Coloring with value G is no more than M."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Member with vtx3 J, with edge8 V, whenever there is a Dynamic with vtx3 J, with edge8 M at most V, whenever there is a Graph_Coloring with value G at most M.",
            "NL": "It is prohibited for a Dynamic with vtx3 J and edge8 M to be present if there is a Graph_Coloring with value G of at most M and a Member with vtx3 J and edge8 V."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Member with vtx3 J, with edge8 V, whenever there is a Dynamic with vtx3 J, with edge8 M at most V, whenever there is a Graph_Coloring with value G at most M.",
            "NL": "Whenever there is a Member with vtx3 J and edge8 V, it is forbidden to have a Dynamic with vtx3 J and edge8 M that is less than V, when there is a Graph_Coloring with value G that is no more than M."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Member with vtx3 J, with edge8 V, whenever there is a Dynamic with vtx3 J, with edge8 M at most V, whenever there is a Graph_Coloring with value G at most M.",
            "NL": "If there is a Member with vtx3 J and edge8 V, then it is not allowed to have a Dynamic with vtx3 J and edge8 M that is less than V when there is a Graph_Coloring with value G that is no more than M."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Name X, whenever there is a Partition with fourth vertex I, with first id X.",
            "NL": "No Name X is allowed when there is a Partition with fourth vertex I and first id X."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Name X, whenever there is a Partition with fourth vertex I, with first id X.",
            "NL": "It is forbidden for Name X to exist when a Partition has fourth vertex I and first id X."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Name X, whenever there is a Partition with fourth vertex I, with first id X.",
            "NL": "It is forbidden for Name X to be present when there is a Partition with fourth vertex I and first id X."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Name X, whenever there is a Partition with fourth vertex I, with first id X.",
            "NL": "It is forbidden to have a Name X when there is a Partition with fourth vertex I and first id X."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Name X, whenever there is a Partition with fourth vertex I, with first id X.",
            "NL": "It is forbidden for Name X to exist when there is a Partition with fourth vertex I and first id X."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Network with field10 D, whenever there is not a Unarrowed with field10 D, whenever there is not a Index with field10 D.",
            "NL": "If there is not an Unarrowed or an Index with field10 D, a Network with field10 D is prohibited."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Network with field10 D, whenever there is not a Unarrowed with field10 D, whenever there is not a Index with field10 D.",
            "NL": "Whenever there is not an Unarrowed or Index with field10 D, there is a prohibition against having a Network with field10 D."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Network with field10 D, whenever there is not a Unarrowed with field10 D, whenever there is not a Index with field10 D.",
            "NL": "Whenever there is not a Unarrowed or an Index with field10 D, a Network with field10 D is prohibited."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Network with field10 D, whenever there is not a Unarrowed with field10 D, whenever there is not a Index with field10 D.",
            "NL": "If there is not an Unarrowed or an Index with field10 D, then there must be a Network with field10 D."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Network with field10 D, whenever there is not a Unarrowed with field10 D, whenever there is not a Index with field10 D.",
            "NL": "If there is no Unarrowed or Index with field10 D, then a Network with field10 D is prohibited."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Node with node8 S, whenever there is Node with node8 O, whenever there is not a Mass with edge8 S, whenever there is not a Mass with edge8 O different from S, whenever there is an Arrived with edge9 O, with edge1 S, with id7 F, whenever there is not a Atom with edge9 O, with edge1 S, with id7 F. ",
            "NL": "It is forbidden to have a Node with node8 S, a Node with node8 O, no Mass with edge8 S, no Mass with edge8 O, an Arrived with edge9 O, edge1 S, and id7 F, where W is not equal to S, unless there is no Atom with edge9 O, edge1 S, and id7 F."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Node with node8 S, whenever there is Node with node8 O, whenever there is not a Mass with edge8 S, whenever there is not a Mass with edge8 O different from S, whenever there is an Arrived with edge9 O, with edge1 S, with id7 F, whenever there is not a Atom with edge9 O, with edge1 S, with id7 F. ",
            "NL": "It is forbidden for there to be a Node with node8 S, a Node with node8 O, no Mass with edge8 S, no Mass with edge8 O, an Arrived with edge9 O, edge1 S, and id7 F, where W does not equal S, unless there is no Atom with edge9 O, edge1 S, and id7 F."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Node with node8 S, whenever there is Node with node8 O, whenever there is not a Mass with edge8 S, whenever there is not a Mass with edge8 O different from S, whenever there is an Arrived with edge9 O, with edge1 S, with id7 F, whenever there is not a Atom with edge9 O, with edge1 S, with id7 F. ",
            "NL": "It is forbidden to have a Node with node8 S, a Node with node8 O, no Mass with edge8 S, no Mass with edge8 O, an Arrived with edge9 O, edge1 S, and id7 F where W is not equal to S, unless there is no Atom with edge9 O, edge1 S, and id7 F."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Node with node8 S, whenever there is Node with node8 O, whenever there is not a Mass with edge8 S, whenever there is not a Mass with edge8 O different from S, whenever there is an Arrived with edge9 O, with edge1 S, with id7 F, whenever there is not a Atom with edge9 O, with edge1 S, with id7 F. ",
            "NL": "It is forbidden for there to be a Node with node8 S, a Node with node8 O, a Mass with edge8 S, a Mass with edge8 O, or an Arrived with edge9 O, edge1 S, and id7 F if W does not equal S, unless there is no Atom with edge9 O, edge1 S, and id7 F."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Node with node8 S, whenever there is Node with node8 O, whenever there is not a Mass with edge8 S, whenever there is not a Mass with edge8 O different from S, whenever there is an Arrived with edge9 O, with edge1 S, with id7 F, whenever there is not a Atom with edge9 O, with edge1 S, with id7 F. ",
            "NL": "It is not allowed for there to be a Node with node8 S, a Node with node8 O, a Mass with edge8 S, a Mass with edge8 O, or an Arrived with edge9 O, edge1 S, and id7 F where W is not equal to S, unless there is a Atom with edge9 O, edge1 S, and id7 F."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a order with value X, with id Y, whenever there is a tran with value X, with id Z less than W, whenever there is a mtrans with value Y, with id W.",
            "NL": "Whenever there is a trans with value X, and its id Z is less than W, and there is also a mtrans with value Y, and its id W, then it is prohibited for an order to be made with value X and id Y."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a order with value X, with id Y, whenever there is a tran with value X, with id Z less than W, whenever there is a mtrans with value Y, with id W.",
            "NL": "Whenever there is a transaction with value X and id Z that is less than W, and a mtrans with value Y and id W, it is prohibited to have an order with value X and id Y."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a order with value X, with id Y, whenever there is a tran with value X, with id Z less than W, whenever there is a mtrans with value Y, with id W.",
            "NL": "Whenever there is a trans with value X, with id Z, where Z is less than W, and a mtrans with value Y, with id W, there is a prohibition against creating an order with value X, and id Y."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a order with value X, with id Y, whenever there is a tran with value X, with id Z less than W, whenever there is a mtrans with value Y, with id W.",
            "NL": "Whenever there is a trans with value X, with id Z, where Z is less than W, and a mtrans with value Y, with id W, an order with value X, with id Y, is prohibited."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a order with value X, with id Y, whenever there is a tran with value X, with id Z less than W, whenever there is a mtrans with value Y, with id W.",
            "NL": "Whenever there is a trans with value X, with id Z, and Z is less than W, and a mtrans with value Y, with id W, an order with value X, with id Y, is prohibited."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Outgoing with id8 P, whenever there is not a Inspect with key5 P, whenever there is not an Graph_Coloring with edge7 P, with id4 C, whenever there is not an Graph_Coloring with edge7 P, with id4 A, whenever there is not a Auxiliary with key5 P.",
            "NL": "It is forbidden for there to be an Outgoing with id8 P unless there is an Inspect with key5 P, a Graph_Coloring with edge7 P and id4 C, a Graph_Coloring with edge7 P and id4 A, and an Auxiliary with key5 P."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Outgoing with id8 P, whenever there is not a Inspect with key5 P, whenever there is not an Graph_Coloring with edge7 P, with id4 C, whenever there is not an Graph_Coloring with edge7 P, with id4 A, whenever there is not a Auxiliary with key5 P.",
            "NL": "It is prohibited for there to be an Outgoing with id8 P unless there is an Inspect with key5 P, a Graph_Coloring with edge7 P and id4 C, or a Graph_Coloring with edge7 P and id4 A, and an Auxiliary with key5 P."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Outgoing with id8 P, whenever there is not a Inspect with key5 P, whenever there is not an Graph_Coloring with edge7 P, with id4 C, whenever there is not an Graph_Coloring with edge7 P, with id4 A, whenever there is not a Auxiliary with key5 P.",
            "NL": "When there is not an Outgoing with id8 P, an Inspect with key5 P, a Graph_Coloring with edge7 P and id4 C, or a Graph_Coloring with edge7 P and id4 A, and an Auxiliary with key5 P, it is prohibited."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Outgoing with id8 P, whenever there is not a Inspect with key5 P, whenever there is not an Graph_Coloring with edge7 P, with id4 C, whenever there is not an Graph_Coloring with edge7 P, with id4 A, whenever there is not a Auxiliary with key5 P.",
            "NL": "It is not allowed for there to be an Outgoing with id8 P unless there is an Inspect with key5 P, a Graph_Coloring with edge7 P and id4 C, and a Graph_Coloring with edge7 P and id4 A, and an Auxiliary with key5 P."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Outgoing with id8 P, whenever there is not a Inspect with key5 P, whenever there is not an Graph_Coloring with edge7 P, with id4 C, whenever there is not an Graph_Coloring with edge7 P, with id4 A, whenever there is not a Auxiliary with key5 P.",
            "NL": "It is not allowed to have an Outgoing with id8 P unless there is an Inspect with key5 P, a Graph_Coloring with edge7 P and id4 C, a Graph_Coloring with edge7 P and id4 A, and an Auxiliary with key5 P present."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Partition with edge5 T, with id9 G, whenever there is a Dormant with edge5 T, with id9 F at most S, whenever there is a Out_Hamiltonian with edge5 G, with id9 S.",
            "NL": "No Partition with edge5 T, with id9 G, should be allowed if there is a Dormant with edge5 T, with id9 F, where F is at most S, and an Out_Hamiltonian with edge5 G, with id9 S is present."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Partition with edge5 T, with id9 G, whenever there is a Dormant with edge5 T, with id9 F at most S, whenever there is a Out_Hamiltonian with edge5 G, with id9 S.",
            "NL": "Whenever an Out_Hamiltonian with edge5 G, id9 S exists, a prohibition is in place to prevent a Partition with edge5 T, id9 G from occurring if a Dormant with edge5 T, id9 F is present, where F is at most S."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Partition with edge5 T, with id9 G, whenever there is a Dormant with edge5 T, with id9 F at most S, whenever there is a Out_Hamiltonian with edge5 G, with id9 S.",
            "NL": "Whenever there is an Out_Hamiltonian with edge5 G, with id9 S, there is a prohibition against there being a Partition with edge5 T, with id9 G, if there is a Dormant with edge5 T, with id9 F, and F is at most S."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Partition with edge5 T, with id9 G, whenever there is a Dormant with edge5 T, with id9 F at most S, whenever there is a Out_Hamiltonian with edge5 G, with id9 S.",
            "NL": "No Partition with edge5 T, with id9 G, is allowed when there is a Dormant with edge5 T, with id9 F, and F is less than or equal to S, when there is an Out_Hamiltonian with edge5 G, with id9 S."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Partition with edge5 T, with id9 G, whenever there is a Dormant with edge5 T, with id9 F at most S, whenever there is a Out_Hamiltonian with edge5 G, with id9 S.",
            "NL": "Whenever there is a Dormant with edge5 T, with id9 F, where F is at most S, and an Out_Hamiltonian with edge5 G, with id9 S, it is prohibited to have a Partition with edge5 T, with id9 G."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Planar_Embedding with key2 N, whenever there is not a Used_Edge with key2 N, whenever there is not a Controlling with key2 N.",
            "NL": "Anytime there is not a Used_Edge with key2 N or a Controlling with key2 N, it is prohibited to have a Planar_Embedding with key2 N."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Planar_Embedding with key2 N, whenever there is not a Used_Edge with key2 N, whenever there is not a Controlling with key2 N.",
            "NL": "It is forbidden to have a Planar_Embedding with key2 N if there is no Used_Edge or Controlling with key2 N."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Planar_Embedding with key2 N, whenever there is not a Used_Edge with key2 N, whenever there is not a Controlling with key2 N.",
            "NL": "Whenever there is not a Used_Edge with key2 N and not a Controlling with key2 N, there is a prohibition on having a Planar_Embedding with key2 N."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Planar_Embedding with key2 N, whenever there is not a Used_Edge with key2 N, whenever there is not a Controlling with key2 N.",
            "NL": "Whenever there is not a Used_Edge with key2 N or a Controlling with key2 N, a Planar_Embedding with key2 N must not be present."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Planar_Embedding with key2 N, whenever there is not a Used_Edge with key2 N, whenever there is not a Controlling with key2 N.",
            "NL": "If there is no Used_Edge or Controlling with key2 N, there must be a Planar_Embedding with key2 N."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Sanction with value7 E, whenever there is not a Connected with node10 E, whenever there is not an Residual_Graph with id4 E, with edge9 H, whenever there is not an Residual_Graph with id4 E, with edge9 U, whenever there is not a Final with node10 E.",
            "NL": "It is prohibited to have a Sanction with value7 E unless there is a Connected node10 E, a Residual_Graph with id4 E and edge9 H, a Residual_Graph with id4 E and edge9 U, and a Final with node10 E."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Sanction with value7 E, whenever there is not a Connected with node10 E, whenever there is not an Residual_Graph with id4 E, with edge9 H, whenever there is not an Residual_Graph with id4 E, with edge9 U, whenever there is not a Final with node10 E.",
            "NL": "It is forbidden to have Sanction with value7 E when there is no Connected node10 E, Residual_Graph with id4 E and edge9 H, Residual_Graph with id4 E and edge9 U, or Final with node10 E."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Sanction with value7 E, whenever there is not a Connected with node10 E, whenever there is not an Residual_Graph with id4 E, with edge9 H, whenever there is not an Residual_Graph with id4 E, with edge9 U, whenever there is not a Final with node10 E.",
            "NL": "It is forbidden to have a Sanction with value7 E if there is no Connected node10 E, Residual_Graph with id4 E and edge9 H, Residual_Graph with id4 E and edge9 U, and Final node10 E."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Sanction with value7 E, whenever there is not a Connected with node10 E, whenever there is not an Residual_Graph with id4 E, with edge9 H, whenever there is not an Residual_Graph with id4 E, with edge9 U, whenever there is not a Final with node10 E.",
            "NL": "It is forbidden to have a Sanction with value7 E if there is not a Connected with node10 E, a Residual_Graph with id4 E and edge9 H, or a Residual_Graph with id4 E and edge9 U, and a Final with node10 E."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Sanction with value7 E, whenever there is not a Connected with node10 E, whenever there is not an Residual_Graph with id4 E, with edge9 H, whenever there is not an Residual_Graph with id4 E, with edge9 U, whenever there is not a Final with node10 E.",
            "NL": "It is not allowed to have a Sanction with value7 E if there is no Connected node10 E, Residual_Graph with id4 E and edge9 H, or Residual_Graph with id4 E and edge9 U, or Final with node10 E."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Solitary with node7 F, whenever there is not a Link with key8 F, whenever there is a Solitary with node7 A, whenever there is not a Link with key8 A, whenever there is not a Eulerian_Circuit with value3 F, with node7 A. ",
            "NL": "When there is no Link with key8 F and no Eulerian_Circuit with value3 F, there is a prohibition against having a Solitary with node7 A, and similarly, when there is no Link with key8 A and no Eulerian_Circuit with node7 A, there is a prohibition against having a Solitary with node7 F."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Solitary with node7 F, whenever there is not a Link with key8 F, whenever there is a Solitary with node7 A, whenever there is not a Link with key8 A, whenever there is not a Eulerian_Circuit with value3 F, with node7 A. ",
            "NL": "When there is no Link with key8 F and no Eulerian_Circuit with value3 F, a prohibition exists that there is a Solitary with node7 F. Similarly, when there is no Link with key8 A and no Eulerian_Circuit with node7 A, a prohibition exists that there is a Solitary with node7 A."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Solitary with node7 F, whenever there is not a Link with key8 F, whenever there is a Solitary with node7 A, whenever there is not a Link with key8 A, whenever there is not a Eulerian_Circuit with value3 F, with node7 A. ",
            "NL": "When there is no Link with key8 F, no Solitary with node7 F, no Link with key8 A, no Solitary with node7 A, no Eulerian_Circuit with value3 F, and no Eulerian_Circuit with node7 A, there is a prohibition in place."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Solitary with node7 F, whenever there is not a Link with key8 F, whenever there is a Solitary with node7 A, whenever there is not a Link with key8 A, whenever there is not a Eulerian_Circuit with value3 F, with node7 A. ",
            "NL": "When there is no Link with key8 F and no Eulerian_Circuit with value3 F, a Solitary with node7 A is prohibited, as is a Solitary with node7 F when there is no Link with key8 A and no Eulerian_Circuit with node7 A."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Solitary with node7 F, whenever there is not a Link with key8 F, whenever there is a Solitary with node7 A, whenever there is not a Link with key8 A, whenever there is not a Eulerian_Circuit with value3 F, with node7 A. ",
            "NL": "If there is no Link with key8 F and no Eulerian_Circuit with value3 F, then there is a prohibition against having a Solitary with node7 A, and likewise if there is no Link with key8 A and no Eulerian_Circuit with node7 A, then there is a prohibition against having a Solitary with node7 F."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a start Y, whenever there is a inPath with first vtx X, with second vtx Y.",
            "NL": "It is forbidden for there to be a start Y when there is an inPath with X as its first vertex and Y as its second vertex."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a start Y, whenever there is a inPath with first vtx X, with second vtx Y.",
            "NL": "It is not allowed for there to be a start Y when an inPath with X as the first vertex and Y as the second vertex exists."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a start Y, whenever there is a inPath with first vtx X, with second vtx Y.",
            "NL": "It is not allowed for there to be a start Y when there is an inPath with X as its first vertex and Y as its second vertex."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a start Y, whenever there is a inPath with first vtx X, with second vtx Y.",
            "NL": "It is forbidden for there to be a start Y if there is an inPath with X as its first vertex and Y as its second vertex."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a start Y, whenever there is a inPath with first vtx X, with second vtx Y.",
            "NL": "It is prohibited to have a start Y whenever there is an inPath with X as the first vertex and Y as the second vertex."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Trail with field G, whenever there is not a Offspring with edge1 G, whenever there is not an Forest with field7 G, with edge5 F, whenever there is not an Forest with field7 G, with edge5 E, whenever there is not a Node with edge1 G.",
            "NL": "It is prohibited to have a Trail with field G if there is not an Offspring with edge1 G, Forest with field7 G and edge5 F, or Forest with field7 G and edge5 E, or Node with edge1 G."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Trail with field G, whenever there is not a Offspring with edge1 G, whenever there is not an Forest with field7 G, with edge5 F, whenever there is not an Forest with field7 G, with edge5 E, whenever there is not a Node with edge1 G.",
            "NL": "No Trail with field G is allowed unless there is an Offspring with edge1 G, an Forest with field7 G and edge5 F, or an Forest with field7 G and edge5 E, or a Node with edge1 G."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Trail with field G, whenever there is not a Offspring with edge1 G, whenever there is not an Forest with field7 G, with edge5 F, whenever there is not an Forest with field7 G, with edge5 E, whenever there is not a Node with edge1 G.",
            "NL": "It is not allowed to have a Trail with field G if there is no Offspring with edge1 G, Forest with field7 G and edge5 F, or Forest with field7 G and edge5 E, or Node with edge1 G."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Trail with field G, whenever there is not a Offspring with edge1 G, whenever there is not an Forest with field7 G, with edge5 F, whenever there is not an Forest with field7 G, with edge5 E, whenever there is not a Node with edge1 G.",
            "NL": "It is forbidden to have a Trail with field G if there is no Offspring with edge1 G, no Forest with field7 G and edge5 F, and no Forest with field7 G and edge5 E, and no Node with edge1 G."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Trail with field G, whenever there is not a Offspring with edge1 G, whenever there is not an Forest with field7 G, with edge5 F, whenever there is not an Forest with field7 G, with edge5 E, whenever there is not a Node with edge1 G.",
            "NL": "It is not allowed to have a Trail with field G if there is no Offspring with edge1 G, no Forest with field7 G and edge5 F, or no Forest with field7 G and edge5 E, and no Node with edge1 G."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Trail with key10 B, with edge J, whenever there is a Hint with key10 B, with edge V not after G, whenever there is an In_Hamiltonian with key10 J, with edge G.",
            "NL": "No Trail with key10 B and edge J is allowed when a Hint with key10 B and edge V is present, provided that V is not after G and an In_Hamiltonian with key10 J and edge G is present."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Trail with key10 B, with edge J, whenever there is a Hint with key10 B, with edge V not after G, whenever there is an In_Hamiltonian with key10 J, with edge G.",
            "NL": "Whenever there is an In_Hamiltonian with key10 J, with edge G, there is a prohibition against there being a Trail with key10 B, with edge J, if there is a Hint with key10 B, with edge V and V is not after G."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Trail with key10 B, with edge J, whenever there is a Hint with key10 B, with edge V not after G, whenever there is an In_Hamiltonian with key10 J, with edge G.",
            "NL": "Whenever there is an In_Hamiltonian with key10 J, with edge G, it is prohibited for there to be a Trail with key10 B, with edge J, if there is a Hint with key10 B, with edge V and V is not after G."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Trail with key10 B, with edge J, whenever there is a Hint with key10 B, with edge V not after G, whenever there is an In_Hamiltonian with key10 J, with edge G.",
            "NL": "Whenever there is an In_Hamiltonian with key10 J, with edge G, a prohibition is in place to prevent a Trail with key10 B and edge J from existing if there is a Hint with key10 B and edge V, where V is not after G."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Trail with key10 B, with edge J, whenever there is a Hint with key10 B, with edge V not after G, whenever there is an In_Hamiltonian with key10 J, with edge G.",
            "NL": "No Trail with key10 B and edge J is allowed when there is a Hint with key10 B and edge V (not after G) and an In_Hamiltonian with key10 J and edge G."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Valency with first node Q different from K, with second node D, whenever there is a Valency with first node K, with second node D.",
            "NL": "It is not allowed to create a Valency with the first node K and the second node D if there is already a Valency between the first node Q and the second node D, provided that K is not equal to Q."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Valency with first node Q different from K, with second node D, whenever there is a Valency with first node K, with second node D.",
            "NL": "It is not allowed to form a Valency between first node K and second node D if there is already a Valency between first node Q and second node D, and K is not equal to Q."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Valency with first node Q different from K, with second node D, whenever there is a Valency with first node K, with second node D.",
            "NL": "Establishing a Valency between first node K and second node D is not allowed if there is already a Valency between first node Q and second node D, and K is not equal to Q."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Valency with first node Q different from K, with second node D, whenever there is a Valency with first node K, with second node D.",
            "NL": "It is not allowed to create a Valency between first node K and second node D if a Valency already exists between first node Q and second node D, provided that K is not the same as Q."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Valency with first node Q different from K, with second node D, whenever there is a Valency with first node K, with second node D.",
            "NL": "When a Valency exists between first node Q and second node D, it is not allowed to create a Valency between first node K and second node D, assuming K is not equal to Q."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Variation with key2 U, with vtx9 I, whenever there is a Directed with key2 U, with vtx9 B not after Z, whenever there is a Additional with key2 I, with vtx9 Z.",
            "NL": "No variations of key2 U with vtx9 I are allowed when there is a directed key2 U with vtx9 B, unless B is after Z, and no additional key2 I with vtx9 Z is present."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Variation with key2 U, with vtx9 I, whenever there is a Directed with key2 U, with vtx9 B not after Z, whenever there is a Additional with key2 I, with vtx9 Z.",
            "NL": "When a Directed with key2 U and vtx9 B is present, where B is not after Z, and there is an Additional with key2 I and vtx9 Z, no Variation with key2 U and vtx9 I is allowed."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Variation with key2 U, with vtx9 I, whenever there is a Directed with key2 U, with vtx9 B not after Z, whenever there is a Additional with key2 I, with vtx9 Z.",
            "NL": "It is not allowed to have a Variation with key2 U and vtx9 I when there is a Directed with key2 U and vtx9 B that is not after Z, and when there is an Additional with key2 I and vtx9 Z."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Variation with key2 U, with vtx9 I, whenever there is a Directed with key2 U, with vtx9 B not after Z, whenever there is a Additional with key2 I, with vtx9 Z.",
            "NL": "No variations with key2 U and vtx9 I are allowed if there is a Directed with key2 U and vtx9 B (where B is not after Z) and an Additional with key2 I and vtx9 Z."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Variation with key2 U, with vtx9 I, whenever there is a Directed with key2 U, with vtx9 B not after Z, whenever there is a Additional with key2 I, with vtx9 Z.",
            "NL": "No Variation with key2 U, and vtx9 I is allowed when there is a Directed with key2 U, and vtx9 B, unless B is after Z, and an Additional with key2 I, and vtx9 Z is present."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a vertex with node X, whenever there is not a reached with node X, whenever there is not a start with node X.",
            "NL": "It is not allowed for there to be a vertex with node X if there is not a reach with node X or a start with node X."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a vertex with node X, whenever there is not a reached with node X, whenever there is not a start with node X.",
            "NL": "It is prohibited for there to be a vertex with node X if there is no reached node X or start node X."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a vertex with node X, whenever there is not a reached with node X, whenever there is not a start with node X.",
            "NL": "A rule is in place that if no start node is identified with node X, then there cannot be a vertex with node X."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a vertex with node X, whenever there is not a reached with node X, whenever there is not a start with node X.",
            "NL": "It is prohibited for a vertex with node X to exist if there is no endpoint or starting point with node X."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a vertex with node X, whenever there is not a reached with node X, whenever there is not a start with node X.",
            "NL": "No vertex with node X is allowed unless there is a reached node with node X or a start node with node X."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Weighted_Graph with node2 N, with vtx10 Z, whenever there is an Achieved with node2 N, with vtx10 U not after Z, whenever there is a Arc with value V not after U.",
            "NL": "Whenever there is a Weighted_Graph with node2 N, and vtx10 Z is greater than U, it is prohibited that there be an Arc with value V not after U."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Weighted_Graph with node2 N, with vtx10 Z, whenever there is an Achieved with node2 N, with vtx10 U not after Z, whenever there is a Arc with value V not after U.",
            "NL": "Whenever there is a Weighted_Graph with node2 N, and vtx10 Z, it is prohibited that there be an Achieved with node2 N, and vtx10 U lesser than Z, if there is an Arc with value V not after U."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Weighted_Graph with node2 N, with vtx10 Z, whenever there is an Achieved with node2 N, with vtx10 U not after Z, whenever there is a Arc with value V not after U.",
            "NL": "Whenever there is a Weighted_Graph with node2 N, and vtx10 Z, it is prohibited that there be an Achieved with node2 N, with vtx10 U less than Z, if there is an Arc with value V not after U."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Weighted_Graph with node2 N, with vtx10 Z, whenever there is an Achieved with node2 N, with vtx10 U not after Z, whenever there is a Arc with value V not after U.",
            "NL": "Whenever there is a Weighted_Graph with node2 N, and vtx10 Z, it is prohibited to have a Achieved with node2 N, and vtx10 U lower than Z, if there is an Arc with value V not after U."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Weighted_Graph with node2 N, with vtx10 Z, whenever there is an Achieved with node2 N, with vtx10 U not after Z, whenever there is a Arc with value V not after U.",
            "NL": "Whenever there is a Weighted_Graph with node2 N, with vtx10 Z, it is prohibited that there be an Achieved with node2 N, with vtx10 U lesser than Z, if there is an Arc with value V not after U."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Width with edge9 T, whenever there is Width with edge9 Y, whenever there is not a Location with id7 T, whenever there is not a Location with id7 Y different from T, whenever there is a Chromatic_Number with field5 Y, with edge7 T, with node3 L, whenever there is not a Parentedge with field5 Y, with edge7 T, with node3 L. ",
            "NL": "It is not allowed to have a Width with edge9 T, a Width with edge9 Y, a Location with id7 T, a Location with id7 Y, a Chromatic_Number with field5 Y, edge7 T, and node3 L, where W is not equal to T, if there is no Parentedge with field5 Y, edge7 T, and node3 L."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Width with edge9 T, whenever there is Width with edge9 Y, whenever there is not a Location with id7 T, whenever there is not a Location with id7 Y different from T, whenever there is a Chromatic_Number with field5 Y, with edge7 T, with node3 L, whenever there is not a Parentedge with field5 Y, with edge7 T, with node3 L. ",
            "NL": "It is forbidden to have a Width with edge9 T and a Width with edge9 Y, no Location with id7 T or Location with id7 Y, a Chromatic_Number with field5 Y, edge7 T, and node3 L, where W is not equal to T, if there is no Parentedge with field5 Y, edge7 T, and node3 L."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Width with edge9 T, whenever there is Width with edge9 Y, whenever there is not a Location with id7 T, whenever there is not a Location with id7 Y different from T, whenever there is a Chromatic_Number with field5 Y, with edge7 T, with node3 L, whenever there is not a Parentedge with field5 Y, with edge7 T, with node3 L. ",
            "NL": "It is forbidden to have a Width with edge9 T, a Width with edge9 Y, a Location with id7 T, a Location with id7 Y, a Chromatic_Number with field5 Y, edge7 T, and node3 L, where W is not equal to T, if there is no Parentedge with field5 Y, edge7 T, and node3 L."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Width with edge9 T, whenever there is Width with edge9 Y, whenever there is not a Location with id7 T, whenever there is not a Location with id7 Y different from T, whenever there is a Chromatic_Number with field5 Y, with edge7 T, with node3 L, whenever there is not a Parentedge with field5 Y, with edge7 T, with node3 L. ",
            "NL": "It is prohibited that there is a Width with edge9 T, there is Width with edge9 Y, there is not a Location with id7 T, there is not a Location with id7 Y, and a Chromatic_Number with field5 Y, edge7 T, and node3 L, where W is not equal to T, if there is no Parentedge with field5 Y, edge7 T, and node3 L."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is a Width with edge9 T, whenever there is Width with edge9 Y, whenever there is not a Location with id7 T, whenever there is not a Location with id7 Y different from T, whenever there is a Chromatic_Number with field5 Y, with edge7 T, with node3 L, whenever there is not a Parentedge with field5 Y, with edge7 T, with node3 L. ",
            "NL": "It is forbidden to have a Width with edge9 T, Width with edge9 Y, Location with id7 T, Location with id7 Y, Chromatic_Number with field5 Y, edge7 T, node3 L, where W is not equal to T, if there is no Parentedge with field5 Y, edge7 T, node3 L."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is Accomplishment with value4 X, with field6 X. ",
            "NL": "It is forbidden to have Accomplishment with value4 X and field6 X."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is Accomplishment with value4 X, with field6 X. ",
            "NL": "Accomplishment with value4 X and field6 X is not allowed."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is Accomplishment with value4 X, with field6 X. ",
            "NL": "It is forbidden to have an Achievement with value4 X and in the area of field6 X."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is Accomplishment with value4 X, with field6 X. ",
            "NL": "It is not allowed to have Accomplishment with value4 X and field6 X."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is Accomplishment with value4 X, with field6 X. ",
            "NL": "Having Accomplishment with value4 X and field6 X is not allowed."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an active with key V, whenever there is not a trivial with value V, whenever there is an active with key W, whenever there is not a trivial with value W, whenever there is not a reach with field1 V, with field2 W.",
            "NL": "It is prohibited to have an active key with value V if there is no trivial value with V, and an active key with value W if there is no trivial value with W, and no reach with field1 value V, and no reach with field2 value W."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an active with key V, whenever there is not a trivial with value V, whenever there is an active with key W, whenever there is not a trivial with value W, whenever there is not a reach with field1 V, with field2 W.",
            "NL": "It is forbidden to have an active with key V when there is no trivial with value V, and to have an active with key W when there is no trivial with value W, as well as to have a reach with field1 V and a reach with field2 W."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an active with key V, whenever there is not a trivial with value V, whenever there is an active with key W, whenever there is not a trivial with value W, whenever there is not a reach with field1 V, with field2 W.",
            "NL": "It is prohibited to have an active key V when there is no trivial value V, an active key W when there is no trivial value W, and no reach with field1 V or field2 W."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an active with key V, whenever there is not a trivial with value V, whenever there is an active with key W, whenever there is not a trivial with value W, whenever there is not a reach with field1 V, with field2 W.",
            "NL": "It is prohibited to have an active with the key V when there is no trivial with value V, or an active with the key W when there is no trivial with value W, or a reach with field1 V when there is not a reach with field2 W."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an active with key V, whenever there is not a trivial with value V, whenever there is an active with key W, whenever there is not a trivial with value W, whenever there is not a reach with field1 V, with field2 W.",
            "NL": "If there is no trivial with value V when an active with key V is present, no trivial with value W when an active with key W is present, and no reach with field1 V and field2 W, then a prohibition is in effect."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Active with second point F, with second vertex E, whenever there is an Active with second point F, with second vertex Y different from E.",
            "NL": "When there is an Active with second point F and second vertex E, it is not allowed to create another Active with second point F and second vertex Y, unless Y is the same as E."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Active with second point F, with second vertex E, whenever there is an Active with second point F, with second vertex Y different from E.",
            "NL": "When there is an Active with second point F and second vertex E, it is forbidden to create another Active with second point F and second vertex Y if Y does not equal E."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Active with second point F, with second vertex E, whenever there is an Active with second point F, with second vertex Y different from E.",
            "NL": "If there is an Active with second point F and second vertex E, it is not allowed to create another Active with second point F and second vertex Y, when Y does not match E."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Active with second point F, with second vertex E, whenever there is an Active with second point F, with second vertex Y different from E.",
            "NL": "Establishing an Active with second point F and second vertex Y is not allowed if there is already an Active with second point F and second vertex E, and Y is not the same as E."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Active with second point F, with second vertex E, whenever there is an Active with second point F, with second vertex Y different from E.",
            "NL": "When there is an Active with second point F and second vertex E, it is not allowed to create another Active with the same second point F but a second vertex Y that is not equal to E."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Associated with second id S, with third vertex I, whenever there is an Associated with second id S, with third vertex A different from I.",
            "NL": "It is not allowed to set up a connection between second id S and third vertex A when there is already a connection between second id S and third vertex I, provided that A is not the same as I."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Associated with second id S, with third vertex I, whenever there is an Associated with second id S, with third vertex A different from I.",
            "NL": "When there is an Associated with second id S and third vertex I, it is forbidden to create an Associated with second id S and third vertex A that does not match I."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Associated with second id S, with third vertex I, whenever there is an Associated with second id S, with third vertex A different from I.",
            "NL": "Whenever there is an Associated with second id S and third vertex I, it is not allowed to create an Associated with second id S and third vertex A, if A is not equal to I."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Associated with second id S, with third vertex I, whenever there is an Associated with second id S, with third vertex A different from I.",
            "NL": "It is forbidden to create an association between Second Identifier S and Third Vertex A if there already exists an association between Second Identifier S and Third Vertex I, provided that A is not equal to I."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Associated with second id S, with third vertex I, whenever there is an Associated with second id S, with third vertex A different from I.",
            "NL": "When there is an Association with second id S and third vertex I, it is not allowed to create an Association with second id S and third vertex A, unless A is the same as I."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Employed_Edge with node6 M, whenever there is not a NotFirst with key6 M, whenever there is not an Probability_Value with value9 M, with node2 O, whenever there is not an Probability_Value with value9 M, with node2 K, whenever there is not a Elabel with key6 M.",
            "NL": "When there is not an Employed_Edge with node6 M, a NotFirst with key6 M, or a Probability_Value with value9 M and node2 O or K, it is prohibited for there to be an Elabel with key6 M."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Employed_Edge with node6 M, whenever there is not a NotFirst with key6 M, whenever there is not an Probability_Value with value9 M, with node2 O, whenever there is not an Probability_Value with value9 M, with node2 K, whenever there is not a Elabel with key6 M.",
            "NL": "When there is not an Employed_Edge with node6 M, NotFirst with key6 M, Probability_Value with value9 M, node2 O, or Elabel with key6 M, it is prohibited."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Employed_Edge with node6 M, whenever there is not a NotFirst with key6 M, whenever there is not an Probability_Value with value9 M, with node2 O, whenever there is not an Probability_Value with value9 M, with node2 K, whenever there is not a Elabel with key6 M.",
            "NL": "It is forbidden for there to be an Employed_Edge with node6 M present if there is not a NotFirst with key6 M, or if there is not a Probability_Value with value9 M, with node2 O, or if there is not a Probability_Value with value9 M, with node2 K, or if there is not an Elabel with key6 M."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Employed_Edge with node6 M, whenever there is not a NotFirst with key6 M, whenever there is not an Probability_Value with value9 M, with node2 O, whenever there is not an Probability_Value with value9 M, with node2 K, whenever there is not a Elabel with key6 M.",
            "NL": "It is forbidden for an Employed_Edge with node6 M to be present when there is not a NotFirst with key6 M, and for a Probability_Value with value9 M, with node2 O or K, to be present when there is not an Elabel with key6 M."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Employed_Edge with node6 M, whenever there is not a NotFirst with key6 M, whenever there is not an Probability_Value with value9 M, with node2 O, whenever there is not an Probability_Value with value9 M, with node2 K, whenever there is not a Elabel with key6 M.",
            "NL": "When there is not an Employed_Edge with node6 M, NotFirst with key6 M, Probability_Value with value9 M and node2 O, or Elabel with key6 M, it is prohibited."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Euler_Trail with key7 J, with node4 W, whenever there is a Alpha_Value with key7 J, with node4 G at most X, whenever there is a Subsequently with key7 W, with node4 X.",
            "NL": "Whenever there is an Alpha_Value with key7 J, with node4 G, where G is at most X, and a Subsequently with key7 W, with node4 X, a prohibition is in place against an Euler_Trail with key7 J, with node4 W."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Euler_Trail with key7 J, with node4 W, whenever there is a Alpha_Value with key7 J, with node4 G at most X, whenever there is a Subsequently with key7 W, with node4 X.",
            "NL": "Whenever there is an Alpha_Value with key7 J, node4 G, where G is at most X, and a Subsequently with key7 W, node4 X, there is a prohibition against having an Euler_Trail with key7 J, node4 W."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Euler_Trail with key7 J, with node4 W, whenever there is a Alpha_Value with key7 J, with node4 G at most X, whenever there is a Subsequently with key7 W, with node4 X.",
            "NL": "Whenever there is an Alpha_Value with key7 J, with node4 G, where G is at most X and a Subsequently with key7 W, with node4 X, a prohibition exists against having an Euler_Trail with key7 J, with node4 W."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Euler_Trail with key7 J, with node4 W, whenever there is a Alpha_Value with key7 J, with node4 G at most X, whenever there is a Subsequently with key7 W, with node4 X.",
            "NL": "Whenever there is an Euler_Trail with key7 J, node4 W, an Alpha_Value with key7 J, node4 G where G is at most X, and a Subsequently with key7 W, node4 X, there is a prohibition against it."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Euler_Trail with key7 J, with node4 W, whenever there is a Alpha_Value with key7 J, with node4 G at most X, whenever there is a Subsequently with key7 W, with node4 X.",
            "NL": "Whenever there is an Alpha_Value with key7 J, node4 G, and G is at most X, and a Subsequently with key7 W, node4 X, there is a prohibition against having an Euler_Trail with key7 J, node4 W."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Eulerian_Circuit with second node N, with third node Q, whenever there is a Eulerian_Circuit with second node N, with third node F different from Q.",
            "NL": "If an Eulerian_Circuit exists with second node N and third node Q, it is not allowed to set up an Eulerian_Circuit with second node N and third node F if F is not equal to Q."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Eulerian_Circuit with second node N, with third node Q, whenever there is a Eulerian_Circuit with second node N, with third node F different from Q.",
            "NL": "It is forbidden to construct an Eulerian_Circuit with second node N and third node F if there is already an Eulerian_Circuit with second node N and third node Q and F is not the same as Q."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Eulerian_Circuit with second node N, with third node Q, whenever there is a Eulerian_Circuit with second node N, with third node F different from Q.",
            "NL": "It is not allowed to create an Eulerian_Circuit with second node N and third node F if there is already an Eulerian_Circuit with second node N and third node Q, unless F is the same as Q."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Eulerian_Circuit with second node N, with third node Q, whenever there is a Eulerian_Circuit with second node N, with third node F different from Q.",
            "NL": "When there is an Eulerian_Circuit with second node N and third node Q, it is not allowed to create an Eulerian_Circuit with second node N and third node F if F does not equal Q."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Eulerian_Circuit with second node N, with third node Q, whenever there is a Eulerian_Circuit with second node N, with third node F different from Q.",
            "NL": "It is not allowed to construct an Eulerian_Circuit with second node N and third node F, if there already exists an Eulerian_Circuit with second node N and third node Q, with F not being the same as Q."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Hamgraph with first node X different from J, with third vertex P, whenever there is a Hamgraph with first node J, with third vertex P.",
            "NL": "It is not allowed to build a Hamgraph with first node J and third vertex P if a Hamgraph with first node X and third vertex P already exists, where J is not equal to X."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Hamgraph with first node X different from J, with third vertex P, whenever there is a Hamgraph with first node J, with third vertex P.",
            "NL": "Establishing a Hamgraph with first node J and third vertex P is not allowed when there is already a Hamgraph with first node X and third vertex P, as long as J is not the same as X."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Hamgraph with first node X different from J, with third vertex P, whenever there is a Hamgraph with first node J, with third vertex P.",
            "NL": "Creating a Hamgraph with first node J and third vertex P is not allowed if there is already a Hamgraph with first node X and third vertex P, and J is not equal to X."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Hamgraph with first node X different from J, with third vertex P, whenever there is a Hamgraph with first node J, with third vertex P.",
            "NL": "It is not allowed to create a Hamgraph with first node J and third vertex P if there is already a Hamgraph with first node X and third vertex P, where J and X are not the same."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Hamgraph with first node X different from J, with third vertex P, whenever there is a Hamgraph with first node J, with third vertex P.",
            "NL": "It is forbidden to set up a Hamgraph with first node J and third vertex P if a Hamgraph with first node X and third vertex P already exists, where J is not equal to X."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an In_Hamiltonian with fifth node X, with fifth point W, whenever there is an In_Hamiltonian with fifth node X, with fifth point Y different from W.",
            "NL": "Establishing an In_Hamiltonian with fifth node X and fifth point Y is not allowed if there is already an In_Hamiltonian with fifth node X and fifth point W, and Y is not equal to W."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an In_Hamiltonian with fifth node X, with fifth point W, whenever there is an In_Hamiltonian with fifth node X, with fifth point Y different from W.",
            "NL": "Establishing an In_Hamiltonian with fifth node X and fifth point Y is prohibited if there is already an In_Hamiltonian with fifth node X and fifth point W, and Y is not equal to W."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an In_Hamiltonian with fifth node X, with fifth point W, whenever there is an In_Hamiltonian with fifth node X, with fifth point Y different from W.",
            "NL": "Establishing an In_Hamiltonian with fifth node X and fifth point Y is not allowed when there is already an In_Hamiltonian with fifth node X and fifth point W, unless Y is equal to W."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an In_Hamiltonian with fifth node X, with fifth point W, whenever there is an In_Hamiltonian with fifth node X, with fifth point Y different from W.",
            "NL": "Establishing an In_Hamiltonian with fifth node X and fifth point Y is not allowed when there is already an In_Hamiltonian with fifth node X and fifth point W, as long as Y is not the same as W."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an In_Hamiltonian with fifth node X, with fifth point W, whenever there is an In_Hamiltonian with fifth node X, with fifth point Y different from W.",
            "NL": "It is forbidden to set up an In_Hamiltonian with fifth node X and fifth point Y if there is already an In_Hamiltonian with fifth node X and fifth point W, and Y is not equal to W."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Incidence_Matrix with fifth node O, with first node Q, whenever there is an Incidence_Matrix with fifth node O, with first node D different from Q.",
            "NL": "No Incidence_Matrix with fifth node O and first node D can be created if there is an existing Incidence_Matrix with fifth node O and first node Q, and D does not equal Q."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Incidence_Matrix with fifth node O, with first node Q, whenever there is an Incidence_Matrix with fifth node O, with first node D different from Q.",
            "NL": "When there is an Incidence_Matrix with fifth node O and first node Q, it is not allowed to create another Incidence_Matrix with fifth node O and first node D if D is not equal to Q."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Incidence_Matrix with fifth node O, with first node Q, whenever there is an Incidence_Matrix with fifth node O, with first node D different from Q.",
            "NL": "When there is an Incidence_Matrix with fifth node O and first node Q, and D is not equal to Q, it is not allowed to create an Incidence_Matrix with fifth node O and first node D."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Incidence_Matrix with fifth node O, with first node Q, whenever there is an Incidence_Matrix with fifth node O, with first node D different from Q.",
            "NL": "It is not allowed to create an Incidence_Matrix with fifth node O and first node D if an Incidence_Matrix with fifth node O and first node Q exists, and D is not equal to Q."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Incidence_Matrix with fifth node O, with first node Q, whenever there is an Incidence_Matrix with fifth node O, with first node D different from Q.",
            "NL": "It is not allowed to create an Incidence_Matrix with fifth node O and first node D if there is already an Incidence_Matrix with fifth node O and first node Q, where D does not equal Q."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Index with key1 A, whenever there is not a Indication with edge2 A, whenever there is not an In with key8 A, with field2 X, whenever there is not an In with key8 A, with field2 N, whenever there is not a Out with edge2 A.",
            "NL": "It is not allowed to have an Index with key1 A if there is no Indication with edge2 A, or an In with key8 A and field2 X, or an In with key8 A and field2 N, or an Out with edge2 A."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Index with key1 A, whenever there is not a Indication with edge2 A, whenever there is not an In with key8 A, with field2 X, whenever there is not an In with key8 A, with field2 N, whenever there is not a Out with edge2 A.",
            "NL": "It is forbidden to have an Index with key1 A, if there is not an Indication with edge2 A, and if there is not an In with key8 A, with field2 X, and if there is not an In with key8 A, with field2 N, and if there is not an Out with edge2 A."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Index with key1 A, whenever there is not a Indication with edge2 A, whenever there is not an In with key8 A, with field2 X, whenever there is not an In with key8 A, with field2 N, whenever there is not a Out with edge2 A.",
            "NL": "It is prohibited for there to be an Index with key1 A if there is no Indication with edge2 A, an In with key8 A and field2 X, an In with key8 A and field2 N, or an Out with edge2 A."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Index with key1 A, whenever there is not a Indication with edge2 A, whenever there is not an In with key8 A, with field2 X, whenever there is not an In with key8 A, with field2 N, whenever there is not a Out with edge2 A.",
            "NL": "When there is no Index with key1 A, no Indication with edge2 A, no In with key8 A and field2 X, and no In with key8 A and field2 N, it is prohibited to have an Out with edge2 A."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Index with key1 A, whenever there is not a Indication with edge2 A, whenever there is not an In with key8 A, with field2 X, whenever there is not an In with key8 A, with field2 N, whenever there is not a Out with edge2 A.",
            "NL": "It is not allowed to have an Index with key1 A if there is no Indication with edge2 A, an In with key8 A and field2 X, an In with key8 A and field2 N, or an Out with edge2 A."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an IngoingPath with third point Y different from Z, with second vertex I, whenever there is an IngoingPath with third point Z, with second vertex I.",
            "NL": "Establishing an IngoingPath with third point Z and second vertex I is prohibited if there is already an IngoingPath with third point Y and second vertex I and Z is not equal to Y."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an IngoingPath with third point Y different from Z, with second vertex I, whenever there is an IngoingPath with third point Z, with second vertex I.",
            "NL": "Establishing an IngoingPath with third point Z and second vertex I is not allowed when there is already an IngoingPath with third point Y and second vertex I, and Z is not the same as Y."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an IngoingPath with third point Y different from Z, with second vertex I, whenever there is an IngoingPath with third point Z, with second vertex I.",
            "NL": "When third point Y and second vertex I have an IngoingPath, it is not allowed to create an IngoingPath with third point Z and second vertex I, unless Z is the same as Y."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an IngoingPath with third point Y different from Z, with second vertex I, whenever there is an IngoingPath with third point Z, with second vertex I.",
            "NL": "When third point Z is not the same as third point Y and second vertex I is the same for both, it is not allowed to create an IngoingPath with third point Z and second vertex I if one already exists with third point Y and second vertex I."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an IngoingPath with third point Y different from Z, with second vertex I, whenever there is an IngoingPath with third point Z, with second vertex I.",
            "NL": "Whenever third point Z and second vertex I are used to create an IngoingPath and third point Y and second vertex I are already in an IngoingPath, and Z is not equal to Y, establishing an IngoingPath is prohibited."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an inPath with first vtx X, with second vtx Y1, whenever there is a inPath with first vtx X, with second vtx Y different from Y1.",
            "NL": "Establishing an inPath with the same first vertex X and second vertex Y is prohibited when Y is not equal to Y1, if there already exists an inPath with X and Y1."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an inPath with first vtx X, with second vtx Y1, whenever there is a inPath with first vtx X, with second vtx Y different from Y1.",
            "NL": "It is not allowed to make an inPath with X as the first vertex and Y as the second vertex if there is already an inPath with X as the first vertex and a different vertex, Y1, as the second vertex."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an inPath with first vtx X, with second vtx Y1, whenever there is a inPath with first vtx X, with second vtx Y different from Y1.",
            "NL": "It is forbidden to create an inPath with X as the first vertex and Y as the second vertex if there is already an existing inPath with X as the first vertex and Y1 as the second vertex, where Y and Y1 are not the same."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an inPath with first vtx X, with second vtx Y1, whenever there is a inPath with first vtx X, with second vtx Y different from Y1.",
            "NL": "Establishing an inPath with first vertex X and second vertex Y is not allowed when there is already an inPath with first vertex X and second vertex Y1, and Y is not equal to Y1."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an inPath with first vtx X, with second vtx Y1, whenever there is a inPath with first vtx X, with second vtx Y different from Y1.",
            "NL": "No inPath may be set up between vertices X and Y if an inPath already exists between X and Y1, with Y1 being different from Y."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an inPath with first vtx X1 different from X, with second vtx Y, whenever there is a inPath with first vtx X, with second vtx Y. ",
            "NL": "It is forbidden to create an inPath with X as the starting point and Y as the end point if there is already an inPath between X1 and Y, where X and X1 are not the same."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an inPath with first vtx X1 different from X, with second vtx Y, whenever there is a inPath with first vtx X, with second vtx Y. ",
            "NL": "It is forbidden to construct an inPath with X as the first vertex and Y as the second vertex if an inPath already exists with X1 as the first vertex and Y as the second vertex, with X and X1 not being the same."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an inPath with first vtx X1 different from X, with second vtx Y, whenever there is a inPath with first vtx X, with second vtx Y. ",
            "NL": "Establishing an inPath with the first vertex being X and the second vertex being Y is not allowed when there already exists an inPath with the first vertex being X1 and the second vertex being Y, provided that X is not equal to X1."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an inPath with first vtx X1 different from X, with second vtx Y, whenever there is a inPath with first vtx X, with second vtx Y. ",
            "NL": "It is forbidden to create an inPath from X to Y if there already exists an inPath from X1 to Y, where X and X1 are not the same."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an inPath with first vtx X1 different from X, with second vtx Y, whenever there is a inPath with first vtx X, with second vtx Y. ",
            "NL": "Establishing an inPath with first vertex X and second vertex Y is not allowed if there is already an existing inPath with first vertex X1 and second vertex Y, when X and X1 are not the same."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Input_Data with second id B different from K, with fourth vertex Q, whenever there is a Input_Data with second id K, with fourth vertex Q.",
            "NL": "It is not allowed to create an Input_Data with second id K and fourth vertex Q if there is already an Input_Data with second id B and fourth vertex Q, and K is not equal to B."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Input_Data with second id B different from K, with fourth vertex Q, whenever there is a Input_Data with second id K, with fourth vertex Q.",
            "NL": "It is forbidden to create an Input_Data with second id K and fourth vertex Q if there is already an Input_Data with second id B and fourth vertex Q, provided K is not the same as B."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Input_Data with second id B different from K, with fourth vertex Q, whenever there is a Input_Data with second id K, with fourth vertex Q.",
            "NL": "Establishing an Input_Data with second id K and fourth vertex Q is not allowed if there is already an existing Input_Data with second id B and fourth vertex Q, as long as K is not equal to B."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Input_Data with second id B different from K, with fourth vertex Q, whenever there is a Input_Data with second id K, with fourth vertex Q.",
            "NL": "It is not allowed to create an Input_Data with second id K and fourth vertex Q if there is already an Input_Data with second id B and fourth vertex Q, provided that K and B are not the same."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Input_Data with second id B different from K, with fourth vertex Q, whenever there is a Input_Data with second id K, with fourth vertex Q.",
            "NL": "If Input_Data with second id B and fourth vertex Q exists, it is not allowed to create another Input_Data with second id K and fourth vertex Q, unless K is equal to B."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Investigate with node X, whenever there is Investigate with node L, whenever there is not a Nonclique with vtx8 X, whenever there is not a Nonclique with vtx8 L different from X, whenever there is a Unmatch with node8 L, with id3 X, with key3 T, whenever there is not a Maximum_Matching with node8 L, with id3 X, with key3 T. ",
            "NL": "It is forbidden to have an Investigate with node X, an Investigate with node L, no Nonclique with vtx8 X, no Nonclique with vtx8 L, an Unmatch with node8 L, with id3 X, with key3 T, where W is not equal to X, if there is not a Maximum_Matching with node8 L, with id3 X, with key3 T."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Investigate with node X, whenever there is Investigate with node L, whenever there is not a Nonclique with vtx8 X, whenever there is not a Nonclique with vtx8 L different from X, whenever there is a Unmatch with node8 L, with id3 X, with key3 T, whenever there is not a Maximum_Matching with node8 L, with id3 X, with key3 T. ",
            "NL": "It is forbidden to conduct an Investigation with node X, an Investigation with node L, a Nonclique with vtx8 X, a Nonclique with vtx8 L, an Unmatch with node8 L, with id3 X, with key3 T, when W does not equal X, unless there is a Maximum_Matching with node8 L, with id3 X, with key3 T."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Investigate with node X, whenever there is Investigate with node L, whenever there is not a Nonclique with vtx8 X, whenever there is not a Nonclique with vtx8 L different from X, whenever there is a Unmatch with node8 L, with id3 X, with key3 T, whenever there is not a Maximum_Matching with node8 L, with id3 X, with key3 T. ",
            "NL": "Whenever there is not a Maximum_Matching with node8 L, id3 X, and key3 T, it is prohibited to have an Investigate with node X, an Investigate with node L, a Nonclique with vtx8 X, and a Nonclique with vtx8 L, and an Unmatch with node8 L, id3 X, and key3 T, where W is not equal to X."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Investigate with node X, whenever there is Investigate with node L, whenever there is not a Nonclique with vtx8 X, whenever there is not a Nonclique with vtx8 L different from X, whenever there is a Unmatch with node8 L, with id3 X, with key3 T, whenever there is not a Maximum_Matching with node8 L, with id3 X, with key3 T. ",
            "NL": "No Investigate with node X is allowed, Investigate with node L is permitted, Nonclique with vtx8 X is not allowed, Nonclique with vtx8 L is not allowed, Unmatch with node8 L, with id3 X, with key3 T is allowed, provided that W is not equal to X, unless Maximum_Matching with node8 L, with id3 X, with key3 T is present."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Investigate with node X, whenever there is Investigate with node L, whenever there is not a Nonclique with vtx8 X, whenever there is not a Nonclique with vtx8 L different from X, whenever there is a Unmatch with node8 L, with id3 X, with key3 T, whenever there is not a Maximum_Matching with node8 L, with id3 X, with key3 T. ",
            "NL": "It is not allowed for there to be an Investigation with node X, an Investigation with node L, no Nonclique with vtx8 X, no Nonclique with vtx8 L, an Unmatch with node8 L, with id3 X, with key3 T, where W is not equal to X, and no Maximum_Matching with node8 L, with id3 X, with key3 T."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an order with value X, with id Y, whenever there is a tran with value X, with id Z less than Y, whenever there is a Atomcnt with value N less than Z. ",
            "NL": "Whenever there is an order with value X, and ID Y, and an Atomicnt with value N less than Z, it is prohibited for there to be a Trans with value X and ID Z that is less than Y."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an order with value X, with id Y, whenever there is a tran with value X, with id Z less than Y, whenever there is a Atomcnt with value N less than Z. ",
            "NL": "Whenever there is an order with value X, with ID Y, and an Atomcnt with value N that is less than Z, it is prohibited for there to be a trans with value X, with ID Z that is less than Y."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an order with value X, with id Y, whenever there is a tran with value X, with id Z less than Y, whenever there is a Atomcnt with value N less than Z. ",
            "NL": "Whenever there is an order with value X and ID Y, and an Atomicnt with value N less than Z, it is prohibited to have a trans with value X and ID Z lower than Y."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an order with value X, with id Y, whenever there is a tran with value X, with id Z less than Y, whenever there is a Atomcnt with value N less than Z. ",
            "NL": "Whenever there is an order with value X, with ID Y, and an Atomcnt with value N less than Z, it is forbidden for there to be a trans with value X, with ID Z lower than Y."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an order with value X, with id Y, whenever there is a tran with value X, with id Z less than Y, whenever there is a Atomcnt with value N less than Z. ",
            "NL": "Whenever there is an Atomicnt with value N less than Z, and an order with value X and ID Y, it is prohibited for there to be a trans with value X and ID Z that is lesser than Y."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Out_HamiltonianCycle with second node C different from D, with fourth point H, whenever there is an Out_HamiltonianCycle with second node D, with fourth point H.",
            "NL": "If there is an Out_HamiltonianCycle with second node C and fourth point H, it is not allowed to construct an Out_HamiltonianCycle with second node D and fourth point H if D is not the same as C."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Out_HamiltonianCycle with second node C different from D, with fourth point H, whenever there is an Out_HamiltonianCycle with second node D, with fourth point H.",
            "NL": "It is not allowed to create an Out_HamiltonianCycle that has second node D and fourth point H when there is already an Out_HamiltonianCycle with second node C and fourth point H, as long as D is not the same as C."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Out_HamiltonianCycle with second node C different from D, with fourth point H, whenever there is an Out_HamiltonianCycle with second node D, with fourth point H.",
            "NL": "If an Out_HamiltonianCycle exists with second node C and fourth point H, it is not allowed to create another Out_HamiltonianCycle with second node D and fourth point H if D is not equal to C."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Out_HamiltonianCycle with second node C different from D, with fourth point H, whenever there is an Out_HamiltonianCycle with second node D, with fourth point H.",
            "NL": "It is not allowed to create an Out_HamiltonianCycle with second node D and fourth point H when another Out_HamiltonianCycle with second node C and fourth point H exists, provided that D is not the same as C."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Out_HamiltonianCycle with second node C different from D, with fourth point H, whenever there is an Out_HamiltonianCycle with second node D, with fourth point H.",
            "NL": "It is not allowed to create an Out_HamiltonianCycle with second node D and fourth point H if an Out_HamiltonianCycle with second node C and fourth point H already exists, provided that D is not the same as C."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Outgoing with fifth vertex P different from O, with second node E, whenever there is a Outgoing with fifth vertex O, with second node E.",
            "NL": "It is not allowed to create an Outgoing connection with fifth vertex O and second node E if there is already an Outgoing connection with fifth vertex P and second node E, and O is not the same as P."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Outgoing with fifth vertex P different from O, with second node E, whenever there is a Outgoing with fifth vertex O, with second node E.",
            "NL": "It is forbidden to create an Outgoing with fifth vertex O and second node E if there is already an Outgoing with fifth vertex P and second node E, provided that O is not the same as P."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Outgoing with fifth vertex P different from O, with second node E, whenever there is a Outgoing with fifth vertex O, with second node E.",
            "NL": "It is not allowed to create an Outgoing with fifth vertex O and second node E when there is already an Outgoing with fifth vertex P and second node E, where O and P are not the same."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Outgoing with fifth vertex P different from O, with second node E, whenever there is a Outgoing with fifth vertex O, with second node E.",
            "NL": "It is not allowed to have an Outgoing with fifth vertex O and second node E when there is already an Outgoing with fifth vertex P and second node E, and O is not the same as P."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Outgoing with fifth vertex P different from O, with second node E, whenever there is a Outgoing with fifth vertex O, with second node E.",
            "NL": "It is not allowed to create an Outgoing from fifth vertex O to second node E when there is already an Outgoing from fifth vertex P to second node E, as long as O is not the same as P."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an OutgoingRoute with value1 N, whenever there is not a Longest_Path with value1 N, whenever there is not a Selected_Color with value1 N.",
            "NL": "Whenever a Longest_Path with value1 N or a Selected_Color with value1 N does not exist, it is prohibited for an OutgoingRoute to have value1 N."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an OutgoingRoute with value1 N, whenever there is not a Longest_Path with value1 N, whenever there is not a Selected_Color with value1 N.",
            "NL": "It is prohibited that an OutgoingRoute with a value of N is present if there is not a Longest_Path with a value of N or a Selected_Color with a value of N."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an OutgoingRoute with value1 N, whenever there is not a Longest_Path with value1 N, whenever there is not a Selected_Color with value1 N.",
            "NL": "It is forbidden for an OutgoingRoute to have value1 N if there is no Longest_Path with value1 N or Selected_Color with value1 N."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an OutgoingRoute with value1 N, whenever there is not a Longest_Path with value1 N, whenever there is not a Selected_Color with value1 N.",
            "NL": "If there is no Longest_Path with value1 N or Selected_Color with value1 N, then there must not be an OutgoingRoute with value1 N."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an OutgoingRoute with value1 N, whenever there is not a Longest_Path with value1 N, whenever there is not a Selected_Color with value1 N.",
            "NL": "It is forbidden to have an OutgoingRoute with value1 N if there is no Longest_Path with value1 N or Selected_Color with value1 N."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Painted with fifth point H different from S, with first id X, whenever there is a Painted with fifth point S, with first id X.",
            "NL": "Establishing a Painted with fifth point S and first id X is not allowed if there is already a Painted with fifth point H and first id X, provided that S is not equal to H."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Painted with fifth point H different from S, with first id X, whenever there is a Painted with fifth point S, with first id X.",
            "NL": "Establishing a Painted with fifth point S and first id X is not allowed if there is already a Painted with fifth point H and first id X present, provided that S is not equal to H."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Painted with fifth point H different from S, with first id X, whenever there is a Painted with fifth point S, with first id X.",
            "NL": "Establishing a Painted with fifth point S and first id X is not allowed if there is already a Painted with fifth point H and first id X present, provided that S does not equal H."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Painted with fifth point H different from S, with first id X, whenever there is a Painted with fifth point S, with first id X.",
            "NL": "Establishing a Painted with fifth point S and first id X is not allowed if there is already a Painted with fifth point H and first id X present, where S is not the same as H."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Painted with fifth point H different from S, with first id X, whenever there is a Painted with fifth point S, with first id X.",
            "NL": "Establishing a Painted with fifth point S and first id X is not allowed when there is already a Painted with fifth point H and first id X present, where S and H are not equal."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Trail with first node L different from A, with second node G, whenever there is a Trail with first node A, with second node G.",
            "NL": "Establishing a Trail with first node A and second node G is not allowed when there is already a Trail with first node L and second node G, as long as A is not equal to L."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Trail with first node L different from A, with second node G, whenever there is a Trail with first node A, with second node G.",
            "NL": "It is not allowed to create a Path with first node A and second node G if there is already a Path with first node L and second node G, and A is not equal to L."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Trail with first node L different from A, with second node G, whenever there is a Trail with first node A, with second node G.",
            "NL": "Establishing a Trail between first node A and second node G is not allowed if there is already a Trail between first node L and second node G, and A does not equal L."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Trail with first node L different from A, with second node G, whenever there is a Trail with first node A, with second node G.",
            "NL": "Establishing a Trail with first node A and second node G is not allowed if there is already a Trail with first node L and second node G and A is not equal to L."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Trail with first node L different from A, with second node G, whenever there is a Trail with first node A, with second node G.",
            "NL": "It is not allowed to create a Trail between Node A and Node G if there is already a Trail between Node L and Node G, and A is not the same as L."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Tree with third vertex G, with first vertex J, whenever there is a Tree with third vertex G, with first vertex A different from J.",
            "NL": "It is not allowed to create a Tree with third vertex G and first vertex A if there is already a Tree with third vertex G and first vertex J, provided A is not the same as J."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Tree with third vertex G, with first vertex J, whenever there is a Tree with third vertex G, with first vertex A different from J.",
            "NL": "It is not allowed to create a Tree with third vertex G and first vertex A if there is already a Tree with third vertex G and first vertex J, where A and J are not the same."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Tree with third vertex G, with first vertex J, whenever there is a Tree with third vertex G, with first vertex A different from J.",
            "NL": "It is not allowed to create a Tree with a third vertex of G and a first vertex of A if there is already a Tree with a third vertex of G and a first vertex of J, where A does not equal J."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Tree with third vertex G, with first vertex J, whenever there is a Tree with third vertex G, with first vertex A different from J.",
            "NL": "It is not allowed to create a Tree with third vertex G and first vertex A when there is already a Tree with third vertex G and first vertex J, and A is not the same as J."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Tree with third vertex G, with first vertex J, whenever there is a Tree with third vertex G, with first vertex A different from J.",
            "NL": "Whenever a Tree exists with a third vertex G and a first vertex J, it is not allowed to construct another Tree with a third vertex G and a first vertex A if A is not equal to J."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Undirected_Graph with first point X different from V, with first id U, whenever there is an Undirected_Graph with first point V, with first id U.",
            "NL": "It is not allowed to create an Undirected_Graph with first point V and first id U if there is already an Undirected_Graph with first point X and first id U, and V is not the same as X."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Undirected_Graph with first point X different from V, with first id U, whenever there is an Undirected_Graph with first point V, with first id U.",
            "NL": "Establishing an Undirected_Graph with first point V and first id U is not allowed if there is already an Undirected_Graph with first point X and first id U, and V is not equal to X."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Undirected_Graph with first point X different from V, with first id U, whenever there is an Undirected_Graph with first point V, with first id U.",
            "NL": "It is not allowed to create an Undirected_Graph with the first point V and first id U if there is already an Undirected_Graph with first point X and the same first id U, and V is not equal to X."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Undirected_Graph with first point X different from V, with first id U, whenever there is an Undirected_Graph with first point V, with first id U.",
            "NL": "It is not allowed to create an Undirected_Graph with first point V and first id U if there is already an Undirected_Graph with first point X and first id U, where V is not the same as X."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Undirected_Graph with first point X different from V, with first id U, whenever there is an Undirected_Graph with first point V, with first id U.",
            "NL": "Establishing an Undirected_Graph with a first point V and first id U is forbidden if there is already an Undirected_Graph with first point X and first id U, where V is not the same as X."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Undirected_Graph with vtx9 L, with vtx2 A, whenever there is a Unit with vtx9 L, with vtx2 W not after M, whenever there is a Arrowed with vtx9 A, with vtx2 M.",
            "NL": "Whenever there is an Undirected_Graph with vtx9 L and vtx2 A, or an Unit with vtx9 L and vtx2 W where W is not after M, and an Arrowed with vtx9 A and vtx2 M, a prohibition applies."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Undirected_Graph with vtx9 L, with vtx2 A, whenever there is a Unit with vtx9 L, with vtx2 W not after M, whenever there is a Arrowed with vtx9 A, with vtx2 M.",
            "NL": "Whenever there is an Undirected_Graph with vtx9 L and vtx2 A, as well as an Unit with vtx9 L and vtx2 W, where W is not after M, and an Arrowed with vtx9 A and vtx2 M, it is prohibited."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Undirected_Graph with vtx9 L, with vtx2 A, whenever there is a Unit with vtx9 L, with vtx2 W not after M, whenever there is a Arrowed with vtx9 A, with vtx2 M.",
            "NL": "No Undirected_Graph with vtx9 L and vtx2 A shall be allowed if there is an Unit with vtx9 L and vtx2 W, where W is not after M, and an Arrowed with vtx9 A and vtx2 M is present."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Undirected_Graph with vtx9 L, with vtx2 A, whenever there is a Unit with vtx9 L, with vtx2 W not after M, whenever there is a Arrowed with vtx9 A, with vtx2 M.",
            "NL": "No Undirected_Graph can exist with vtx9 L, and vtx2 A, if an Unit with vtx9 L, and vtx2 W, where W is not after M, is present, and there is an Arrowed with vtx9 A, and vtx2 M."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is an Undirected_Graph with vtx9 L, with vtx2 A, whenever there is a Unit with vtx9 L, with vtx2 W not after M, whenever there is a Arrowed with vtx9 A, with vtx2 M.",
            "NL": "No Undirected_Graph with vtx9 L and vtx2 A should be created if an Unit with vtx9 L and vtx2 W exists, provided W is not after M, and there is an Arrowed with vtx9 A and vtx2 M."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is Enumeration with id1 U.",
            "NL": "Having an Enumeration with id1 U is not allowed."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is Enumeration with id1 U.",
            "NL": "It is not allowed to list items with id1 U."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is Enumeration with id1 U.",
            "NL": "It is not allowed to have an itemized list with id1 U."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is Enumeration with id1 U.",
            "NL": "No Enumeration with id1 U is allowed."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is Enumeration with id1 U.",
            "NL": "It is not allowed to have an Enumeration with the id1 U."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is Eulerian_Circuit with value3 P, with node2 H.",
            "NL": "It is not permissible to have an Eulerian Circuit with node2 H and value3 P."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is Eulerian_Circuit with value3 P, with node2 H.",
            "NL": "It is not permissible to have a Eulerian Circuit with a value of 3P and node 2H."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is Eulerian_Circuit with value3 P, with node2 H.",
            "NL": "The node2 H is not permitted to have an Eulerian_Circuit with value3 P, therefore."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is Eulerian_Circuit with value3 P, with node2 H.",
            "NL": "It is not permissible to have an Eulerian Circuit with value 3P that has node 2H."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is Eulerian_Circuit with value3 P, with node2 H.",
            "NL": "Therefore, it is not permissible to have a Eulerian_Circuit that has node2 H and has a value3 P."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is Inorder with key4 C.",
            "NL": "It is not allowed to use key4 to conduct an Inorder."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is Inorder with key4 C.",
            "NL": "It is not allowed to use key4 for an Inorder."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is Inorder with key4 C.",
            "NL": "It is not permitted to use key4 for an Inorder."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is Inorder with key4 C.",
            "NL": "It is not allowed to have an Inorder that uses key4."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is Inorder with key4 C.",
            "NL": "Having key4 Inorder is not allowed."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is Mark with id9 G, with value9 G. ",
            "NL": "Mark with ID9 G and value9 G is not allowed to exist."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is Mark with id9 G, with value9 G. ",
            "NL": "Mark's id9 G and value9 G are not allowed."
        },
		{
            "Category": "Definition Const/Compound",
            "CNL": "A blue is key9.",
            "NL": "The node key9 is blue."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "key8 is X.",
            "NL": "The name of the X is key8."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "There is a Includes with field7 K.",
            "NL": "There is a Includes with the field7 K. "
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "vtx6 16 has a Mass.",
            "NL": "There is a Mass with the vtx6 16."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is Mark with id9 G, with value9 G. ",
            "NL": "Mark with an id of 9G and a value of 9G is not allowed."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is Mark with id9 G, with value9 G. ",
            "NL": "It is forbidden for Mark with id9 G and value9 G to exist."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is Mark with id9 G, with value9 G. ",
            "NL": "Mark with ID9G and value9G is not allowed to exist."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is Maximum_Flow with key3 K, with id4 K. ",
            "NL": "It is forbidden to have Maximum_Flow with key3 K and with id4 K."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is Maximum_Flow with key3 K, with id4 K. ",
            "NL": "The Maximum_Flow with key3 K and id4 K is not allowed."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is Maximum_Flow with key3 K, with id4 K. ",
            "NL": "It is not allowed to have Maximum_Flow with key3 K and id4 K."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is Maximum_Flow with key3 K, with id4 K. ",
            "NL": "It is not allowed to have a Maximum_Flow with key3 K and id4 K."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is Maximum_Flow with key3 K, with id4 K. ",
            "NL": "The key3 K and id4 K Maximum_Flow is not allowed to exist."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is no_reached with vertex X.",
            "NL": "It is prohibited to have no contact with vertex X."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is no_reached with vertex X.",
            "NL": "It is prohibited to establish a connection with vertex X."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is no_reached with vertex X.",
            "NL": "It is forbidden to have no contact with vertex X."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is no_reached with vertex X.",
            "NL": "Vertex X is not allowed to be contacted."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is no_reached with vertex X.",
            "NL": "It is not allowed to have a connection with vertex X."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is Nonclique with field5 R, with key6 R. ",
            "NL": "It is forbidden to have Nonclique with field5 R and key6 R."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is Nonclique with field5 R, with key6 R. ",
            "NL": "The use of Nonclique with field5 R and key6 R is not allowed."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is Nonclique with field5 R, with key6 R. ",
            "NL": "It is not allowed for Nonclique to have field5 R and key6 R."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is Nonclique with field5 R, with key6 R. ",
            "NL": "It is forbidden for Nonclique to have field5 R and key6 R."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is Nonclique with field5 R, with key6 R. ",
            "NL": "Nonclique with field5 R and key6 R is not allowed."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is NonOriented with id7 J, with key S.",
            "NL": "Therefore, it is prohibited to have a NonOriented with ID7 J and key S."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is NonOriented with id7 J, with key S.",
            "NL": "Therefore, possessing a NonOriented with identification number 7 J and key S is not permissible."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is NonOriented with id7 J, with key S.",
            "NL": "Therefore, it is not permissible to have NonOriented J with id7 and key S."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is NonOriented with id7 J, with key S.",
            "NL": "Consequently, it is forbidden to have a NonOriented with id7 J and key S."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is NonOriented with id7 J, with key S.",
            "NL": "Therefore, it is not permissible to have a NonOriented with id7 J and key S."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is Partition with field3 A, with vtx2 A. ",
            "NL": "It is forbidden to have both Partition with field3 A and vtx2 A."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is Partition with field3 A, with vtx2 A. ",
            "NL": "It is not allowed to have Partition with field3 A and vtx2 A."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is Partition with field3 A, with vtx2 A. ",
            "NL": "Having Partition with field3 A and vtx2 A is not allowed."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is Partition with field3 A, with vtx2 A. ",
            "NL": "It is forbidden for Partition to have both field3 A and vtx2 A."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is Partition with field3 A, with vtx2 A. ",
            "NL": "It is not allowed to have a Partition with field3 A and vtx2 A."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is Passive with edge1 L.",
            "NL": "It is not allowed to possess a Passive with edge1 L."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is Passive with edge1 L.",
            "NL": "It is not allowed to possess an Passive with edge1 L."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is Passive with edge1 L.",
            "NL": "It is prohibited to possess a Passive with an edge1 L."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is Passive with edge1 L.",
            "NL": "It is not allowed to possess an edge1 L with a passive attitude."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is Passive with edge1 L.",
            "NL": "Having a Passive with edge1 L is not allowed."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is Planar_Graph with vtx3 B, with edge1 H.",
            "NL": "Therefore, it is not permissible to construct a Planar_Graph with vertex 3 B and edge 1 H."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is Planar_Graph with vtx3 B, with edge1 H.",
            "NL": "Therefore, it is prohibited to have a Planar_Graph with vertex 3 B and edge 1 H."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is Planar_Graph with vtx3 B, with edge1 H.",
            "NL": "Therefore, it is prohibited to construct a Planar_Graph containing vertex B and edge H."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is Planar_Graph with vtx3 B, with edge1 H.",
            "NL": "Therefore, it is not permissible to construct a Planar_Graph with vertex 3B and edge 1H."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is Planar_Graph with vtx3 B, with edge1 H.",
            "NL": "Therefore, it is not permissible to have a Planar_Graph with vertex 3 B connected by edge 1 H."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is Predominant with value1 I, with vtx2 I. ",
            "NL": "It is forbidden to have Predominant with value1 I and with vtx2 I."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is Predominant with value1 I, with vtx2 I. ",
            "NL": "It is forbidden to have Predominant with value1 I and vtx2 I."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is Predominant with value1 I, with vtx2 I. ",
            "NL": "The presence of anything with a value1 I and a vtx2 I is not allowed."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is Predominant with value1 I, with vtx2 I. ",
            "NL": "The presence of Predominant with value1 I and vtx2 I is not allowed."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is Predominant with value1 I, with vtx2 I. ",
            "NL": "It is forbidden to have both Predominant with value1 I and vtx2 I."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is r with id V, with id1 V.",
            "NL": "It is forbidden to have two entities with the same ID V and ID1 V."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is r with id V, with id1 V.",
            "NL": "It is forbidden for r to be present with both id V and id1 V."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is r with id V, with id1 V.",
            "NL": "It is not allowed to have two r's with the IDs V and V1."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is r with id V, with id1 V.",
            "NL": "It is not allowed to have two r's with V id and V id1."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is r with id V, with id1 V.",
            "NL": "It is forbidden to have two r's with the same ID V and ID1 V."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is r with id X, with id2 X1.",
            "NL": "Therefore, it is prohibited to possess an id X and id2 X1."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is r with id X, with id2 X1.",
            "NL": "Therefore, it is prohibited to possess an item with both ID X and ID X1."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is r with id X, with id2 X1.",
            "NL": "Therefore, it is prohibited to possess an r with ID X and ID2 X1."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is r with id X, with id2 X1.",
            "NL": "Therefore, it is not permissible to possess an r with id X and id2 X1."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is r with id X, with id2 X1.",
            "NL": "Consequently, possessing a r with id X and id2 X1 is prohibited."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is Thickness with id5 N.",
            "NL": "Having a Thickness with an id of 5 is not allowed."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is Thickness with id5 N.",
            "NL": "It is prohibited to have an item with an id5 N thickness."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is Thickness with id5 N.",
            "NL": "Having a Thickness with id5 is not allowed."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is Thickness with id5 N.",
            "NL": "Having a Thickness with an id5 of N is not allowed."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is Thickness with id5 N.",
            "NL": "It is not allowed to possess an item with id5 N that has a Thickness."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is Unmatched with id9 F.",
            "NL": "It is not allowed to possess an Unmatched item with id9 F."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is Unmatched with id9 F.",
            "NL": "Having an Unmatched with id9 F is not allowed."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is Unmatched with id9 F.",
            "NL": "It is not allowed to have an Unmatched item with an ID of 9F."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is Unmatched with id9 F.",
            "NL": "Having an Unmatched with id9 is not allowed."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that there is Unmatched with id9 F.",
            "NL": "It is not permitted to have an Unmatched with id9 F."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that W is not after T, whenever there is an Index with fourth vertex W, whenever there is an Index with fourth vertex T, whenever there is not Success with node6 W, and with key9 T, whenever there is not Success with node6 T, and with key9 W.",
            "NL": "It is forbidden to have an Index with fourth vertex W and an Index with fourth vertex T, and no Success with node6 W, key9 T, or Success with node6 T, key9 W."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that W is not after T, whenever there is an Index with fourth vertex W, whenever there is an Index with fourth vertex T, whenever there is not Success with node6 W, and with key9 T, whenever there is not Success with node6 T, and with key9 W.",
            "NL": "It is forbidden to have an Index with fourth vertex W and an Index with fourth vertex T, and there is no Success with node6 W, key9 T, nor any Success with node6 T, key9 W."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that W is not after T, whenever there is an Index with fourth vertex W, whenever there is an Index with fourth vertex T, whenever there is not Success with node6 W, and with key9 T, whenever there is not Success with node6 T, and with key9 W.",
            "NL": "It is not allowed to have an Index with fourth vertex W and an Index with fourth vertex T, nor is there an Success with node6 W, key9 T, or an Success with node6 T, key9 W."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that W is not after T, whenever there is an Index with fourth vertex W, whenever there is an Index with fourth vertex T, whenever there is not Success with node6 W, and with key9 T, whenever there is not Success with node6 T, and with key9 W.",
            "NL": "It is not allowed to have an Index with fourth vertex W and an Index with fourth vertex T, nor is there an Success with node6 W and key9 T, or an Success with node6 T and key9 W."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that W is not after T, whenever there is an Index with fourth vertex W, whenever there is an Index with fourth vertex T, whenever there is not Success with node6 W, and with key9 T, whenever there is not Success with node6 T, and with key9 W.",
            "NL": "It is not allowed to have an Index with fourth vertex W and an Index with fourth vertex T, nor is it permissible to have an Success with node6 W and key9 T or an Success with node6 T and key9 W."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when edge C is Begin then edge C is not Maximum_Matching.",
            "NL": "It is forbidden to not Maximum_Matching edge C when edge C is Begin."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when edge C is Begin then edge C is not Maximum_Matching.",
            "NL": "No Maximum_Matching of edge C is allowed when it is in the Begin state."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when edge C is Begin then edge C is not Maximum_Matching.",
            "NL": "It is prohibited to not Maximum_Matching edge C when edge C is Begin."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when edge C is Begin then edge C is not Maximum_Matching.",
            "NL": "It is not allowed to omit edge C when it is starting."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when edge C is Begin then edge C is not Maximum_Matching.",
            "NL": "It is forbidden to not Maximum_Match edge C when edge C is starting."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when edge4 E is NonConsecutive then edge4 E is not Edge_Level.",
            "NL": "It is not allowed to not Edge_Level edge4 E when edge4 E is NonConsecutive."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when edge4 E is NonConsecutive then edge4 E is not Edge_Level.",
            "NL": "It is forbidden to not Edge_Level edge4 E when edge4 E is NonConsecutive."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when edge4 E is NonConsecutive then edge4 E is not Edge_Level.",
            "NL": "It is forbidden to not use Edge Level Edge4E when Edge4E is not consecutive."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when edge4 E is NonConsecutive then edge4 E is not Edge_Level.",
            "NL": "Edge_Level edge4 E cannot be NonConsecutive."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when edge4 E is NonConsecutive then edge4 E is not Edge_Level.",
            "NL": "Edge Level edge4 E must not be NonConsecutive; it is prohibited."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when edge6 M is not Cut_Vertex edge6 M then vtx8 T is Network and also edge6 T is Network, where M is at most T.",
            "NL": "For edge6 M and T that are not Cut_Vertex, edge6 M can be a Network of at most the same size as edge6 T's Network."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when edge6 M is not Cut_Vertex edge6 M then vtx8 T is Network and also edge6 T is Network, where M is at most T.",
            "NL": "For edge6 M and T that are not Cut_Vertex, edge6 M can be a Network of up to T size."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when edge6 M is not Cut_Vertex edge6 M then vtx8 T is Network and also edge6 T is Network, where M is at most T.",
            "NL": "For edge6 M and T that are not Cut_Vertex, M can be a Network whose size is at most that of T, which is also a Network."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when edge6 M is not Cut_Vertex edge6 M then vtx8 T is Network and also edge6 T is Network, where M is at most T.",
            "NL": "For edge6 M and T that are not Cut_Vertex, edge6 M can be a Network if it is no larger than edge6 T, which can also be a Network."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when edge6 M is not Cut_Vertex edge6 M then vtx8 T is Network and also edge6 T is Network, where M is at most T.",
            "NL": "For edge6 M and T that are not Cut_Vertex, edge6 M can be a Network if it is no more than edge6 T, which can also be a Network."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when field E is Edge field B then field E is Edge Visit G and also field B is Edge Visit G, where E is at most B.",
            "NL": "If field E is bordered by field B, both fields must also be bordered by Visit G, and field E must not be larger than field B."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when field E is Edge field B then field E is Edge Visit G and also field B is Edge Visit G, where E is at most B.",
            "NL": "When field E is adjacent to field B, both fields are also adjacent to Visit G, with E being no farther than B."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when field E is Edge field B then field E is Edge Visit G and also field B is Edge Visit G, where E is at most B.",
            "NL": "If Field E is adjacent to Field B, then Field E must also be adjacent to Visit G, and Field B must also be adjacent to Visit G, with Field E being no further away than Field B."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when field E is Edge field B then field E is Edge Visit G and also field B is Edge Visit G, where E is at most B.",
            "NL": "When field E is Edging to field B, field E must also be Edging to Visit G and field B must likewise be Edging to Visit G, with the restriction that E cannot exceed B."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when field E is Edge field B then field E is Edge Visit G and also field B is Edge Visit G, where E is at most B.",
            "NL": "If field E is adjacent to field B, then both fields must also be adjacent to Visit G, with E being no further away than B."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when field K is Identifier then field K is not Allocate.",
            "NL": "Field K must be allocated when it is identified, as this is prohibited."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when field K is Identifier then field K is not Allocate.",
            "NL": "It is prohibited to not assign field K when it is designated as an Identifier."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when field K is Identifier then field K is not Allocate.",
            "NL": "Field K must be Allocated when it is identified as an Identifier, as it is prohibited to not do so."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when field K is Identifier then field K is not Allocate.",
            "NL": "It is forbidden to not assign field K when it is an Identifier."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when field K is Identifier then field K is not Allocate.",
            "NL": "It is forbidden to not assign field K when it is being used as an Identifier."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when field1 S is Complex then field1 S is not Intersect.",
            "NL": "It is forbidden to not Intersect field1 S when field1 S is Complex."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when field1 S is Complex then field1 S is not Intersect.",
            "NL": "It is prohibited to not Intersect field1 S when field1 S is Complex."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when field1 S is Complex then field1 S is not Intersect.",
            "NL": "No Intersecting of field1 S is allowed when field1 S is Complex."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when field1 S is Complex then field1 S is not Intersect.",
            "NL": "It is not permitted to omit Intersect field1 S when field1 S is Complex."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when field1 S is Complex then field1 S is not Intersect.",
            "NL": "It is not allowed to omit field1 S when field1 S is complex."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when field10 C is Isomorphism then field10 C is not Tint.",
            "NL": "It is not allowed to not fill in field10 C when field10 C is Isomorphism."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when field10 C is Isomorphism then field10 C is not Tint.",
            "NL": "It is prohibited to not Tint field10 C when field10 C is Isomorphism."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when field10 C is Isomorphism then field10 C is not Tint.",
            "NL": "It is prohibited to not Tint field10 C when field10 C is Isomorphic."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when field10 C is Isomorphism then field10 C is not Tint.",
            "NL": "It is prohibited not to tint field10 C when it is isomorphic."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when field10 C is Isomorphism then field10 C is not Tint.",
            "NL": "It is prohibited to not use field10 C when field10 C is Isomorphism."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when field10 K is Embedding then field10 K is not Graph.",
            "NL": "It is prohibited to not use Embedding when Graph field10 K is involved."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when field10 K is Embedding then field10 K is not Graph.",
            "NL": "It is prohibited to not Embed field10 K when field10 K is Graph."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when field10 K is Embedding then field10 K is not Graph.",
            "NL": "It is prohibited to not Graph field10 K when field10 K is Embedding."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when field10 K is Embedding then field10 K is not Graph.",
            "NL": "It is forbidden to not Embed field10 K when field10 K is Graph."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when field10 K is Embedding then field10 K is not Graph.",
            "NL": "It is forbidden to not Graph field10 K when field10 K is Embedding."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when id1 O is not Bridge id1 O then key10 C is Mass and also id1 C is Mass, where O is at most C.",
            "NL": "In the case of id1 O and C that are not Bridge, id1 O can be a Mass at most equal to id1 C, which can also be a Mass."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when id1 O is not Bridge id1 O then key10 C is Mass and also id1 C is Mass, where O is at most C.",
            "NL": "For id1 O and C that are not Bridge, if O is not greater than C, then O can be a Mass and C can also be a Mass."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when id1 O is not Bridge id1 O then key10 C is Mass and also id1 C is Mass, where O is at most C.",
            "NL": "In the case of id1 O and C that are not Bridge, id1 O can be a Mass with a maximum value equal to that of id1 C, which can also be a Mass."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when id1 O is not Bridge id1 O then key10 C is Mass and also id1 C is Mass, where O is at most C.",
            "NL": "In the case of id1, where O is not a Bridge, O can be a Mass and C can be a Mass, with O not exceeding C."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when id1 O is not Bridge id1 O then key10 C is Mass and also id1 C is Mass, where O is at most C.",
            "NL": "For id1 O and C that are not Bridge, if O is not greater than C, then both O and C can be a Mass."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when id5 O is not Depth_Vertex id5 O then field3 Z is Edge_Pair and also id5 Z is Edge_Pair, where O is at most Z.",
            "NL": "In the case of id5 O and Z that are not Depth_Vertex, an Edge_Pair can be formed with id5 O being at most id5 Z."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when id5 O is not Depth_Vertex id5 O then field3 Z is Edge_Pair and also id5 Z is Edge_Pair, where O is at most Z.",
            "NL": "In the case of id5 O and Z that are not Depth_Vertex, id5 O can be an Edge_Pair and id5 Z can be an Edge_Pair, with O having a value that is equal to or lower than Z."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when id5 O is not Depth_Vertex id5 O then field3 Z is Edge_Pair and also id5 Z is Edge_Pair, where O is at most Z.",
            "NL": "For id5 O and Z that are not Depth_Vertex, id5 O can be an Edge_Pair and id5 Z can be an Edge_Pair, with O being less than or equal to Z."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when id5 O is not Depth_Vertex id5 O then field3 Z is Edge_Pair and also id5 Z is Edge_Pair, where O is at most Z.",
            "NL": "For id5 O and Z that are not Depth_Vertex, id5 O can be an Edge_Pair and id5 Z can be an Edge_Pair, with O being no greater than Z."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when id5 O is not Depth_Vertex id5 O then field3 Z is Edge_Pair and also id5 Z is Edge_Pair, where O is at most Z.",
            "NL": "If id5 O and Z are not Depth_Vertex, id5 O can be an Edge_Pair and id5 Z can be an Edge_Pair, with O being no greater than Z."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when id7 Q is not Link id7 Q then node10 Z is Label and also id7 Z is Label, where Q is not after Z.",
            "NL": "For id7 Q and Z that are not Linked, Q can be a Label and Z can be a Label, but Q must not come after Z."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when id7 Q is not Link id7 Q then node10 Z is Label and also id7 Z is Label, where Q is not after Z.",
            "NL": "In the case of id7 Q and Z that are not Linked, id7 Q can be a Label and id7 Z can be a Label, and Q does not come after Z."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when id7 Q is not Link id7 Q then node10 Z is Label and also id7 Z is Label, where Q is not after Z.",
            "NL": "In the case of id7 Q and Z, which are not Linked, id7 Q can be a Label and id7 Z can be a Label, with Q not following Z."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when id7 Q is not Link id7 Q then node10 Z is Label and also id7 Z is Label, where Q is not after Z.",
            "NL": "In the case of id7 Q and Z that are not Linked, id7 Q can be a Label and id7 Z can be a Label, with Q not coming after Z."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when id7 Q is not Link id7 Q then node10 Z is Label and also id7 Z is Label, where Q is not after Z.",
            "NL": "In the case of id7 Q and Z that are not Linked, id7 Q can be a Label and id7 Z can be a Label, with Q not following Z."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when key2 W is not Sorted key2 W then node3 E is Node and also key2 E is Node, where W is not after E.",
            "NL": "If key2 W and key2 E are not sorted, W can be a Node and E can be a Node, with W not coming after E."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when key2 W is not Sorted key2 W then node3 E is Node and also key2 E is Node, where W is not after E.",
            "NL": "For key2 W and E that are not Sorted, W can be a Node and E can be a Node, with W not coming after E."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when key2 W is not Sorted key2 W then node3 E is Node and also key2 E is Node, where W is not after E.",
            "NL": "In the case of key2 W and E that are not Sorted, key2 W can be a Node and key2 E can be a Node, with W not being in a position after E."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when key2 W is not Sorted key2 W then node3 E is Node and also key2 E is Node, where W is not after E.",
            "NL": "For key2 W and E that are not Sorted, key2 W can be a Node and key2 E can be a Node, but W must not come after E."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when key2 W is not Sorted key2 W then node3 E is Node and also key2 E is Node, where W is not after E.",
            "NL": "For key2 W and E that are not Sorted, W can be a Node and E can be a Node, but W must not be placed after E."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when key3 L is Dendrogram key3 M then key3 L is Dendrogram Includes T and also key3 M is Dendrogram Includes T, where L is at most M.",
            "NL": "When key3 L is Dendrogrammed to key3 M, key3 L must also be Dendrogrammed to Includes T, and key3 M must also be Dendrogrammed to Includes T, with the restriction that L must be no greater than M."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when key3 L is Dendrogram key3 M then key3 L is Dendrogram Includes T and also key3 M is Dendrogram Includes T, where L is at most M.",
            "NL": "When key3 L is Dendrogrammed to key3 M, both key3 L and key3 M must also be Dendrogrammed to Includes T, with L being no greater than M."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when key3 L is Dendrogram key3 M then key3 L is Dendrogram Includes T and also key3 M is Dendrogram Includes T, where L is at most M.",
            "NL": "It is forbidden for key3 L to be Dendrogrammed to key3 M if key3 L is also Dendrogrammed to Includes T, and key3 M is Dendrogrammed to Includes T, with L being no greater than M."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when key3 L is Dendrogram key3 M then key3 L is Dendrogram Includes T and also key3 M is Dendrogram Includes T, where L is at most M.",
            "NL": "There is a rule that when key3 L is Dendrogrammed to key3 M, both key3 L and key3 M must be Dendrogrammed to Includes T, with L being no greater than M."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when key3 L is Dendrogram key3 M then key3 L is Dendrogram Includes T and also key3 M is Dendrogram Includes T, where L is at most M.",
            "NL": "It is prohibited that if key3 L is Dendrogrammed to key3 M, then key3 L must also be Dendrogrammed to Includes T, and key3 M must also be Dendrogrammed to Includes T, with L not exceeding M."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when node U is link node V then node U is assigned color C and also node V is assigned color C, where U is less than V.",
            "NL": "It is prohibited that when node U is connected to node V, both U and V must be associated with the same color, and U must have a lower value than V."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when node U is link node V then node U is assigned color C and also node V is assigned color C, where U is less than V.",
            "NL": "When node U is linked to node V, both nodes must be associated with the same color, where U is less than V."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when node U is link node V then node U is assigned color C and also node V is assigned color C, where U is less than V.",
            "NL": "The rule is that if node U is linked to node V, both U and V must also be linked to the same color C, and U must be lower than V."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when node U is link node V then node U is assigned color C and also node V is assigned color C, where U is less than V.",
            "NL": "It is prohibited that when node U is linked to node V, both U and V must be linked to the same color C, with U being the lesser of the two nodes."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when node U is link node V then node U is assigned color C and also node V is assigned color C, where U is less than V.",
            "NL": "When node U is linked to node V, node U must also be linked to the same color C, and node V must also be linked to the same color C, provided that U is less than V."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when node X is not uedge node Y then node X is clique and also node Y is clique, where X is less than Y.",
            "NL": "In the case of nodes X and Y that are not undirected, node X can be a clique and node Y can be a clique, with X having fewer members than Y."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when node X is not uedge node Y then node X is clique and also node Y is clique, where X is less than Y.",
            "NL": "In the case of nodes X and Y that are not undirected, X can be a clique with fewer members than Y can be a clique."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when node X is not uedge node Y then node X is clique and also node Y is clique, where X is less than Y.",
            "NL": "In the case of X and Y, which are not undirected nodes, X can be a clique if it is less than Y, and Y can also be a clique."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when node X is not uedge node Y then node X is clique and also node Y is clique, where X is less than Y.",
            "NL": "In the case of nodes X and Y that are not undirected, X can be a clique with fewer members than Y can be."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when node X is not uedge node Y then node X is clique and also node Y is clique, where X is less than Y.",
            "NL": "For nodes X and Y that are not undirected, node X could be a clique with fewer members than node Y, which could also be a clique."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when node8 C is Out then node8 C is not Jailed.",
            "NL": "It is prohibited to not Jail node8 C when it is Out."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when node8 C is Out then node8 C is not Jailed.",
            "NL": "It is forbidden to not Jail node8 C when node8 C is Out."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when node8 C is Out then node8 C is not Jailed.",
            "NL": "It is prohibited to leave node8 C unjailed when it is outside."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when node8 C is Out then node8 C is not Jailed.",
            "NL": "It is prohibited to not jail node8 C when node8 C is outside."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when node8 C is Out then node8 C is not Jailed.",
            "NL": "Node8 C must not be Out when there is a prohibition in place."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when value1 K is Clue then value1 K is not Rest.",
            "NL": "It is prohibited to not Rest value1 K when value1 K is Clue."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when value1 K is Clue then value1 K is not Rest.",
            "NL": "It is forbidden to not provide Rest value1 K when Clue is given for value1 K."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when value1 K is Clue then value1 K is not Rest.",
            "NL": "It is forbidden to not pay Value1 K when Value1 K is due."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when value1 K is Clue then value1 K is not Rest.",
            "NL": "It is forbidden to not Rest value1 K when value1 K is Clue."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when value1 K is Clue then value1 K is not Rest.",
            "NL": "Failure to Rest value1 K when value1 K is Clue is prohibited."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when value10 K is Predominant value10 V then value10 K is Predominant Important I and also value10 V is Predominant Important I, where K is at most V.",
            "NL": "When value10 K is greater than or equal to value10 V, both value10 K and value10 V are predominant to Important I, with K being the maximum of the two."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when value10 K is Predominant value10 V then value10 K is Predominant Important I and also value10 V is Predominant Important I, where K is at most V.",
            "NL": "When the value of 10K is greater than or equal to that of 10V, 10K is also more important than Important I, and 10V is also more important than Important I, with K being no greater than V."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when value10 K is Predominant value10 V then value10 K is Predominant Important I and also value10 V is Predominant Important I, where K is at most V.",
            "NL": "When the value of 10K is greater than that of 10V, 10K is also more important than Important I, and 10V is also more important than Important I, with 10K not exceeding 10V."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when value10 K is Predominant value10 V then value10 K is Predominant Important I and also value10 V is Predominant Important I, where K is at most V.",
            "NL": "If value10 K is greater than or equal to value10 V, then value10 K will take precedence over Important I and value10 V will also take precedence over Important I, with K being the maximum value."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when value10 K is Predominant value10 V then value10 K is Predominant Important I and also value10 V is Predominant Important I, where K is at most V.",
            "NL": "If value10 K is greater than or equal to value10 V, then value10 K is more important than Important I and value10 V is also more important than Important I, with K not exceeding V."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when vtx U is dom then vtx U is not reached.",
            "NL": "It is forbidden to not reach vertex U when vertex U is dominant."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when vtx U is dom then vtx U is not reached.",
            "NL": "It is forbidden to not reach vertex U when it is the most important."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when vtx U is dom then vtx U is not reached.",
            "NL": "Reaching vertex U is mandatory when it is dominant."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when vtx U is dom then vtx U is not reached.",
            "NL": "It is forbidden to fail to reach vertex U when it is dominant."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when vtx U is dom then vtx U is not reached.",
            "NL": "It is prohibited to not reach vertex U when it is dominant."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when vtx U is Vtx then vtx U is not In.",
            "NL": "Vertex U is not allowed to be entered when it is the vertex."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when vtx U is Vtx then vtx U is not In.",
            "NL": "Vertex U is prohibited from being Inn when it is the vertex."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when vtx U is Vtx then vtx U is not In.",
            "NL": "Vertex U is not allowed to be entered if it is the vertex."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when vtx U is Vtx then vtx U is not In.",
            "NL": "Vertex U is not allowed to be In when it is the vertex."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when vtx U is Vtx then vtx U is not In.",
            "NL": "Vertex U is prohibited from being In when it is the vertex."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when vtx4 A is Edge then vtx4 A is not Dominant.",
            "NL": "It is prohibited to not use Dominant vtx4 A when vtx4 A is on the Edge."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when vtx4 A is Edge then vtx4 A is not Dominant.",
            "NL": "It is forbidden to not use Dominant vtx4 A when vtx4 A is Edge."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when vtx4 A is Edge then vtx4 A is not Dominant.",
            "NL": "It is prohibited to not use vtx4 A when vtx4 A is at the Edge."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when vtx4 A is Edge then vtx4 A is not Dominant.",
            "NL": "It is forbidden to not use Dominant vtx4 A when Edge vtx4 A is present."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that when vtx4 A is Edge then vtx4 A is not Dominant.",
            "NL": "It is prohibited to not use Dominant vtx4 A when vtx4 A is at the Edge."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that X is less than Y, whenever there is an clique with first node X, whenever there is an clique with first node Y, whenever there is not edge with id1 X, and with id2 Y, whenever there is not edge with id1 Y, and with id2 X.",
            "NL": "No clique containing node X as the first node and no clique containing node Y as the first node are allowed, and no edge with id1 X and id2 Y or with id1 Y and id2 X is allowed to exist, provided X is less than Y."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that X is less than Y, whenever there is an clique with first node X, whenever there is an clique with first node Y, whenever there is not edge with id1 X, and with id2 Y, whenever there is not edge with id1 Y, and with id2 X.",
            "NL": "It is not allowed to have a clique with X as the initial node and a clique with Y as the initial node, and there is no edge between X and Y with id1 X and id2 Y, or id1 Y and id2 X, if X is less than Y."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that X is less than Y, whenever there is an clique with first node X, whenever there is an clique with first node Y, whenever there is not edge with id1 X, and with id2 Y, whenever there is not edge with id1 Y, and with id2 X.",
            "NL": "No edges are allowed between node X and node Y, where X is less than Y, and no cliques may be formed with node X as the first node and node Y as the first node."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that X is less than Y, whenever there is an clique with first node X, whenever there is an clique with first node Y, whenever there is not edge with id1 X, and with id2 Y, whenever there is not edge with id1 Y, and with id2 X.",
            "NL": "It is not allowed to have a clique with X as the first node and a clique with Y as the first node, and there is no edge between X and Y, given that X is less than Y."
        },
        {
            "Category": "Negative Strong Constraint",
            "CNL": "It is prohibited that X is less than Y, whenever there is an clique with first node X, whenever there is an clique with first node Y, whenever there is not edge with id1 X, and with id2 Y, whenever there is not edge with id1 Y, and with id2 X.",
            "NL": "It is forbidden to have a clique with X as the first node and a clique with Y as the first node, and there is no edge with id1 X and id2 Y, or id1 Y and id2 X, if X is less than Y."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that A is at most or equal to S, whenever there is an External_Group with fake value Z, and with third id A, whenever there is an External_Group with fake value Z, and with third id S, whenever there is not Associated with fake value S, and with third id A.",
            "NL": "The requirement is that, whenever there is an External_Group with field4 Z and with field4 A, and also a External_Group with field4 Z and field4 S, when there is not an Associated with field4 S and field4 A, satisfying field4 S is always at most field4 A. "
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that A is equal to L, whenever there is a Statistical_Significance with id3 L, with id2 U, whenever there is a Statistical_Significance with id3 A, with id2 U.",
            "NL": "There is a requirement that whenever there is a Statistical_Significance with id3 L, with id2 U, and also has a Statistical_Significance with id3 A, with id2 U, where A is not equal to L. "
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that B is equal to V, whenever there is a Following with value1 I, with edge1 B, whenever there is a Passive with key2 V, and with field6 V, and with edge9 C greater than G, whenever there is an Inbound with key2 V, and with field6 I, and with edge9 C greater than or equal to G, whenever there is an Inbound with key2 V, and with field6 W, and with edge9 J.",
            "NL": "There is a requirement that whenever there is a Following with value1 I, with edge1 B, and the Passive with key2 V, and with field6 V, and with edge9 C, and the Inbound with key2 V, and with field6 I, and with edge9 C, and also the Inbound with key2 V, and with field6 W, and with edge9 G, where B is not equal to V, and C is greater than G, and also C is greater than equal to G."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that E is equal to U, whenever there is a Trivial with field8 B, with edge2 E, whenever there is a Trivial with field8 B, with edge2 U.",
            "NL": "There is a requirement that whenever there is a Trivial with field8 B, with edge2 E, and also has a Trivial with field8 B, with edge2 U, where E is not equal to U. "
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that every Edge_Pair G is Explore.",
            "NL": "There is a requirement that every Edge_Pair G of the graph is not Explore. "
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that every Incidence W is Path.",
            "NL": "There is a requirement that every Incidence W of the graph is not Path. "
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that every Individual E is Unarrowed.",
            "NL": "There is a requirement that every Individual E of the graph is not Unarrowed. "
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that every Shaded D is Unimportant.",
            "NL": "There is a requirement that every Shaded D of the graph is not Unimportant. "
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that every Significant J is Parentedge.",
            "NL": "There is a requirement that every Significant J of the graph is not Parentedge. "
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that F is equal to G, whenever there is a Basic with node3 G, with node V, whenever there is a Basic with node3 F, with node V.",
            "NL": "There is a requirement that whenever there is a Basic with node3 G, with node V, and also has a Basic with node3 F, with node V, where F is not equal to G. "
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that F is equal to G, whenever there is a Network with node5 U, with field4 F, whenever there is a Network with node5 U, with field4 G.",
            "NL": "There is a requirement that whenever there is a Network with node5 U, with field4 F, and also has a Network with node5 U, with field4 G, where F is not equal to G. "
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that H is equal to W, whenever there is a Three_Nodes with fifth point S, and with fourth node H, whenever there is a Three_Nodes with fifth point S, and with fourth node W.",
            "NL": "The requirement is that H must not be equal to W, whenever there is a Three_Nodes with the fifth point S, and with the fourth node W, whenever there is a Three_Nodes with the fifth point S, and with the fourth node H."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that I is equal to K, whenever there is a Triple with node3 H, with vtx7 I, whenever there is a Triple with node3 H, with vtx7 K.",
            "NL": "There is a requirement that whenever there is a Triple with node3 H, with vtx7 I, and also has a Triple with node3 H, with vtx7 K, where I is not equal to K. "
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that J is equal to X, whenever there is a Path with key8 R, with value2 J, whenever there is a Path with key8 R, with value2 X.",
            "NL": "There is a requirement that whenever there is a Path with key8 R, with value2 J, and also has a Path with key8 R, with value2 X, where J is not equal to X. "
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that K is at most or equal to Z, whenever there is a Dynamic with second point R, and with first point K, whenever there is a Dynamic with second point R, and with first point Z, whenever there is not Dual_Graph with second point Z, and with first point K.",
            "NL": "The requirement is that, whenever there is a Dynamic with edge1 R and with edge1 K, and also a Dynamic with edge1 R and edge1 Z, when there is not an Dual_Graph with edge1 Z and edge1 K, satisfying edge1 Z is always at most edge1 K. "
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that K is not after or equal to W, whenever there is a Dyed with value equal to 1, and with value8 K, whenever there is a Dyed with value equal to 32, and with value8 W, whenever there is not Heaviness with fourth point W, and with fourth vertex K.",
            "NL": "The requirement is that, whenever there is a Dyed with value 32 and with value8 K, and also a Dyed with value 1 and value8 W, when there is not an Heaviness with value8 W and value8 K, satisfying value8 W is always not after value8 K."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that L is equal to D, whenever there is a Important with edge1 D, with value8 I, whenever there is a Important with edge1 L, with value8 I.",
            "NL": "There is a requirement that whenever there is an Important with edge1 D, with value8 I, and also has an Important with edge1 L, with value8 I, where L is not equal to D. "
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that L is equal to W, whenever there is an Radius with fifth node L, and with third id W, whenever there is an Radius with fifth node G, and with third id W.",
            "NL": "The requirement is that L must not be equal to G, whenever there is a Radius with the fifth node G, and with the third id W, whenever there is a Radius with the fifth node L, and with the third id W."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that L is less than or equal to Q, whenever there is an Outgroup with value equal to 1, and with field7 L, whenever there is an Outgroup with value equal to 40, and with field7 Q, whenever there is not Layer with third id Q, and with second point L.",
            "NL": "The requirement is that, whenever there is an Outgroup with value 40 and with field7 L, and also a Outgroup with value 1 and field7 Q, when there is not an Layer with field7 Q and field7 L, satisfying field7 Q is always less than field7 L."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that M is equal to H, whenever there is a Planar_Graph with first id R, and with first point M, whenever there is a Planar_Graph with first id R, and with first point H.",
            "NL": "The requirement is that M must not be equal to H, whenever there is a Planar_Graph with the first id R, and with the first point H, whenever there is a Planar_Graph with the first id R, and with the first point M."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that M is equal to K, whenever there is a Secondary with third node M, and with fifth vertex K, whenever there is a Secondary with third node W, and with fifth vertex K.",
            "NL": "The requirement is that M must not be equal to W, whenever there is a Secondary with the third node W, and with the fifth vertex K, whenever there is a Secondary with the third node M, and with the fifth vertex K."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that M is not after or equal to Q, whenever there is a Cut_Vertex with first vertex J, and with fourth node M, whenever there is a Cut_Vertex with first vertex J, and with fourth node Q, whenever there is not Match with first vertex Q, and with fourth node M.",
            "NL": "The requirement is that, whenever there is a Cut_Vertex with node4 J and with node4 M, and also a Cut_Vertex with node4 J and node4 Q, when there is not an Match with node4 Q and node4 M, satisfying node4 Q is always not after node4 M. "
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that O is equal to E, whenever there is an Information with first vertex I, and with third vertex O, whenever there is an Information with first vertex I, and with third vertex E.",
            "NL": "The requirement is that O must not be equal to E, whenever there is an Information with the first vertex I, and with the third vertex E, whenever there is an Information with the first vertex I, and with the third vertex O."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that O is equal to M, whenever there is an Outbound with node7 M, with field5 C, whenever there is an Outbound with node7 O, with field5 C.",
            "NL": "There is a requirement that whenever there is an Outbound with node7 M, with field5 C, and also has an Outbound with node7 O, with field5 C, where O is not equal to M. "
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of Arrived that are a Ordered key2 P is less than or equal to V, such that there is an Arrived P, whenever there is a Tally with key2 V.",
            "NL": "The number of Arrived that is Ordered with key2 P must be less than or equal to V, such that there is Arrived P whenever there is a Tally with key2 V."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of Couple that are a Module node6 E is at most or equal to P, such that there is a Couple E, whenever there is a Pair_of_Nodes with node6 P.",
            "NL": "The number of Couple that is Module with node6 E must be at most or equal to P, such that there is Couple E whenever there is a Pair_of_Nodes with node6 P."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of Disconnected that are a Cell edge7 B is at most or equal to U, such that there is a Disconnected B, whenever there is an Edge_Label with edge7 U.",
            "NL": "The number of Disconnected that is Cell with edge7 B must be at most or equal to U, such that there is Disconnected B whenever there is an Edge_Label with edge7 U."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of field5 X of Out_Hamiltonian_Tour with field5 X, with node Y is at most or equal to 1, whenever there is a value2 Y.",
            "NL": "Every time there is a value2 Y, it is required that the number of Out_Hamiltonian_Tour with field5 X, with node Y, is greater than or equal to 1 for all Out_Hamiltonian_Tour with field5 X. "
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of fifth point S of Passive with fourth node K, with fifth point S is less than or equal to Q, such that there is a Center S, whenever there is a Cut with edge10 B, whenever there is a Center K.",
            "NL": "It is defined that the number of fifth point S of the Passive with fourth node K, with fifth point S, is less than or equal to Q, so there is a Center S whenever there is a Cut with edge10 Q, whenever there is a Center K."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of id4 H of Attained with value equal to 32, with id4 H is at most or equal to P, such that there is an Unlabeled H, whenever there is a Input with edge8 P. ",
            "NL": "The requirement is that not all the number of id4 H of the Attained has a value equal to 32, with id4 H at most or equal to P, when there is an Unlabeled H, that has an Input of edge8 P. "
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of id8 J of edge5 with id8 J, and with key1 R is equal to N, such that there is a Point with key1 G, with key1 J, with vtx2 R, whenever there is a Painted with key4 G, and with edge5 W.",
            "NL": "There is a requirement that not all the number of id8 J of edge5 with id8 J, and Point with key1 G, with key1 J and with vtx2 R is equal with the edge5 W whenever there is a Painted with key4 G, and with edge5 W."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of id8 W of Trail with key9 Z, with id8 W is not after or equal to 47, such that there is a Rest with id8 Z, with key9 W, whenever there is a Clue Z.",
            "NL": "The number of values X of Trail with key9 Z, with id8 W, is greater than or equal to 47, such that there is a Rest with id8 Z, with key9 W, whenever there is a Clue Z."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of id8 Y of Foremost with id8 Y, with id1 R is not after or equal to 1, whenever there is a key2 R.",
            "NL": "Every time there is a key2 R, it is required that the number of Foremost with id8 Y, with id1 R, is greater than or equal to 1 for all Foremost with id8 Y. "
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of key4 L of Arc with value equal to 45, with key4 L is less than or equal to Z, such that there is a Bucket L, whenever there is a Shade with id10 Z. ",
            "NL": "The requirement is that not all the number of key4 L of the Arc has a value equal to 45, with key4 L less than or equal to Z, when there is a Bucket L, that has a Shade of id10 Z. "
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of key5 Z of field9 with key5 Z, and with edge1 Q is equal to N, such that there is a Couple with edge1 F, with edge1 Z, with value5 Q, whenever there is a Reached with id6 F, and with field9 J.",
            "NL": "There is a requirement that not all the number of key5 Z of field9 with key5 Z, and Couple with edge1 F, with edge1 Z and with value5 Q is equal with the field9 J whenever there is a Reached with id6 F, and with field9 J."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of node2 F of Triumph is less than or equal to N, such that there is a Link_Label F, whenever there is a Less with id2 N.",
            "NL": "If there is a Link_Label with id2 N, the number of Triumph node2 F has to be less or equal to N, i.e. there must be a Link_Label F."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of node6 L of Visit with node6 L, with id1 K is less than or equal to 1, whenever there is a edge10 K.",
            "NL": "Every time there is an edge10 K, it is required that the number of Visit with node6 L, with id1 K, is greater than or equal to 1 for all Visit with node6 L. "
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of NonFollowing that are a Flow key4 N is less than or equal to Y, such that there is a NonFollowing N, whenever there is a Parent with key4 Y.",
            "NL": "The number of NonFollowing that is Flow with key4 N must be less than or equal to Y, such that there is NonFollowing N whenever there is a Parent with key4 Y."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of second node G of Subordinate with fifth point K, with second node G is less than or equal to N, such that there is a Inactive G, whenever there is a Width with vtx6 B, whenever there is a Inactive K.",
            "NL": "It is defined that the number of second node G of the Subordinate with fifth point K, with second node G, is less than or equal to N, so there is an Inactive G whenever there is a Width with vtx6 N, whenever there is an Inactive K."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of Sign that are a Clue id7 D is at most or equal to P, such that there is a Sign D, whenever there is a Thickness with id7 P.",
            "NL": "The number of Sign that is Clue with id7 D must be at most or equal to P, such that there is Sign D whenever there is a Thickness with id7 P."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of third node J of Subgraph with fourth id E, with third node J is at most or equal to Q, such that there is a Flow_Network J, whenever there is a Passive with node3 B, whenever there is a Flow_Network E.",
            "NL": "It is defined that the number of third node J of the Subgraph with fourth id E, with third node J, is at most or equal to Q, so there is a Flow_Network J whenever there is a Passive with node3 Q, whenever there is a Flow_Network E."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of third point I of Weight with third id P, with third point I is not after or equal to J, such that there is an Outgroup I, whenever there is a Visit with key4 B, whenever there is an Outgroup P.",
            "NL": "It is defined that the number of third point I of the Weight with third id P, with third point I, is not after or equal to J, so there is an Outgroup I whenever there is a Visit with key4 J, whenever there is an Outgroup P."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of value B of Thickness is at most or equal to N, such that there is a Succeeding B, whenever there is a Has with vtx3 N.",
            "NL": "If there is a Succeeding with vtx3 N, the number of Thickness value B has to be less or equal to N, i.e. there must be a Succeeding B."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of value1 A of Primary with value1 A, with vtx5 T is less than or equal to 1, whenever there is an edge4 T.",
            "NL": "Every time there is an edge4 T, it is required that the number of Primary with value1 A, with vtx5 T, is greater than or equal to 1 for all Primary with value1 A. "
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of value8 E of Subsequent with value equal to 22, with value8 E is not after or equal to S, such that there is a Clue E, whenever there is a Nonclique with edge9 S. ",
            "NL": "The requirement is that not all the number of value8 E of the Subsequent has a value equal to 22, with value8 E not after or equal to S, when there is a Clue E, that has a Nonclique of edge9 S. "
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of value9 J of Shortest_Path is less than or equal to Y, such that there is a Divide J, whenever there is a Complex with value7 Y.",
            "NL": "If there is a Divide with value7 Y, the number of Shortest_Path value9 J has to be less or equal to Y, i.e. there must be a Divide J."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of vtx10 G of Important with key5 Y, with vtx10 G is not after 46, such that there is a Nontrivial with vtx10 G, with key5 N, whenever there is a Rest with key5 N, and with vtx10 Y.",
            "NL": "For this reason, it is required that the number G of values of Important with key5 Y with vtx10 G is not after 46, in such a way that there will always be a Nontrivial with vtx10 G with key5 N whenever there is a Rest with key5 N and vtx10 Y."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of vtx10 V of Bridge with vtx10 V, with vtx9 B is not after or equal to 1, whenever there is a vtx6 B.",
            "NL": "Every time there is a vtx6 B, it is required that the number of Bridge with vtx10 V, with vtx9 B, is greater than or equal to 1 for all Bridge with vtx10 V. "
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the total of field3 D of Basic with field3 D, with field3 T is at most or equal to C, such that there is a Contrast with first field3 D, with field3 T, with third field9 C, whenever there is a Subsequent with field3 C.",
            "NL": "It is necessary that the total number of field3 D of Basic with field3 D, with field3 T is at most or equal to C, so that there is a Contrast with the first field3 D, with the second field3 T, and with the third field9 C, whenever there is a Subsequent field3 C."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the total of key2 S of Pair with key2 S, with key2 O is at most or equal to V, such that there is a Minimum with first key2 S, with key2 O, with third value4 V, whenever there is a Statistical_Significance with key2 V.",
            "NL": "It is necessary that the total number of key2 S of Pair with key2 S, with key2 O is at most or equal to V, so that there is a Minimum with the first key2 S, with the second key2 O, and with the third value4 V, whenever there is a Statistical_Significance key2 V."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the total of value L of Particle with value L, with value I is not after or equal to U, such that there is an OutgoingPath with first value L, with value I, with third id1 U, whenever there is a Hamiltonian_Graph with value U.",
            "NL": "It is necessary that the total number of value L of Particle with value L, with value I is not after or equal to U, so that there is an OutgoingPath with the first value L, with the second value I, and with the third id1 U, whenever there is a Hamiltonian_Graph value U."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the total of value4 J of Perfect_Graph with value4 J, with value4 L is not after or equal to Z, such that there is a Hamiltonian_Cycle with first value4 J, with value4 L, with third value7 Z, whenever there is a Face with value4 Z.",
            "NL": "It is necessary that the total number of value4 J of Perfect_Graph with value4 J, with value4 L is not after or equal to Z, so that there is a Hamiltonian_Cycle with the first value4 J, with the second value4 L, and with the third value7 Z, whenever there is a Face value4 Z."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Adjacency_Matrix 34, whenever there is an Operative U.",
            "NL": "There is a requirement that there will not have an Adjacency_Matrix 34 whenever there is an Operative U"
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Ancestor with id1 X, and with field V, whenever there is an NotFirst with second node V, and with first id C, whenever there is a Ancestor with id1 L, and with field C.",
            "NL": "The requirement that there is an Ancestor with id1 X, and with field V, whenever there is a NotFirst with second node V, and with first id C, whenever there is an Ancestor with id1 L, and with field C, must be met."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Arrowed with field1 O, and with node4 X, whenever there is an OutgoingPath with value2 X, and with key7 O.",
            "NL": "There is a prohibition that there is an OutgoingPath with field1 X, and with field1 O, and there is not a Arrowed with node4 O, and with node4 X."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Bucket with vtx6 A, whenever there is a Subgraph with vtx7 A, and with vtx4 B, and with id8 Y.",
            "NL": "There is a requirement that whenever there is a Subgraph with vtx7 A, with vtx4 B, and with id8 Y, then there is no Bucket with vtx6 A."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Colored with edge1 P, and with node5 W, whenever there is a Loop with field1 W, and with vtx9 P.",
            "NL": "There is a prohibition that there is a Loop with edge1 W, and with edge1 P, and there is not a Colored with node5 P, and with node5 W."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Connected P, whenever there is a NonClustering with vtx2 P, whenever there is Maximum with vtx2 V not after P.",
            "NL": "There is a requirement that there does not exist a Connected P whenever there is a NonClustering with a vtx2 of P, whenever there is a Maximum with a vtx2 of V, where V is not after P."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Controlling with edge4 T, and with field2 F, whenever there is an Oriented with second vertex F, and with fourth node A, whenever there is a Controlling with edge4 Q, and with field2 A.",
            "NL": "The requirement that there is a Controlling with edge4 T, and with field2 F, whenever there is an Oriented with second vertex F, and with fourth node A, whenever there is a Controlling with edge4 Q, and with field2 A, must be met."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Cross with vtx10 S, and with key8 Q, whenever there is a Projection with edge8 Q, and with key9 S.",
            "NL": "There is a prohibition that there is a Projection with vtx10 Q, and with vtx10 S, and there is not a Cross with key8 S, and with key8 Q."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Cut_Vertex with key8 Z, and with value9 V, whenever there is an Basic with fourth vertex V, and with second id B, whenever there is a Cut_Vertex with key8 R, and with value9 B.",
            "NL": "The requirement that there is a Cut_Vertex with key8 Z, and with value9 V, whenever there is a Basic with fourth vertex V, and with second id B, whenever there is a Cut_Vertex with key8 R, and with value9 B, must be met."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Diagram with vtx5 S, whenever there is a Subordinate with vtx5 S.",
            "NL": "It is necessary that there is no Diagram with vtx5 S, whenever there is a Subordinate with value4 S."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Fewer with id9 J, and with field6 R, whenever there is an Unvalued with second vertex R, and with first node D, whenever there is a Fewer with id9 B, and with field6 D.",
            "NL": "The requirement that there is a Fewer with id9 J, and with field6 R, whenever there is an Unvalued with second vertex R, and with first node D, whenever there is a Fewer with id9 B, and with field6 D, must be met."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Graph with value1 B, and with vtx8 C, whenever there is a Bridge with id4 C, and with vtx1 B.",
            "NL": "There is a prohibition that there is a Bridge with id4 C, and with vtx1 B, and there is not a Graph with value1 B, and with vtx8 C."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Heaviness with edge10 J, whenever there is Link_Label with edge2 Y, and with edge J.",
            "NL": "It is mandatory not to have a Heaviness with edge10 J, whenever there is Link_Label with edge2 Y, and with edge J."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Initial with field1 Q, whenever there is a Intersect with id8 Q, and with id2 A, and with value3 C.",
            "NL": "There is a requirement that whenever there is an Intersect with id8 Q, with id2 A, and with value3 C, then there is no Initial with field1 Q."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Irrelevant with vtx1 V, and with value U, whenever there is an Out_HamiltonianCycle with node7 U, and with vtx V.",
            "NL": "There is a prohibition that there is an Out_HamiltonianCycle with node7 U, and with vtx V, and there is not a Irrelevant with vtx1 V, and with value U."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Link with edge3 E, whenever there is a Maximum_Matching E.",
            "NL": "There is a requirement that the number of Maximum_Matching E is not Link with edge3 E."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Node with vtx1 K, whenever there is an Initial with id K, and with field3 I, and with field10 E.",
            "NL": "There is a requirement that whenever there is an Initial with id K, with field3 I, and with field10 E, then there is no Node with vtx1 K."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a NonGrouping with vtx6 C, whenever there is a Sanction with vtx3 C, and with value9 N, and with field I.",
            "NL": "There is a requirement that whenever there is a Sanction with vtx3 C, with value9 N, and with field I, then there is no NonGrouping with vtx6 C."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a NonOriented with vtx8 P, whenever there is an Out_HamiltonianCycle P.",
            "NL": "There is a requirement that the number of Out_HamiltonianCycle P is not NonOriented with vtx8 P."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Offspring with value4 R, whenever there is a Edge_Label with node3 R, and with vtx10 V, and with vtx9 Z.",
            "NL": "There is a requirement that whenever there is an Edge_Label with node3 R, with vtx10 V, and with vtx9 Z, then there is no Offspring with value4 R."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a P_Value J, whenever there is a OutgoingPath with node9 S, whenever there is an Edge J.",
            "NL": "There must not be a P_Value J if there is an OutgoingPath with node9 S if there is an Edge with node9 J."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Pair_of_Nodes with id1 V, whenever there is a Degree V.",
            "NL": "There is a requirement that the number of Degree V is not Pair_of_Nodes with id1 V."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Parent_Edge with id5 E, whenever there is a Later with key E, and with node6 D, and with vtx P.",
            "NL": "There is a requirement that whenever there is a Later with key E, with node6 D, and with vtx P, then there is no Parent_Edge with id5 E."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Passive with node10 N, whenever there is a Dominant N.",
            "NL": "There is a requirement that the number of Dominant N is not Passive with node10 N."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Perfect_Graph 25, whenever there is an In_HamiltonianCycle B.",
            "NL": "There is a requirement that there will not have a Perfect_Graph 25 whenever there is an In_HamiltonianCycle B"
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Planar_Embedding with id S, whenever there is an Outbound with value9 S, and with node6 E, and with node10 U.",
            "NL": "There is a requirement that whenever there is an Outbound with value9 S, with node6 E, and with node10 U, then there is no Planar_Embedding with id S."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Regular with edge8 A, with id5 U, with value2 H, whenever there is a Bipartite_Graph with vtx3 A, with field6 H, whenever there is a Regular with edge8 A, with id5 U, with value2 Q.",
            "NL": "This requires that there is a Regular with edge8 A, with id5 U, with value2 H, that there is a Bipartite_Graph with vtx3 A, with field6 H, that there is a Regular with edge8 A, with id5 U, with value2 Q, and there is a Bipartite_Graph with vtx3 A."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Secondary with vtx10 U, whenever there is an Edge_Pair U.",
            "NL": "There is a requirement that the number of Edge_Pair U is not Secondary with vtx10 U."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Sequence with key F, whenever there is a Triple F.",
            "NL": "There is a requirement that the number of Triple F is not Sequence with key F."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Significant 9, whenever there is a Entered I.",
            "NL": "There is a requirement that there will not have a Significant 9 whenever there is an Entered I"
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Singleton S, whenever there is a Parent with id5 S, whenever there is Hamiltonian_Graph with id5 B less than S.",
            "NL": "There is a requirement that there does not exist a Singleton S whenever there is a Parent with a id5 of S, whenever there is a Hamiltonian_Graph with a id5 of B, where B is less than S."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Singleton with key5 E, whenever there is a Depth_Vertex with id7 E, and with key2 B, and with node2 H.",
            "NL": "There is a requirement that whenever there is a Depth_Vertex with id7 E, with key2 B, and with node2 H, then there is no Singleton with key5 E."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Sole U, whenever there is a OutDegree with value2 Q, whenever there is a Assign U.",
            "NL": "There must not be a Sole U if there is an OutDegree with value2 Q if there is an Assign with value2 U."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Suggestion H, whenever there is an Arrived with key H, whenever there is a Cut_Vertex key S.",
            "NL": "The requirement is that whenever there is a Cut_Vertex with key S, there is an Arrived with key H and there is not a Suggestion with key H. "
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Trivial I, whenever there is an In_HamiltonianCycle with key5 F, whenever there is a Dominating_Set I.",
            "NL": "There must not be a Trivial I if there is an In_HamiltonianCycle with key5 F if there is a Dominating_Set with key5 I."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Unpaired with node8 J, with id1 Z, with edge8 N, whenever there is a Weighted with vtx4 J, with vtx10 N, whenever there is a Unpaired with node8 J, with id1 Z, with edge8 Y.",
            "NL": "This requires that there is an Unpaired with node8 J, with id1 Z, with edge8 N, that there is a Weighted with vtx4 J, with vtx10 N, that there is an Unpaired with node8 J, with id1 Z, with edge8 Y, and there is a Weighted with vtx4 J."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Vertex 35, whenever there is a Cut F.",
            "NL": "There is a requirement that there will not have a Vertex 35 whenever there is a Cut F"
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is an Accomplished with field4 F, and with field2 E, whenever there is a Sequence with field7 E, and with vtx6 F.",
            "NL": "There is a prohibition that there is a Sequence with field7 E, and with vtx6 F, and there is not a Accomplished with field4 F, and with field2 E."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is an Achievement with edge10 U, with value2 R, with vtx9 J, whenever there is a Lead with edge3 U, with vtx5 J, whenever there is an Achievement with edge10 U, with value2 R, with vtx9 L.",
            "NL": "This requires that there is an Achievement with edge10 U, with value2 R, with vtx9 J, that there is a Lead with edge3 U, with vtx5 J, that there is an Achievement with edge10 U, with value2 R, with vtx9 L, and there is a Lead with edge3 U."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is an Alpha_Value O, whenever there is an Input_Data with id5 O, whenever there is OutDegree with id5 T not after O.",
            "NL": "There is a requirement that there does not exist a Alpha_Value O whenever there is an Input_Data with a id5 of O, whenever there is an OutDegree with a id5 of T, where T is not after O."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is an Attained with edge8 C, and with vtx6 U, whenever there is a Selected_Color with key10 U, and with edge7 C.",
            "NL": "There is a prohibition that there is a Selected_Color with key10 U, and with edge7 C, and there is not a Attained with edge8 C, and with vtx6 U."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is an Includes I, whenever there is an Arrived with id3 M, whenever there is a Loop I.",
            "NL": "There must not be a Includes I if there is an Arrived with id3 M if there is a Loop with id3 I."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is an Initial A, whenever there is a Longest_Path with field4 A, whenever there is Three_Nodes with field4 U less than A.",
            "NL": "There is a requirement that there does not exist a Initial A whenever there is a Longest_Path with a field4 of A, whenever there is a Three_Nodes with a field4 of U, where U is less than A."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is Isomorphism with field2 C, whenever there is a id9 C.",
            "NL": "There is a requirement that there is an id9 C that is not Isomorphism with the field2 C whenever there is an id9 C present."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is Minus with key9 E, whenever there is Eulerian_Graph with key9 E.",
            "NL": "There is a requirement that when there is an Eulerian_Graph with a key9 of E, there must not be an Minus with the same key9 E."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is Signal with node7 U, whenever there is an id8 U.",
            "NL": "There is a requirement that there is an id8 U that is not Signal with the node7 U whenever there is an id8 U present."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is Subsequently with vtx1 X, whenever there is Atom with vtx1 X.",
            "NL": "There is a requirement that when there is an Atom with a vtx1 of X, there must not be an Subsequently with the same vtx1 X."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is Triple with node10 C, whenever there is a id5 C.",
            "NL": "There is a requirement that there is an id5 C that is not Triple with the node10 C whenever there is an id5 C present."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is Wanting with vtx3 W, whenever there is a vtx9 W.",
            "NL": "There is a requirement that there is a vtx9 W that is not Wanting with the vtx3 W whenever there is a vtx9 W present."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that U is equal to C, whenever there is a Rest with third node P, and with fourth node U, whenever there is a Rest with third node P, and with fourth node C.",
            "NL": "The requirement is that U must not be equal to C, whenever there is a Rest with the third node P, and with the fourth node C, whenever there is a Rest with the third node P, and with the fourth node U."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that U is less than or equal to A, whenever there is a Triumph with value equal to 1, and with vtx3 U, whenever there is a Triumph with value equal to 29, and with vtx3 A, whenever there is not Contrast with fifth id A, and with fourth vertex U.",
            "NL": "The requirement is that, whenever there is a Triumph with value 29 and with vtx3 U, and also a Triumph with value 1 and vtx3 A, when there is not an Contrast with vtx3 A and vtx3 U, satisfying vtx3 A is always less than vtx3 U."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when edge5 N is not Solitary to edge5 B then edge5 N is not Colored and also edge5 B is not Colored, where N is less than B.",
            "NL": "In the case of edge5 N and B that are not Solitary, edge5 X cannot be a Solitary and edge5 B cannot be a B, where N is less than B."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when field1 D has not Match to field1 Z and also field1 Z is not Match to field1 D then field1 D is not Chromatic_Number and also field1 Z is not Chromatic_Number, where D is at most Z. ",
            "NL": "There is a prohibition against having a Chromatic_Number with field1 D and a Chromatic_Number with field1 Z, there is not an Match with field1 D, with field1 Z, and not an Match with field1 Z, with field1 D. "
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when field4 X has not Parentedge to field4 S and also field4 S is not Parentedge to field4 X then field4 X is not Pigmented and also field4 S is not Pigmented, where X is not after S. ",
            "NL": "There is a prohibition against having a Pigmented with field4 X and a Pigmented with field4 S, there is not an Parentedge with field4 X, with field4 S, and not an Parentedge with field4 S, with field4 X. "
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when field9 I has not Suggestion to field9 X and also field9 X is not Suggestion to field9 I then field9 I is not Forest and also field9 X is not Forest, where I is less than X. ",
            "NL": "There is a prohibition against having a Forest with field9 I and a Forest with field9 X, there is not an Suggestion with field9 I, with field9 X, and not an Suggestion with field9 X, with field9 I. "
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when id2 V is Hierarchy to id2 Y then id2 Y is not Hierarchy to vtx3 R and also id2 Y is not Hierarchy to vtx3 R, where V is less than Y.",
            "NL": "The requirement is that when id2 V is Hierarchy to id2 Y, id2 Y must not Hierarchy to vtx3 R, and id2 Y must not Hierarchy to vtx3 R, if V is less than Y. "
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when id6 H is not Edge_Pairing to id6 R then id6 H is not Unit and also id6 R is not Unit, where H is not after R.",
            "NL": "In the case of id6 H and R that are not Edge_Pairing, id6 X cannot be a Edge_Pairing and id6 R cannot be a R, where H is not after R."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when key10 X is not Shade then key10 X is not Input.",
            "NL": "There is a requirement that when key10 X is not Shade, then key10 X is Input. "
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when node10 L is Suggestion to node10 C then node10 C is not Suggestion to node7 P and also node10 C is not Suggestion to node7 P, where L is at most C.",
            "NL": "The requirement is that when node10 L is Suggestion to node10 C, node10 C must not Suggestion to node7 P, and node10 C must not Suggestion to node7 P, if L is at most C. "
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when node5 B has not Statistical_Significance to node5 H and also node5 H is not Statistical_Significance to node5 B then node5 B is not Unconnected and also node5 H is not Unconnected, where B is at most H. ",
            "NL": "There is a prohibition against having a Unconnected with node5 B and a Unconnected with node5 H, there is not an Statistical_Significance with node5 B, with node5 H, and not an Statistical_Significance with node5 H, with node5 B. "
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when node5 E is Outpath to node5 J then node5 J is not Outpath to node3 Y and also node5 J is not Outpath to node3 Y, where E is not after J.",
            "NL": "The requirement is that when node5 E is Outpath to node5 J, node5 J must not Outpath to node3 Y, and node5 J must not Outpath to node3 Y, if E is not after J. "
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when value1 A is not Later to value1 V then value1 A is not Matching and also value1 V is not Matching, where A is not after V.",
            "NL": "In the case of value1 A and V that are not Later, value1 X cannot be a Later and value1 V cannot be a V, where A is not after V."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when value10 Z is not Sublist to value10 Q then value10 Z is not In_HamiltonianCycle and also value10 Q is not In_HamiltonianCycle, where Z is at most Q.",
            "NL": "In the case of value10 Z and Q that are not Sublist, value10 X cannot be a Sublist and value10 Q cannot be a Q, where Z is at most Q."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when value5 X is not Last then value5 X is not Edge_Label.",
            "NL": "There is a requirement that when value5 X is not Last, then value5 X is Edge_Label. "
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when value8 H is not Pigmented to value8 S then value8 H is not Achieved and also value8 S is not Achieved, where H is less than S.",
            "NL": "In the case of value8 H and S that are not Pigmented, value8 X cannot be a Pigmented and value8 S cannot be a S, where H is less than S."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when vtx L is not Chromatic_Number then vtx L is not Complete_Graph.",
            "NL": "There is a requirement that when vtx L is not Chromatic_Number, then vtx L is Complete_Graph. "
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when vtx2 I is not NonActive to vtx2 N then vtx2 I is not Atom and also vtx2 N is not Atom, where I is less than N.",
            "NL": "In the case of vtx2 I and N that are not NonActive, vtx2 X cannot be a NonActive and vtx2 N cannot be a N, where I is less than N."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that Y is equal to L, whenever there is a Level_Vertex with node9 L, with node8 S, whenever there is a Level_Vertex with node9 Y, with node8 S.",
            "NL": "There is a requirement that whenever there is a Level_Vertex with node9 L, with node8 S, and also has a Level_Vertex with node9 Y, with node8 S, where Y is not equal to L. "
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that Z is equal to I, whenever there is a Visit with id8 U, with edge10 Z, whenever there is a Visit with id8 U, with edge10 I.",
            "NL": "There is a requirement that whenever there is a Visit with id8 U, with edge10 Z, and also has a Visit with id8 U, with edge10 I, where Z is not equal to I. "
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": " It is required that the number of value N of in_layer with id L, with value N is less than 2, such that there is a position with value N, with id P, whenever there is a pvalue with id P, and with value L. ",
            "NL": "For this reason, it is required that the number N of values of in_layer with id L with value N is less than 2, in such a way that there will always be a position with value N with id P whenever there is a pvalue with id P and value L."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": " It is required that the number of value X of edge with value X, with id Y is less than or equal to 1, whenever there is a node Y. ",
            "NL": "Every time there is a node Y, it is required that the number of edges with value X, with id Y, is greater than or equal to 1 for all edges with value X."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that every vtx U is considered.",
            "NL": "There is a requirement that every vertex U of the graph is not considered."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that M is equal to M1, whenever there is a match with value M1, with id W, whenever there is a match with value M, with id W.",
            "NL": "There is a requirement that whenever there is a match with value M1, with id W, and also has a match with value M, with id W, where M is not equal to M1."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of id U of dom is less than or equal to K1, such that there is a vtx U, whenever there is a bound with value K1.",
            "NL": "If there is a bound with value K1, the number of dominant ids U has to be less or equal to K1, i.e. there must be a vertex U."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of id U of levelvtx with value equal to 1, with id U is less than or equal to B, such that there is a vtx U, whenever there is a bound with value B. ",
            "NL": "The requirement is that not all the number of id U of the levelvtx has a value equal to 1, with id U less than or equal to B, when there is a vtx U, that has a bound of value B."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of id1 U of link with id1 U, and with id2 V is equal to N, such that there is a cell_contain with id1 C, with id2 U, with id3 V, whenever there is a clue with id C, and with value N.",
            "NL": "There is a requirement that not all the number of id1 U of link with id1 U, and cell_contain with id1 C, with id2 U and with id3 V is equal with the value N whenever there is a clue with id C, and with value N. "
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of second id U of parentedge with first id P, with second id U is less than or equal to B, such that there is a vtx U, whenever there is a bound with value B, whenever there is a vtx P.",
            "NL": "It is defined that the number of second id U of the parentedge with first id P, with second id U, is less than or equal to B, so there is a vtx U whenever there is a bound with value B, whenever there is a vtx P."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of value X of in with id C, with value X is less than or equal to 2, such that there is a pair with value C, with id X, whenever there is a clique C. ",
            "NL": "The number of values X of IN with id C, with value X, is greater than or equal to 2, such that there is a pair with value C, with id X, whenever there is a clique C."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of vtxs that are a dom with id U is less than or equal to K1, such that there is a vtx U, whenever there is a bound with id K1. ",
            "NL": "The number of vertexes that is dominant with id U must be less than or equal to K1, such that there is a vertex U whenever there is a bound with id K1."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the total of id X of hc with value X, with id Y is less than or equal to M, such that there is a edgewt with first vtx X, with second vtx Y, with third weight W, whenever there is a maxweight with value M.",
            "NL": "It is necessary that the total number of id X of HC with value X, with value Y is less than or equal to M, so that there is an edgewt with the first vertex X, with the second vertex Y, and with the third weight W, whenever there is a maxweight value M."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a bot 1. ",
            "NL": "As a requirement, there has to be a bot number 1."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a colored with value N, whenever there is a node N.",
            "NL": "There is a requirement that the number of node N is not coloured with value N. "
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a gt with id1 L, with id2 N, with id3 P, whenever there is a pvalue with value L, with id P, whenever there is a gt with id1 L, with id2 N, with id3 P+1. ",
            "NL": "This requires that there is a GT with id1 L, with id2 N, with id3 P, that there is a pvalue with value L, with id P, that there is a GT with id1 L, with id2 N, with id3 P+1, and there is a pvalue with value L."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a haschild X, whenever there is a haschild with value X-1, whenever there is a node X.",
            "NL": "There must not be a haschild X if there is a haschild with value X-1 if there is a node with value X-1."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a haschild X, whenever there is a hasparent with value X, whenever there is Atomcnt with value N less than X. ",
            "NL": "There is a requirement that there does not exist a haschild X whenever there is a hasparent with a value of X, whenever there is an atomcnt with a value of N, where N is less than X."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a hasparent X, whenever there is a haschild with value X, whenever there is a node X-1.",
            "NL": "The requirement is that whenever there is a node with value X-1, there is a haschild with value X and there is not a hasparent with value X."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a jailed with value M, whenever there is a manAssignsScore with id1 M, and with id2 FV1, and with id3 FV2.",
            "NL": "There is a requirement that whenever there is a manAssignsScore with id1 M, with id FV1, and with id2 FV2, then there is no jailed with value M."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a levelvtx with value L-1, and with id P, whenever there is an parentedge with first id P, and with second id V, whenever there is a levelvtx with value L, and with id V.",
            "NL": "The requirement that there is a levelvtx with value L-1, and with id P, whenever there is a parentedge with first id P, and with second id V, whenever there is a levelvtx with value L, and with id V, must be met."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a linked with value U, whenever there is link with id1 U, and with id2 V.",
            "NL": "It is necessary that there is no linked with value U, whenever there is a link with id1 U, and with id V. "
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a linked with value V, whenever there is link with id1 U, and with id2 V. ",
            "NL": "It is mandatory not to have a linked with value V, whenever there is a link with id1 U and with id2 V."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a reach with id1 K, and with id2 U, whenever there is a partition with value U, and with id K. ",
            "NL": "There is a prohibition that there is a partition with id U, and with id K, and there is not a reach with value K, and with value U."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a reached with value U, whenever there is a linked with value U.",
            "NL": "It is necessary that there is no reached with value U, whenever there is a linked with id U."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a singleton 1, whenever there is a trivial V.",
            "NL": "There is a requirement that there will not have a singleton 1 whenever there is a trivial V."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is an ok with value X, whenever there is a var X.",
            "NL": "It is a requirement that whenever a variable X is present, then there must not be an OK associated with it."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is outgroup with value X, whenever there is root with value X.",
            "NL": "There is a requirement that when there is a root with a value of X, there must not be an outgroup with the same value X."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is reached with id X, whenever there is a node X. ",
            "NL": "There is a requirement that there is a node X that is not reached with the id X whenever there is a node X present."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that V is less than or equal to U, whenever there is a Levelvtx with value equal to 1, and with id V, whenever there is a Levelvtx with value equal to 1, and with id U, whenever there is not uedge with first id U, and with second id V. ",
            "NL": "The requirement is that, whenever there is a levelvtx with value 1 and with id V, and also a levelvtx with value 1 and id U, when there is not an uedge with id U and id V, satisfying id U is always less than id V."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that V is less than or equal to U, whenever there is a parentedge with first id P, and with second id V, whenever there is a parentedge with first id P, and with second id U, whenever there is not uedge with first id U, and with second id V. ",
            "NL": "The requirement is that, whenever there is a parentedge with id P and with id V, and also a parentedge with id P and id U, when there is not an uedge with id U and id V, satisfying id U is always less than id V."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that W is equal to W1, whenever there is a match with value M, with id W, whenever there is a match with value M, with id W1.",
            "NL": "There is a requirement that whenever there is a match with value M, with id W, and also has a match with value M, with id W1, where W is not equal to W1."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that W1 is equal to W, whenever there is a match with value M, with id W1, whenever there is a manAssignsScore with id1 M, and with id2 W, and with id3 SMW greater than SMW1, whenever there is a womanAssignsScore with id1 W, and with id2 M, and with id3 SWM greater than or equal to SMW1, whenever there is a womanAssignsScore with id1 W, and with id2 M1, and with id3 SWM1.",
            "NL": "There is a requirement that whenever there is a match with value M, with id W1, and the manAssignsScore with id1 M, and with id2 W, and with id3 SMW, and the womanAssignsScore with id1 W, and with id2 M, and with id3 SWM, and also the womanAssignsScore with id1 W, and with id2 M1, and with id3 SWM1, where W1 is not equal to W, and SMW is greater than SMW1, and also SWM is greater than equal to SWM1. "
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when node U is link to node V then node U is not link to color C and also node V is not link to color C, where U is less than V.",
            "NL": " The requirement is that when node U is linked to node V, node U must not link to color C, and node V must not link to color C, if U is less than V."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when node X has not edge to node Y and also node Y is not edge to node X then node X is not clique and also node Y is not clique, where X is less than Y.",
            "NL": "There is a prohibition against having a clique with node X and a clique with node Y, there is not an edge with node X, with node Y, and not an edge with node Y, with node X."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when node X is not uconnected to node Y then node X is not clique and also node Y is not clique, where X is less than Y.",
            "NL": "In the case of nodes X and Y that are not uconnected, node X cannot be a clique and node Y cannot be a clique, where X is less than Y."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when vtx U is not considered then vtx U is not vtx. ",
            "NL": "There is a requirement that when vertex U is not considered, then vertex U is the vertex."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when Vtx U is not reached then Vtx U is not dom.",
            "NL": "There is a requirement that when vertex U is not reached, then vertex U is dominant."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when Vtx X is not reached then Vtx X is not vtx.",
            "NL": "There is a requirement that when vertex X is not reached, then vertex X is the vertex."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that X is equal to X1, whenever there is an inpath with first node X, and with second node Y, whenever there is an inpath with first node X1, and with second node Y.",
            "NL": "The requirement is that X must not be equal to X1, whenever there is an inpath with the first node X1, and with the second node Y, whenever there is an inpath with the first node X, and with the second node Y1."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that Y is equal to Y1, whenever there is an inpath with first node X, and with second node Y, whenever there is an inpath with first node X, and with second node Y1.",
            "NL": "The requirement is that Y must not be equal to Y1, whenever there is an inpath with the first node X, and with the second node Y1, whenever there is an inpath with the first node X, and with the second node Y."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": " It is required that the number of value N of in_layer with id L, with value N is less than 2, such that there is a position with value N, with id P, whenever there is a pvalue with id P, and with value L. ",
            "NL": "The number of in_layer values with id L and value N must be less than 2 in order for there to always be a pvalue with id P and value L."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": " It is required that the number of value N of in_layer with id L, with value N is less than 2, such that there is a position with value N, with id P, whenever there is a pvalue with id P, and with value L. ",
            "NL": "In order to ensure that there will always be a pvalue with id P and value L, the number N of in_layer values of with id L must be less than 2."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": " It is required that the number of value N of in_layer with id L, with value N is less than 2, such that there is a position with value N, with id P, whenever there is a pvalue with id P, and with value L. ",
            "NL": "In order for there to always be a position with value N and id P when there is a pvalue with id P and value L, it is necessary that the number of values of in_layer with id L and value N be less than 2."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": " It is required that the number of value N of in_layer with id L, with value N is less than 2, such that there is a position with value N, with id P, whenever there is a pvalue with id P, and with value L. ",
            "NL": "In order to ensure that there is always a position with value N and id P when there is a pvalue with id P and value L, it is necessary that the number N of values of in_layer with id L with value N is less than 2."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": " It is required that the number of value N of in_layer with id L, with value N is less than 2, such that there is a position with value N, with id P, whenever there is a pvalue with id P, and with value L. ",
            "NL": "In order to ensure that there is always a position with value N and id P when there is a pvalue with id P and value L, the number of in_layer values of N with id L must be less than 2."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": " It is required that the number of value X of edge with value X, with id Y is less than or equal to 1, whenever there is a node Y. ",
            "NL": "For all edges with value X, it is necessary that the number of edges with value X and id Y is at least 1 each time Y is a node."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": " It is required that the number of value X of edge with value X, with id Y is less than or equal to 1, whenever there is a node Y. ",
            "NL": "For any node Y, the quantity of edges with value X, having id Y, must be at least 1 for all edges with value X."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": " It is required that the number of value X of edge with value X, with id Y is less than or equal to 1, whenever there is a node Y. ",
            "NL": "For every node Y, the quantity of edges with value X and id Y must be no less than 1 for all edges with value X."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": " It is required that the number of value X of edge with value X, with id Y is less than or equal to 1, whenever there is a node Y. ",
            "NL": "For all edges with value X, it is necessary that the quantity of edges with value X and id Y is at least 1 every time there is a node Y."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": " It is required that the number of value X of edge with value X, with id Y is less than or equal to 1, whenever there is a node Y. ",
            "NL": "For any node Y, the quantity of edges with value X and ID Y must be at least 1 for all edges with value X."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that A is equal to F, whenever there is a Shortest_Path with field9 U, with edge10 A, whenever there is a Chart with field3 F, and with edge F, and with vtx4 S greater than P, whenever there is a Label with field3 F, and with edge U, and with vtx4 S greater than or equal to P, whenever there is a Label with field3 F, and with edge R, and with vtx4 L.",
            "NL": "The Shortest_Path must have a field9 U, an edge10 A, a Chart with field3 F and edge F, a Label with field3 F, edge U, and vtx4 S, and a Label with field3 F, edge R, and vtx4 P, where A is not equal to F, S is greater than P, and S is greater or equal to P."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that A is equal to F, whenever there is a Shortest_Path with field9 U, with edge10 A, whenever there is a Chart with field3 F, and with edge F, and with vtx4 S greater than P, whenever there is a Label with field3 F, and with edge U, and with vtx4 S greater than or equal to P, whenever there is a Label with field3 F, and with edge R, and with vtx4 L.",
            "NL": "When there is a Shortest_Path with field9 U, edge10 A, Chart with field3 F, edge F, vtx4 S, Label with field3 F, edge U, vtx4 S, and another Label with field3 F, edge R, and vtx4 P, A must not be equal to F, S must be greater than P, and S must be greater than or equal to P."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that A is equal to F, whenever there is a Shortest_Path with field9 U, with edge10 A, whenever there is a Chart with field3 F, and with edge F, and with vtx4 S greater than P, whenever there is a Label with field3 F, and with edge U, and with vtx4 S greater than or equal to P, whenever there is a Label with field3 F, and with edge R, and with vtx4 L.",
            "NL": "If the Shortest_Path field9 is U, edge10 is A, the Chart field3 is F, edge is F, vtx4 is S, the Label field3 is F, edge is U, vtx4 is S, and the Label field3 is F, edge is R, vtx4 is P, and A is not equal to F, S is greater than P, and S is greater than or equal to P, then a requirement must be met."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that A is equal to F, whenever there is a Shortest_Path with field9 U, with edge10 A, whenever there is a Chart with field3 F, and with edge F, and with vtx4 S greater than P, whenever there is a Label with field3 F, and with edge U, and with vtx4 S greater than or equal to P, whenever there is a Label with field3 F, and with edge R, and with vtx4 L.",
            "NL": "If the Shortest_Path has field9 U, edge10 A, the Chart has field3 F, edge F, vtx4 S, the Label has field3 F, edge U, vtx4 S, and another Label has field3 F, edge R, vtx4 P, and A is not equal to F, S is greater than P, and S is greater or equal to P, then it is a requirement."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that A is equal to F, whenever there is a Shortest_Path with field9 U, with edge10 A, whenever there is a Chart with field3 F, and with edge F, and with vtx4 S greater than P, whenever there is a Label with field3 F, and with edge U, and with vtx4 S greater than or equal to P, whenever there is a Label with field3 F, and with edge R, and with vtx4 L.",
            "NL": "Whenever there is a Shortest_Path with field9 U, edge10 A, Chart with field3 F, edge F, vtx4 S, Label with field3 F, edge U, vtx4 S, and another Label with field3 F, edge R, and vtx4 P, the condition that A is not equal to F, S is greater than P, and S is greater than or equal to P must be met."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that A is equal to U, whenever there is a Important with node9 U, with field4 R, whenever there is a Important with node9 A, with field4 R.",
            "NL": "Whenever an Important with node9 U and field4 R is present, there must also be an Important with node9 A and field4 R, where A does not equal U."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that A is equal to U, whenever there is a Important with node9 U, with field4 R, whenever there is a Important with node9 A, with field4 R.",
            "NL": "Whenever there is an Important with node9 U and field4 R, and also an Important with node9 A and field4 R, provided that A is not equal to U, it is a requirement."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that A is equal to U, whenever there is a Important with node9 U, with field4 R, whenever there is a Important with node9 A, with field4 R.",
            "NL": "Whenever there is an Important with node9 U, with field4 R, and also an Important with node9 A (where A is not equal to U) there is a requirement."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that A is equal to U, whenever there is a Important with node9 U, with field4 R, whenever there is a Important with node9 A, with field4 R.",
            "NL": "A requirement exists that whenever there is an Important with node9 U and field4 R, there must also be an Important with node9 A and field4 R, where A is not the same as U."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that A is equal to U, whenever there is a Important with node9 U, with field4 R, whenever there is a Important with node9 A, with field4 R.",
            "NL": "It is essential that when there is an Important with node9 U and field4 R, there must also be an Important with node9 A and field4 R, where A is not the same as U."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that D is equal to H, whenever there is an OutDegree with key1 Y, with value1 D, whenever there is an OutDegree with key1 Y, with value1 H.",
            "NL": "Any time an OutDegree with key1 Y has a value1 of D, and another OutDegree with key1 Y has a value1 of H, the two values must not be equal."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that D is equal to H, whenever there is an OutDegree with key1 Y, with value1 D, whenever there is an OutDegree with key1 Y, with value1 H.",
            "NL": "When an OutDegree has a key1 of Y and a value1 of D, and a different OutDegree also has a key1 of Y with a value1 of H, where D is not equal to H, it is a requirement."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that D is equal to H, whenever there is an OutDegree with key1 Y, with value1 D, whenever there is an OutDegree with key1 Y, with value1 H.",
            "NL": "Whenever an OutDegree with key1 Y has value1 D, and also has an OutDegree with key1 Y but with value1 H which is not equal to D, there is a requirement."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that D is equal to H, whenever there is an OutDegree with key1 Y, with value1 D, whenever there is an OutDegree with key1 Y, with value1 H.",
            "NL": "If OutDegree has key1 Y, value1 D, and also has an OutDegree with key1 Y, value1 H, but D is not the same as H, then it is a requirement."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that D is equal to H, whenever there is an OutDegree with key1 Y, with value1 D, whenever there is an OutDegree with key1 Y, with value1 H.",
            "NL": "If OutDegree with key1 Y has a value1 of D, and another OutDegree with key1 Y has a value1 of H, and D is not equal to H, then it is a requirement."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that every Adjacent H is Ending.",
            "NL": "It is required that no Adjacent H of the graph is Terminating."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that every Adjacent H is Ending.",
            "NL": "It is necessary that none of the Adjacent Hs of the graph have an End."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that every Adjacent H is Ending.",
            "NL": "It is necessary that no Adjacent H of the graph be Terminated."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that every Adjacent H is Ending.",
            "NL": "It is necessary that no Adjacent H of the graph is Final."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that every Adjacent H is Ending.",
            "NL": "It is necessary that no Adjacent H of the graph be Finishing."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that every Complete_Graph N is Utilized_Edge.",
            "NL": "Every Complete_Graph N must not have any Utilized_Edges."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that every Complete_Graph N is Utilized_Edge.",
            "NL": "It is required that no Utilized_Edge is present in any Complete_Graph N of the graph."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that every Complete_Graph N is Utilized_Edge.",
            "NL": "There is a requirement that no Utilized_Edge should be present in any Complete_Graph N."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that every Complete_Graph N is Utilized_Edge.",
            "NL": "It is a requirement that no edges are utilized in any Complete_Graph N of the graph."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that every Complete_Graph N is Utilized_Edge.",
            "NL": "It is required that no edges are used in any Complete_Graph N of the graph."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that every Identifier X is Symbol.",
            "NL": "It is necessary that no Symbol be used for any Identifier X in the graph."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that every Identifier X is Symbol.",
            "NL": "It is necessary that no Identifier X of the graph is a Symbol."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that every Identifier X is Symbol.",
            "NL": "It is necessary that no Symbol is an Identifier X of the graph."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that every Identifier X is Symbol.",
            "NL": "It is necessary that no Symbol be used as an Identifier X of the graph."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that every Identifier X is Symbol.",
            "NL": "It is necessary that no Symbol be an Identifier X of the graph."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that every Joined H is Edge_Match.",
            "NL": "It is necessary that no Joined H of the graph is Edge_Matched."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that every Joined H is Edge_Match.",
            "NL": "It is a requirement that no Joined H of the graph is Edge_Match."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that every Joined H is Edge_Match.",
            "NL": "It is a requirement that no two Joined H's of the graph are Edge_Matched."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that every Joined H is Edge_Match.",
            "NL": "It is necessary that no Joined H of the graph is Edge_Match."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that every Joined H is Edge_Match.",
            "NL": "It is a requirement that no Joined H of the graph is Edge_Matched."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that every Pairing M is Out.",
            "NL": "It is necessary that no Pairing M of the graph is Out."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that every Pairing M is Out.",
            "NL": "It is required that no Pairing M of the graph is Out."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that every Pairing M is Out.",
            "NL": "Every Pairing M of the graph must not be Out."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that every Pairing M is Out.",
            "NL": "It is a necessity that no Pairing M of the graph is Out."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that every Pairing M is Out.",
            "NL": "It is necessary for all Pairs M of the graph to not be Out."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that every Punishment L is Parent.",
            "NL": "It is necessary that each Punishment L in the graph is not a Parent."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that every Punishment L is Parent.",
            "NL": "It is necessary that no Punishment L of the graph is a Parent."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that every Punishment L is Parent.",
            "NL": "It is necessary that every Punishment on the graph not be a Parent."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that every Punishment L is Parent.",
            "NL": "It is necessary that all Punishments L of the graph are not Parents."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that every Punishment L is Parent.",
            "NL": "It is necessary that all Punishment L of the graph are not Parents."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that every vtx U is considered.",
            "NL": "It is a requirement that every vertex U of the graph is not taken into account."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that every vtx U is considered.",
            "NL": "It is necessary to exclude every vertex U of the graph from consideration."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that every vtx U is considered.",
            "NL": "It is necessary to exclude every vertex U of the graph."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that every vtx U is considered.",
            "NL": "It is a requirement that no vertex U of the graph is taken into consideration."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that every vtx U is considered.",
            "NL": "It is required that no vertex U of the graph be taken into account."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that F is equal to N, whenever there is a Thickness with value7 N, with vtx4 E, whenever there is a Thickness with value7 F, with vtx4 E.",
            "NL": "When the Thickness is set to 7 N and vtx4 is E, and the Thickness is set to 7 F and vtx4 is E where F is not equal to N, there is a requirement that must be met."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that F is equal to N, whenever there is a Thickness with value7 N, with vtx4 E, whenever there is a Thickness with value7 F, with vtx4 E.",
            "NL": "Whenever the Thickness has a value of 7 N and vtx4 E, as well as 7 F and vtx4 E, but F is not equal to N, there is a requirement."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that F is equal to N, whenever there is a Thickness with value7 N, with vtx4 E, whenever there is a Thickness with value7 F, with vtx4 E.",
            "NL": "Whenever the Thickness has a value of 7 N and a vtx4 E, and when the Thickness also has a value of 7 F with a vtx4 E, where F is not equal to N, there is a requirement."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that F is equal to N, whenever there is a Thickness with value7 N, with vtx4 E, whenever there is a Thickness with value7 F, with vtx4 E.",
            "NL": "Whenever a Thickness of value 7 N with vtx4 E and a Thickness of value 7 F with vtx4 E exist, where F is not equal to N, is a requirement."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that F is equal to N, whenever there is a Thickness with value7 N, with vtx4 E, whenever there is a Thickness with value7 F, with vtx4 E.",
            "NL": "Whenever there is a Thickness with value7 N and vtx4 E, and a Thickness with value7 F and vtx4 E, where F is not equal to N, it is required."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that H is equal to Y, whenever there is an Inspect with node4 Y, with node6 F, whenever there is an Inspect with node4 H, with node6 F.",
            "NL": "Whenever there is an Inspect with node4 Y and node6 F, and also an Inspect with node4 H and node6 F, where H is not equal to Y, it is required."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that H is equal to Y, whenever there is an Inspect with node4 Y, with node6 F, whenever there is an Inspect with node4 H, with node6 F.",
            "NL": "When an Inspection is conducted with node4 Y and node6 F, and a separate Inspection is conducted with node4 H and node6 F, where H is not equal to Y, this is a requirement."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that H is equal to Y, whenever there is an Inspect with node4 Y, with node6 F, whenever there is an Inspect with node4 H, with node6 F.",
            "NL": "Whenever an Inspection with node4 Y and node6 F is done, and another Inspection with node4 H and node6 F is done, where H is not equal to Y, is required."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that H is equal to Y, whenever there is an Inspect with node4 Y, with node6 F, whenever there is an Inspect with node4 H, with node6 F.",
            "NL": "Whenever there is an Inspect with node4 Y and node6 F, and another Inspect with node4 H and node6 F, where H is not equal to Y, there is a requirement that must be met."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that H is equal to Y, whenever there is an Inspect with node4 Y, with node6 F, whenever there is an Inspect with node4 H, with node6 F.",
            "NL": "Whenever an Inspection is conducted with node4 Y and node6 F, and a separate Inspection is also conducted with node4 H and node6 F, where H does not equal Y, it is a requirement."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that H is equal to Z, whenever there is an NonClustering with fake value H, and with first vertex Z, whenever there is an NonClustering with fake value J, and with first vertex Z.",
            "NL": "Whenever there is a NonClustering with the fake value J and the first vertex Z, H must not be equal to J. Similarly, when there is a NonClustering with the fake value H and the first vertex Z, H must not be equal to J."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that H is equal to Z, whenever there is an NonClustering with fake value H, and with first vertex Z, whenever there is an NonClustering with fake value J, and with first vertex Z.",
            "NL": "Whenever there is a NonClustering with the first vertex Z and a fake value J, H must not be equal to J; similarly, when there is a NonClustering with the first vertex Z and a fake value H, H must not be equal to J."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that H is equal to Z, whenever there is an NonClustering with fake value H, and with first vertex Z, whenever there is an NonClustering with fake value J, and with first vertex Z.",
            "NL": "Whenever there is a NonClustering with the first vertex Z, H must not equal J if the fake value is J, and H must not equal J if the fake value is H."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that H is equal to Z, whenever there is an NonClustering with fake value H, and with first vertex Z, whenever there is an NonClustering with fake value J, and with first vertex Z.",
            "NL": "Whenever there is a NonClustering with the first vertex Z and a fake value J, H must not equal J, and likewise, when there is a NonClustering with the first vertex Z and a fake value H, H must not equal J."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that H is equal to Z, whenever there is an NonClustering with fake value H, and with first vertex Z, whenever there is an NonClustering with fake value J, and with first vertex Z.",
            "NL": "Whenever a NonClustering with the first vertex Z occurs and the fake value is either H or J, H must not be equal to J."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that I is at most or equal to Z, whenever there is a Punishment with value equal to 1, and with node2 I, whenever there is a Punishment with value equal to 20, and with node2 Z, whenever there is not Clue with first node Z, and with first point I.",
            "NL": "If there is a Punishment with a value of 20 assigned to node2 I and a Punishment with a value of 1 assigned to node2 Z and there is no Clue with both node2 I and node2 Z, then node2 Z must be less than or equal to node2 I."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that I is at most or equal to Z, whenever there is a Punishment with value equal to 1, and with node2 I, whenever there is a Punishment with value equal to 20, and with node2 Z, whenever there is not Clue with first node Z, and with first point I.",
            "NL": "If there is a Punishment with a value of 20 and node2 I, and a Punishment with a value of 1 and node2 Z, and there is not an Clue with node2 Z and node2 I, then node2 Z must always be less than or equal to node2 I."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that I is at most or equal to Z, whenever there is a Punishment with value equal to 1, and with node2 I, whenever there is a Punishment with value equal to 20, and with node2 Z, whenever there is not Clue with first node Z, and with first point I.",
            "NL": "Whenever there is a Punishment with value 20 and node2 I, and a Punishment with value 1 and node2 Z, if there is not an Clue with node2 Z and node2 I, then node2 Z must be less than or equal to node2 I."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that I is at most or equal to Z, whenever there is a Punishment with value equal to 1, and with node2 I, whenever there is a Punishment with value equal to 20, and with node2 Z, whenever there is not Clue with first node Z, and with first point I.",
            "NL": "Whenever there is a Punishment with value 20 and node2 I, and a Punishment with value 1 and node2 Z, if there is not an Clue with node2 Z and node2 I, the requirement is that node2 Z must be no greater than node2 I."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that I is at most or equal to Z, whenever there is a Punishment with value equal to 1, and with node2 I, whenever there is a Punishment with value equal to 20, and with node2 Z, whenever there is not Clue with first node Z, and with first point I.",
            "NL": "Whenever a Punishment of value 20 with node2 I and a Punishment of value 1 with node2 Z exist, when there is no Clue with node2 Z and node2 I, node2 Z must be less than or equal to node2 I."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that I is not after or equal to O, whenever there is a Degree_Sequence with fake value U, and with fifth vertex I, whenever there is a Degree_Sequence with fake value U, and with fifth vertex O, whenever there is not Out with fake value O, and with fifth vertex I.",
            "NL": "Whenever there is a Degree_Sequence with field9 U and field9 I, and a Degree_Sequence with field9 U and field9 O, if an Out with field9 O and field9 I does not exist, then field9 O must never come after field9 I."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that I is not after or equal to O, whenever there is a Degree_Sequence with fake value U, and with fifth vertex I, whenever there is a Degree_Sequence with fake value U, and with fifth vertex O, whenever there is not Out with fake value O, and with fifth vertex I.",
            "NL": "Whenever there is a Degree_Sequence with field9 U and field9 I, and also a Degree_Sequence with field9 U and field9 O, if there is not an Out with field9 O and field9 I, the requirement is that field9 O must never come after field9 I."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that I is not after or equal to O, whenever there is a Degree_Sequence with fake value U, and with fifth vertex I, whenever there is a Degree_Sequence with fake value U, and with fifth vertex O, whenever there is not Out with fake value O, and with fifth vertex I.",
            "NL": "Whenever there is a Degree_Sequence with field9 U and field9 I, and also a Degree_Sequence with field9 U and field9 O, the requirement is that there is not an Out with field9 O and field9 I, and that field9 O must never come after field9 I."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that I is not after or equal to O, whenever there is a Degree_Sequence with fake value U, and with fifth vertex I, whenever there is a Degree_Sequence with fake value U, and with fifth vertex O, whenever there is not Out with fake value O, and with fifth vertex I.",
            "NL": "Whenever there is a Degree_Sequence with field9 U and field9 I, and also one with field9 U and field9 O, if there is not an Out with field9 O and field9 I, the rule is that field9 O must not come after field9 I."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that I is not after or equal to O, whenever there is a Degree_Sequence with fake value U, and with fifth vertex I, whenever there is a Degree_Sequence with fake value U, and with fifth vertex O, whenever there is not Out with fake value O, and with fifth vertex I.",
            "NL": "Whenever there is a Degree_Sequence with field9 U and field9 I, as well as one with field9 U and field9 O, and when there is not an Out with field9 O and field9 I, it is required that field9 O is never after field9 I."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that J is equal to N, whenever there is a Complete with value1 Y, with vtx9 J, whenever there is an Oriented with value6 N, and with field6 N, and with key C greater than S, whenever there is an Utilized_Edge with value6 N, and with field6 Y, and with key C greater than or equal to S, whenever there is an Utilized_Edge with value6 N, and with field6 O, and with key K.",
            "NL": "If the Complete has value1 Y, vtx9 J, and the Oriented has value6 N, field6 N, and key C, and the Utilized_Edge has value6 N, field6 Y, and key C, and additionally the Utilized_Edge has value6 N, field6 O, and key S, where J is not equal to N, C is greater than S, and C is greater than or equal to S, then a requirement is in effect."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that J is equal to N, whenever there is a Complete with value1 Y, with vtx9 J, whenever there is an Oriented with value6 N, and with field6 N, and with key C greater than S, whenever there is an Utilized_Edge with value6 N, and with field6 Y, and with key C greater than or equal to S, whenever there is an Utilized_Edge with value6 N, and with field6 O, and with key K.",
            "NL": "A requirement exists that when Complete has value1 Y, vtx9 J, and Oriented has value6 N, field6 N, and key C, Utilized_Edge has value6 N, field6 Y, and key C, and Utilized_Edge has value6 N, field6 O, and key S, J does not equal N, C is greater than S, and C is greater than or equal to S."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that J is equal to N, whenever there is a Complete with value1 Y, with vtx9 J, whenever there is an Oriented with value6 N, and with field6 N, and with key C greater than S, whenever there is an Utilized_Edge with value6 N, and with field6 Y, and with key C greater than or equal to S, whenever there is an Utilized_Edge with value6 N, and with field6 O, and with key K.",
            "NL": "Whenever there is a Complete with value1 Y, vtx9 J, and Oriented with value6 N, field6 N, and key C; and Utilized_Edge with value6 N, field6 Y, and key C; and Utilized_Edge with value6 N, field6 O, and key S, where J is not equal to N, C is greater than S, and C is greater than or equal to S, there is a requirement."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that J is equal to N, whenever there is a Complete with value1 Y, with vtx9 J, whenever there is an Oriented with value6 N, and with field6 N, and with key C greater than S, whenever there is an Utilized_Edge with value6 N, and with field6 Y, and with key C greater than or equal to S, whenever there is an Utilized_Edge with value6 N, and with field6 O, and with key K.",
            "NL": "Whenever there is a Complete with a value of Y, a vtx9 of J, an Oriented with a value of N, a field6 of N, a key of C, a Utilized_Edge with a value of N, a field6 of Y, a key of C, and another Utilized_Edge with a value of N, a field6 of O, and a key of S, then J must not be equal to N, C must be greater than S, and C must be greater than or equal to S."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that J is equal to N, whenever there is a Complete with value1 Y, with vtx9 J, whenever there is an Oriented with value6 N, and with field6 N, and with key C greater than S, whenever there is an Utilized_Edge with value6 N, and with field6 Y, and with key C greater than or equal to S, whenever there is an Utilized_Edge with value6 N, and with field6 O, and with key K.",
            "NL": "Whenever there is a Complete with value1 Y, a vtx9 J, an Oriented with value6 N, a field6 N, a key C, a Utilized_Edge with value6 N, a field6 Y, a key C, and a Utilized_Edge with value6 N, a field6 O, and a key S, the requirement is that J must not be equal to N, C must be greater than S, and C must be greater than or equal to S."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that K is equal to Q, whenever there is an Incoming_Level with fifth id A, and with second point K, whenever there is an Incoming_Level with fifth id A, and with second point Q.",
            "NL": "Whenever an Incoming_Level with the fifth id A has the second point Q, K must not be equal to Q, and when the same Incoming_Level has the second point K, K must not be equal to Q either."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that K is equal to Q, whenever there is an Incoming_Level with fifth id A, and with second point K, whenever there is an Incoming_Level with fifth id A, and with second point Q.",
            "NL": "Whenever there is an Incoming_Level with the fifth id A, and with the second point K, K must not be equal to Q."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that K is equal to Q, whenever there is an Incoming_Level with fifth id A, and with second point K, whenever there is an Incoming_Level with fifth id A, and with second point Q.",
            "NL": "Whenever Incoming_Level has the fifth id A and second point Q, K must not be equal to Q; similarly, when Incoming_Level has the fifth id A and second point K, K must not be equal to Q."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that K is equal to Q, whenever there is an Incoming_Level with fifth id A, and with second point K, whenever there is an Incoming_Level with fifth id A, and with second point Q.",
            "NL": "K must not be equal to Q whenever there is an Incoming_Level with fifth id A and second point either K or Q."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that K is equal to Q, whenever there is an Incoming_Level with fifth id A, and with second point K, whenever there is an Incoming_Level with fifth id A, and with second point Q.",
            "NL": "Whenever there is an Incoming_Level with the fifth id A, and with the second point Q, the requirement is that K must not be equal to Q; likewise, when there is an Incoming_Level with the fifth id A, and with the second point K, K must not be equal to Q."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that K is equal to S, whenever there is an Inputted with edge6 Z, with vtx5 K, whenever there is an Inputted with edge6 Z, with vtx5 S.",
            "NL": "Whenever an Inputted with edge6 Z, with vtx5 K, is not equal to an Inputted with edge6 Z, with vtx5 S, there is a requirement."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that K is equal to S, whenever there is an Inputted with edge6 Z, with vtx5 K, whenever there is an Inputted with edge6 Z, with vtx5 S.",
            "NL": "Whenever there is an Inputted with edge6 Z and vtx5 K, and another Inputted with edge6 Z and vtx5 S, where K and S are not equal to each other, there is a requirement."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that K is equal to S, whenever there is an Inputted with edge6 Z, with vtx5 K, whenever there is an Inputted with edge6 Z, with vtx5 S.",
            "NL": "If an Inputted with edge6 Z and vtx5 K is given, and another Inputted with edge6 Z and vtx5 S is given, where K is not equal to S, there is a requirement to be fulfilled."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that K is equal to S, whenever there is an Inputted with edge6 Z, with vtx5 K, whenever there is an Inputted with edge6 Z, with vtx5 S.",
            "NL": "Whenever an Inputted edge6 Z with vtx5 K is not equal to an Inputted edge6 Z with vtx5 S, there is a requirement."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that K is equal to S, whenever there is an Inputted with edge6 Z, with vtx5 K, whenever there is an Inputted with edge6 Z, with vtx5 S.",
            "NL": "When there is an Inputted with edge6 Z and vtx5 K, and another Inputted with edge6 Z and vtx5 S, then K must not be equal to S."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that L is at most or equal to O, whenever there is an Accomplished with value equal to 1, and with id1 L, whenever there is an Accomplished with value equal to 16, and with id1 O, whenever there is not Passive with fourth node O, and with first point L.",
            "NL": "Whenever an Accomplished with value 16 and id1 L exists, and an Accomplished with value 1 and id1 O is also present but there is no Passive with both id1 O and id1 L, the requirement is that id1 O is always less than or equal to id1 L."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that L is at most or equal to O, whenever there is an Accomplished with value equal to 1, and with id1 L, whenever there is an Accomplished with value equal to 16, and with id1 O, whenever there is not Passive with fourth node O, and with first point L.",
            "NL": "Whenever there is an Accomplished with value 16 and id1 L, and an Accomplished with value 1 and id1 O, but no Passive with id1 O and id1 L, the requirement is that id1 O must always be less than or equal to id1 L."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that L is at most or equal to O, whenever there is an Accomplished with value equal to 1, and with id1 L, whenever there is an Accomplished with value equal to 16, and with id1 O, whenever there is not Passive with fourth node O, and with first point L.",
            "NL": "Whenever there is an Accomplished with value 16 and id1 L, as well as an Accomplished with value 1 and id1 O, if there is not a Passive with id1 O and id1 L, then id1 O must be no greater than id1 L."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that L is at most or equal to O, whenever there is an Accomplished with value equal to 1, and with id1 L, whenever there is an Accomplished with value equal to 16, and with id1 O, whenever there is not Passive with fourth node O, and with first point L.",
            "NL": "If there is an Accomplished with value 16 and id1 L, and an Accomplished with value 1 and id1 O, but no Passive with id1 O and id1 L, then id1 O must be equal to or less than id1 L."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that L is at most or equal to O, whenever there is an Accomplished with value equal to 1, and with id1 L, whenever there is an Accomplished with value equal to 16, and with id1 O, whenever there is not Passive with fourth node O, and with first point L.",
            "NL": "If there is an Accomplished with value 16 and id1 L, and an Accomplished with value 1 and id1 O, and not a Passive with id1 O and id1 L, then id1 O must be less than or equal to id1 L."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that M is equal to K, whenever there is a Lacking with field2 O, with id2 M, whenever there is a Lacking with field2 O, with id2 K.",
            "NL": "When there is a Lacking with field2 O, and id2 M, and another Lacking with field2 O, and id2 K, the condition of M not being equal to K must be met."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that M is equal to K, whenever there is a Lacking with field2 O, with id2 M, whenever there is a Lacking with field2 O, with id2 K.",
            "NL": "Whenever there is a Lacking with field2 O, with id2 M, and there is also a Lacking with field2 O, with id2 K, but M is not equal to K, there is a requirement."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that M is equal to K, whenever there is a Lacking with field2 O, with id2 M, whenever there is a Lacking with field2 O, with id2 K.",
            "NL": "Whenever there is a Lacking with field2 O, and the id2s are M and K, where M is not equal to K, there is a requirement."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that M is equal to K, whenever there is a Lacking with field2 O, with id2 M, whenever there is a Lacking with field2 O, with id2 K.",
            "NL": "Whenever there is a Lacking with field2 O and id2 M, and another Lacking with field2 O and id2 K, where M is not equal to K, there is a requirement."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that M is equal to K, whenever there is a Lacking with field2 O, with id2 M, whenever there is a Lacking with field2 O, with id2 K.",
            "NL": "If field2 O has a Lacking with id2 M and another Lacking with id2 K, where M and K are not equal, there is a requirement."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that M is equal to M1, whenever there is a match with value M1, with id W, whenever there is a match with value M, with id W.",
            "NL": "Whenever there is a match with value M1, having the id W, and another match with value M (not equal to M1), having the same id W, a requirement must be met."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that M is equal to M1, whenever there is a match with value M1, with id W, whenever there is a match with value M, with id W.",
            "NL": "Whenever a match with value M1 and id W is present, and there is also a match with value M (where M is not equal to M1) and id W, a requirement must be fulfilled."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that M is equal to M1, whenever there is a match with value M1, with id W, whenever there is a match with value M, with id W.",
            "NL": "If M and M1 are not equal and there is a match with value M1 and ID W, as well as a match with value M and ID W, then it is necessary."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that M is equal to M1, whenever there is a match with value M1, with id W, whenever there is a match with value M, with id W.",
            "NL": "Whenever a match with value M1 and id W is present, and a match with a different value M and the same id W is also present, then it is required."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that M is equal to M1, whenever there is a match with value M1, with id W, whenever there is a match with value M, with id W.",
            "NL": "If there is a match with value M1 and id W, and a separate match with value M and the same id W, where M is not equal to M1, then there is a requirement."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that N is equal to I, whenever there is an Perfect_Graph with second vertex N, and with second id I, whenever there is an Perfect_Graph with second vertex Z, and with second id I.",
            "NL": "If a Perfect_Graph contains a second vertex Z and a second id I, N must not be equal to Z. Similarly, when a Perfect_Graph contains a second vertex N and a second id I, N must not be equal to Z."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that N is equal to I, whenever there is an Perfect_Graph with second vertex N, and with second id I, whenever there is an Perfect_Graph with second vertex Z, and with second id I.",
            "NL": "Whenever a Perfect_Graph has a second vertex of Z and a second id of I, then N must not be equal to Z; similarly, when a Perfect_Graph has a second vertex of N and a second id of I, N must still not be equal to Z."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that N is equal to I, whenever there is an Perfect_Graph with second vertex N, and with second id I, whenever there is an Perfect_Graph with second vertex Z, and with second id I.",
            "NL": "Whenever a Perfect_Graph has a second vertex Z and a second id of I, N must not be equal to Z. Likewise, when a Perfect_Graph has a second vertex N and a second id of I, N must not be equal to Z."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that N is equal to I, whenever there is an Perfect_Graph with second vertex N, and with second id I, whenever there is an Perfect_Graph with second vertex Z, and with second id I.",
            "NL": "Whenever a Perfect_Graph has a second vertex of Z with a second id of I, N must not be equal to Z; likewise, if a Perfect_Graph has a second vertex of N with a second id of I, N must not be equal to Z."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that N is equal to I, whenever there is an Perfect_Graph with second vertex N, and with second id I, whenever there is an Perfect_Graph with second vertex Z, and with second id I.",
            "NL": "Whenever a Perfect_Graph has the second vertex Z and second id I, N must not be equal to Z. Likewise, if a Perfect_Graph has the second vertex N and second id I, N must not be equal to Z."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that Q is equal to L, whenever there is an Edge_Paired with id2 V, with node8 Q, whenever there is an Edge_Paired with id2 V, with node8 L.",
            "NL": "If Edge_Paired with id2 V has both node8 Q and node8 L, then Q must not be equal to L."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that Q is equal to L, whenever there is an Edge_Paired with id2 V, with node8 Q, whenever there is an Edge_Paired with id2 V, with node8 L.",
            "NL": "When Edge_Paired with id2 V is present, node8 Q and node8 L must be different from each other."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that Q is equal to L, whenever there is an Edge_Paired with id2 V, with node8 Q, whenever there is an Edge_Paired with id2 V, with node8 L.",
            "NL": "Whenever there is an Edge_Paired with id2 V and node8 Q, and another Edge_Paired with id2 V and node8 L, where Q is not equal to L, there is a requirement."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that Q is equal to L, whenever there is an Edge_Paired with id2 V, with node8 Q, whenever there is an Edge_Paired with id2 V, with node8 L.",
            "NL": "Whenever there is an Edge_Paired with id2 V, the requirement is that node8 Q must not be equal to node8 L, even if both Edges_Paired have id2 V."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that Q is equal to L, whenever there is an Edge_Paired with id2 V, with node8 Q, whenever there is an Edge_Paired with id2 V, with node8 L.",
            "NL": "Whenever there is an Edge_Paired with id2 V and node8 Q, and another Edge_Paired with id2 V and node8 L, Q and L must not be equal."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that R is not after or equal to W, whenever there is a NotFirst with value equal to 1, and with value4 R, whenever there is a NotFirst with value equal to 34, and with value4 W, whenever there is not Three_Nodes with second vertex W, and with fifth id R.",
            "NL": "Whenever there is a NotFirst with a value of 34 and a value4 of R, and also a NotFirst with a value of 1 and a value4 of W, if there is not an Three_Nodes with a value4 of W and a value4 of R, the requirement is that the value4 W must always be before the value4 R."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that R is not after or equal to W, whenever there is a NotFirst with value equal to 1, and with value4 R, whenever there is a NotFirst with value equal to 34, and with value4 W, whenever there is not Three_Nodes with second vertex W, and with fifth id R.",
            "NL": "Whenever a NotFirst with value 34 and value4 R, and also a NotFirst with value 1 and value4 W exist, and there is not an Three_Nodes with value4 W and value4 R, the requirement is that value4 W is always not after value4 R."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that R is not after or equal to W, whenever there is a NotFirst with value equal to 1, and with value4 R, whenever there is a NotFirst with value equal to 34, and with value4 W, whenever there is not Three_Nodes with second vertex W, and with fifth id R.",
            "NL": "Whenever there is a NotFirst with a value of 34 and a value4 of R, and a NotFirst with a value of 1 and a value4 of W, when there is not an Three_Nodes with a value4 of W and a value4 of R, the requirement is that the value4 W is never after the value4 R."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that R is not after or equal to W, whenever there is a NotFirst with value equal to 1, and with value4 R, whenever there is a NotFirst with value equal to 34, and with value4 W, whenever there is not Three_Nodes with second vertex W, and with fifth id R.",
            "NL": "Whenever there is a NotFirst with value 34 and value4 R, and a NotFirst with value 1 and value4 W, if there is not an Three_Nodes with value4 W and value4 R, the requirement is that value4 W is always not after value4 R."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that R is not after or equal to W, whenever there is a NotFirst with value equal to 1, and with value4 R, whenever there is a NotFirst with value equal to 34, and with value4 W, whenever there is not Three_Nodes with second vertex W, and with fifth id R.",
            "NL": "Whenever there is a NotFirst with value 34 and value4 R, and also a NotFirst with value 1 and value4 W, if there is not an Three_Nodes with value4 W and value4 R, the requirement is that value4 W must always come before value4 R."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that S is equal to C, whenever there is an Eulerian_Graph with fifth point S, and with first id C, whenever there is an Eulerian_Graph with fifth point G, and with first id C.",
            "NL": "Whenever there is an Eulerian_Graph with the first id C, the requirement is that the fifth point S must not be equal to the fifth point G."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that S is equal to C, whenever there is an Eulerian_Graph with fifth point S, and with first id C, whenever there is an Eulerian_Graph with fifth point G, and with first id C.",
            "NL": "Whenever there is an Eulerian_Graph with the first id C and the fifth point G, S must not be equal to G; similarly, for an Eulerian_Graph with the first id C and the fifth point S, S must not be equal to G."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that S is equal to C, whenever there is an Eulerian_Graph with fifth point S, and with first id C, whenever there is an Eulerian_Graph with fifth point G, and with first id C.",
            "NL": "Whenever there is an Eulerian_Graph with the first id C, the requirement is that S must not be equal to G when the fifth point is G, and S when the fifth point is S."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that S is equal to C, whenever there is an Eulerian_Graph with fifth point S, and with first id C, whenever there is an Eulerian_Graph with fifth point G, and with first id C.",
            "NL": "Whenever there is an Eulerian_Graph with a first id of C and a fifth point of G, the fifth point of S must not be equal to G, and whenever there is an Eulerian_Graph with a first id of C and a fifth point of S, the fifth point of S must not be equal to G."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that S is equal to C, whenever there is an Eulerian_Graph with fifth point S, and with first id C, whenever there is an Eulerian_Graph with fifth point G, and with first id C.",
            "NL": "Whenever an Eulerian_Graph with the first id C has the fifth point G, S must not be equal to G, and the same is true when the fifth point S is present and the first id C is present."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that T is equal to P, whenever there is a Complete_Graph with field Q, with node T, whenever there is a Complete_Graph with field Q, with node P.",
            "NL": "When a Complete_Graph with field Q has a node T, and another Complete_Graph with field Q has a node P, but T does not equal P, then this is a requirement."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that T is equal to P, whenever there is a Complete_Graph with field Q, with node T, whenever there is a Complete_Graph with field Q, with node P.",
            "NL": "Whenever there is a Complete_Graph with field Q containing both node T and node P, with T not being equal to P, there is a requirement."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that T is equal to P, whenever there is a Complete_Graph with field Q, with node T, whenever there is a Complete_Graph with field Q, with node P.",
            "NL": "A Complete_Graph with field Q, containing a node T, must not have a node P that is equal to T, if there is another Complete_Graph with field Q."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that T is equal to P, whenever there is a Complete_Graph with field Q, with node T, whenever there is a Complete_Graph with field Q, with node P.",
            "NL": "When there is a Complete_Graph with field Q and node T, and also a Complete_Graph with field Q and node P, T must not be equal to P."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that T is equal to P, whenever there is a Complete_Graph with field Q, with node T, whenever there is a Complete_Graph with field Q, with node P.",
            "NL": "When a Complete_Graph with field Q and node T exists, and another Complete_Graph with field Q and node P exists, where T is not equal to P, there is a requirement."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of field8 C of Painted with edge3 L, with field8 C is not after 39, such that there is a Weighted with field8 C, with edge3 H, whenever there is a Trivial with edge3 H, and with field8 L.",
            "NL": "In order to ensure that there is always a Weighted with field8 C and edge3 H for each Trivial with edge3 H and field8 L, it is necessary to set the number of values of Painted with edge3 L and field8 C to no more than 39."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of field8 C of Painted with edge3 L, with field8 C is not after 39, such that there is a Weighted with field8 C, with edge3 H, whenever there is a Trivial with edge3 H, and with field8 L.",
            "NL": "It is necessary to ensure that the quantity of values of Painted with edge3 L and field8 C is not greater than 39, so that there will always be a Weighted with field8 C and edge3 H when there is a Trivial with edge3 H and field8 L."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of field8 C of Painted with edge3 L, with field8 C is not after 39, such that there is a Weighted with field8 C, with edge3 H, whenever there is a Trivial with edge3 H, and with field8 L.",
            "NL": "In order to ensure that there is always a Weighted with field8 C and edge3 H when there is a Trivial with edge3 H and field8 L, the number of Painted with edge3 L and field8 C values must not exceed 39."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of field8 C of Painted with edge3 L, with field8 C is not after 39, such that there is a Weighted with field8 C, with edge3 H, whenever there is a Trivial with edge3 H, and with field8 L.",
            "NL": "In order to ensure that a Trivial with edge3 H and field8 L always has a Weighted with field8 C and edge3 H, the number of values of Painted with edge3 L and field8 C must not exceed 39."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of field8 C of Painted with edge3 L, with field8 C is not after 39, such that there is a Weighted with field8 C, with edge3 H, whenever there is a Trivial with edge3 H, and with field8 L.",
            "NL": "It is necessary to ensure that the amount of values of Painted with an edge3 L and field8 C is not greater than 39, so that there will always be a Weighted with field8 C and edge3 H when there is a Trivial with edge3 H and field8 L."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of fifth point E of Allocate with first id O, with fifth point E is not after or equal to W, such that there is a Vertex E, whenever there is a Duo with value2 B, whenever there is a Vertex O.",
            "NL": "Whenever there is a Duo with value2 W, the number of fifth point E of the Allocate with first id O is not after or equal to W, so there is always a Vertex E when there is a Vertex O."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of fifth point E of Allocate with first id O, with fifth point E is not after or equal to W, such that there is a Vertex E, whenever there is a Duo with value2 B, whenever there is a Vertex O.",
            "NL": "Whenever there is a Duo with value2 W, and the number of fifth point E of the Allocate with first id O is not after or equal to W, then there is a Vertex E whenever there is a Vertex O."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of fifth point E of Allocate with first id O, with fifth point E is not after or equal to W, such that there is a Vertex E, whenever there is a Duo with value2 B, whenever there is a Vertex O.",
            "NL": "Whenever there is a Duo with value2 W, and the number of fifth point E of the Allocate with first id O is not after or equal to W, then there will be a Vertex E whenever there is a Vertex O."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of fifth point E of Allocate with first id O, with fifth point E is not after or equal to W, such that there is a Vertex E, whenever there is a Duo with value2 B, whenever there is a Vertex O.",
            "NL": "The definition states that the fifth point E of the Allocate with first id O cannot be greater than or equal to W, so if there is a Duo with value2 W, there will always be a Vertex E and a Vertex O."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of fifth point E of Allocate with first id O, with fifth point E is not after or equal to W, such that there is a Vertex E, whenever there is a Duo with value2 B, whenever there is a Vertex O.",
            "NL": "The definition stipulates that the fifth point E of Allocate with first id O is not greater than or equal to W, thus when the Duo has a value2 of W, there will always be a Vertex E; likewise, when there is a Vertex O, it will always be present."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of fifth point Z of Contrast with first id D, with fifth point Z is at most or equal to V, such that there is a Unarrowed Z, whenever there is a Inpath with key9 B, whenever there is a Unarrowed D.",
            "NL": "The Contrast with first id D states that the number of fifth point Z, when there is an Inpath with key9 V, must be no more than V; thus, when there is an Unarrowed D, there is always an Unarrowed Z."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of fifth point Z of Contrast with first id D, with fifth point Z is at most or equal to V, such that there is a Unarrowed Z, whenever there is a Inpath with key9 B, whenever there is a Unarrowed D.",
            "NL": "The definition states that the maximum value of fifth point Z in Contrast with first id D is V, therefore any Inpath with key9 V will always have an Unarrowed Z and Unarrowed D."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of fifth point Z of Contrast with first id D, with fifth point Z is at most or equal to V, such that there is a Unarrowed Z, whenever there is a Inpath with key9 B, whenever there is a Unarrowed D.",
            "NL": "The value of fifth point Z in regards to first id D must be less than or equal to V, and thus, if there is an Inpath with key9 V, then an Unarrowed Z will exist, in the event of an Unarrowed D."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of fifth point Z of Contrast with first id D, with fifth point Z is at most or equal to V, such that there is a Unarrowed Z, whenever there is a Inpath with key9 B, whenever there is a Unarrowed D.",
            "NL": "The maximum value of fifth point Z in Contrast with first id D is V, thus an Unarrowed Z is present when there is an Inpath with key9 V and an Unarrowed D."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of fifth point Z of Contrast with first id D, with fifth point Z is at most or equal to V, such that there is a Unarrowed Z, whenever there is a Inpath with key9 B, whenever there is a Unarrowed D.",
            "NL": "The definition states that the value of fifth point Z when paired with first id D must be no greater than V, thus an Unarrowed Z will always be present when there is an Inpath with key9 V and an Unarrowed D."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of id U of dom is less than or equal to K1, such that there is a vtx U, whenever there is a bound with value K1.",
            "NL": "U must have a vertex such that the number of dominant ids it has is less than or equal to the value of K1, which is a given bound."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of id U of dom is less than or equal to K1, such that there is a vtx U, whenever there is a bound with value K1.",
            "NL": "The vertex U must be less than or equal to K1 if there is a bound with value K1, meaning there must be a vertex U."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of id U of dom is less than or equal to K1, such that there is a vtx U, whenever there is a bound with value K1.",
            "NL": "U must have a vertex if there is a limit of K1, meaning the number of dominant ids U must be less than or equal to K1."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of id U of dom is less than or equal to K1, such that there is a vtx U, whenever there is a bound with value K1.",
            "NL": "The number of dominant ids U must not exceed the bound K1, and thus a vertex U must exist."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of id U of dom is less than or equal to K1, such that there is a vtx U, whenever there is a bound with value K1.",
            "NL": "The vertex U must be less than or equal to K1, meaning that if there is a bound with the value K1, the number of dominant ids U cannot exceed that amount."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of id U of levelvtx with value equal to 1, with id U is less than or equal to B, such that there is a vtx U, whenever there is a bound with value B. ",
            "NL": "The requirement is that when there is a vtx U, with a bound of value B, not all the number of id U of the levelvtx has a value equal to 1, with id U being less than or equal to B."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of id U of levelvtx with value equal to 1, with id U is less than or equal to B, such that there is a vtx U, whenever there is a bound with value B. ",
            "NL": "When there is a vtx U with a bound of value B, the requirement is that not all id U of the levelvtx have a value of 1, with id U being less than or equal to B."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of id U of levelvtx with value equal to 1, with id U is less than or equal to B, such that there is a vtx U, whenever there is a bound with value B. ",
            "NL": "The requirement is that for any vtx U, with a bound of value B, not all the id U of the levelvtx have a value equal to 1 when id U is less than or equal to B."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of id U of levelvtx with value equal to 1, with id U is less than or equal to B, such that there is a vtx U, whenever there is a bound with value B. ",
            "NL": "The requirement states that not all id U of the levelvtx have a value of 1, when the vtx U is less than or equal to B, and has a bound of value B."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of id U of levelvtx with value equal to 1, with id U is less than or equal to B, such that there is a vtx U, whenever there is a bound with value B. ",
            "NL": "The requirement is that when there is a vtx U with a bound of value B, not all id U of the levelvtx have a value equal to 1, with id U being less than or equal to B."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of id1 U of link with id1 U, and with id2 V is equal to N, such that there is a cell_contain with id1 C, with id2 U, with id3 V, whenever there is a clue with id C, and with value N.",
            "NL": "Whenever there is a clue with id C and a value of N, there is a requirement that not all the number of id1 U of link with id1 U, cell_contain with id1 C, id2 U and id3 V are equal to N."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of id1 U of link with id1 U, and with id2 V is equal to N, such that there is a cell_contain with id1 C, with id2 U, with id3 V, whenever there is a clue with id C, and with value N.",
            "NL": "Whenever there is a clue with id C and value N, the number of linkages between id1 U, cell_contain with id1 C, id2 U, and id3 V must be equal to N."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of id1 U of link with id1 U, and with id2 V is equal to N, such that there is a cell_contain with id1 C, with id2 U, with id3 V, whenever there is a clue with id C, and with value N.",
            "NL": "Whenever there is a clue with id C and value N, not all the number of id1 U linked with id1 U, cell_contain with id1 C, id2 U and id3 V must be equal to N."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of id1 U of link with id1 U, and with id2 V is equal to N, such that there is a cell_contain with id1 C, with id2 U, with id3 V, whenever there is a clue with id C, and with value N.",
            "NL": "Whenever there is a clue with id C and a value of N, not all of the number of id1 U that are linked with id1 U, cell_contain with id1 C, with id2 U and with id3 V must be equal to N."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of id1 U of link with id1 U, and with id2 V is equal to N, such that there is a cell_contain with id1 C, with id2 U, with id3 V, whenever there is a clue with id C, and with value N.",
            "NL": "Whenever there is a clue with id C and a value of N, the number of id1 U linked with id1 U, cell_contain with id1 C, with id2 U and with id3 V must be equal to N."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of id10 J of Cut_Vertex is not after or equal to S, such that there is a Shade J, whenever there is an Inactive with edge1 S.",
            "NL": "The number of Cut_Vertex J must be less than or equal to S for there to be a Shade with edge1 S, meaning Shade J must exist."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of id10 J of Cut_Vertex is not after or equal to S, such that there is a Shade J, whenever there is an Inactive with edge1 S.",
            "NL": "For a Shade with edge number S, the number of Cut_Vertex must be no greater than S, meaning that there must be a Shade J."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of id10 J of Cut_Vertex is not after or equal to S, such that there is a Shade J, whenever there is an Inactive with edge1 S.",
            "NL": "The number of Cut_Vertex J must be less than or equal to S for there to be a Shade with edge1 S, thus J must be a Shade."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of id10 J of Cut_Vertex is not after or equal to S, such that there is a Shade J, whenever there is an Inactive with edge1 S.",
            "NL": "If there is a Shade S with edge1, the number of Cut_Vertex J must be no more than S, meaning there must be a Shade J."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of id10 J of Cut_Vertex is not after or equal to S, such that there is a Shade J, whenever there is an Inactive with edge1 S.",
            "NL": "The number of Cut_Vertex id10 J must be less than or equal to S for there to be a Shade with edge1 S, i.e. there must be a Shade J."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of id5 L of Planar_Embedding is at most or equal to D, such that there is a Planar L, whenever there is a First with edge D.",
            "NL": "The number of edges in a Planar_Embedding with id5 L must not exceed the edge D of the Planar, meaning that a Planar L must exist."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of id5 L of Planar_Embedding is at most or equal to D, such that there is a Planar L, whenever there is a First with edge D.",
            "NL": "The number of edges in the Planar Embedding with ID5 L must not exceed the edge D of the Planar, meaning that the Planar L must be Planar."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of id5 L of Planar_Embedding is at most or equal to D, such that there is a Planar L, whenever there is a First with edge D.",
            "NL": "The number of edges in Planar_Embedding id5 L must be less than or equal to D, meaning that Planar L must be Planar."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of id5 L of Planar_Embedding is at most or equal to D, such that there is a Planar L, whenever there is a First with edge D.",
            "NL": "The number of Planar_Embedding id5 L must not exceed the edge D of the Planar, meaning that a Planar L must exist."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of id5 L of Planar_Embedding is at most or equal to D, such that there is a Planar L, whenever there is a First with edge D.",
            "NL": "The number of edges in a Planar_Embedding with ID5 L must be less than or equal to D, meaning that there must be a Planar L."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of id6 F of Functioning is not after or equal to K, such that there is a Compartment F, whenever there is a Next with edge1 K.",
            "NL": "The number of Functioning id6 F in a Compartment with edge1 K must be no greater than K, meaning that there must be a Compartment F."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of id6 F of Functioning is not after or equal to K, such that there is a Compartment F, whenever there is a Next with edge1 K.",
            "NL": "The Compartment F must have a number of Functioning id6s that is less than or equal to K if there is a Compartment with edge1 K."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of id6 F of Functioning is not after or equal to K, such that there is a Compartment F, whenever there is a Next with edge1 K.",
            "NL": "The number of Functioning id6 F within the Compartment with edge1 K must be less than or equal to K, meaning that a Compartment F must be present."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of id6 F of Functioning is not after or equal to K, such that there is a Compartment F, whenever there is a Next with edge1 K.",
            "NL": "For Compartment K with edge1, there must be no more than K Functioning id6s, meaning that there must be at least one Compartment F."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of id6 F of Functioning is not after or equal to K, such that there is a Compartment F, whenever there is a Next with edge1 K.",
            "NL": "The number of Functioning id6 F must be less than or equal to edge1 K of the Compartment, meaning there must be a Compartment F."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of key5 B of Layer with value equal to 37, with key5 B is at most or equal to I, such that there is a Connection B, whenever there is a Mass with key8 I. ",
            "NL": "When there is a Connection B with a Mass of key8 I, not all key5 B in the Layer must have a value equal to 37, though key5 B must be at most or equal to I."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of key5 B of Layer with value equal to 37, with key5 B is at most or equal to I, such that there is a Connection B, whenever there is a Mass with key8 I. ",
            "NL": "When Connection B has a Mass of key8 I, not all of the Layer's key5 B values must be equal to 37, with key5 B being at most or equal to I."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of key5 B of Layer with value equal to 37, with key5 B is at most or equal to I, such that there is a Connection B, whenever there is a Mass with key8 I. ",
            "NL": "When Connection B has a Mass of key8 I, not all of the key5 B of the Layer need to have a value of 37, with the maximum value of key5 B being I."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of key5 B of Layer with value equal to 37, with key5 B is at most or equal to I, such that there is a Connection B, whenever there is a Mass with key8 I. ",
            "NL": "The requirement states that when a Connection B exists with a Mass of key8 I, the number of key5 B must not all have a value of 37, with key5 B being no greater than I."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of key5 B of Layer with value equal to 37, with key5 B is at most or equal to I, such that there is a Connection B, whenever there is a Mass with key8 I. ",
            "NL": "When there is a Connection B with a Mass of key8 I, not all the number of key5 B of the Layer must have a value equal to 37, with key5 B being at most or equal to I."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of node10 J of Nfirst is at most or equal to N, such that there is a Reached J, whenever there is a Link_Label with value N.",
            "NL": "If the Reached value is N, then the number of the first node J must be less than or equal to N, meaning that a Reached J must exist."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of node10 J of Nfirst is at most or equal to N, such that there is a Reached J, whenever there is a Link_Label with value N.",
            "NL": "If there is a Reached value of N, the number of the first node J must be less than or equal to N, meaning there must be a Reached J."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of node10 J of Nfirst is at most or equal to N, such that there is a Reached J, whenever there is a Link_Label with value N.",
            "NL": "If the Reached value is N, the number of the first node J must be less than or equal to N, meaning that there must be a Reached J."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of node10 J of Nfirst is at most or equal to N, such that there is a Reached J, whenever there is a Link_Label with value N.",
            "NL": "The Reached J must be less than or equal to N, meaning that there must be a Reached J if there is a Reached with value N."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of node10 J of Nfirst is at most or equal to N, such that there is a Reached J, whenever there is a Link_Label with value N.",
            "NL": "If the Reached value is N, then the amount of the Nfirst node10 J must be less than or equal to N; thus, a Reached J must exist."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of node2 M of Weight with value equal to 37, with node2 M is at most or equal to V, such that there is a Following M, whenever there is a Penalty with id5 V. ",
            "NL": "The requirement is that not all of the node2 M weights must have a value of 37, with node2 M being no more than V; if there is a Subsequent M, it will incur a Penalty of id5 V."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of node2 M of Weight with value equal to 37, with node2 M is at most or equal to V, such that there is a Following M, whenever there is a Penalty with id5 V. ",
            "NL": "The requirement is that not all of node2 M's Weight must be equal to 37, with node2 M no greater than V, and if there is a Following M, it needs to have a Penalty of id5 V."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of node2 M of Weight with value equal to 37, with node2 M is at most or equal to V, such that there is a Following M, whenever there is a Penalty with id5 V. ",
            "NL": "The requirement is that not all the node2 M of the Weight must have a value of 37, and node2 M must be less than or equal to V when there is a Following M with a Penalty of id5 V."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of node2 M of Weight with value equal to 37, with node2 M is at most or equal to V, such that there is a Following M, whenever there is a Penalty with id5 V. ",
            "NL": "The requirement is that the number of node2 M of the Weight must not all have a value equal to 37, with node2 M being at most or equal to V, and if there is a Following M, it must have a Penalty of id5 V."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of node2 M of Weight with value equal to 37, with node2 M is at most or equal to V, such that there is a Following M, whenever there is a Penalty with id5 V. ",
            "NL": "The requirement states that not all of the Weight's node2 M values must be equal to 37, with node2 M being at most or equal to V, and if there is a Following M, it is subject to a Penalty of id5 V."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of node4 O of Subsequently with value equal to 13, with node4 O is at most or equal to E, such that there is an Edge_Level O, whenever there is a Mass with id9 E. ",
            "NL": "The requirement states that the value of node4 O must not always be 13, and must be less than or equal to E when there is an Edge_Level O with a Mass of id9 E."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of node4 O of Subsequently with value equal to 13, with node4 O is at most or equal to E, such that there is an Edge_Level O, whenever there is a Mass with id9 E. ",
            "NL": "The requirement is that node4 O cannot all have a value of 13, with a maximum of E, when there is an Edge_Level O with a Mass of id9 E."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of node4 O of Subsequently with value equal to 13, with node4 O is at most or equal to E, such that there is an Edge_Level O, whenever there is a Mass with id9 E. ",
            "NL": "The requirement is that node4 O cannot all have a value equal to 13, and must be less than or equal to E when there is an Edge_Level O with a Mass of id9 E."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of node4 O of Subsequently with value equal to 13, with node4 O is at most or equal to E, such that there is an Edge_Level O, whenever there is a Mass with id9 E. ",
            "NL": "When Edge_Level O has a Mass of id9 E, the requirement is that not all the number of node4 O must have a value equal to 13, with node4 O being at most or equal to E."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of node4 O of Subsequently with value equal to 13, with node4 O is at most or equal to E, such that there is an Edge_Level O, whenever there is a Mass with id9 E. ",
            "NL": "For node4 O, the requirement is that not all its values are equal to 13, as long as it is less than or equal to E, and there is an Edge_Level O with a Mass of id9 E."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of node5 I of Nontrivial is at most or equal to H, such that there is a Weight I, whenever there is an Edge_Paired with key8 H.",
            "NL": "If Weight key8 H is present, then Nontrivial node5 I must be less than or equal to H, meaning a Weight I must exist."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of node5 I of Nontrivial is at most or equal to H, such that there is a Weight I, whenever there is an Edge_Paired with key8 H.",
            "NL": "If the Weight of key8 H is present, the number of Nontrivial node5 I must be less than or equal to H, meaning that a Weight I must exist."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of node5 I of Nontrivial is at most or equal to H, such that there is a Weight I, whenever there is an Edge_Paired with key8 H.",
            "NL": "If key8 H is present, the number of Nontrivial node5 I must not exceed H, meaning that a Weight I must be in place."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of node5 I of Nontrivial is at most or equal to H, such that there is a Weight I, whenever there is an Edge_Paired with key8 H.",
            "NL": "If the Weight with key8 H is present, the number of Nontrivial node5 I must not exceed H, meaning that a Weight I must exist."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of node5 I of Nontrivial is at most or equal to H, such that there is a Weight I, whenever there is an Edge_Paired with key8 H.",
            "NL": "If the Weight for key8 H is present, the number of Nontrivial node5 I must be less than or equal to H, meaning that a Weight I must exist."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of node7 T of Dendrogram with node7 T, with id3 S is at most or equal to 1, whenever there is a key S.",
            "NL": "The number of Dendrogram with node7 T, with id3 S, must always be at least 1 whenever there is a key S present."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of node7 T of Dendrogram with node7 T, with id3 S is at most or equal to 1, whenever there is a key S.",
            "NL": "For all Dendrogram with node7 T, it is a necessity that the number of Dendrogram with node7 T, and id3 S, must be no less than 1 each time a key S appears."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of node7 T of Dendrogram with node7 T, with id3 S is at most or equal to 1, whenever there is a key S.",
            "NL": "For any Key S, it is necessary that the amount of Dendrograms with Node7 T and ID3 S be at least 1."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of node7 T of Dendrogram with node7 T, with id3 S is at most or equal to 1, whenever there is a key S.",
            "NL": "For all Dendrogram with node7 T, the amount of Dendrogram with node7 T, and id3 S, must be at least 1 whenever there is a key S."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of node7 T of Dendrogram with node7 T, with id3 S is at most or equal to 1, whenever there is a key S.",
            "NL": "For all Dendrogram with node7 T, it is mandatory that the amount of Dendrogram with node7 T and id3 S must be at least 1 whenever there is a key S present."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of Nontrivial that are a OutgoingRoute field7 T is not after or equal to C, such that there is a Nontrivial T, whenever there is a Particle with field7 C.",
            "NL": "There must be a Nontrivial T for every Particle with field7 C, provided that the number of OutgoingRoute Nontrivial with field7 T is less than or equal to C."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of Nontrivial that are a OutgoingRoute field7 T is not after or equal to C, such that there is a Nontrivial T, whenever there is a Particle with field7 C.",
            "NL": "The number of OutgoingRoute T with field7 that are Nontrivial must be less than C, so that there is a Nontrivial T for every Particle with field7 C."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of Nontrivial that are a OutgoingRoute field7 T is not after or equal to C, such that there is a Nontrivial T, whenever there is a Particle with field7 C.",
            "NL": "The number of Nontrivial OutgoingRoute T must be less than C, so that whenever there is a Particle with field7 C, there will always be a Nontrivial T."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of Nontrivial that are a OutgoingRoute field7 T is not after or equal to C, such that there is a Nontrivial T, whenever there is a Particle with field7 C.",
            "NL": "The number of Nontrivial OutgoingRoutes with field7 T must be less than C, so that when there is a Particle with field7 C, there is always a Nontrivial T."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of Nontrivial that are a OutgoingRoute field7 T is not after or equal to C, such that there is a Nontrivial T, whenever there is a Particle with field7 C.",
            "NL": "The quantity of Nontrivial OutgoingRoutes with field7 T must be less than C, so that whenever there is a Particle with field7 C, there is always a Nontrivial T."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of Planar_Embedding that are a Twosome field10 D is at most or equal to U, such that there is a Planar_Embedding D, whenever there is a Predominant with field10 U.",
            "NL": "The maximum number of Planar_Embeddings that are Twosomes with field10 D must be U, so that if there is a Predominant with field10 U, there will be Planar_Embedding D."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of Planar_Embedding that are a Twosome field10 D is at most or equal to U, such that there is a Planar_Embedding D, whenever there is a Predominant with field10 U.",
            "NL": "The quantity of Planar_Embedding having field10 D must not exceed U, so that when there is a Predominant with field10 U, there is also Planar_Embedding D."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of Planar_Embedding that are a Twosome field10 D is at most or equal to U, such that there is a Planar_Embedding D, whenever there is a Predominant with field10 U.",
            "NL": "The quantity of Planar_Embedding pairs with field10 D must not exceed U, so that when there is a Predominant with field10 U, there is also a Planar_Embedding D."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of Planar_Embedding that are a Twosome field10 D is at most or equal to U, such that there is a Planar_Embedding D, whenever there is a Predominant with field10 U.",
            "NL": "The quantity of Planar_Embedding that is Twosome with field10 D must not exceed U, so that when there is a Predominant with field10 U, there will be a Planar_Embedding D present."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of Planar_Embedding that are a Twosome field10 D is at most or equal to U, such that there is a Planar_Embedding D, whenever there is a Predominant with field10 U.",
            "NL": "The maximum number of Planar_Embedding D that can be paired with field10 U must be U or less, so that every Predominant with field10 U will have a Planar_Embedding D."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of Regular that are a Edge value1 H is not after or equal to N, such that there is a Regular H, whenever there is a Parent with value1 N.",
            "NL": "Regular H must be less than or equal to N such that whenever there is a Parent with value1 N, there is also Regular H."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of Regular that are a Edge value1 H is not after or equal to N, such that there is a Regular H, whenever there is a Parent with value1 N.",
            "NL": "The amount of Regular H Edges must not exceed N, so that whenever there is a Parent with value1 N, there will be Regular H present."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of Regular that are a Edge value1 H is not after or equal to N, such that there is a Regular H, whenever there is a Parent with value1 N.",
            "NL": "The quantity of Regular Edges with value1 H must be less than or equal to N, so that when there is a Parent with value1 N, there is also a Regular H."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of Regular that are a Edge value1 H is not after or equal to N, such that there is a Regular H, whenever there is a Parent with value1 N.",
            "NL": "Regular H must be less than or equal to N, so that when there is a Parent with value1 N, there is also Regular H."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of Regular that are a Edge value1 H is not after or equal to N, such that there is a Regular H, whenever there is a Parent with value1 N.",
            "NL": "Regular H must be less than or equal to N, so that when there is a Parent with value1 N, there will also be Regular H."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of second id U of parentedge with first id P, with second id U is less than or equal to B, such that there is a vtx U, whenever there is a bound with value B, whenever there is a vtx P.",
            "NL": "Whenever there is a vertex P, the number of vertices U associated with the parent edge of P, with second id U, must be less than or equal to B, meaning there will be a vertex U whenever there is a bound with value B."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of second id U of parentedge with first id P, with second id U is less than or equal to B, such that there is a vtx U, whenever there is a bound with value B, whenever there is a vtx P.",
            "NL": "Whenever there is a vertex P, it is defined that the number of second id U of the parentedge with first id P is less than or equal to B, so there is a vertex U with a bound of value B."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of second id U of parentedge with first id P, with second id U is less than or equal to B, such that there is a vtx U, whenever there is a bound with value B, whenever there is a vtx P.",
            "NL": "Whenever there is a vertex P, the number of second IDs U of the parentedge with first ID P must be less than or equal to B, thus, a vertex U will exist whenever there is a bound with value B."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of second id U of parentedge with first id P, with second id U is less than or equal to B, such that there is a vtx U, whenever there is a bound with value B, whenever there is a vtx P.",
            "NL": "Whenever there is a vertex P, the number of second ids U of the parentedge with first id P must be less than or equal to B, meaning that a vertex U will always be present when there is a bound with value B."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of second id U of parentedge with first id P, with second id U is less than or equal to B, such that there is a vtx U, whenever there is a bound with value B, whenever there is a vtx P.",
            "NL": "Whenever there is a vertex P, and a bound with value B, it is defined that the number of second ids U associated with the parentedge of first id P is less than or equal to B, thus a vertex U is present."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of value X of in with id C, with value X is less than or equal to 2, such that there is a pair with value C, with id X, whenever there is a clique C. ",
            "NL": "Whenever there is a clique C, the number of values X of IN with id C that have a corresponding pair with value C and id X is at least 2."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of value X of in with id C, with value X is less than or equal to 2, such that there is a pair with value C, with id X, whenever there is a clique C. ",
            "NL": "Whenever there is a clique C, there must be a pair with value C and id X, and the quantity of INs with id C and value X must be at least 2."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of value X of in with id C, with value X is less than or equal to 2, such that there is a pair with value C, with id X, whenever there is a clique C. ",
            "NL": "Whenever there is a clique C, the amount of INs with id C that have a value of X is at least 2, and there is always a pair with value C, and id X."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of value X of in with id C, with value X is less than or equal to 2, such that there is a pair with value C, with id X, whenever there is a clique C. ",
            "NL": "Whenever there is a clique C, the quantity of X values of IN with ID C, that have a value of X, is at least 2, and there is a pair with value C and ID X."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of value X of in with id C, with value X is less than or equal to 2, such that there is a pair with value C, with id X, whenever there is a clique C. ",
            "NL": "Whenever there is a clique C, the number of values X of IN with id C, with value X, is at least two, and there is always a pair with value C and id X."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of value9 W of Atom with edge10 O, with value9 W is not after 20, such that there is a Valency with value9 W, with edge10 F, whenever there is a Unlabeled with edge10 F, and with value9 O.",
            "NL": "In order to maintain a Valency with value9 W and edge10 F whenever there is an Unlabeled with edge10 F and value9 O, it is necessary to ensure that the number of Atoms with edge10 O and value9 W is not greater than 20."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of value9 W of Atom with edge10 O, with value9 W is not after 20, such that there is a Valency with value9 W, with edge10 F, whenever there is a Unlabeled with edge10 F, and with value9 O.",
            "NL": "In order to ensure that there will always be an Unlabeled with edge10 F and value9 O with a Valency of value9 W with edge10 F, the number of Atom with edge10 O and value9 W must not exceed 20."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of value9 W of Atom with edge10 O, with value9 W is not after 20, such that there is a Valency with value9 W, with edge10 F, whenever there is a Unlabeled with edge10 F, and with value9 O.",
            "NL": "It is necessary that the number of Atoms with edge10 O and value9 W does not exceed 20, so that there is always a Valency with edge10 F and value9 W when there is an Unlabeled with edge10 F and value9 O."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of value9 W of Atom with edge10 O, with value9 W is not after 20, such that there is a Valency with value9 W, with edge10 F, whenever there is a Unlabeled with edge10 F, and with value9 O.",
            "NL": "It is necessary to ensure that the number of Atom values with edge10 O and value9 W does not exceed 20, so that there is always a Valency with value9 W and edge10 F when an Unlabeled with edge10 F and value9 O is present."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of value9 W of Atom with edge10 O, with value9 W is not after 20, such that there is a Valency with value9 W, with edge10 F, whenever there is a Unlabeled with edge10 F, and with value9 O.",
            "NL": "In order to ensure that there is a Valency with edge10 F and value9 W whenever there is an Unlabeled with edge10 F and value9 O, the number of Atoms with edge10 O and value9 W must not exceed 20."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of vtx6 D of field with vtx6 D, and with node Q is equal to N, such that there is a P_Value with node R, with node D, with value10 Q, whenever there is an OutgoingRoute with vtx3 R, and with field I.",
            "NL": "Whenever an OutgoingRoute with vtx3 R exists, there is a requirement that the number of vtx6 D fields, P_Value with node R, node D, and value10 Q are all equal to field I."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of vtx6 D of field with vtx6 D, and with node Q is equal to N, such that there is a P_Value with node R, with node D, with value10 Q, whenever there is an OutgoingRoute with vtx3 R, and with field I.",
            "NL": "Whenever there is an OutgoingRoute with vtx3 R, there must be a requirement that the number of vtx6 D fields, P_Value nodes R and D, and value10 Q are all equal to the field I."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of vtx6 D of field with vtx6 D, and with node Q is equal to N, such that there is a P_Value with node R, with node D, with value10 Q, whenever there is an OutgoingRoute with vtx3 R, and with field I.",
            "NL": "Whenever an OutgoingRoute with vtx3 R is present, there must be an equal number of vtx6 D fields, P_Value fields with node R, and fields with node D and value10 Q, as there is in the field I."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of vtx6 D of field with vtx6 D, and with node Q is equal to N, such that there is a P_Value with node R, with node D, with value10 Q, whenever there is an OutgoingRoute with vtx3 R, and with field I.",
            "NL": "Whenever there is an OutgoingRoute with vtx3 R, there must be an equal number of vtx6 D and P_Value with node R, node D, and value10 Q fields, as well as a field I."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of vtx6 D of field with vtx6 D, and with node Q is equal to N, such that there is a P_Value with node R, with node D, with value10 Q, whenever there is an OutgoingRoute with vtx3 R, and with field I.",
            "NL": "Whenever there is an OutgoingRoute with vtx3 R, there is a requirement that not all the number of vtx6 D fields with vtx6 D, P_Value with node R, and with value10 Q must be equal to the field I."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of vtx8 C of Difference with node5 P, with vtx8 C is not after or equal to 30, such that there is an Ending with vtx8 P, with node5 C, whenever there is a Link_Label P.",
            "NL": "Whenever there is a Link_Label P, the number of values X of Difference with node5 P, and vtx8 C, must be greater than or equal to 30, so that there is an Ending with vtx8 P, and node5 C."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of vtx8 C of Difference with node5 P, with vtx8 C is not after or equal to 30, such that there is an Ending with vtx8 P, with node5 C, whenever there is a Link_Label P.",
            "NL": "Whenever there is a Link_Label P, the quantity of X, which is the Difference between node5 P and vtx8 C, must be at least 30, and there will be an Ending at vtx8 P with node5 C."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of vtx8 C of Difference with node5 P, with vtx8 C is not after or equal to 30, such that there is an Ending with vtx8 P, with node5 C, whenever there is a Link_Label P.",
            "NL": "Whenever there is a Link_Label P, the number of values X of the Difference with node5 P and vtx8 C must be at least 30, so that there is an Ending with vtx8 P and node5 C."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of vtx8 C of Difference with node5 P, with vtx8 C is not after or equal to 30, such that there is an Ending with vtx8 P, with node5 C, whenever there is a Link_Label P.",
            "NL": "Whenever there is a Link_Label P, the number of values X of Difference with node5 P and vtx8 C must be greater than or equal to 30, so that an Ending with vtx8 P and node5 C is possible."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of vtx8 C of Difference with node5 P, with vtx8 C is not after or equal to 30, such that there is an Ending with vtx8 P, with node5 C, whenever there is a Link_Label P.",
            "NL": "Whenever there is a Link_Label P, the number of values X of Difference with node5 P and vtx8 C must be at least 30 for there to be an Ending with vtx8 P and node5 C."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of vtxs that are a dom with id U is less than or equal to K1, such that there is a vtx U, whenever there is a bound with id K1. ",
            "NL": "The vertex with id U must have a count less than or equal to K1 so that there is a vertex U for every bound with id K1."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of vtxs that are a dom with id U is less than or equal to K1, such that there is a vtx U, whenever there is a bound with id K1. ",
            "NL": "The number of vertices with ID U must be no greater than K1 so that a vertex U is associated with the corresponding bound of ID K1."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of vtxs that are a dom with id U is less than or equal to K1, such that there is a vtx U, whenever there is a bound with id K1. ",
            "NL": "The amount of vertices associated with ID U should be no greater than K1, so that whenever a boundary with ID K1 is present, vertex U is also present."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of vtxs that are a dom with id U is less than or equal to K1, such that there is a vtx U, whenever there is a bound with id K1. ",
            "NL": "The vertex with id U must have a count no greater than K1, so that when there is a bound with id K1, there is a corresponding vertex U."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the number of vtxs that are a dom with id U is less than or equal to K1, such that there is a vtx U, whenever there is a bound with id K1. ",
            "NL": "The amount of vertices with ID U must not exceed K1, so that a vertex U always corresponds to the bound with ID K1."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the total of id X of hc with value X, with id Y is less than or equal to M, such that there is a edgewt with first vtx X, with second vtx Y, with third weight W, whenever there is a maxweight with value M.",
            "NL": "For an edge to exist between vertices X and Y with weight W, the total number of ids X of HC with value X, with value Y must be less than or equal to the maxweight value M."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the total of id X of hc with value X, with id Y is less than or equal to M, such that there is a edgewt with first vtx X, with second vtx Y, with third weight W, whenever there is a maxweight with value M.",
            "NL": "For a maxweight value of M to exist, the total number of id X of HC with value X and value Y must be less than or equal to M, in order for an edgewt to form with the first vertex X, the second vertex Y, and a weight of W."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the total of id X of hc with value X, with id Y is less than or equal to M, such that there is a edgewt with first vtx X, with second vtx Y, with third weight W, whenever there is a maxweight with value M.",
            "NL": "In order for there to be an edge with a first vertex X, a second vertex Y, and a third weight W, whenever there is a maxweight value M, the total number of id X of HC with value X, with value Y must be less than or equal to M."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the total of id X of hc with value X, with id Y is less than or equal to M, such that there is a edgewt with first vtx X, with second vtx Y, with third weight W, whenever there is a maxweight with value M.",
            "NL": "The total number of id X of HC with value X, with value Y must be less than or equal to M in order for there to be an edgewt with the first vertex X, the second vertex Y, and the third weight W, when the maxweight value is M."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the total of id X of hc with value X, with id Y is less than or equal to M, such that there is a edgewt with first vtx X, with second vtx Y, with third weight W, whenever there is a maxweight with value M.",
            "NL": "For there to be an edge with first vertex X, second vertex Y, and weight W, the total number of IDs X of HC with value X and value Y must be less than or equal to the maximum weight value M."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the total of key5 F of Dominant with key5 F, with key5 N is not after or equal to G, such that there is a Edge_Level with first key5 F, with key5 N, with third vtx8 G, whenever there is a Intersect with key5 G.",
            "NL": "In order for there to be an Edge_Level consisting of the first key5 F, the second key5 N, and the third vtx8 G when there is an Intersect key5 G, the sum of key5 F of Dominant and key5 N must be less than G."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the total of key5 F of Dominant with key5 F, with key5 N is not after or equal to G, such that there is a Edge_Level with first key5 F, with key5 N, with third vtx8 G, whenever there is a Intersect with key5 G.",
            "NL": "For an Edge_Level to exist with the first key5 F, the second key5 N, and the third vtx8 G, the total number of key5 F of Dominant must be less than G."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the total of key5 F of Dominant with key5 F, with key5 N is not after or equal to G, such that there is a Edge_Level with first key5 F, with key5 N, with third vtx8 G, whenever there is a Intersect with key5 G.",
            "NL": "It is essential that the total of key5 F of Dominant, with key5 F and key5 N, is less than G, so that an Edge_Level is created with the first key5 F, the second key5 N, and the third vtx8 G, whenever an Intersect key5 G is present."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the total of key5 F of Dominant with key5 F, with key5 N is not after or equal to G, such that there is a Edge_Level with first key5 F, with key5 N, with third vtx8 G, whenever there is a Intersect with key5 G.",
            "NL": "In order for there to be an Edge_Level with the first key5 F, the second key5 N, and the third vtx8 G, it must be ensured that the total number of key5 F of Dominant with key5 F and key5 N is not greater than or equal to G."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that the total of key5 F of Dominant with key5 F, with key5 N is not after or equal to G, such that there is a Edge_Level with first key5 F, with key5 N, with third vtx8 G, whenever there is a Intersect with key5 G.",
            "NL": "In order for there to be an Edge_Level with the first key5 F, the second key5 N, and the third vtx8 G when an Intersect key5 G exists, the total number of key5 F of Dominant must not be greater than or equal to G."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Accomplished with value2 L, whenever there is Reckoning with edge3 L, and with key Z.",
            "NL": "Whenever a Reckoning with edge3 L and key Z occurs, it is essential that there is no Accomplished with value2 L."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Accomplished with value2 L, whenever there is Reckoning with edge3 L, and with key Z.",
            "NL": "It is essential that when a Reckoning with edge3 L and key Z occurs, there is no Accomplished with value2 L."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Accomplished with value2 L, whenever there is Reckoning with edge3 L, and with key Z.",
            "NL": "It is essential that a Reckoning with edge3 L and key Z is not completed with value2 L."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Accomplished with value2 L, whenever there is Reckoning with edge3 L, and with key Z.",
            "NL": "Whenever there is a Reckoning with edge3 L and key Z, it is essential that there is no Accomplished with value2 L."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Accomplished with value2 L, whenever there is Reckoning with edge3 L, and with key Z.",
            "NL": "Whenever there is a Reckoning with edge3 L and key Z, it is necessary that there is no Accomplishment with value2 L."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a bot 1. ",
            "NL": "A bot number 1 is required."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a bot 1. ",
            "NL": "A bot number 1 is a requirement."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a bot 1. ",
            "NL": "A bot number 1 must be included as a requirement."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a bot 1. ",
            "NL": "A bot numbered one must be present as a requirement."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a bot 1. ",
            "NL": "A bot numbered one is a requirement."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Bridge with node10 G, and with key6 O, whenever there is a Variation with node6 O, and with edge8 G.",
            "NL": "No Variation with node6 O, no edge8 G, and no Bridge with node10 G and key6 O is allowed."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Bridge with node10 G, and with key6 O, whenever there is a Variation with node6 O, and with edge8 G.",
            "NL": "There is a rule that node6 O must be different and edge8 G must be present, but node10 G cannot have a Bridge and key6 O must not be present."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Bridge with node10 G, and with key6 O, whenever there is a Variation with node6 O, and with edge8 G.",
            "NL": "There is a ban on having a node6 O and edge8 G combination, and no Bridge with node10 G and key6 O is allowed."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Bridge with node10 G, and with key6 O, whenever there is a Variation with node6 O, and with edge8 G.",
            "NL": "No variations of node6 O and edge8 G are allowed, and there is no bridge with node10 G and key6 O."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Bridge with node10 G, and with key6 O, whenever there is a Variation with node6 O, and with edge8 G.",
            "NL": "No Variation with node6 O, no Edge8 G, and no Bridge with node10 G and key6 O are allowed."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Bucket with edge S, whenever there is List with key2 D, and with key S.",
            "NL": "Whenever there is a List with key2 D and key S, it is mandatory to not have a Bucket with edge S."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Bucket with edge S, whenever there is List with key2 D, and with key S.",
            "NL": "Whenever a List with key2 D and key S is present, it is mandatory to not have a Bucket with edge S."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Bucket with edge S, whenever there is List with key2 D, and with key S.",
            "NL": "Whenever there is a List with key2 D and key S, it is mandatory not to have a Bucket with edge S."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Bucket with edge S, whenever there is List with key2 D, and with key S.",
            "NL": "Whenever List D has key2 D and key S, it is a must not to have a Bucket with edge S."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Bucket with edge S, whenever there is List with key2 D, and with key S.",
            "NL": "Whenever List D has key2 and key S, it is mandatory not to have a Bucket with edge S."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Chromatic_Number B, whenever there is a Point with id3 B, whenever there is Dominating_Set with id3 Y not after B.",
            "NL": "Whenever there is a Point with an id3 of B and a Dominating_Set with an id3 of Y, where Y is not after B, there is a requirement that Chromatic_Number B does not exist."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Chromatic_Number B, whenever there is a Point with id3 B, whenever there is Dominating_Set with id3 Y not after B.",
            "NL": "Whenever there is a Point with an id3 of B, and a Dominating_Set with an id3 of Y (where Y is not after B), there is a requirement that a Chromatic_Number B does not exist."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Chromatic_Number B, whenever there is a Point with id3 B, whenever there is Dominating_Set with id3 Y not after B.",
            "NL": "Whenever there is a Point with an id3 of B, and a Dominating_Set with an id3 of Y where Y is not after B, it is required that there does not exist a Chromatic_Number B."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Chromatic_Number B, whenever there is a Point with id3 B, whenever there is Dominating_Set with id3 Y not after B.",
            "NL": "Whenever there is a Point with an id3 of B, and a Dominating_Set with an id3 of Y (where Y is not after B), there is a requirement that there does not exist a Chromatic_Number B."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Chromatic_Number B, whenever there is a Point with id3 B, whenever there is Dominating_Set with id3 Y not after B.",
            "NL": "Whenever there is a Point with an id3 of B and a Dominating_Set with an id3 of Y, where Y is not after B, there must not be a Chromatic_Number B."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a colored with value N, whenever there is a node N.",
            "NL": "It is necessary that the node N not be assigned a colour with the same numerical value as N."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a colored with value N, whenever there is a node N.",
            "NL": "It is necessary that no node N be assigned the value N."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a colored with value N, whenever there is a node N.",
            "NL": "Nodes with a value of N must not be colored."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a colored with value N, whenever there is a node N.",
            "NL": "It is necessary that the node N does not have a colour assigned to it that is equal to N."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a colored with value N, whenever there is a node N.",
            "NL": "Nodes with the value N must not be coloured."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Container with value7 T, with key8 P, with node10 D, whenever there is a Marker with vtx5 T, with field8 D, whenever there is a Container with value7 T, with key8 P, with node10 G.",
            "NL": "This necessitates the presence of a Container with value 7T, key 8P, and node 10D; a Marker with vtx5T, and field 8D; a Container with value 7T, key 8P, and node 10G; and a Marker with vtx5T."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Container with value7 T, with key8 P, with node10 D, whenever there is a Marker with vtx5 T, with field8 D, whenever there is a Container with value7 T, with key8 P, with node10 G.",
            "NL": "This necessitates the presence of a Container with value7 T, key8 P, and node10 D, a Marker with vtx5 T and field8 D, another Container with value7 T, key8 P, and node10 G, and a Marker with vtx5 T."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Container with value7 T, with key8 P, with node10 D, whenever there is a Marker with vtx5 T, with field8 D, whenever there is a Container with value7 T, with key8 P, with node10 G.",
            "NL": "This necessitates the presence of a Container with value7 T, key8 P, and node10 D; a Marker with vtx5 T, and field8 D; a Container with value7 T, key8 P, and node10 G; and a Marker with vtx5 T."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Container with value7 T, with key8 P, with node10 D, whenever there is a Marker with vtx5 T, with field8 D, whenever there is a Container with value7 T, with key8 P, with node10 G.",
            "NL": "This necessitates the existence of a Container with value7 T, key8 P, and node10 D, a Marker with vtx5 T and field8 D, another Container with value7 T, key8 P, and node10 G, and finally a Marker with vtx5 T."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Container with value7 T, with key8 P, with node10 D, whenever there is a Marker with vtx5 T, with field8 D, whenever there is a Container with value7 T, with key8 P, with node10 G.",
            "NL": "This necessitates the presence of a Container with value 7T, key 8P, and node 10D, a Marker with vtx 5T, and field 8D, another Container with value 7T, key 8P, and node 10G, as well as a Marker with vtx 5T."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Diversity with value6 Q, whenever there is a Investigate with node2 Q, and with id4 G, and with vtx8 V.",
            "NL": "Whenever an Investigate with node2 Q, id4 G, and vtx8 V occurs, there is no Diversity with value6 Q mandated."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Diversity with value6 Q, whenever there is a Investigate with node2 Q, and with id4 G, and with vtx8 V.",
            "NL": "Whenever an Investigate is conducted with node2 Q, id4 G, and vtx8 V, Diversity must not have a value6 Q."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Diversity with value6 Q, whenever there is a Investigate with node2 Q, and with id4 G, and with vtx8 V.",
            "NL": "Whenever an Investigate occurs with node2 Q, id4 G, and vtx8 V, there can be no Diversity with value6 Q."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Diversity with value6 Q, whenever there is a Investigate with node2 Q, and with id4 G, and with vtx8 V.",
            "NL": "Whenever an Investigation is conducted with node2 Q, id4 G, and vtx8 V, no Diversity with value6 Q is required."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Diversity with value6 Q, whenever there is a Investigate with node2 Q, and with id4 G, and with vtx8 V.",
            "NL": "Whenever an Investigate is done with node2 Q, id4 G, and vtx8 V, Diversity with value6 Q cannot be present."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Divide with key4 I, and with id8 R, whenever there is a Adjacency_Matrix with id3 R, and with key7 I.",
            "NL": "It is prohibited to have an Adjacency_Matrix with id3 R and key7 I, however, there is no Divide with key4 I and id8 R."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Divide with key4 I, and with id8 R, whenever there is a Adjacency_Matrix with id3 R, and with key7 I.",
            "NL": "It is forbidden to have an Adjacency_Matrix with id3 R and key7 I, but there cannot be a Divide with key4 I and id8 R."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Divide with key4 I, and with id8 R, whenever there is a Adjacency_Matrix with id3 R, and with key7 I.",
            "NL": "It is prohibited to have an Adjacency_Matrix with id3 R and key7 I, but there must not be a Divide with key4 I and id8 R."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Divide with key4 I, and with id8 R, whenever there is a Adjacency_Matrix with id3 R, and with key7 I.",
            "NL": "There is a rule stating that an Adjacency_Matrix with id3 R and key7 I must exist, but a Divide with key4 I and id8 R must not exist."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Divide with key4 I, and with id8 R, whenever there is a Adjacency_Matrix with id3 R, and with key7 I.",
            "NL": "It is prohibited to have an Adjacency_Matrix with id3 R and key7 I, but it is not allowed to have a Divide with key4 I and id8 R."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Dynamic O, whenever there is a Denied with id6 O, whenever there is a Residual_Graph id6 Q.",
            "NL": "It is a requirement that when there is a Residual_Graph with an id6 Q, there must be a Denied with an id6 O and there cannot be a Dynamic with an id6 O."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Dynamic O, whenever there is a Denied with id6 O, whenever there is a Residual_Graph id6 Q.",
            "NL": "Whenever there is a Residual_Graph with id6 Q, there must be a Denied with id6 O and no Dynamic with id6 O."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Dynamic O, whenever there is a Denied with id6 O, whenever there is a Residual_Graph id6 Q.",
            "NL": "Whenever there is a Residual_Graph with id6 Q, it is necessary to have a Denied with id6 O and not have a Dynamic with id6 O."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Dynamic O, whenever there is a Denied with id6 O, whenever there is a Residual_Graph id6 Q.",
            "NL": "Whenever a Residual_Graph with an id6 Q is present, there must be a Denied with an id6 O and there cannot be a Dynamic with an id6 O."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Dynamic O, whenever there is a Denied with id6 O, whenever there is a Residual_Graph id6 Q.",
            "NL": "Whenever there is a Residual_Graph with id6 Q, it is required that a Denied with id6 O exists and a Dynamic with id6 O does not exist."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Entered with id10 B, with field Y, with id1 C, whenever there is a Achievement with id5 B, with node6 C, whenever there is a Entered with id10 B, with field Y, with id1 M.",
            "NL": "This necessitates that there is an Entered record with ID 10B, Field Y, and ID 1C; an Achievement with ID 5B and Node 6C; another Entered record with ID 10B, Field Y, and ID 1M; and finally, an Achievement with ID 5B."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Entered with id10 B, with field Y, with id1 C, whenever there is a Achievement with id5 B, with node6 C, whenever there is a Entered with id10 B, with field Y, with id1 M.",
            "NL": "This necessitates the presence of an Entered with id10 B, field Y, and id1 C, an Achievement with id5 B, node6 C, an Entered with id10 B, field Y, and id1 M, and an Achievement with id5 B."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Entered with id10 B, with field Y, with id1 C, whenever there is a Achievement with id5 B, with node6 C, whenever there is a Entered with id10 B, with field Y, with id1 M.",
            "NL": "This necessitates the presence of an Entered with id10 B, field Y, and id1 C, an Achievement with id5 B, node6 C, another Entered with id10 B, field Y, and id1 M, and an Achievement with id5 B."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Entered with id10 B, with field Y, with id1 C, whenever there is a Achievement with id5 B, with node6 C, whenever there is a Entered with id10 B, with field Y, with id1 M.",
            "NL": "This necessitates the presence of an Entered with id10 B, with field Y, and id1 C, an Achievement with id5 B, and node6 C, another Entered with id10 B, with field Y, and id1 M, and an Achievement with id5 B."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Entered with id10 B, with field Y, with id1 C, whenever there is a Achievement with id5 B, with node6 C, whenever there is a Entered with id10 B, with field Y, with id1 M.",
            "NL": "This necessitates the presence of an Entered with id10 B, field Y, and id1 C, an Achievement with id5 B, and node6 C, another Entered with id10 B, field Y, and id1 M, and another Achievement with id5 B."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Fine with id9 Q, whenever there is a Punishment with id9 Q.",
            "NL": "It is imperative that there is no Fine associated with id9 Q if there is a Punishment in field1 Q."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Fine with id9 Q, whenever there is a Punishment with id9 Q.",
            "NL": "It is essential that no Fines exist with id9 Q when there is a Punishment associated with field1 Q."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Fine with id9 Q, whenever there is a Punishment with id9 Q.",
            "NL": "It is essential that a Fine with id9 Q is not present when a Punishment with field1 Q is present."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Fine with id9 Q, whenever there is a Punishment with id9 Q.",
            "NL": "It is mandatory that no Fine with id9 Q is present when a Punishment with field1 Q is given."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Fine with id9 Q, whenever there is a Punishment with id9 Q.",
            "NL": "It is essential that there is no Fine associated with ID9Q when there is a Punishment associated with Field1Q."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Forest with vtx10 O, and with id2 D, whenever there is a Weighted_Graph with edge D, and with id1 O.",
            "NL": "It is forbidden for there to be a Weighted_Graph with 10 vertices D, and 10 vertices O, while there is no Forest with 2 vertices O, and 2 vertices D."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Forest with vtx10 O, and with id2 D, whenever there is a Weighted_Graph with edge D, and with id1 O.",
            "NL": "It is forbidden to have a Weighted_Graph with 10 vertices of type D and 10 vertices of type O, and there cannot be a Forest with 2 vertices of type O and 2 vertices of type D."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Forest with vtx10 O, and with id2 D, whenever there is a Weighted_Graph with edge D, and with id1 O.",
            "NL": "It is forbidden for a Weighted_Graph to have both vtx10 D and vtx10 O, and a Forest cannot have both id2 O and id2 D."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Forest with vtx10 O, and with id2 D, whenever there is a Weighted_Graph with edge D, and with id1 O.",
            "NL": "It is not allowed to have a Weighted_Graph with 10 vertices of type D and another one with 10 vertices of type O, nor a Forest with 2 vertices of type O and another one with 2 vertices of type D."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Forest with vtx10 O, and with id2 D, whenever there is a Weighted_Graph with edge D, and with id1 O.",
            "NL": "It is prohibited to have a Weighted Graph with 10 vertices D and 10 O, as well as a Forest with 2 O and 2 D vertices."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Graph 47.",
            "NL": "No Graph number 47 is required."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Graph 47.",
            "NL": "Graph number 47 is not a requirement."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Graph 47.",
            "NL": "Graph number 47 has not been required."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Graph 47.",
            "NL": "Graph number 47 is not required."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Graph 47.",
            "NL": "There is no Graph number 47 required."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a gt with id1 L, with id2 N, with id3 P, whenever there is a pvalue with value L, with id P, whenever there is a gt with id1 L, with id2 N, with id3 P+1. ",
            "NL": "This necessitates the existence of a GT with id1 L, id2 N, and id3 P; a pvalue with value L and id P; a GT with id1 L, id2 N, and id3 P+1; and a pvalue with value L."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a gt with id1 L, with id2 N, with id3 P, whenever there is a pvalue with value L, with id P, whenever there is a gt with id1 L, with id2 N, with id3 P+1. ",
            "NL": "It is necessary that a GT with id1 L, id2 N, and id3 P is present, and a pvalue with value L and id P is present, as well as a GT with id1 L, id2 N, and id3 P+1, and a pvalue with value L."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a gt with id1 L, with id2 N, with id3 P, whenever there is a pvalue with value L, with id P, whenever there is a gt with id1 L, with id2 N, with id3 P+1. ",
            "NL": "This necessitates the presence of a GT having id1 L, id2 N, and id3 P, a pvalue with value L and id P, a GT having id1 L, id2 N, and id3 P+1, and a pvalue with value L."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a gt with id1 L, with id2 N, with id3 P, whenever there is a pvalue with value L, with id P, whenever there is a gt with id1 L, with id2 N, with id3 P+1. ",
            "NL": "This necessitates the presence of a GT with id1 L, id2 N, and id3 P, a pvalue with value L and id P, a GT with id1 L, id2 N, and id3 P+1, and a pvalue with value L."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a gt with id1 L, with id2 N, with id3 P, whenever there is a pvalue with value L, with id P, whenever there is a gt with id1 L, with id2 N, with id3 P+1. ",
            "NL": "This necessitates the existence of a GT with id1 L, id2 N, and id3 P, a pvalue with value L and id P, another GT with id1 L, id2 N, and id3 P+1, and a pvalue with value L."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Has 24.",
            "NL": "No Has number 24 has been required."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Has 24.",
            "NL": "No number 24 has been required."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Has 24.",
            "NL": "No Has number 24 is required."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Has 24.",
            "NL": "There is no requirement for Has number 24."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Has 24.",
            "NL": "There is no requirement that Has number 24 must be present."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a haschild X, whenever there is a haschild with value X-1, whenever there is a node X.",
            "NL": "If a node has a value of X-1, there cannot be a haschild X present."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a haschild X, whenever there is a haschild with value X-1, whenever there is a node X.",
            "NL": "If there is a node with value X-1, there must not be a haschild with value X."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a haschild X, whenever there is a haschild with value X-1, whenever there is a node X.",
            "NL": "If there is a node with a value of X-1, then it is not possible for there to be a haschild with a value of X."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a haschild X, whenever there is a haschild with value X-1, whenever there is a node X.",
            "NL": "If a node has a value of X-1, then there should not be a haschild with a value of X."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a haschild X, whenever there is a haschild with value X-1, whenever there is a node X.",
            "NL": "If a node has a value of X-1, then there must not be a haschild with a value of X."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a haschild X, whenever there is a hasparent with value X, whenever there is Atomcnt with value N less than X. ",
            "NL": "It is necessary that when there is a hasparent with a value of X and an atomcnt with a value of N (where N is less than X), there should not be a haschild X."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a haschild X, whenever there is a hasparent with value X, whenever there is Atomcnt with value N less than X. ",
            "NL": "Whenever an atomcnt has a value of N, which is less than X, it is required that there is no haschild X present if there is a hasparent with a value of X."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a haschild X, whenever there is a hasparent with value X, whenever there is Atomcnt with value N less than X. ",
            "NL": "No haschild X should exist if there is a hasparent with a value of X and an atomcnt with a value of N, where N is less than X."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a haschild X, whenever there is a hasparent with value X, whenever there is Atomcnt with value N less than X. ",
            "NL": "Whenever there is an atomcnt with a value of N, where N is less than X, there must not be a haschild X if there is a hasparent with a value of X."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a haschild X, whenever there is a hasparent with value X, whenever there is Atomcnt with value N less than X. ",
            "NL": "Whenever there is an atomcnt with a value of N, where N is less than X, it is required that no haschild X exists in conjunction with a hasparent with a value of X."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a hasparent X, whenever there is a haschild with value X, whenever there is a node X-1.",
            "NL": "Whenever there is a node with a value of X-1, there must be a haschild with a value of X and no hasparent with a value of X."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a hasparent X, whenever there is a haschild with value X, whenever there is a node X-1.",
            "NL": "It is necessary that when there is a node with a value one lower than X, there must be a haschild with the same value X and no hasparent with the value X."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a hasparent X, whenever there is a haschild with value X, whenever there is a node X-1.",
            "NL": "Whenever a node with value X-1 exists, it must have a haschild with value X and not have a hasparent with value X."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a hasparent X, whenever there is a haschild with value X, whenever there is a node X-1.",
            "NL": "Whenever a node has a value of X-1, there must be a haschild with a value of X and there cannot be a hasparent with a value of X."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a hasparent X, whenever there is a haschild with value X, whenever there is a node X-1.",
            "NL": "It is necessary that when there is a node with a value of X-1, there is a haschild with a value of X and there is no hasparent with a value of X."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Idle with vtx9 H, with id3 B, with edge10 T, whenever there is a Compartment with key4 H, with vtx4 T, whenever there is a Idle with vtx9 H, with id3 B, with edge10 W.",
            "NL": "This necessitates the presence of an Idle with vtx9 H, id3 B, and edge10 T; a Compartment with key4 H and vtx4 T; an Idle with vtx9 H, id3 B, and edge10 W; and a Compartment with key4 H."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Idle with vtx9 H, with id3 B, with edge10 T, whenever there is a Compartment with key4 H, with vtx4 T, whenever there is a Idle with vtx9 H, with id3 B, with edge10 W.",
            "NL": "This necessitates the presence of an Idle with vtx9 H, id3 B, and edge10 T, as well as a Compartment with key4 H and vtx4 T, and additionally an Idle with vtx9 H, id3 B, and edge10 W, plus a Compartment with key4 H."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Idle with vtx9 H, with id3 B, with edge10 T, whenever there is a Compartment with key4 H, with vtx4 T, whenever there is a Idle with vtx9 H, with id3 B, with edge10 W.",
            "NL": "This necessitates the presence of an Idle with vtx9 H, id3 B, and edge10 T, a Compartment with key4 H and vtx4 T, an Idle with vtx9 H, id3 B, and edge10 W, and a Compartment with key4 H."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Idle with vtx9 H, with id3 B, with edge10 T, whenever there is a Compartment with key4 H, with vtx4 T, whenever there is a Idle with vtx9 H, with id3 B, with edge10 W.",
            "NL": "This necessitates the presence of an Idle with vtx9 H, id3 B, and edge10 T, as well as a Compartment with key4 H, vtx4 T, and an Idle with vtx9 H, id3 B, and edge10 W."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Idle with vtx9 H, with id3 B, with edge10 T, whenever there is a Compartment with key4 H, with vtx4 T, whenever there is a Idle with vtx9 H, with id3 B, with edge10 W.",
            "NL": "This necessitates the existence of an Idle with vtx9 H, id3 B, and edge10 T; a Compartment with key4 H and vtx4 T; an Idle with vtx9 H, id3 B, and edge10 W; and a Compartment with key4 H."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Incorporates with field5 O, and with edge5 G, whenever there is a Simple_Graph with field4 G, and with vtx10 O.",
            "NL": "It is prohibited for a Simple_Graph to have both field5 G and field5 O, and there can not be an Incorporates with both edge5 O and edge5 G."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Incorporates with field5 O, and with edge5 G, whenever there is a Simple_Graph with field4 G, and with vtx10 O.",
            "NL": "It is not allowed for a Simple_Graph to have both field5 G and field5 O, nor is it possible for an Incorporates to have both edge5 O and edge5 G."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Incorporates with field5 O, and with edge5 G, whenever there is a Simple_Graph with field4 G, and with vtx10 O.",
            "NL": "It is prohibited to have a Simple_Graph with both field5 G and field5 O, and there cannot be an Incorporates with both edge5 O and edge5 G."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Incorporates with field5 O, and with edge5 G, whenever there is a Simple_Graph with field4 G, and with vtx10 O.",
            "NL": "It is not allowed for there to be a Simple_Graph with the field5 G and O, nor an Incorporates with edge5 O and G."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Incorporates with field5 O, and with edge5 G, whenever there is a Simple_Graph with field4 G, and with vtx10 O.",
            "NL": "It is not allowed for a Simple_Graph to have both field5 G and field5 O, nor for an Incorporates to have both edge5 O and edge5 G."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a jailed with value M, whenever there is a manAssignsScore with id1 M, and with id2 FV1, and with id3 FV2.",
            "NL": "Whenever ManAssignsScore with id1 M and id2 FV2 is present, there must not be any jailed with value M."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a jailed with value M, whenever there is a manAssignsScore with id1 M, and with id2 FV1, and with id3 FV2.",
            "NL": "Whenever a manAssignsScore has an ID of M, FV1, or FV2, there is no jailing with a value of M."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a jailed with value M, whenever there is a manAssignsScore with id1 M, and with id2 FV1, and with id3 FV2.",
            "NL": "Whenever a manAssignsScore with id1 M, id FV1, and id2 FV2 exists, there must not be any jailed with value M."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a jailed with value M, whenever there is a manAssignsScore with id1 M, and with id2 FV1, and with id3 FV2.",
            "NL": "Whenever a manAssignsScore is present with ID1 M, ID FV1, and ID2 FV2, there shall be no jailing with the value of M."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a jailed with value M, whenever there is a manAssignsScore with id1 M, and with id2 FV1, and with id3 FV2.",
            "NL": "Anytime a person with ID1 M, ID FV1, and ID2 FV2 is present, there must not be any individuals in jail with value M."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Label with node8 L, whenever there is a Painted with node8 L.",
            "NL": "It is essential that node8 L has no Label when there is an id1 L Painted."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Label with node8 L, whenever there is a Painted with node8 L.",
            "NL": "It is imperative that node8 L should not be labeled when id1 L is painted."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Label with node8 L, whenever there is a Painted with node8 L.",
            "NL": "It is essential that there is no Label associated with node8 L when Painted is identified as id1 L."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Label with node8 L, whenever there is a Painted with node8 L.",
            "NL": "It is essential that no Label is associated with node8 L when Painted has id1 L."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Label with node8 L, whenever there is a Painted with node8 L.",
            "NL": "It is necessary that no Label exists with node8 L when there is a Painted with id1 L."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a levelvtx with value L-1, and with id P, whenever there is a parentedge with first id P, and with second id V, whenever there is a levelvtx with value L, and with id V.",
            "NL": "A levelvtx with value L-1 and id P must be present whenever there is a parentedge with first id P and a levelvtx with value L and id V is present."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a levelvtx with value L-1, and with id P, whenever there is a parentedge with first id P, and with second id V, whenever there is a levelvtx with value L, and with id V.",
            "NL": "It must be ensured that whenever there is a parentedge with first id P and second id V, and a levelvtx with value L and id V, there is also a levelvtx with value L-1 and id P."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a levelvtx with value L-1, and with id P, whenever there is a parentedge with first id P, and with second id V, whenever there is a levelvtx with value L, and with id V.",
            "NL": "It must be ensured that whenever there is a parentedge with first id P, and with second id V, there is a levelvtx with value L-1, and with id P, and whenever there is a levelvtx with value L, and with id V, there is a levelvtx with value L, and with id V."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a levelvtx with value L-1, and with id P, whenever there is a parentedge with first id P, and with second id V, whenever there is a levelvtx with value L, and with id V.",
            "NL": "It must be ensured that whenever there is a levelvtx with value L and id V, there is a parentedge with first id P and second id V, and also a levelvtx with value L-1 and id P."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a levelvtx with value L-1, and with id P, whenever there is a parentedge with first id P, and with second id V, whenever there is a levelvtx with value L, and with id V.",
            "NL": "It must be ensured that for any parentedge with first id P and second id V, where there is a levelvtx with value L and id V, there is also a levelvtx with value L-1 and id P."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a linked with value U, whenever there is link with id1 U, and with id2 V.",
            "NL": "Whenever there is a link with id1 U, it is necessary that there is no link with value U, and with id V."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a linked with value U, whenever there is link with id1 U, and with id2 V.",
            "NL": "Whenever there is a link with id1 U, it is essential that there is no connection with value U, and with id V."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a linked with value U, whenever there is link with id1 U, and with id2 V.",
            "NL": "Whenever there is a link with id1 U, it is essential that there is no link with value U, and with id V."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a linked with value U, whenever there is link with id1 U, and with id2 V.",
            "NL": "Whenever a link with id1 U is present, it is essential that there is no connection with value U and id V."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a linked with value U, whenever there is link with id1 U, and with id2 V.",
            "NL": "Whenever a link with id1 U is present, it is essential that there is no link with value U and id V."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a linked with value V, whenever there is link with id1 U, and with id2 V. ",
            "NL": "Whenever there is a link with id1 U, it is mandatory not to have a link with id2 V."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a linked with value V, whenever there is link with id1 U, and with id2 V. ",
            "NL": "Whenever there is a link with id1 U, it is mandatory that there is no link with id2 V."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a linked with value V, whenever there is link with id1 U, and with id2 V. ",
            "NL": "Whenever there is a link with id1 U, it is mandatory not to have a link with value V and id2 V."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a linked with value V, whenever there is link with id1 U, and with id2 V. ",
            "NL": "Whenever there is a link with id1 U, it is mandatory to not have a link with id2 V."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a linked with value V, whenever there is link with id1 U, and with id2 V. ",
            "NL": "It is mandatory that there is no link with value V when there is a link with id1 U and id2 V."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Maximum_Flow with node1 S, whenever there is a Module with node1 S.",
            "NL": "No Maximum_Flow should exist with node1 S when a Module has value10 S."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Maximum_Flow with node1 S, whenever there is a Module with node1 S.",
            "NL": "It is essential that there is no Maximum_Flow with node1 S if there is a Module with a value of 10 S."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Maximum_Flow with node1 S, whenever there is a Module with node1 S.",
            "NL": "It is necessary that there is no Maximum_Flow with node1 S when there is a Module with value10 S."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Maximum_Flow with node1 S, whenever there is a Module with node1 S.",
            "NL": "Whenever there is a Module with a value of 10 S, it is essential that there is no Maximum_Flow with node1 S."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Maximum_Flow with node1 S, whenever there is a Module with node1 S.",
            "NL": "It is essential that there be no Maximum_Flow with node1 S if there is a Module with a value of 10 S."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Maximum_Matching with key C, and with id1 N, whenever there is an Arrived with first node N, and with second vertex I, whenever there is a Maximum_Matching with key X, and with id1 I.",
            "NL": "Whenever there is an Arrived with first node N and second vertex I, there must be a Maximum_Matching with key C and id1 N, as well as a Maximum_Matching with key X and id1 I."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Maximum_Matching with key C, and with id1 N, whenever there is an Arrived with first node N, and with second vertex I, whenever there is a Maximum_Matching with key X, and with id1 I.",
            "NL": "Whenever there is an Arrived with first node N and second vertex I, there must be a Maximum_Matching with key C and id1 N, and whenever there is a Maximum_Matching with key X and id1 I, this requirement must be fulfilled."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Maximum_Matching with key C, and with id1 N, whenever there is an Arrived with first node N, and with second vertex I, whenever there is a Maximum_Matching with key X, and with id1 I.",
            "NL": "Whenever there is an Arrived with first node N and second vertex I, and a Maximum_Matching with key X and id1 I, then there must be a Maximum_Matching with key C and id1 N."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Maximum_Matching with key C, and with id1 N, whenever there is an Arrived with first node N, and with second vertex I, whenever there is a Maximum_Matching with key X, and with id1 I.",
            "NL": "Whenever there is an Arrived with first node N and second vertex I, the requirement that there is a Maximum_Matching with key C and id1 N, and another Maximum_Matching with key X and id1 I, must be fulfilled."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Maximum_Matching with key C, and with id1 N, whenever there is an Arrived with first node N, and with second vertex I, whenever there is a Maximum_Matching with key X, and with id1 I.",
            "NL": "Whenever an Arrived with first node N and second vertex I occurs, a Maximum_Matching with key C and id1 N, as well as a Maximum_Matching with key X and id1 I must be present."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a NonActive with value8 B, and with vtx3 L, whenever there is a Sign with node8 L, and with value6 B.",
            "NL": "A Sign with node8 L and value6 B is prohibited, and a NonActive with value8 B and vtx3 L is not allowed."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a NonActive with value8 B, and with vtx3 L, whenever there is a Sign with node8 L, and with value6 B.",
            "NL": "A Sign with node8 L and value6 B is prohibited, and there is no NonActive with value8 B and vtx3 L."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a NonActive with value8 B, and with vtx3 L, whenever there is a Sign with node8 L, and with value6 B.",
            "NL": "No Sign with Node8 L and Value6 B is allowed, and there must not be any NonActive with Value8 B and VTX3 L."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a NonActive with value8 B, and with vtx3 L, whenever there is a Sign with node8 L, and with value6 B.",
            "NL": "No Sign with node8 L and value6 B is allowed, and NonActive with value8 B and vtx3 L is not permitted."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a NonActive with value8 B, and with vtx3 L, whenever there is a Sign with node8 L, and with value6 B.",
            "NL": "There is a Sign with node8 L and value6 B, however, there is no NonActive with value8 B and vtx3 L."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a NonFollowing with node7 S, whenever there is a Minimum_Vertex_Cover with field5 S, and with node5 J, and with node8 T.",
            "NL": "Whenever there is a Minimum_Vertex_Cover that contains field5 S, node5 J, and node8 T, there cannot be a NonFollowing with node7 S."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a NonFollowing with node7 S, whenever there is a Minimum_Vertex_Cover with field5 S, and with node5 J, and with node8 T.",
            "NL": "Whenever there is a Minimum_Vertex_Cover with field5 S, node5 J, and node8 T, there must not be any NonFollowing with node7 S."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a NonFollowing with node7 S, whenever there is a Minimum_Vertex_Cover with field5 S, and with node5 J, and with node8 T.",
            "NL": "Whenever a Minimum_Vertex_Cover is present with field5 S, node5 J, and node8 T, any NonFollowing with node7 S is not allowed."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a NonFollowing with node7 S, whenever there is a Minimum_Vertex_Cover with field5 S, and with node5 J, and with node8 T.",
            "NL": "Whenever there is a Minimum_Vertex_Cover with field5 S, node5 J, and node8 T, no NonFollowing should be present with node7 S."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a NonFollowing with node7 S, whenever there is a Minimum_Vertex_Cover with field5 S, and with node5 J, and with node8 T.",
            "NL": "Whenever a Minimum_Vertex_Cover is present with field5 S, node5 J, and node8 T, there cannot be any NonFollowing with node7 S."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Nontrivial G, whenever there is a Element with id3 G, whenever there is Hamiltonian_Graph with id3 A at most G.",
            "NL": "If there is an element with an id3 of G, and there is a Hamiltonian_Graph with an id3 of A, then it is necessary that there is no Nontrivial G where A is no greater than G."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Nontrivial G, whenever there is a Element with id3 G, whenever there is Hamiltonian_Graph with id3 A at most G.",
            "NL": "If there is an Element with an id3 of G and a Hamiltonian_Graph with an id3 of A, where A is no greater than G, then it is required that there is no Nontrivial G."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Nontrivial G, whenever there is a Element with id3 G, whenever there is Hamiltonian_Graph with id3 A at most G.",
            "NL": "Whenever there is a Hamiltonian_Graph with a id3 of A, where A is not greater than G, there must not be a Nontrivial G with an Element having a id3 of G."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Nontrivial G, whenever there is a Element with id3 G, whenever there is Hamiltonian_Graph with id3 A at most G.",
            "NL": "If there is an Element with an id3 of G, and a Hamiltonian_Graph with an id3 of A (where A is equal to or less than G), then there must not be a Nontrivial G."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Nontrivial G, whenever there is a Element with id3 G, whenever there is Hamiltonian_Graph with id3 A at most G.",
            "NL": "Whenever there is a Hamiltonian_Graph with a id3 of A, and A is at most G, it is required that there does not exist a Nontrivial G with a id3 of G."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Out_Hamiltonian_Tour S, whenever there is a P_Value with value2 G, whenever there is a Maximum S.",
            "NL": "If the P_Value has a value of G and the Maximum has a value of S, then there cannot be an Out_Hamiltonian_Tour."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Out_Hamiltonian_Tour S, whenever there is a P_Value with value2 G, whenever there is a Maximum S.",
            "NL": "If there is a P_Value with a value of G and a Maximum with a value of S, then there cannot be an Out_Hamiltonian_Tour S."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Out_Hamiltonian_Tour S, whenever there is a P_Value with value2 G, whenever there is a Maximum S.",
            "NL": "If there is a P_Value with a value of G and a Maximum with a value of S, then no Out_Hamiltonian_Tour should exist."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Out_Hamiltonian_Tour S, whenever there is a P_Value with value2 G, whenever there is a Maximum S.",
            "NL": "If there is a Maximum with a value of S, there cannot be an Out_Hamiltonian_Tour if there is a P_Value with a value of G."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Out_Hamiltonian_Tour S, whenever there is a P_Value with value2 G, whenever there is a Maximum S.",
            "NL": "If the P_Value has a value of G and the Maximum has a value of S, then an Out_Hamiltonian_Tour must not exist."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Parentedge with value9 E, whenever there is a Eulerian_Graph E.",
            "NL": "Eulerian Graph E must not have any Parentedge with a value of 9."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Parentedge with value9 E, whenever there is a Eulerian_Graph E.",
            "NL": "There is a requirement that the number of Eulerian_Graph E must not have a Parentedge with a value of 9."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Parentedge with value9 E, whenever there is a Eulerian_Graph E.",
            "NL": "The requirement is that Eulerian Graph E must not have a Parentedge with a value of 9."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Parentedge with value9 E, whenever there is a Eulerian_Graph E.",
            "NL": "Eulerian_Graph E must not contain any Parentedge with a value of 9."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Parentedge with value9 E, whenever there is a Eulerian_Graph E.",
            "NL": "Eulerian Graph E must not have any edges with a value of 9."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Particle with value3 V, whenever there is Complicated with key2 V, and with vtx10 R.",
            "NL": "Whenever there is a Complicated with key2 V and vtx10 R, it is necessary that there is no Particle with value3 V."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Particle with value3 V, whenever there is Complicated with key2 V, and with vtx10 R.",
            "NL": "Whenever a Complicated with key2 V and vtx10 R exists, it is essential that there is no Particle with value3 V present."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Particle with value3 V, whenever there is Complicated with key2 V, and with vtx10 R.",
            "NL": "Whenever there is a Complicated with key2 V and vtx10 R, it is essential that there is no Particle with value3 V."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Particle with value3 V, whenever there is Complicated with key2 V, and with vtx10 R.",
            "NL": "Whenever there is a Complicated with key2 V and vtx10 R, it is necessary that no Particle has value3 V."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Particle with value3 V, whenever there is Complicated with key2 V, and with vtx10 R.",
            "NL": "Whenever there is a Complicated with key2 V and vtx10 R, it is imperative that there is no Particle with value3 V."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Passive G, whenever there is a Contrast with value6 I, whenever there is a Reached G.",
            "NL": "If value6 I is not in contrast with value6 G, then a Passive G must not be present."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Passive G, whenever there is a Contrast with value6 I, whenever there is a Reached G.",
            "NL": "If there is a Contrast with value6 I, then there must not be a Passive G; however, if there is a Reached with value6 G, then it is acceptable."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Passive G, whenever there is a Contrast with value6 I, whenever there is a Reached G.",
            "NL": "If value6 I is in contrast with value6 G, there must not be a Passive G."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Passive G, whenever there is a Contrast with value6 I, whenever there is a Reached G.",
            "NL": "If value6 I is not in contrast with value6 G, then there should not be a Passive G."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Passive G, whenever there is a Contrast with value6 I, whenever there is a Reached G.",
            "NL": "If there is a Contrast with value6 I, there must not be a Reached with value6 G."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Point O, whenever there is a Significant with node G, whenever there is a Solitary O.",
            "NL": "If there is a Significant with node G, then there cannot be a Point O if there is a Solitary with node O."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Point O, whenever there is a Significant with node G, whenever there is a Solitary O.",
            "NL": "If there is a Significant with node G, there must not be a Point O, and if there is a Solitary with node O, there must not be a Point O either."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Point O, whenever there is a Significant with node G, whenever there is a Solitary O.",
            "NL": "If there is a Significant with node G, there must not be a Point O; likewise, if there is a Solitary with node O, there must not be a Point O."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Point O, whenever there is a Significant with node G, whenever there is a Solitary O.",
            "NL": "If there is a Significant node G, there must not be a Point O, and if there is a Solitary node O, there must not be a Point O."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Point O, whenever there is a Significant with node G, whenever there is a Solitary O.",
            "NL": "If there is a Significant with node G, then there must not be a Point O if there is a Solitary with node O."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Project with field9 V, whenever there is a Variation V.",
            "NL": "It is a stipulation that Variation V cannot be associated with field9 V."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Project with field9 V, whenever there is a Variation V.",
            "NL": "It is required that Variation V not be associated with Project field9 V."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Project with field9 V, whenever there is a Variation V.",
            "NL": "It is required that Variation V cannot be associated with field9 V."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Project with field9 V, whenever there is a Variation V.",
            "NL": "It is mandatory that Variation V should not be associated with field9 V."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Project with field9 V, whenever there is a Variation V.",
            "NL": "It is necessary that Variation V not be associated with Project field9 V."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Radius with key6 J, and with node7 C, whenever there is a Minor with id6 C, and with field7 J.",
            "NL": "It is forbidden for a Minor to have key6 C and key6 J, while Radius is not allowed to have node7 J and node7 C."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Radius with key6 J, and with node7 C, whenever there is a Minor with id6 C, and with field7 J.",
            "NL": "It is forbidden for a Minor to have key6 C and key6 J, while a Radius is not allowed to have node7 J or node7 C."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Radius with key6 J, and with node7 C, whenever there is a Minor with id6 C, and with field7 J.",
            "NL": "It is prohibited for a Minor to have key6 C and key6 J, and Radius cannot have node7 J and node7 C."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Radius with key6 J, and with node7 C, whenever there is a Minor with id6 C, and with field7 J.",
            "NL": "No Minor with key6 C or key6 J is allowed, and no Radius with node7 J or node7 C is permitted."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Radius with key6 J, and with node7 C, whenever there is a Minor with id6 C, and with field7 J.",
            "NL": "There is a ban on Minors with key6 C and key6 J, however, there is no Radius with node7 J and node7 C."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a reach with id1 K, and with id2 U, whenever there is a partition with value U, and with id K. ",
            "NL": "There is a ban on having partitions with IDs U and K, and there is no access allowed with values K and U."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a reach with id1 K, and with id2 U, whenever there is a partition with value U, and with id K. ",
            "NL": "There is a prohibition against having a partition with ID U and ID K, and there is no reach with values K and U."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a reach with id1 K, and with id2 U, whenever there is a partition with value U, and with id K. ",
            "NL": "There is a ban on both partitions with IDs U and K, and there is no access to values K and U."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a reach with id1 K, and with id2 U, whenever there is a partition with value U, and with id K. ",
            "NL": "There is a ban on having a partition with ID U and ID K, and there is no reach with values K and U."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a reach with id1 K, and with id2 U, whenever there is a partition with value U, and with id K. ",
            "NL": "There is a ban in place for partitions with IDs U and K, and no reach with values K and U."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Reached with edge8 G, whenever there is a Color with edge8 G.",
            "NL": "It is essential that there is no Reached with edge8 G when there is a Color with id2 G."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Reached with edge8 G, whenever there is a Color with edge8 G.",
            "NL": "It is essential that no Reached with edge8 G is present whenever a Color with id2 G is present."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Reached with edge8 G, whenever there is a Color with edge8 G.",
            "NL": "It is imperative that no Reached with edge8 G be present whenever a Color with id2 G is present."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Reached with edge8 G, whenever there is a Color with edge8 G.",
            "NL": "It is essential that there is no Reached with edge8 G present when there is a Color with id2 G."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Reached with edge8 G, whenever there is a Color with edge8 G.",
            "NL": "It is essential that no Reached with edge8 G is present when there is a Color with id2 G."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a reached with value U, whenever there is a linked with value U.",
            "NL": "It is essential that there is no value associated with U when there is a link with the same ID U."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a reached with value U, whenever there is a linked with value U.",
            "NL": "It is essential that there is no value associated with U when there is an item linked with U."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a reached with value U, whenever there is a linked with value U.",
            "NL": "It is essential that there is no value associated with U whenever there is a link identified as U."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a reached with value U, whenever there is a linked with value U.",
            "NL": "It is essential that there is no value associated with U if there is an item linked to U."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a reached with value U, whenever there is a linked with value U.",
            "NL": "It is essential that there is no value associated with U when there is an id linked to U."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Regular with edge6 U, and with vtx8 K, whenever there is a Particle with edge1 K, and with edge5 U.",
            "NL": "It is forbidden to have a Particle with edge1 K and edge5 U, but not a Regular with edge6 U and vtx8 K."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Regular with edge6 U, and with vtx8 K, whenever there is a Particle with edge1 K, and with edge5 U.",
            "NL": "There is a Particle with edge1 K and edge5 U, but there is no Regular with edge6 U and vtx8 K."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Regular with edge6 U, and with vtx8 K, whenever there is a Particle with edge1 K, and with edge5 U.",
            "NL": "It is prohibited to have a Particle with edge1 K and edge5 U, but there is no Regular with edge6 U and vtx8 K."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Regular with edge6 U, and with vtx8 K, whenever there is a Particle with edge1 K, and with edge5 U.",
            "NL": "It is forbidden for there to be a Particle with edge1 K and edge5 U, but there cannot be a Regular with edge6 U and vtx8 K."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Regular with edge6 U, and with vtx8 K, whenever there is a Particle with edge1 K, and with edge5 U.",
            "NL": "It is prohibited to have a Particle with edge1 K and edge5 U, but there cannot be a Regular with edge6 U and vtx8 K."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Shade with key B, and with id5 P, whenever there is a Incorporates with id1 P, and with field3 B.",
            "NL": "It is prohibited for an Incorporate to have a key P and a key B, and there is no Shade with id5 B or id5 P."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Shade with key B, and with id5 P, whenever there is a Incorporates with id1 P, and with field3 B.",
            "NL": "There is a ban on Incorporates with key P and key B, but no Shade with id5 B or id5 P."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Shade with key B, and with id5 P, whenever there is a Incorporates with id1 P, and with field3 B.",
            "NL": "It is prohibited for an Incorporate to have the keys P and B, and for a Shade to not have the ids 5B and 5P."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Shade with key B, and with id5 P, whenever there is a Incorporates with id1 P, and with field3 B.",
            "NL": "It is forbidden for an Incorporate to possess key P and key B, and there is no Shade with id5 B and id5 P."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Shade with key B, and with id5 P, whenever there is a Incorporates with id1 P, and with field3 B.",
            "NL": "It is forbidden for an Incorporates to have a key P and a key B, and there is no Shade with id5 B or id5 P."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Shaded with edge3 S, whenever there is a Foremost with vtx3 S, and with key9 N, and with key5 Q.",
            "NL": "Whenever a Foremost has vtx3 S, key9 N, and key5 Q, no Shaded can have edge3 S."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Shaded with edge3 S, whenever there is a Foremost with vtx3 S, and with key9 N, and with key5 Q.",
            "NL": "Whenever a Foremost has vtx3 S, key9 N, and key5 Q, no Shaded may have edge3 S."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Shaded with edge3 S, whenever there is a Foremost with vtx3 S, and with key9 N, and with key5 Q.",
            "NL": "Whenever there is a Foremost with vtx3 S, key9 N, and key5 Q, there can not be a Shaded with edge3 S."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Shaded with edge3 S, whenever there is a Foremost with vtx3 S, and with key9 N, and with key5 Q.",
            "NL": "Whenever Foremost has vtx3 S, key9 N, and key5 Q, no Shaded should have edge3 S."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Shaded with edge3 S, whenever there is a Foremost with vtx3 S, and with key9 N, and with key5 Q.",
            "NL": "Anytime a Foremost has vtx3 S, key9 N, and key5 Q, no Shaded shall be present with edge3 S."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a singleton 1, whenever there is a trivial V.",
            "NL": "It is mandated that a trivial V cannot be accompanied by a singleton 1."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a singleton 1, whenever there is a trivial V.",
            "NL": "No trivial V shall be unaccompanied by a singleton 1."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a singleton 1, whenever there is a trivial V.",
            "NL": "It is mandated that a trivial V must never have a singleton 1."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a singleton 1, whenever there is a trivial V.",
            "NL": "A singleton 1 should never be present when a trivial V is present."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a singleton 1, whenever there is a trivial V.",
            "NL": "It is mandatory that a trivial V will never have a singleton 1."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Statistical_Significance with edge A, whenever there is a Attained with edge A.",
            "NL": "It is essential that no Statistical_Significance is present with edge A when node A has achieved something."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Statistical_Significance with edge A, whenever there is a Attained with edge A.",
            "NL": "It is essential that no Statistical_Significance is present at edge A whenever an Attained is observed at node A."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Statistical_Significance with edge A, whenever there is a Attained with edge A.",
            "NL": "It is essential that if node A has Attained, there is no Statistical_Significance with edge A."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Statistical_Significance with edge A, whenever there is a Attained with edge A.",
            "NL": "It is essential that there be no Statistical_Significance associated with edge A when node A has been Attained."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Statistical_Significance with edge A, whenever there is a Attained with edge A.",
            "NL": "It is essential that there is no Statistical_Significance associated with edge A if node A has been Attained."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Subsequent with node9 F, with vtx9 C, with edge1 V, whenever there is a Accessed with id10 F, with key V, whenever there is a Subsequent with node9 F, with vtx9 C, with edge1 W.",
            "NL": "This necessitates that there is a Subsequent node9 F with vtx9 C and edge1 V, an Accessed id10 F with key V, another Subsequent node9 F with vtx9 C and edge1 W, and another Accessed id10 F."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Subsequent with node9 F, with vtx9 C, with edge1 V, whenever there is a Accessed with id10 F, with key V, whenever there is a Subsequent with node9 F, with vtx9 C, with edge1 W.",
            "NL": "This necessitates the presence of a Subsequent node9 F, vtx9 C, and edge1 V, an Accessed id10 F, and key V, another Subsequent node9 F, vtx9 C, and edge1 W, as well as an Accessed id10 F."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Subsequent with node9 F, with vtx9 C, with edge1 V, whenever there is a Accessed with id10 F, with key V, whenever there is a Subsequent with node9 F, with vtx9 C, with edge1 W.",
            "NL": "This necessitates that there is a Subsequent node with node9 F, vtx9 C, and edge1 V, as well as an Accessed one with id10 F and key V, and another Subsequent node with node9 F, vtx9 C, and edge1 W, plus an Accessed one with id10 F."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Subsequent with node9 F, with vtx9 C, with edge1 V, whenever there is a Accessed with id10 F, with key V, whenever there is a Subsequent with node9 F, with vtx9 C, with edge1 W.",
            "NL": "This necessitates that there is a Subsequent node with node9 F, vtx9 C, and edge1 V, an Accessed id10 F with key V, another Subsequent node with node9 F, vtx9 C, and edge1 W, and an Accessed id10 F."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Subsequent with node9 F, with vtx9 C, with edge1 V, whenever there is a Accessed with id10 F, with key V, whenever there is a Subsequent with node9 F, with vtx9 C, with edge1 W.",
            "NL": "This necessitates the existence of a Subsequent node9 F, having vtx9 C, and edge1 V, an Accessed id10 F, with key V, another Subsequent node9 F, with vtx9 C, and edge1 W, and an Accessed id10 F."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Succeeding with id6 A, whenever there is a Elabel with id6 A.",
            "NL": "It is essential that there be no Succession with node6 A when there is an Elabel with node6 A."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Succeeding with id6 A, whenever there is a Elabel with id6 A.",
            "NL": "It is essential that there is no Success associated with Node 6A if there is an eLabel present with Node 6A."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Succeeding with id6 A, whenever there is a Elabel with id6 A.",
            "NL": "It is essential that no Success is associated with Node6 A when there is an Elabel with Node6 A."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Succeeding with id6 A, whenever there is a Elabel with id6 A.",
            "NL": "It is essential that there be no success with ID6A when there is an Elabel present with node6A."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Succeeding with id6 A, whenever there is a Elabel with id6 A.",
            "NL": "It is essential that no Success be associated with Node 6A when there is an Elabel present with Node 6A."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Trail B, whenever there is a Hamiltonian_Cycle with field B, whenever there is a Succeeding field O.",
            "NL": "It is necessary that if there is a Succeeding with field O, then there must be a Hamiltonian_Cycle with field B and no Trail with field B."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Trail B, whenever there is a Hamiltonian_Cycle with field B, whenever there is a Succeeding field O.",
            "NL": "Whenever there is a Succeeding with field O present, a Hamiltonian_Cycle with field B must be present, and a Trail with field B must not be present."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Trail B, whenever there is a Hamiltonian_Cycle with field B, whenever there is a Succeeding field O.",
            "NL": "Whenever there is a Succeeding with field O, a Hamiltonian_Cycle with field B must be present and a Trail with field B must not be present."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Trail B, whenever there is a Hamiltonian_Cycle with field B, whenever there is a Succeeding field O.",
            "NL": "Whenever a Succeeding with field O is present, there must be a Hamiltonian_Cycle with field B and no Trail with field B."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Trail B, whenever there is a Hamiltonian_Cycle with field B, whenever there is a Succeeding field O.",
            "NL": "Whenever there is a Succeeding with field O, a Hamiltonian_Cycle must be present with field B and there must not be a Trail with field B."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Undirected with id6 B, and with value8 Z, whenever there is a Regular with id4 Z, and with node1 B.",
            "NL": "It is prohibited that there is a Regular with id4 Z and node1 B, and there cannot be an Undirected with id6 B and value8 Z."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Undirected with id6 B, and with value8 Z, whenever there is a Regular with id4 Z, and with node1 B.",
            "NL": "It is forbidden for there to be a Regular connection with id4 Z and node1 B, and there cannot be an Undirected connection with id6 B and value8 Z."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Undirected with id6 B, and with value8 Z, whenever there is a Regular with id4 Z, and with node1 B.",
            "NL": "There is a restriction that a Regular with id4 Z and node1 B cannot exist, and neither can a Undirected with id6 B and value8 Z."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Undirected with id6 B, and with value8 Z, whenever there is a Regular with id4 Z, and with node1 B.",
            "NL": "It is forbidden for there to be a Regular connection with id4 Z and node1 B, and there must not be an Undirected connection with id6 B and value8 Z."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Undirected with id6 B, and with value8 Z, whenever there is a Regular with id4 Z, and with node1 B.",
            "NL": "It is forbidden to have a Regular with id4 Z and node1 B, and there is no Undirected with id6 B and value8 Z."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Victory R, whenever there is a Wanting with id8 U, whenever there is a Utilized_Edge R.",
            "NL": "If Utilized_Edge with id8 R is present, Victory R must not be present, and if Wanting with id8 U is present, Victory R must not be present."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Victory R, whenever there is a Wanting with id8 U, whenever there is a Utilized_Edge R.",
            "NL": "If Utilized_Edge with id8 R exists, Victory R should not be present, and if Wanting with id8 U is present, Victory R must not be present."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Victory R, whenever there is a Wanting with id8 U, whenever there is a Utilized_Edge R.",
            "NL": "If an Utilized_Edge with id8 R exists, there cannot be a Victory R; likewise, if there is a Wanting with id8 U, there cannot be a Victory R."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Victory R, whenever there is a Wanting with id8 U, whenever there is a Utilized_Edge R.",
            "NL": "If there is an Utilized_Edge with id8 R, then there cannot be a Victory R; likewise, if there is a Wanting with id8 U, then there must not be a Victory R."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Victory R, whenever there is a Wanting with id8 U, whenever there is a Utilized_Edge R.",
            "NL": "If Utilized_Edge with id8 R exists, there must not be a Victory R, and if Wanting with id8 U exists, there must not be a Victory R either."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Visit with vtx C, and with value9 Z, whenever there is an Associated with node3 Z, and with vtx6 C.",
            "NL": "It is prohibited to have an association with VTX Z and VTX C, and there is no visit allowed with Value9 C and Value9 Z."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Visit with vtx C, and with value9 Z, whenever there is an Associated with node3 Z, and with vtx6 C.",
            "NL": "There is a ban on visiting with value9 C and value9 Z, but there is an association with vtx C and vtx Z."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Visit with vtx C, and with value9 Z, whenever there is an Associated with node3 Z, and with vtx6 C.",
            "NL": "There is a ban on visits with value9 C and value9 Z for both vtx C and vtx Z."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Visit with vtx C, and with value9 Z, whenever there is an Associated with node3 Z, and with vtx6 C.",
            "NL": "There is a restriction that there is no association between vtx C and value9 C, or between vtx Z and value9 Z."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is a Visit with vtx C, and with value9 Z, whenever there is an Associated with node3 Z, and with vtx6 C.",
            "NL": "It is prohibited to have an association with VTX Z and C, and there is no visit associated with value9 C and Z."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is an Achievement with field1 I, and with value3 C, whenever there is an Depth_Vertex with first point C, and with fourth node W, whenever there is an Achievement with field1 E, and with value3 W.",
            "NL": "It is necessary to meet the requirement that when there is a Depth_Vertex with first point C, and with fourth node W, an Achievement with field1 I and value3 C must be present, and when there is an Achievement with field1 E and value3 W, it must also be present."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is an Achievement with field1 I, and with value3 C, whenever there is an Depth_Vertex with first point C, and with fourth node W, whenever there is an Achievement with field1 E, and with value3 W.",
            "NL": "It is necessary to satisfy the condition that when there is a Depth_Vertex with first point C and fourth node W, then there must be an Achievement with field1 I and value3 C, and when there is an Achievement with field1 E and value3 W, then there must be an Achievement with field1 I and value3 C."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is an Achievement with field1 I, and with value3 C, whenever there is an Depth_Vertex with first point C, and with fourth node W, whenever there is an Achievement with field1 E, and with value3 W.",
            "NL": "It is necessary to fulfill the condition that when there is a Depth_Vertex with first point C and fourth node W, there must be an Achievement with field1 I and value3 C, and when there is an Achievement with field1 E and value3 W, there must also be an Achievement with field1 I and value3 C."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is an Achievement with field1 I, and with value3 C, whenever there is an Depth_Vertex with first point C, and with fourth node W, whenever there is an Achievement with field1 E, and with value3 W.",
            "NL": "It must be ensured that when a Depth_Vertex has a first point of C and a fourth node of W, an Achievement with field1 I and value3 C, and an Achievement with field1 E and value3 W, are both present."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is an Achievement with field1 I, and with value3 C, whenever there is an Depth_Vertex with first point C, and with fourth node W, whenever there is an Achievement with field1 E, and with value3 W.",
            "NL": "It must be ensured that every time there is a Depth_Vertex with first point C and fourth node W, there is an Achievement with field1 I and value3 C, and whenever there is an Achievement with field1 E and value3 W."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is an Active 21, whenever there is a Walk V.",
            "NL": "iva It is necessary that there not be an Active 21 when there is a Walk Viva."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is an Active 21, whenever there is a Walk V.",
            "NL": "igor It is a requirement that there will not be an Active 21 when there is a Walk Vigor."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is an Active 21, whenever there is a Walk V.",
            "NL": "It is necessary that there cannot be an Active 21 when there is a Walk V."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is an Active 21, whenever there is a Walk V.",
            "NL": "igour No Active 21 will be allowed when there is a Walk Vigour."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is an Active 21, whenever there is a Walk V.",
            "NL": "igor It is a requirement that there cannot be an Active 21 when there is a Walk Vigor."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is an Ancestor P, whenever there is a Outbound with id5 P, whenever there is Pair_of_Nodes with id5 K at most P.",
            "NL": "Whenever there is a Pair_of_Nodes with a id5 of K, where K is not greater than P, there must not be an Ancestor P when there is an Outbound with a id5 of P."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is an Ancestor P, whenever there is a Outbound with id5 P, whenever there is Pair_of_Nodes with id5 K at most P.",
            "NL": "If there is an Outbound with a id5 of P, and there is a Pair_of_Nodes with a id5 of K, where K is not greater than P, then there must not be an Ancestor P."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is an Ancestor P, whenever there is a Outbound with id5 P, whenever there is Pair_of_Nodes with id5 K at most P.",
            "NL": "Whenever there is an Outbound with an id5 of P and a Pair_of_Nodes with an id5 of K, where K is no greater than P, it is required that there is no Ancestor P."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is an Ancestor P, whenever there is a Outbound with id5 P, whenever there is Pair_of_Nodes with id5 K at most P.",
            "NL": "No Ancestor P should be present when there is an Outbound with an id5 of P and a Pair_of_Nodes with an id5 of K, where K is no greater than P."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is an Ancestor P, whenever there is a Outbound with id5 P, whenever there is Pair_of_Nodes with id5 K at most P.",
            "NL": "Whenever there is a Pair_of_Nodes with an id5 of K, where K is not greater than P, there must not be an Ancestor P in existence for any Outbound with an id5 of P."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is an Arc_Label 14.",
            "NL": "No Arc_Label number 14 is required."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is an Arc_Label 14.",
            "NL": "There is no Arc_Label number 14 as a requirement."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is an Arc_Label 14.",
            "NL": "Arc_Label number 14 is not a requirement."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is an Arc_Label 14.",
            "NL": "Arc_Label number 14 has not been a requirement."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is an Arc_Label 14.",
            "NL": "Arc_Label number 14 has not been required."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is an Attained with vtx10 Y, whenever there is NonForemost with key4 V, and with edge8 Y.",
            "NL": "Whenever there is NonForemost with key4 V and edge8 Y, it is required that there not be an Attained with vtx10 Y."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is an Attained with vtx10 Y, whenever there is NonForemost with key4 V, and with edge8 Y.",
            "NL": "Whenever NonForemost with key4 V is present, it is mandatory to not have an Attained with vtx10 Y and edge8 Y."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is an Attained with vtx10 Y, whenever there is NonForemost with key4 V, and with edge8 Y.",
            "NL": "It is mandatory to not have an Attained with vtx10 Y if there is NonForemost with key4 V and edge8 Y."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is an Attained with vtx10 Y, whenever there is NonForemost with key4 V, and with edge8 Y.",
            "NL": "Whenever NonForemost with key4 V and edge8 Y is present, it is mandatory not to have an Attained with vtx10 Y."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is an Attained with vtx10 Y, whenever there is NonForemost with key4 V, and with edge8 Y.",
            "NL": "Whenever NonForemost with key4 V and edge8 Y is present, it is compulsory to not have an Attained with vtx10 Y."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is an Augmenting_Path with value10 U, whenever there is Following with vtx2 U, and with vtx1 P.",
            "NL": "Whenever there is a Following with vtx2 U and vtx1 P, it is necessary that there is no Augmenting_Path with a value of 10 U."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is an Augmenting_Path with value10 U, whenever there is Following with vtx2 U, and with vtx1 P.",
            "NL": "Whenever there is a Following with vtx2 U and vtx1 P, it is necessary that there is no Augmenting_Path with value10 U."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is an Augmenting_Path with value10 U, whenever there is Following with vtx2 U, and with vtx1 P.",
            "NL": "Whenever vtx1 has a value of P, it is essential that there is no Augmenting Path with a value of 10 U if there is a Following with vtx2 U."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is an Augmenting_Path with value10 U, whenever there is Following with vtx2 U, and with vtx1 P.",
            "NL": "Whenever vtx1 has a value of P and vtx2 has a value of U, it is necessary that there is no Augmenting Path with a value of 10U."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is an Augmenting_Path with value10 U, whenever there is Following with vtx2 U, and with vtx1 P.",
            "NL": "Whenever there is a Following with vtx2 U and vtx1 P, it is necessary that there is no Augmenting Path with value 10 U."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is an Edge with field7 C, whenever there is Notnext with key B, and with value C.",
            "NL": "Whenever key B is Notnext and has the value C, it is imperative to not have an Edge with field7 C."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is an Edge with field7 C, whenever there is Notnext with key B, and with value C.",
            "NL": "It is a requirement that there be no Edge with field7 C when there is a Notnext with key B and value C."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is an Edge with field7 C, whenever there is Notnext with key B, and with value C.",
            "NL": "Whenever there is Notnext with key B and value C, it is mandatory to not have an Edge with field7 C."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is an Edge with field7 C, whenever there is Notnext with key B, and with value C.",
            "NL": "Whenever there is Notnext with key B and value C, it is mandatory not to have an Edge with field7 C."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is an Edge with field7 C, whenever there is Notnext with key B, and with value C.",
            "NL": "Whenever Notnext with key B and value C is present, it is mandatory not to have an Edge with field7 C."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is an Edge_Label with vtx4 Q, and with value1 K, whenever there is a Related with fake value K, and with second vertex S, whenever there is an Edge_Label with vtx4 G, and with value1 S.",
            "NL": "The requirement that Edge_Label with vtx4 Q and value1 K must be present when there is a Related with fake value K and second vertex S, and Edge_Label with vtx4 G and value1 S must be present when there is an Edge_Label, must be fulfilled."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is an Edge_Label with vtx4 Q, and with value1 K, whenever there is a Related with fake value K, and with second vertex S, whenever there is an Edge_Label with vtx4 G, and with value1 S.",
            "NL": "It is necessary that any time there is a Related with fake value K and second vertex S, there must be an Edge_Label with vtx4 Q and value1 K, and any time there is an Edge_Label with vtx4 G and value1 S, there must be a Related with fake value K and second vertex S."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is an Edge_Label with vtx4 Q, and with value1 K, whenever there is a Related with fake value K, and with second vertex S, whenever there is an Edge_Label with vtx4 G, and with value1 S.",
            "NL": "It must be ensured that when a Related with fake value K and second vertex S exists, there must be an Edge_Label with vtx4 Q and value1 K, and when an Edge_Label with vtx4 G and value1 S exists, there must be a Related with fake value K and second vertex S."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is an Edge_Label with vtx4 Q, and with value1 K, whenever there is a Related with fake value K, and with second vertex S, whenever there is an Edge_Label with vtx4 G, and with value1 S.",
            "NL": "The requirement must be met that an Edge_Label with vtx4 Q and value1 K exists whenever a Related with fake value K and second vertex S is present, and an Edge_Label with vtx4 G and value1 S is present."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is an Edge_Label with vtx4 Q, and with value1 K, whenever there is a Related with fake value K, and with second vertex S, whenever there is an Edge_Label with vtx4 G, and with value1 S.",
            "NL": "It must be ensured that when there is a Related with fake value K and second vertex S, there is an Edge_Label with vtx4 Q and value1 K, and when there is an Edge_Label with vtx4 G and value1 S, there is also an Edge_Label with vtx4 Q and value1 K."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is an Edge_Pair with node10 X, and with edge7 N, whenever there is a Tally with second node N, and with first node A, whenever there is an Edge_Pair with node10 B, and with edge7 A.",
            "NL": "The requirement that whenever there is a Tally with second node N and first node A, there must be an Edge_Pair with node10 X and edge7 N, and whenever there is an Edge_Pair with node10 B and edge7 A, must be met."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is an Edge_Pair with node10 X, and with edge7 N, whenever there is a Tally with second node N, and with first node A, whenever there is an Edge_Pair with node10 B, and with edge7 A.",
            "NL": "The necessity of having an Edge_Pair with node10 X and edge7 N when there is a Tally with second node N and first node A, and an Edge_Pair with node10 B and edge7 A, must be satisfied."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is an Edge_Pair with node10 X, and with edge7 N, whenever there is a Tally with second node N, and with first node A, whenever there is an Edge_Pair with node10 B, and with edge7 A.",
            "NL": "It must be ensured that when there is a Tally with second node N and first node A, there is an Edge_Pair with node10 X and edge7 N, and when there is an Edge_Pair with node10 B and edge7 A, there is also a Tally with second node N and first node A."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is an Edge_Pair with node10 X, and with edge7 N, whenever there is a Tally with second node N, and with first node A, whenever there is an Edge_Pair with node10 B, and with edge7 A.",
            "NL": "It must be ensured that whenever there is a Tally with second node N and first node A, there is an Edge_Pair with node10 X and edge7 N, and whenever there is an Edge_Pair with node10 B and edge7 A, there is a Tally with second node N and first node A."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is an Edge_Pair with node10 X, and with edge7 N, whenever there is a Tally with second node N, and with first node A, whenever there is an Edge_Pair with node10 B, and with edge7 A.",
            "NL": "The requirement that an Edge_Pair with node10 X and edge7 N must be present whenever a Tally exists with second node N and first node A, and an Edge_Pair with node10 B and edge7 A must also be present, must be fulfilled."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is an Engaged with vtx1 L, whenever there is a Utilized_Edge with vtx1 L.",
            "NL": "It is essential that vtx1 L is not Engaged when edge9 L is Utilized."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is an Engaged with vtx1 L, whenever there is a Utilized_Edge with vtx1 L.",
            "NL": "It is essential that vtx1 L is not Engaged when Utilized_Edge with edge9 L is present."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is an Engaged with vtx1 L, whenever there is a Utilized_Edge with vtx1 L.",
            "NL": "It is essential to ensure that vtx1 L is not Engaged when edge9 L is Utilized."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is an Engaged with vtx1 L, whenever there is a Utilized_Edge with vtx1 L.",
            "NL": "It is essential that vtx1 L not be Engaged when there is an Utilized_Edge with edge9 L."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is an Engaged with vtx1 L, whenever there is a Utilized_Edge with vtx1 L.",
            "NL": "It is essential that vtx1 L is not Engaged when there is an Utilized_Edge with edge9 L."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is an Entered with vtx I, and with id6 J, whenever there is an Edge_Label with fake value J, and with fifth node W, whenever there is an Entered with vtx K, and with id6 W.",
            "NL": "The Entered with vtx I, and with id6 J, must be present whenever there is an Edge_Label with fake value J, and the Entered with vtx K, and with id6 W, must be present whenever there is an fifth node W."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is an Entered with vtx I, and with id6 J, whenever there is an Edge_Label with fake value J, and with fifth node W, whenever there is an Entered with vtx K, and with id6 W.",
            "NL": "The condition that an Entered with vtx I and id6 J must be present when Edge_Label has fake value J and fifth node W, as well as an Entered with vtx K and id6 W, must be fulfilled."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is an Entered with vtx I, and with id6 J, whenever there is an Edge_Label with fake value J, and with fifth node W, whenever there is an Entered with vtx K, and with id6 W.",
            "NL": "It must be ensured that when there is an Edge_Label with fake value J, and a fifth node W, there is an Entered with vtx I, and id6 J, as well as an Entered with vtx K, and id6 W."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is an Entered with vtx I, and with id6 J, whenever there is an Edge_Label with fake value J, and with fifth node W, whenever there is an Entered with vtx K, and with id6 W.",
            "NL": "It is essential that if there is an Edge_Label with fake value J and fifth node W, then there must be an Entered with vtx I and id6 J, and if there is an Entered with vtx K and id6 W, then it must also be fulfilled."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is an Entered with vtx I, and with id6 J, whenever there is an Edge_Label with fake value J, and with fifth node W, whenever there is an Entered with vtx K, and with id6 W.",
            "NL": "Any Edge_Label with a fake value of J must be accompanied by an Entered with vtx I and id6 J, and any Entered with vtx K and id6 W must be accompanied by a fifth node W."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is an Index 43.",
            "NL": "No Index number 43 has been required."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is an Index 43.",
            "NL": "Index number 43 is not a requirement."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is an Index 43.",
            "NL": "There is no Index number 43 required."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is an Index 43.",
            "NL": "No Index number 43 is required."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is an Index 43.",
            "NL": "Index number 43 is not required."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is an Investigate with id2 J, with id9 T, with node3 C, whenever there is a Fewer with value8 J, with field C, whenever there is an Investigate with id2 J, with id9 T, with node3 F.",
            "NL": "An investigation involving id2 J, id9 T, and node3 C is necessary, as well as a Fewer with value8 J and field C. Subsequently, an investigation involving id2 J, id9 T, and node3 F, as well as a Fewer with value8 J, is also required."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is an Investigate with id2 J, with id9 T, with node3 C, whenever there is a Fewer with value8 J, with field C, whenever there is an Investigate with id2 J, with id9 T, with node3 F.",
            "NL": "This necessitates an Investigation with id2 J, id9 T, and node3 C; a Fewer with value8 J and field C; and another Investigation with id2 J, id9 T, and node3 F; as well as a Fewer with value8 J."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is an Investigate with id2 J, with id9 T, with node3 C, whenever there is a Fewer with value8 J, with field C, whenever there is an Investigate with id2 J, with id9 T, with node3 F.",
            "NL": "An Investigation with ID2 J, ID9 T, and Node3 C must be conducted, as well as a Fewer with Value8 J and Field C. Additionally, an Investigation with ID2 J, ID9 T, and Node3 F, and a Fewer with Value8 J must also be conducted."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is an Investigate with id2 J, with id9 T, with node3 C, whenever there is a Fewer with value8 J, with field C, whenever there is an Investigate with id2 J, with id9 T, with node3 F.",
            "NL": "This necessitates an Investigation with id2 J, id9 T, and node3 C; a Lesser with value8 J, and field C; another Investigation with id2 J, id9 T, and node3 F; and a Lesser with value8 J."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is an Investigate with id2 J, with id9 T, with node3 C, whenever there is a Fewer with value8 J, with field C, whenever there is an Investigate with id2 J, with id9 T, with node3 F.",
            "NL": "This necessitates the existence of an Investigation with ID2 J, ID9 T, and Node3 C; a Fewer with Value8 J and Field C; another Investigation with ID2 J, ID9 T, and Node3 F; and finally, a Fewer with Value8 J."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is an ok with value X, whenever there is a var X.",
            "NL": "Whenever variable X is present, there must not be an OK associated with it, as this is a requirement."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is an ok with value X, whenever there is a var X.",
            "NL": "Whenever variable X is present, there must not be an OK associated with it, which is a requirement."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is an ok with value X, whenever there is a var X.",
            "NL": "Whenever X is present, no OK should be associated with it."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is an ok with value X, whenever there is a var X.",
            "NL": "It is mandatory that when variable X is present, OK must not be present."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is an ok with value X, whenever there is a var X.",
            "NL": "Whenever X is present, it is not allowed to have an OK associated with it."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is an Unarrowed with field6 V, with vtx5 U, with edge1 X, whenever there is a Idle with field8 V, with value1 X, whenever there is an Unarrowed with field6 V, with vtx5 U, with edge1 L.",
            "NL": "This necessitates the presence of an Unarrowed with field6 V, vtx5 U, and edge1 X; an Idle with field8 V and value1 X; an Unarrowed with field6 V, vtx5 U, and edge1 L; and an Idle with field8 V."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is an Unarrowed with field6 V, with vtx5 U, with edge1 X, whenever there is a Idle with field8 V, with value1 X, whenever there is an Unarrowed with field6 V, with vtx5 U, with edge1 L.",
            "NL": "This necessitates an Unarrowed with field6 V, vtx5 U, and edge1 X; an Idle with field8 V and value1 X; another Unarrowed with field6 V, vtx5 U, and edge1 L; and another Idle with field8 V."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is an Unarrowed with field6 V, with vtx5 U, with edge1 X, whenever there is a Idle with field8 V, with value1 X, whenever there is an Unarrowed with field6 V, with vtx5 U, with edge1 L.",
            "NL": "This necessitates the existence of an Unarrowed field6 V with vtx5 U and edge1 X, an Idle field8 V with value1 X, another Unarrowed field6 V with vtx5 U and edge1 L, and an Idle field8 V."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is an Unarrowed with field6 V, with vtx5 U, with edge1 X, whenever there is a Idle with field8 V, with value1 X, whenever there is an Unarrowed with field6 V, with vtx5 U, with edge1 L.",
            "NL": "This necessitates the presence of an Unarrowed having field6 V, vtx5 U, and edge1 X; an Idle with field8 V, and value1 X; another Unarrowed with field6 V, vtx5 U, and edge1 L; and an Idle with field8 V."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is an Unarrowed with field6 V, with vtx5 U, with edge1 X, whenever there is a Idle with field8 V, with value1 X, whenever there is an Unarrowed with field6 V, with vtx5 U, with edge1 L.",
            "NL": "This necessitates an Unarrowed with field6 V, vtx5 U, and edge1 X, an Idle with field8 V and value1 X, another Unarrowed with field6 V, vtx5 U, and edge1 L, and finally an Idle with field8 V."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is an Used_Edge with vtx1 X, whenever there is a Planar with vtx1 X.",
            "NL": "It is essential that no Used_Edge exists with vtx1 X when there is a Planar with node2 X."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is an Used_Edge with vtx1 X, whenever there is a Planar with vtx1 X.",
            "NL": "Whenever there is a Planar with node2 X, it is necessary that there is no Used_Edge with vtx1 X."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is an Used_Edge with vtx1 X, whenever there is a Planar with vtx1 X.",
            "NL": "It is essential that no Used_Edge is connected to vtx1 X whenever a Planar has node2 X."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is an Used_Edge with vtx1 X, whenever there is a Planar with vtx1 X.",
            "NL": "It is essential that there be no Used_Edge associated with node1 X if there is a Planar linked to node2 X."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is an Used_Edge with vtx1 X, whenever there is a Planar with vtx1 X.",
            "NL": "Whenever there is a Planar with node2 X, it is essential that there is no Used_Edge with vtx1 X."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is Basic with value6 B, whenever there is a id6 B.",
            "NL": "Whenever an id6 B is present, there is a requirement for a non-Basic value6 B."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is Basic with value6 B, whenever there is a id6 B.",
            "NL": "Whenever an id6 B is present, there is a requirement for it to not be Basic and to have a value6 B."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is Basic with value6 B, whenever there is a id6 B.",
            "NL": "When an id6 B is present, it is required that the value6 B is not Basic."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is Basic with value6 B, whenever there is a id6 B.",
            "NL": "Whenever an id6 B is present, there is a requirement that a non-Basic value6 B must be included."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is Basic with value6 B, whenever there is a id6 B.",
            "NL": "Whenever an id6 B is present, there is a requirement that a value6 B which is not Basic must be included."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is Coloring with id2 M, whenever there is Child with id2 M.",
            "NL": "It is mandatory that if a Child has an id2 of M, there must not be a Coloring with the same id2 of M."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is Coloring with id2 M, whenever there is Child with id2 M.",
            "NL": "A Child must not have an Coloring with the same id2 of M if they possess an id2 of M."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is Coloring with id2 M, whenever there is Child with id2 M.",
            "NL": "When a Child has an id2 of M, there cannot be a Coloring with the same id2 M."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is Coloring with id2 M, whenever there is Child with id2 M.",
            "NL": "No Coloring should have the same id2 as a Child with an id2 of M."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is Coloring with id2 M, whenever there is Child with id2 M.",
            "NL": "It is necessary that when a Child has an id2 of M, there cannot be an Coloring item with the same id2 of M."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is Hue with field1 U, whenever there is a key9 U.",
            "NL": "Whenever a key9 U is present, there is a requirement that it does not match with the field1 U."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is Hue with field1 U, whenever there is a key9 U.",
            "NL": "Whenever a key9 U is present, there is a requirement that it does not match the field1 U."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is Hue with field1 U, whenever there is a key9 U.",
            "NL": "Whenever a key9 U is present, there must be a key9 U that does not match the field1 U."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is Hue with field1 U, whenever there is a key9 U.",
            "NL": "Whenever a key9 U is present, it must not be in conflict with the field1 U requirement."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is Hue with field1 U, whenever there is a key9 U.",
            "NL": "Whenever a key9 U is present, there is a requirement for it to not match the field1 U."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is Inpath with id2 D, whenever there is Root with id2 D.",
            "NL": "It is mandatory that no Inpath should have an id2 of D if there is a Root with the same id2 of D."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is Inpath with id2 D, whenever there is Root with id2 D.",
            "NL": "When there is a Root with an id2 of D, there must not be an Inpath with the same id2 of D as a requirement."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is Inpath with id2 D, whenever there is Root with id2 D.",
            "NL": "When a Root has an id2 of D, there must not be an Inpath with the same id2 of D."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is Inpath with id2 D, whenever there is Root with id2 D.",
            "NL": "When a Root has an id2 of D, no Inpath with the same id2 D is allowed."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is Inpath with id2 D, whenever there is Root with id2 D.",
            "NL": "It is mandatory that an Inpath with id2 D should not exist if a Root with the same id2 D is present."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is outgroup with value X, whenever there is root with value X.",
            "NL": "When the root has a value of X, it is not permissible for any outgroup to have the same value X."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is outgroup with value X, whenever there is root with value X.",
            "NL": "No outgroup should have the same value X as any root that has a value of X."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is outgroup with value X, whenever there is root with value X.",
            "NL": "It is mandatory that an outgroup must not have the same value X when the root has a value of X."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is outgroup with value X, whenever there is root with value X.",
            "NL": "It is necessary that no outgroup have the same value X when a root has a value of X."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is outgroup with value X, whenever there is root with value X.",
            "NL": "It is mandatory that no outgroup should have the same value X as the root when it has a value of X."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is Path with value8 M, whenever there is Primary with value8 M.",
            "NL": "When a Primary has a value8 of M, there must not be a Path with the same value8 M."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is Path with value8 M, whenever there is Primary with value8 M.",
            "NL": "It is mandatory that no Path should have the same value8 M when there is a Primary with value8 M."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is Path with value8 M, whenever there is Primary with value8 M.",
            "NL": "It is mandatory that when a Primary has a value8 of M, no Path should have the same value8 of M."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is Path with value8 M, whenever there is Primary with value8 M.",
            "NL": "It is mandated that no Path should have the same value8 M if there is a Primary with a value8 of M."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is Path with value8 M, whenever there is Primary with value8 M.",
            "NL": "It is mandatory that if the Primary has a value8 of M, then there should not be a Path with the same value8 of M."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is reached with id X, whenever there is a node X. ",
            "NL": "Whenever a node X is present, it is required that the node X cannot be reached with the id X."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is reached with id X, whenever there is a node X. ",
            "NL": "Whenever a node X is present, it is necessary that it cannot be accessed with the ID X."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is reached with id X, whenever there is a node X. ",
            "NL": "Whenever a node X is present, there must be an unreached node X with the same ID."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is reached with id X, whenever there is a node X. ",
            "NL": "Whenever a node X is present, it is necessary for there to be a node X which cannot be accessed with the ID X."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that there is reached with id X, whenever there is a node X. ",
            "NL": "Whenever a node X is present, there must be a node X that is not reached with the id X."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that V is equal to C, whenever there is a Begin with node9 C, with key10 R, whenever there is a Begin with node9 V, with key10 R.",
            "NL": "The requirement is that when there is a Begin with node9 C, with key10 R, there must also be a Begin with node9 V, with key10 R, where V is not equal to C."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that V is equal to C, whenever there is a Begin with node9 C, with key10 R, whenever there is a Begin with node9 V, with key10 R.",
            "NL": "If there is a Begin with node9 C, with key10 R, there must also be a Begin with node9 V, with key10 R, provided that V does not equal C."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that V is equal to C, whenever there is a Begin with node9 C, with key10 R, whenever there is a Begin with node9 V, with key10 R.",
            "NL": "Whenever there is a Begin with node9 C, with key10 R, there must also be a Begin with node9 V, with key10 R, provided V is not equal to C."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that V is equal to C, whenever there is a Begin with node9 C, with key10 R, whenever there is a Begin with node9 V, with key10 R.",
            "NL": "If there is a node9 C with key10 R, there must also be a node9 V with key10 R, provided that V is not equal to C."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that V is equal to C, whenever there is a Begin with node9 C, with key10 R, whenever there is a Begin with node9 V, with key10 R.",
            "NL": "Whenever there is a Begin with node9 C, with key10 R, there is a requirement that the Begin with node9 V, with key10 R, must not be equal to C."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that V is equal to P, whenever there is a Spanning_Tree with edge1 D, with vtx9 V, whenever there is a Matching with node8 P, and with id5 P, and with edge2 R greater than C, whenever there is a Simple_Graph with node8 P, and with id5 D, and with edge2 R greater than or equal to C, whenever there is a Simple_Graph with node8 P, and with id5 G, and with edge2 N.",
            "NL": "Whenever there is a Spanning_Tree with edge1 D and vtx9 V where V is not equal to P, and a Matching with node8 P and id5 P, and a Simple_Graph with node8 P, id5 D, and edge2 R, and another Simple_Graph with node8 P, id5 G, and edge2 C, where R is greater than C and greater than or equal to C, there is a requirement."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that V is equal to P, whenever there is a Spanning_Tree with edge1 D, with vtx9 V, whenever there is a Matching with node8 P, and with id5 P, and with edge2 R greater than C, whenever there is a Simple_Graph with node8 P, and with id5 D, and with edge2 R greater than or equal to C, whenever there is a Simple_Graph with node8 P, and with id5 G, and with edge2 N.",
            "NL": "Whenever there is a Spanning_Tree with edge1 D, vtx9 V, a Matching with node8 P, id5 P, and edge2 R, a Simple_Graph with node8 P, id5 D, and edge2 R, and another Simple_Graph with node8 P, id5 G, and edge2 C, where V does not equal P, R is greater than C, and R is greater or equal to C, there is a requirement."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that V is equal to P, whenever there is a Spanning_Tree with edge1 D, with vtx9 V, whenever there is a Matching with node8 P, and with id5 P, and with edge2 R greater than C, whenever there is a Simple_Graph with node8 P, and with id5 D, and with edge2 R greater than or equal to C, whenever there is a Simple_Graph with node8 P, and with id5 G, and with edge2 N.",
            "NL": "Whenever there is a Spanning_Tree with edge1 D, vtx9 V, and a Matching with node8 P, id5 P, and edge2 R, or a Simple_Graph with node8 P, id5 D, and edge2 R, or a Simple_Graph with node8 P, id5 G, and edge2 C, where V is not equal to P, and R is greater than C, and R is greater than or equal to C, there is a requirement."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that V is equal to P, whenever there is a Spanning_Tree with edge1 D, with vtx9 V, whenever there is a Matching with node8 P, and with id5 P, and with edge2 R greater than C, whenever there is a Simple_Graph with node8 P, and with id5 D, and with edge2 R greater than or equal to C, whenever there is a Simple_Graph with node8 P, and with id5 G, and with edge2 N.",
            "NL": "Whenever there is a Spanning_Tree with edge1 D, vtx9 V, a Matching with node8 P, id5 P, edge2 R, a Simple_Graph with node8 P, id5 D, edge2 R, and another Simple_Graph with node8 P, id5 G, edge2 C, provided V is not equal to P, and R is greater than C, or equal to C, there is a requirement."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that V is equal to P, whenever there is a Spanning_Tree with edge1 D, with vtx9 V, whenever there is a Matching with node8 P, and with id5 P, and with edge2 R greater than C, whenever there is a Simple_Graph with node8 P, and with id5 D, and with edge2 R greater than or equal to C, whenever there is a Simple_Graph with node8 P, and with id5 G, and with edge2 N.",
            "NL": "Whenever there is a Spanning_Tree with edge1 D, vtx9 V, and a Matching with node8 P, id5 P, edge2 R, a Simple_Graph with node8 P, id5 D, edge2 R, and another Simple_Graph with node8 P, id5 G, edge2 C, where V is not equal to P, and R is greater than C, and R is greater or equal to C, it is a requirement."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that V is less than or equal to U, whenever there is a Levelvtx with value equal to 1, and with id V, whenever there is a Levelvtx with value equal to 1, and with id U, whenever there is not uedge with first id U, and with second id V. ",
            "NL": "Whenever there is a levelvtx with value 1 and id V, and also a levelvtx with value 1 and id U, if there is not an uedge with id U and id V, it must be ensured that id U is always less than id V."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that V is less than or equal to U, whenever there is a Levelvtx with value equal to 1, and with id V, whenever there is a Levelvtx with value equal to 1, and with id U, whenever there is not uedge with first id U, and with second id V. ",
            "NL": "If there is a levelvtx with value 1 and id V, and also a levelvtx with value 1 and id U, and there is not an uedge with id U and id V, then id U must always be less than id V."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that V is less than or equal to U, whenever there is a Levelvtx with value equal to 1, and with id V, whenever there is a Levelvtx with value equal to 1, and with id U, whenever there is not uedge with first id U, and with second id V. ",
            "NL": "Whenever a levelvtx with value 1 and id V, and another levelvtx with value 1 and id U exist, if there is no uedge with id U and id V, then id U must always be less than id V."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that V is less than or equal to U, whenever there is a Levelvtx with value equal to 1, and with id V, whenever there is a Levelvtx with value equal to 1, and with id U, whenever there is not uedge with first id U, and with second id V. ",
            "NL": "Whenever there is a levelvtx with value 1 and id V, and also a levelvtx with value 1 and id U, and there is not an uedge with id U and id V, it is required that id U is always less than id V."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that V is less than or equal to U, whenever there is a Levelvtx with value equal to 1, and with id V, whenever there is a Levelvtx with value equal to 1, and with id U, whenever there is not uedge with first id U, and with second id V. ",
            "NL": "Whenever a levelvtx with value 1 and id V exists, and there is also a levelvtx with value 1 and id U, an uedge with id U and id V should be present, ensuring that id U is always less than id V."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that V is less than or equal to U, whenever there is an parentedge with first id P, and with second id V, whenever there is an parentedge with first id P, and with second id U, whenever there is not uedge with first id U, and with second id V. ",
            "NL": "Whenever a parentedge with id P and id V exists, and there is a parentedge with id P and id U, if an uedge with id U and id V does not exist, then id U must always be less than id V."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that V is less than or equal to U, whenever there is an parentedge with first id P, and with second id V, whenever there is an parentedge with first id P, and with second id U, whenever there is not uedge with first id U, and with second id V. ",
            "NL": "Whenever there is a parentedge with id P and two different idedges, one with id U and one with id V, where id U is less than id V and there is not an uedge with id U and id V, the requirement is that id U is always less than id V."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that V is less than or equal to U, whenever there is an parentedge with first id P, and with second id V, whenever there is an parentedge with first id P, and with second id U, whenever there is not uedge with first id U, and with second id V. ",
            "NL": "Whenever there is a parentedge with id P and id V, and another parentedge with id P and id U, if there is not an uedge with id U and id V, then id U must always be less than id V."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that V is less than or equal to U, whenever there is an parentedge with first id P, and with second id V, whenever there is an parentedge with first id P, and with second id U, whenever there is not uedge with first id U, and with second id V. ",
            "NL": "Whenever there is a parentedge with id P and id V, and also a parentedge with id P and id U, when there is not an uedge with id U and id V, the requirement is that id U must always be less than id V."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that V is less than or equal to U, whenever there is an parentedge with first id P, and with second id V, whenever there is an parentedge with first id P, and with second id U, whenever there is not uedge with first id U, and with second id V. ",
            "NL": "Whenever there is a parentedge with id P and id V, and also a parentedge with id P and id U, if there is not an uedge with id U and id V, the rule is that id U must be less than id V."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that W is equal to W1, whenever there is a match with value M, with id W, whenever there is a match with value M, with id W1.",
            "NL": "It is necessary that when a match of value M with ID W is found, and another match of value M with a different ID W1 is also found, W must not be the same as W1."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that W is equal to W1, whenever there is a match with value M, with id W, whenever there is a match with value M, with id W1.",
            "NL": "Whenever a match with value M and id W is found, and another match with the same value but a different id (W1) is also discovered, the two must not be equal."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that W is equal to W1, whenever there is a match with value M, with id W, whenever there is a match with value M, with id W1.",
            "NL": "Whenever there is a match with value M, and both the matches have different ids (W and W1) then it is a requirement."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that W is equal to W1, whenever there is a match with value M, with id W, whenever there is a match with value M, with id W1.",
            "NL": "Whenever value M and id W are matched, and another instance of value M and id W1 (where W1 is different from W) is also matched, there is a requirement to be met."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that W is equal to W1, whenever there is a match with value M, with id W, whenever there is a match with value M, with id W1.",
            "NL": "If a value M is matched with id W and the same value M is matched with a different id W1, where W does not equal W1, then it is required."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that W1 is equal to W, whenever there is a match with value M, with id W1, whenever there is a manAssignsScore with id1 M, and with id2 W, and with id3 SMW greater than SMW1, whenever there is a womanAssignsScore with id1 W, and with id2 M, and with id3 SWM greater than or equal to SMW1, whenever there is a womanAssignsScore with id1 W, and with id2 M1, and with id3 SWM1.",
            "NL": "Whenever there is a match with value M and id W1, and the manAssignsScore has id1 M, id2 W, and id3 SMW, and the womanAssignsScore has id1 W, id2 M, and id3 SWM, and then a second womanAssignsScore with id1 W, id2 M1, and id3 SWM1, provided that W1 is not equal to W, and SMW is greater than SMW1, and SWM is greater than or equal to SWM1, a requirement must be met."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that W1 is equal to W, whenever there is a match with value M, with id W1, whenever there is a manAssignsScore with id1 M, and with id2 W, and with id3 SMW greater than SMW1, whenever there is a womanAssignsScore with id1 W, and with id2 M, and with id3 SWM greater than or equal to SMW1, whenever there is a womanAssignsScore with id1 W, and with id2 M1, and with id3 SWM1.",
            "NL": "Whenever a match with value M has been identified, where the manAssignsScore with ID1 M, ID2 W, and ID3 SMW is not equal to the womanAssignsScore with ID1 W, ID2 M, and ID3 SWM, and the womanAssignsScore with ID1 W, ID2 M1, and ID3 SWM1, the requirement is that SMW must be greater than SMW1, and SWM must be greater than or equal to SWM1."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that W1 is equal to W, whenever there is a match with value M, with id W1, whenever there is a manAssignsScore with id1 M, and with id2 W, and with id3 SMW greater than SMW1, whenever there is a womanAssignsScore with id1 W, and with id2 M, and with id3 SWM greater than or equal to SMW1, whenever there is a womanAssignsScore with id1 W, and with id2 M1, and with id3 SWM1.",
            "NL": "When a match with value M has an id of W1, and the manAssignsScore has an id of M, W, and SMW, and the womanAssignsScore has an id of W, M1, and SWM1, where W1 is not equal to W, SMW is greater than SMW1, and SWM is greater than or equal to SWM1, there is a requirement."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that W1 is equal to W, whenever there is a match with value M, with id W1, whenever there is a manAssignsScore with id1 M, and with id2 W, and with id3 SMW greater than SMW1, whenever there is a womanAssignsScore with id1 W, and with id2 M, and with id3 SWM greater than or equal to SMW1, whenever there is a womanAssignsScore with id1 W, and with id2 M1, and with id3 SWM1.",
            "NL": "Whenever a match with value M and id W1 exists, if the manAssignsScore with id1 M, id2 W, and id3 SMW is not equal to the womanAssignsScore with id1 W, id2 M, and id3 SWM, and the womanAssignsScore with id1 W, id2 M1, and id3 SWM1 is greater than or equal to SWM, then there is a requirement to be met."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that W1 is equal to W, whenever there is a match with value M, with id W1, whenever there is a manAssignsScore with id1 M, and with id2 W, and with id3 SMW greater than SMW1, whenever there is a womanAssignsScore with id1 W, and with id2 M, and with id3 SWM greater than or equal to SMW1, whenever there is a womanAssignsScore with id1 W, and with id2 M1, and with id3 SWM1.",
            "NL": "Whenever there is a match with value M and id W1, if the manAssignsScore with id1 M, id2 W, and id3 SMW is greater than the womanAssignsScore with id1 W, id2 M1, and id3 SWM1, and W1 does not equal W, and SWM is greater than or equal to SWM1, then a requirement is met."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when edge10 T is Elabel to edge10 R then edge10 R is not Elabel to edge2 X and also edge10 R is not Elabel to edge2 X, where T is not after R.",
            "NL": "If edge10 T is Elabeled to edge10 R, edge10 R must not Elabel to edge2 X unless T is after R."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when edge10 T is Elabel to edge10 R then edge10 R is not Elabel to edge2 X and also edge10 R is not Elabel to edge2 X, where T is not after R.",
            "NL": "If edge10 T is Elabeled to edge10 R, edge10 R must not Elabel to edge2 X, unless edge10 T is after edge10 R."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when edge10 T is Elabel to edge10 R then edge10 R is not Elabel to edge2 X and also edge10 R is not Elabel to edge2 X, where T is not after R.",
            "NL": "Edge10 R must not Elabel to edge2 X if Edge10 T is Elabeled to Edge10 R and Edge10 T is not after Edge10 R."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when edge10 T is Elabel to edge10 R then edge10 R is not Elabel to edge2 X and also edge10 R is not Elabel to edge2 X, where T is not after R.",
            "NL": "If edge10 T is not Elabeled after edge10 R, then edge10 R must not Elabel to edge2 X."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when edge10 T is Elabel to edge10 R then edge10 R is not Elabel to edge2 X and also edge10 R is not Elabel to edge2 X, where T is not after R.",
            "NL": "If edge10 T is labeled to edge10 R, edge10 R must not be labeled to edge2 X unless edge10 T is after edge10 R."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when edge2 T is Has to edge2 G then edge2 G is not Has to vtx8 J and also edge2 G is not Has to vtx8 J, where T is at most G.",
            "NL": "If T is at most G, then edge2 G must not be Has to vtx8 J, and edge2 G must not be Has to vtx8 J either."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when edge2 T is Has to edge2 G then edge2 G is not Has to vtx8 J and also edge2 G is not Has to vtx8 J, where T is at most G.",
            "NL": "If T is at most G, the requirement is that edge2 G must not be connected to vtx8 J, and edge2 G must not be connected to vtx8 J."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when edge2 T is Has to edge2 G then edge2 G is not Has to vtx8 J and also edge2 G is not Has to vtx8 J, where T is at most G.",
            "NL": "When edge2 T is equal to or less than edge2 G, edge2 G must not be connected to vtx8 J, and edge2 G must not be connected to vtx8 J if T is at most G."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when edge2 T is Has to edge2 G then edge2 G is not Has to vtx8 J and also edge2 G is not Has to vtx8 J, where T is at most G.",
            "NL": "If edge2 T is equal to or less than edge2 G, then edge2 G must not be connected to vtx8 J, and edge2 G must not be connected to vtx8 J."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when edge2 T is Has to edge2 G then edge2 G is not Has to vtx8 J and also edge2 G is not Has to vtx8 J, where T is at most G.",
            "NL": "If T is at most G, the requirement is that edge2 G must not have to vtx8 J, and edge2 G must not have to vtx8 J when edge2 T is required."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when field8 C is not Painted then field8 C is not Mass.",
            "NL": "If field8 C is not Painted, it is mandatory that it be Mass."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when field8 C is not Painted then field8 C is not Mass.",
            "NL": "If field8 C is not Painted, it must be Mass."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when field8 C is not Painted then field8 C is not Mass.",
            "NL": "If field8 C is not Painted, it is necessary that it be Mass."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when field8 C is not Painted then field8 C is not Mass.",
            "NL": "When field8 C is not Painted, it is a requirement that field8 C be Mass."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when field8 C is not Painted then field8 C is not Mass.",
            "NL": "When field8 C is not Painted, it is mandatory that it be Mass."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when id8 Q has not Label to id8 I and also id8 I is not Label to id8 Q then id8 Q is not Less and also id8 I is not Less, where Q is not after I. ",
            "NL": "It is not allowed to have a Less with ID8 Q and a Less with ID8 I, nor a Label with ID8 Q or a Label with ID8 I."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when id8 Q has not Label to id8 I and also id8 I is not Label to id8 Q then id8 Q is not Less and also id8 I is not Less, where Q is not after I. ",
            "NL": "It is forbidden to have a Less with ID 8Q and a Less with ID 8I, and there is no Label with ID 8Q or ID 8I."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when id8 Q has not Label to id8 I and also id8 I is not Label to id8 Q then id8 Q is not Less and also id8 I is not Less, where Q is not after I. ",
            "NL": "It is not permitted to possess a Less with ID8 Q and a Less with ID8 I, nor is there a Label with ID8 Q, with ID8 I, or a Label with ID8 I, with ID8 Q."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when id8 Q has not Label to id8 I and also id8 I is not Label to id8 Q then id8 Q is not Less and also id8 I is not Less, where Q is not after I. ",
            "NL": "It is forbidden to have a Less with ID 8Q and a Less with ID 8I, as well as a Label with ID 8Q, with ID 8I, and a Label with ID 8I, with ID 8Q."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when id8 Q has not Label to id8 I and also id8 I is not Label to id8 Q then id8 Q is not Less and also id8 I is not Less, where Q is not after I. ",
            "NL": "It is not allowed to possess a Less with id8 Q and a Less with id8 I, nor is it permissible to have a Label with id8 Q and a Label with id8 I."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when id9 V is not Hamgraph then id9 V is not Entered.",
            "NL": "If id9 V is not Hamgraph, it must be Entered."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when id9 V is not Hamgraph then id9 V is not Entered.",
            "NL": "When id9 V is not Hamgraph, it must be Entered."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when id9 V is not Hamgraph then id9 V is not Entered.",
            "NL": "It is a requirement that when id9 V is not Hamgraph, it must be Entered."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when id9 V is not Hamgraph then id9 V is not Entered.",
            "NL": "It is necessary to input id9 V if it is not Hamgraph."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when id9 V is not Hamgraph then id9 V is not Entered.",
            "NL": "When id9 V is not Hamgraph, it is mandatory that id9 V be Entered."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when key1 M is not Lead then key1 M is not Pair.",
            "NL": "When key1 M is not Lead, they must be Pair according to the requirement."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when key1 M is not Lead then key1 M is not Pair.",
            "NL": "When key1 M is not the Lead, it is mandated that key1 M be the Pair."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when key1 M is not Lead then key1 M is not Pair.",
            "NL": "When key1 M is not Lead, it is necessary that it be Pair."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when key1 M is not Lead then key1 M is not Pair.",
            "NL": "If key1 M is not Lead, it is required that key1 M be Pair."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when key1 M is not Lead then key1 M is not Pair.",
            "NL": "It is mandatory that when key1 M is not the Lead, it must be the Pair."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when key2 F is not Name then key2 F is not Out_Hamiltonian.",
            "NL": "If key2 F is not Name, then it is mandatory that key2 F is Out_Hamiltonian."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when key2 F is not Name then key2 F is not Out_Hamiltonian.",
            "NL": "If key2 F is not Name, it is necessary for key2 F to be Out_Hamiltonian."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when key2 F is not Name then key2 F is not Out_Hamiltonian.",
            "NL": "If key2 F is not Name, it is mandatory that key2 F be Out_Hamiltonian."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when key2 F is not Name then key2 F is not Out_Hamiltonian.",
            "NL": "If key2 F is not Name, it is mandatory that key2 F is Out_Hamiltonian."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when key2 F is not Name then key2 F is not Out_Hamiltonian.",
            "NL": "When key2 F is not Name, it is mandatory that key2 F is Out_Hamiltonian."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when key5 B is not Caught to key5 J then key5 B is not Container and also key5 J is not Container, where B is at most J.",
            "NL": "In the instance of key5 B and J that are not Caught, key5 X cannot be Caught and key5 J cannot be higher than B."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when key5 B is not Caught to key5 J then key5 B is not Container and also key5 J is not Container, where B is at most J.",
            "NL": "If key5 B and J are not Caught, key5 X cannot be Caught and key5 J cannot be greater than B."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when key5 B is not Caught to key5 J then key5 B is not Container and also key5 J is not Container, where B is at most J.",
            "NL": "For key5 B and J that have not been Caught, key5 X cannot be Caught and key5 J cannot be a J, with B being no greater than J."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when key5 B is not Caught to key5 J then key5 B is not Container and also key5 J is not Container, where B is at most J.",
            "NL": "In the case of key5 B and J, if B is not Caught and J is not Caught, then key5 X cannot be Caught and key5 J cannot be J, with B being no greater than J."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when key5 B is not Caught to key5 J then key5 B is not Container and also key5 J is not Container, where B is at most J.",
            "NL": "For key5 B and J that are not Caught, key5 X cannot be Caught and key5 J cannot be greater than B."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when key7 E is Separate to key7 L then key7 L is not Separate to node10 F and also key7 L is not Separate to node10 F, where E is not after L.",
            "NL": "When key7 E is not after key7 L, key7 L must not be separated from node10 F, and key7 L must also not be separated from node10 F if E is after L."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when key7 E is Separate to key7 L then key7 L is not Separate to node10 F and also key7 L is not Separate to node10 F, where E is not after L.",
            "NL": "If key7 E is not after key7 L, then it is required that key7 L must not be separated from node10 F and node10 F must not be separated from key7 L."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when key7 E is Separate to key7 L then key7 L is not Separate to node10 F and also key7 L is not Separate to node10 F, where E is not after L.",
            "NL": "When key7 E is not after key7 L, key7 L must not be separated from node10 F, and key7 L must not be separated from node10 F if E is not after L."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when key7 E is Separate to key7 L then key7 L is not Separate to node10 F and also key7 L is not Separate to node10 F, where E is not after L.",
            "NL": "If key7 E is not after key7 L, then key7 L must not be separated from node10 F and key7 L must not be separated from node10 F."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when key7 E is Separate to key7 L then key7 L is not Separate to node10 F and also key7 L is not Separate to node10 F, where E is not after L.",
            "NL": "If key7 E is not after key7 L, key7 L must not be separated from node10 F, and key7 L must not be separated from node10 F."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when key7 G has not Root to key7 I and also key7 I is not Root to key7 G then key7 G is not Depth_Vertex and also key7 I is not Depth_Vertex, where G is at most I. ",
            "NL": "It is forbidden to have both a Depth_Vertex with key7 G and a Depth_Vertex with key7 I, as well as an Root with either key7 G or key7 I."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when key7 G has not Root to key7 I and also key7 I is not Root to key7 G then key7 G is not Depth_Vertex and also key7 I is not Depth_Vertex, where G is at most I. ",
            "NL": "It is not allowed to have both a Depth_Vertex with key7 G and a Depth_Vertex with key7 I, and there is no Root with key7 G and key7 I, nor a Root with key7 I and key7 G."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when key7 G has not Root to key7 I and also key7 I is not Root to key7 G then key7 G is not Depth_Vertex and also key7 I is not Depth_Vertex, where G is at most I. ",
            "NL": "It is forbidden to have a Depth_Vertex with key7 G and a Depth_Vertex with key7 I, but there is no Root with key7 G and key7 I, or a Root with key7 I and key7 G."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when key7 G has not Root to key7 I and also key7 I is not Root to key7 G then key7 G is not Depth_Vertex and also key7 I is not Depth_Vertex, where G is at most I. ",
            "NL": "It is not allowed to have any Depth_Vertex with key7 G or key7 I, nor is it permissible to have any Root with key7 G and key7 I, or key7 I and key7 G."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when key7 G has not Root to key7 I and also key7 I is not Root to key7 G then key7 G is not Depth_Vertex and also key7 I is not Depth_Vertex, where G is at most I. ",
            "NL": "It is forbidden to have a Depth_Vertex with key7 G and a Depth_Vertex with key7 I, and there is no Root with key7 G and key7 I, or with key7 I and key7 G."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when node U is link to node V then node U is not assigned to color C and also node V is not assigned to color C, where U is less than V.",
            "NL": "If node U is smaller than node V, then neither node U nor node V should be linked to color C."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when node U is link to node V then node U is not assigned to color C and also node V is not assigned to color C, where U is less than V.",
            "NL": "If node U is less than node V, neither node U nor node V must be linked to color C."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when node U is link to node V then node U is not assigned to color C and also node V is not assigned to color C, where U is less than V.",
            "NL": "If node U is less than node V, then it is required that neither U nor V link to color C."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when node U is link to node V then node U is not assigned to color C and also node V is not assigned to color C, where U is less than V.",
            "NL": "If node U is less than node V, then neither U nor V can be linked to color C."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when node U is link to node V then node U is not assigned to color C and also node V is not assigned to color C, where U is less than V.",
            "NL": "Node U must not link to color C when linked to node V, and node V must not link to color C if U is less than V, as required."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when node X has not edge to node Y and also node Y is not edge to node X then node X is not clique and also node Y is not clique, where X is less than Y.",
            "NL": "It is not allowed to form a clique involving node X and another clique involving node Y, and there is no connection between node X and node Y."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when node X has not edge to node Y and also node Y is not edge to node X then node X is not clique and also node Y is not clique, where X is less than Y.",
            "NL": "It is not allowed to form a clique with node X and a separate clique with node Y, and there is no connection between node X and node Y."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when node X has not edge to node Y and also node Y is not edge to node X then node X is not clique and also node Y is not clique, where X is less than Y.",
            "NL": "It is not allowed to form a clique with node X and a clique with node Y, nor is there an edge between node X and node Y, or vice versa."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when node X has not edge to node Y and also node Y is not edge to node X then node X is not clique and also node Y is not clique, where X is less than Y.",
            "NL": "It is not allowed to form a clique with node X and a clique with node Y, nor is there an edge between node X and node Y, or between node Y and node X."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when node X has not edge to node Y and also node Y is not edge to node X then node X is not clique and also node Y is not clique, where X is less than Y.",
            "NL": "It is forbidden to form a group with node X and a group with node Y, and there is no connection between node X and node Y."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when node X is not uconnected to node Y then node X is not clique and also node Y is not clique, where X is less than Y.",
            "NL": "In the case of nodes X and Y that are not connected, since X is less than Y, neither node X nor node Y can be a clique."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when node X is not uconnected to node Y then node X is not clique and also node Y is not clique, where X is less than Y.",
            "NL": "If nodes X and Y are not connected, node X cannot be a clique and node Y cannot be a clique either, with X being less than Y."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when node X is not uconnected to node Y then node X is not clique and also node Y is not clique, where X is less than Y.",
            "NL": "For nodes X and Y, which are not connected, node X cannot form a clique since it is less than node Y, and likewise node Y cannot form a clique."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when node X is not uconnected to node Y then node X is not clique and also node Y is not clique, where X is less than Y.",
            "NL": "If nodes X and Y are not connected, node X cannot form a clique and node Y cannot form a clique, provided that X is less than Y."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when node X is not uconnected to node Y then node X is not clique and also node Y is not clique, where X is less than Y.",
            "NL": "If nodes X and Y are not connected and X is less than Y, neither node X nor node Y can form a clique."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when node9 W is Father_Edge to node9 P then node9 P is not Father_Edge to field2 R and also node9 P is not Father_Edge to field2 R, where W is not after P.",
            "NL": "If node9 W is Father_Edge to node9 P, then node9 P must not be Father_Edge to field2 R if W is not after P."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when node9 W is Father_Edge to node9 P then node9 P is not Father_Edge to field2 R and also node9 P is not Father_Edge to field2 R, where W is not after P.",
            "NL": "If node9 W is Father_Edge to node9 P, then node9 P must not Father_Edge to field2 R if W is not after P."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when node9 W is Father_Edge to node9 P then node9 P is not Father_Edge to field2 R and also node9 P is not Father_Edge to field2 R, where W is not after P.",
            "NL": "If node9 W is not after node9 P, then node9 P must not Father_Edge to field2 R when W is Father_Edge to P."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when node9 W is Father_Edge to node9 P then node9 P is not Father_Edge to field2 R and also node9 P is not Father_Edge to field2 R, where W is not after P.",
            "NL": "If node9 W is not after node9 P, node9 P must not be Father_Edge to field2 R when W is Father_Edge to P."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when node9 W is Father_Edge to node9 P then node9 P is not Father_Edge to field2 R and also node9 P is not Father_Edge to field2 R, where W is not after P.",
            "NL": "When node9 W is the Father_Edge to node9 P, it is required that node9 P must not have a Father_Edge to field2 R if W is not after P."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when value7 T is not Span to value7 H then value7 T is not OutDegree and also value7 H is not OutDegree, where T is at most H.",
            "NL": "In the case of value7 T and H, if either one is not a Span, then value7 X cannot be a Span and value7 H cannot be a H, with T being equal to or less than H."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when value7 T is not Span to value7 H then value7 T is not OutDegree and also value7 H is not OutDegree, where T is at most H.",
            "NL": "If T is not a Span and H is not a H, then value7 X cannot be a Span and value7 H cannot be a H, with T being less than or equal to H."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when value7 T is not Span to value7 H then value7 T is not OutDegree and also value7 H is not OutDegree, where T is at most H.",
            "NL": "In the case of value7 T and H that are not Span, value7 X must be different than Span and value7 H must be less than or equal to H."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when value7 T is not Span to value7 H then value7 T is not OutDegree and also value7 H is not OutDegree, where T is at most H.",
            "NL": "If value7 T is not a Span and value7 H is not a H, value7 X cannot be a Span and value7 H cannot exceed value7 T."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when value7 T is not Span to value7 H then value7 T is not OutDegree and also value7 H is not OutDegree, where T is at most H.",
            "NL": "In the situation where value7 T and value7 H are not Span, value7 X cannot be Span and value7 H cannot be H, and T is equal to or less than H."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when vtx U is not considered then vtx U is not vtx. ",
            "NL": "When vertex U is not taken into consideration, it is the vertex in question."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when vtx U is not considered then vtx U is not vtx. ",
            "NL": "If vertex U is not taken into account, it is the vertex."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when vtx U is not considered then vtx U is not vtx. ",
            "NL": "If vertex U is not taken into account, then it is the vertex in question."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when vtx U is not considered then vtx U is not vtx. ",
            "NL": "If vertex U is not taken into account, then vertex U is the vertex in question."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when vtx U is not considered then vtx U is not vtx. ",
            "NL": "If vertex U is not taken into account, then vertex U must be the vertex."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when Vtx U is not reached then Vtx U is not dom.",
            "NL": "If vertex U is not attained, then vertex U must be predominant."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when Vtx U is not reached then Vtx U is not dom.",
            "NL": "If vertex U is not attained, it must be the dominant vertex."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when Vtx U is not reached then Vtx U is not dom.",
            "NL": "If vertex U is not reached, it must be dominant."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when Vtx U is not reached then Vtx U is not dom.",
            "NL": "Vertex U must be dominant if it is not reached."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when Vtx U is not reached then Vtx U is not dom.",
            "NL": "When vertex U is not attained, it must be dominant."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when Vtx X is not reached then Vtx X is not vtx.",
            "NL": "If vertex X is not reached, it must be the vertex."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when Vtx X is not reached then Vtx X is not vtx.",
            "NL": "If vertex X is not reached, then it must be the vertex in question."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when Vtx X is not reached then Vtx X is not vtx.",
            "NL": "If vertex X is not reached, then it must be the vertex."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when Vtx X is not reached then Vtx X is not vtx.",
            "NL": "If vertex X is not reached, then it must remain the vertex."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when Vtx X is not reached then Vtx X is not vtx.",
            "NL": "If vertex X has not been reached, it must be the vertex."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when vtx10 L is not Rest then vtx10 L is not Depth_Vertex.",
            "NL": "When vtx10 L is not Rest, it is mandatory that vtx10 L is set to Depth_Vertex."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when vtx10 L is not Rest then vtx10 L is not Depth_Vertex.",
            "NL": "When vtx10 L is not Rest, it is mandatory that vtx10 L is Depth_Vertex."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when vtx10 L is not Rest then vtx10 L is not Depth_Vertex.",
            "NL": "It is mandatory that when vtx10 L is not in a Rest state, it must be set to Depth_Vertex."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when vtx10 L is not Rest then vtx10 L is not Depth_Vertex.",
            "NL": "If vtx10 L is not Rest, it is mandatory that vtx10 L is Depth_Vertex."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when vtx10 L is not Rest then vtx10 L is not Depth_Vertex.",
            "NL": "When vtx10 L is not in Rest mode, it must be in Depth_Vertex mode."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when vtx10 R is not In_Hamiltonian to vtx10 I then vtx10 R is not Penalty and also vtx10 I is not Penalty, where R is at most I.",
            "NL": "For vtx10 R and I that are not In_Hamiltonian, vtx10 X cannot be an In_Hamiltonian, and vtx10 I cannot exceed I, either."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when vtx10 R is not In_Hamiltonian to vtx10 I then vtx10 R is not Penalty and also vtx10 I is not Penalty, where R is at most I.",
            "NL": "For vtx10 R and I that are not In_Hamiltonian, vtx10 X cannot be an In_Hamiltonian and vtx10 I cannot be greater than I."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when vtx10 R is not In_Hamiltonian to vtx10 I then vtx10 R is not Penalty and also vtx10 I is not Penalty, where R is at most I.",
            "NL": "In the case of vtx10 R and I that are not In_Hamiltonian, vtx10 X cannot be an In_Hamiltonian and vtx10 I cannot be greater than I, respectively."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when vtx10 R is not In_Hamiltonian to vtx10 I then vtx10 R is not Penalty and also vtx10 I is not Penalty, where R is at most I.",
            "NL": "In the case of vtx10 R and I that are not In_Hamiltonian, vtx10 X cannot be an In_Hamiltonian system and vtx10 I cannot be an I system, where R is at most I in size."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when vtx10 R is not In_Hamiltonian to vtx10 I then vtx10 R is not Penalty and also vtx10 I is not Penalty, where R is at most I.",
            "NL": "In the case of vtx10 R and I that are not In_Hamiltonian, vtx10 X cannot be In_Hamiltonian and vtx10 I cannot be greater than I, where R is at most I."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when vtx2 C is not Forest then vtx2 C is not Investigate.",
            "NL": "If vtx2 C is not Forest, it must be Investigate."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when vtx2 C is not Forest then vtx2 C is not Investigate.",
            "NL": "If vtx2 C is not Forest, then it is mandatory for vtx2 C to be Investigate."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when vtx2 C is not Forest then vtx2 C is not Investigate.",
            "NL": "If vtx2 C is not Forest, it is mandatory that vtx2 C be Investigated."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when vtx2 C is not Forest then vtx2 C is not Investigate.",
            "NL": "If vtx2 C is not Forest, it is required that vtx2 C be Investigated."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when vtx2 C is not Forest then vtx2 C is not Investigate.",
            "NL": "If vtx2 C is not Forest, it is required that vtx2 C is Investigate."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when vtx9 G is not Projection to vtx9 R then vtx9 G is not Maximal and also vtx9 R is not Maximal, where G is not after R.",
            "NL": "For vtx9 G and R that are not Projection, vtx9 X cannot be a Projection and vtx9 R cannot be R if G is not after R."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when vtx9 G is not Projection to vtx9 R then vtx9 G is not Maximal and also vtx9 R is not Maximal, where G is not after R.",
            "NL": "For vtx9 G and R that are not Projection, vtx9 X cannot be Projection and vtx9 R cannot be R if G is not after R."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when vtx9 G is not Projection to vtx9 R then vtx9 G is not Maximal and also vtx9 R is not Maximal, where G is not after R.",
            "NL": "In the case of vtx9 G and R that are not Projection, vtx9 X cannot be a Projection and vtx9 R cannot be a R if G does not come after R."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when vtx9 G is not Projection to vtx9 R then vtx9 G is not Maximal and also vtx9 R is not Maximal, where G is not after R.",
            "NL": "In the instance of vtx9 G and R that are not Projection, vtx9 X cannot be a Projection and vtx9 R cannot be a R, since G is not subsequent to R."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that when vtx9 G is not Projection to vtx9 R then vtx9 G is not Maximal and also vtx9 R is not Maximal, where G is not after R.",
            "NL": "In the case of vtx9 G and R, which are not Projection, vtx9 X cannot be a Projection and vtx9 R cannot be a R if G is not after R."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that X is equal to X1, whenever there is an inpath with first node X, and with second node Y, whenever there is an inpath with first node X1, and with second node Y.",
            "NL": "Whenever there is an inpath with the first node X1 and the second node Y, X must not be equal to X1; likewise, when there is an inpath with the first node X and the second node Y1, X and Y1 must not be the same."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that X is equal to X1, whenever there is an inpath with first node X, and with second node Y, whenever there is an inpath with first node X1, and with second node Y.",
            "NL": "Whenever there is an inpath with the first node X1 and the second node Y, the requirement is that X must not be equal to X1. Likewise, when there is an inpath with the first node X and the second node Y1, X must not be equal to X1."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that X is equal to X1, whenever there is an inpath with first node X, and with second node Y, whenever there is an inpath with first node X1, and with second node Y.",
            "NL": "Whenever there is an inpath with the first node X1 and the second node Y, X must not be equal to X1. Similarly, when there is an inpath with the first node X and the second node Y1, X must not be equal to X1."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that X is equal to X1, whenever there is an inpath with first node X, and with second node Y, whenever there is an inpath with first node X1, and with second node Y.",
            "NL": "Whenever an inpath exists with X1 as the first node and Y as the second node, X must not equal X1. Additionally, when an inpath exists with X as the first node and Y1 as the second node, X and Y must remain unchanged."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that X is equal to X1, whenever there is an inpath with first node X, and with second node Y, whenever there is an inpath with first node X1, and with second node Y.",
            "NL": "Whenever there is an inpath with the first node X1 and the second node Y, X must not be the same as X1, and likewise, when there is an inpath with the first node X and the second node Y1, X must not be equal to Y1."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that Y is equal to B, whenever there is a Tree with value6 B, with node8 I, whenever there is a Tree with value6 Y, with node8 I.",
            "NL": "If a Tree has a value of 6 B and a node of 8 I, and another Tree has a value of 6 Y with a node of 8 I, then Y must not be equal to B."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that Y is equal to B, whenever there is a Tree with value6 B, with node8 I, whenever there is a Tree with value6 Y, with node8 I.",
            "NL": "Whenever a Tree has a value6 of B and a node8 of I, and there is another Tree with a value6 of Y and a node8 of I, where Y does not equal B, a requirement must be met."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that Y is equal to B, whenever there is a Tree with value6 B, with node8 I, whenever there is a Tree with value6 Y, with node8 I.",
            "NL": "If there is a Tree with value6 B and node8 I, and another Tree with value6 Y and node8 I, where Y is not equal to B, then it is a requirement."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that Y is equal to B, whenever there is a Tree with value6 B, with node8 I, whenever there is a Tree with value6 Y, with node8 I.",
            "NL": "Whenever there is a Tree with value 6 B and node 8 I, and a Tree with value 6 Y and node 8 I, where Y is not equal to B, it is a requirement."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that Y is equal to B, whenever there is a Tree with value6 B, with node8 I, whenever there is a Tree with value6 Y, with node8 I.",
            "NL": "Whenever there is a Tree with value6 B and node8 I, and a Tree with value6 Y and node8 I, where Y is not equal to B, it is required."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that Y is equal to Y1, whenever there is an inpath with first node X, and with second node Y, whenever there is an inpath with first node X, and with second node Y1.",
            "NL": "Whenever an inpath exists between nodes X and Y1, Y must not be equal to Y1."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that Y is equal to Y1, whenever there is an inpath with first node X, and with second node Y, whenever there is an inpath with first node X, and with second node Y1.",
            "NL": "Whenever there is an inpath with the first node X, the requirement is that the second node Y must not be equal to Y1."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that Y is equal to Y1, whenever there is an inpath with first node X, and with second node Y, whenever there is an inpath with first node X, and with second node Y1.",
            "NL": "Whenever there is an inpath with the first node X, the requirement is that Y must not be equal to Y1, and with the second node Y."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that Y is equal to Y1, whenever there is an inpath with first node X, and with second node Y, whenever there is an inpath with first node X, and with second node Y1.",
            "NL": "Whenever there is an inpath with the first node X, Y must not be equal to Y1, and with the second node Y."
        },
        {
            "Category": "Positive Strong Constraint",
            "CNL": "It is required that Y is equal to Y1, whenever there is an inpath with first node X, and with second node Y, whenever there is an inpath with first node X, and with second node Y1.",
            "NL": "Whenever there is an inpath with the first node X, the requirement is for Y to not be equal to Y1, and for Y to not be equal to Y when there is an inpath with the first node X and the second node Y."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every Begin H can be a Container.",
            "NL": " It is possible for every Begin to be part of a Container."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every Center X can be a Load.",
            "NL": " It is possible for every Center to be part of a Load."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every edge1 can be Achieved to exactly 30 color.",
            "NL": "There can be only 30 color Achieved to each edge1. "
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every edge7 G can be Has exaclty 23 Full O.",
            "NL": "There is exactly 23 Full O for every edge7 G that can be Has."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every edge7 Q can be Name exaclty 45 Ending V.",
            "NL": "There is exactly 45 Ending V for every edge7 Q that can be Name."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every Explore A can be an Investigate.",
            "NL": " It is possible for every Explore to be part of a Investigate."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every Fewer R can be a Base.",
            "NL": " It is possible for every Fewer to be part of a Base."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every field2 T can be Mark exaclty 17 Unmatched P.",
            "NL": "There is exactly 17 Unmatched P for every field2 T that can be Mark."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every field3 can be a field.",
            "NL": "It is possibe for every field3 to be part of a field. "
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every field3 can be a key1.",
            "NL": "It is possibe for every field3 to be part of a key1. "
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every field3 J can be Subposition exaclty 21 Matching W.",
            "NL": "There is exactly 21 Matching W for every field3 J that can be Subposition."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every field3 V can be Start exaclty 43 Incoming_Level C.",
            "NL": "There is exactly 43 Incoming_Level C for every field3 V that can be Start."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every field7 can be Gravity to exactly 35 color.",
            "NL": "There can be only 35 color Gravity to each field7. "
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every field8 can be a value6.",
            "NL": "It is possibe for every field8 to be part of a value6. "
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every field9 can be a edge10.",
            "NL": "It is possibe for every field9 to be part of a edge10. "
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every id2 X can be Unweighted exaclty 39 Sign A.",
            "NL": "There is exactly 39 Sign A for every id2 X that can be Unweighted."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every id7 can be NonCohesive to exactly 43 color.",
            "NL": "There can be only 43 color NonCohesive to each id7. "
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every id7 can be Success to exactly 32 color.",
            "NL": "There can be only 32 color Success to each id7. "
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every id7 can be Undirected to exactly 1 color.",
            "NL": "There can be only 1 color Undirected to each id7. "
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every id8 can be a field9.",
            "NL": "It is possibe for every id8 to be part of a field9. "
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every id9 V can be Nonclique exaclty 12 Contrast A.",
            "NL": "There is exactly 12 Contrast A for every id9 V that can be Nonclique."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every Irrelevant Q can be a Signal.",
            "NL": " It is possible for every Irrelevant to be part of a Signal."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every key1 can be a node8.",
            "NL": "It is possibe for every key1 to be part of a node8. "
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every key2 can be Longest_Path to exactly 26 color.",
            "NL": "There can be only 26 color Longest_Path to each key2. "
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every key3 O can be Superior exaclty 13 Variation H.",
            "NL": "There is exactly 13 Variation H for every key3 O that can be Superior."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every key4 can be a node3.",
            "NL": "It is possibe for every key4 to be part of a node3. "
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every key4 can be a value5.",
            "NL": "It is possibe for every key4 to be part of a value5. "
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every key7 B can be Valency exaclty 4 Assign Q.",
            "NL": "There is exactly 4 Assign Q for every key7 B that can be Valency."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every key7 can be a field5.",
            "NL": "It is possibe for every key7 to be part of a field5. "
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every key7 can be Individual to exactly 2 color.",
            "NL": "There can be only 2 color Individual to each key7. "
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every key9 can be Cross to exactly 30 color.",
            "NL": "There can be only 30 color Cross to each key9. "
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every key9 P can be Tag exaclty 6 Element J.",
            "NL": "There is exactly 6 Element J for every key9 P that can be Tag."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every node4 A can be Parentedge exaclty 24 Diversity S.",
            "NL": "There is exactly 24 Diversity S for every node4 A that can be Parentedge."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every node5 can be an edge6.",
            "NL": "It is possibe for every node5 to be part of a edge6. "
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every node5 can be Outpath to exactly 14 color.",
            "NL": "There can be only 14 color Outpath to each node5. "
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every node5 Y can be NonInitial exaclty 28 In_HamiltonianCycle T.",
            "NL": "There is exactly 28 In_HamiltonianCycle T for every node5 Y that can be NonInitial."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every node7 can be a field3.",
            "NL": "It is possibe for every node7 to be part of a field3. "
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every node9 B can be Regular exaclty 32 Next I.",
            "NL": "There is exactly 32 Next I for every node9 B that can be Regular."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every node9 can be a edge4.",
            "NL": "It is possibe for every node9 to be part of a edge4. "
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every Outbound Z can be a Coloring.",
            "NL": " It is possible for every Outbound to be part of a Coloring."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every Prevailing X can be a Distinct.",
            "NL": " It is possible for every Prevailing to be part of a Distinct."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every Span N can be a Duo.",
            "NL": " It is possible for every Span to be part of a Duo."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every Spanning_Tree X can be a Complete.",
            "NL": " It is possible for every Spanning_Tree to be part of a Complete."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every value I can be Minimum_Cut exaclty 34 Matching W.",
            "NL": "There is exactly 34 Matching W for every value I that can be Minimum_Cut."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every value1 U can be Associated exaclty 20 Statistical_Significance K.",
            "NL": "There is exactly 20 Statistical_Significance K for every value1 U that can be Associated."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every value10 Z can be Complete exaclty 41 Directed_Graph R.",
            "NL": "There is exactly 41 Directed_Graph R for every value10 Z that can be Complete."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every value2 can be a key1.",
            "NL": "It is possibe for every value2 to be part of a key1. "
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every value2 can be InDegree to exactly 7 color.",
            "NL": "There can be only 7 color InDegree to each value2. "
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every value4 can be Entered to exactly 35 color.",
            "NL": "There can be only 35 color Entered to each value4. "
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every value4 can be Projection to exactly 19 color.",
            "NL": "There can be only 19 color Projection to each value4. "
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every value5 can be a id2.",
            "NL": "It is possibe for every value5 to be part of a id2. "
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every value7 can be Initiate to exactly 10 color.",
            "NL": "There can be only 10 color Initiate to each value7. "
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every value7 can be Parent to exactly 10 color.",
            "NL": "There can be only 10 color Parent to each value7. "
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every value7 O can be Ancestor exaclty 17 Offspring N.",
            "NL": "There is exactly 17 Offspring N for every value7 O that can be Ancestor."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every vtx3 can be a field1.",
            "NL": "It is possibe for every vtx3 to be part of a field1. "
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every vtx4 can be Compartment to exactly 37 color.",
            "NL": "There can be only 37 color Compartment to each vtx4. "
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every vtx4 can be Flow to exactly 35 color.",
            "NL": "There can be only 35 color Flow to each vtx4. "
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every vtx5 can be an edge7.",
            "NL": "It is possibe for every vtx5 to be part of a edge7. "
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every vtx5 can be an id10.",
            "NL": "It is possibe for every vtx5 to be part of a id10. "
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every vtx6 U can be Distinct exaclty 1 Disconnected O.",
            "NL": "There is exactly 1 Disconnected O for every vtx6 U that can be Distinct."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Arrowed K then we can have Inbound with field3 U, and with key3 K exactly 47 Line_Graph U.",
            "NL": "We can always has a Line_Graph with field3 U, and with key3 K exactly 47 Line_Graph U, whenever there is a field3 U."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Associated with id9 T, then we can have exactly 38 link with node5 Y, with vtx5 G such that there is a Layer with value7 Y, with node2 U, or a Attained with node5 Y, with vtx5 G such that there is an Layer with value7 T, with id10 Y.",
            "NL": "We can have exactly 38 Attained nodes with node5 Y, with vtx5 G such that there is a Layer with value7 T, with id10 Y, or a Attained node with node5 Y, with vtx5 G such that there is a Layer with value7 T, with id10 Y whenever there is an Associated node with id9 T."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Base with value9 S, and with value1 Z, whenever there is an Inspect with value9 S, and with value1 Z, whenever there is not a Directed with layer value1 S, and with value9 I, then we can have at least 18 Isomorphism with edge5 S, and with value7 Z, and with key2 I.",
            "NL": "As long as there is a Base with value9 S, and there is an Inspect with value9 S, and with value1 Z, there is no Directed with layer value1 S, and with value9 I, then we can have at least 18 Isomorphism with edge5 S, and with value7 Z, and with key2 I. "
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Basic R then we can have Punishment with node1 Y, and with node3 R exactly 43 Adjacency_Matrix Y.",
            "NL": "We can always has an Adjacency_Matrix with node1 Y, and with node3 R exactly 43 Adjacency_Matrix Y, whenever there is a node1 Y."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Bipartite_Graph K, then we can have exactly 10 Influential with edge2 K, and with vtx10 E such that there is a Denied E.",
            "NL": "We can always has an Influential with edge2 K and vtx10 E exactly 10 Denied E, whenever there is a Bipartite_Graph K."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Breadth with value equal to 45 then we can have at least 1 Ordered with id4 C such that there is an Alpha_Value with vtx2 Cor a Ordered with id4 N such that there is an Alpha_Value with value7 N.",
            "NL": "When a Breadth has a value of 45, we can have at least 1 Ordered with id4 C such that there is an Alpha_Value with vtx2 C or a Ordered with id4 N such that there is an Alpha_Value with value7 N."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Calculation with id8 F, whenever there is a Unmatched with id8 Y, then we can have between 32 and Y Sorted with id8 N, and with id K such that there is a Capacity U.",
            "NL": "We can always has a Sorted with id8 N and id8 F ranging between 32 and Y with Capacity N, whenever we have Calculation F and Unmatched Y. "
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Cell M then we can have Subsequent with value6 A, and with id1 M exactly 32 Weight A.",
            "NL": "We can always has a Weight with value6 A, and with id1 M exactly 32 Weight A, whenever there is a value6 A."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Centrality Q, then we can have exactly 20 Triumph with node10 Q, and with id1 H such that there is a Difference H.",
            "NL": "We can always has a Triumph with node10 Q and id1 H exactly 20 Difference H, whenever there is a Centrality Q."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Child B, then we can have exactly 6 Non_Clique with node1 B, and with node Y such that there is a Probability_Value Y.",
            "NL": "We can always has a Non_Clique with node1 B and node Y exactly 6 Probability_Value Y, whenever there is a Child B."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Chromatic_Number G, then we can have exactly 20 Simple with field G, and with value9 R such that there is a Complete_Graph R.",
            "NL": "We can always has a Simple with field G and value9 R exactly 20 Complete_Graph R, whenever there is a Chromatic_Number G."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Complete S then we can have Reckoning with key10 P, and with value5 S exactly 22 Second P.",
            "NL": "We can always has a Second with key10 P, and with value5 S exactly 22 Second P, whenever there is a key10 P."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Complete_Graph G then we can have Inputted with id5 C, with id5 G exactly 1 Connected with id5 C, with id5 G.",
            "NL": "It is possible to have Inputted with id5 C, with id5 G exactly 1 Connected with id5 C, with id5 G whenever there is a Complete_Graph G."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Cross with value equal to 47 then we can have at least 43 Cliquesize with node8 D such that there is a Cut with node2 Dor a Cliquesize with node8 S such that there is a Cut with edge8 S.",
            "NL": "When a Cross has a value of 47, we can have at least 43 Cliquesize with node8 D such that there is a Cut with node2 D or a Cliquesize with node8 S such that there is a Cut with edge8 S."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Degree_Sequence with value equal to 29 then we can have at least 26 Project with field10 A such that there is a Depth_Vertex with edge7 Aor a Project with field10 Q such that there is a Depth_Vertex with id10 Q.",
            "NL": "When a Degree_Sequence has a value of 29, we can have at least 26 Project with field10 A such that there is a Depth_Vertex with edge7 A or a Project with field10 Q such that there is a Depth_Vertex with id10 Q."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Dendrogram P then we can have Unvalued with key7 O, with key7 P exactly 1 Notnext with key7 O, with key7 P.",
            "NL": "It is possible to have Unvalued with key7 O, with key7 P exactly 1 Notnext with key7 O, with key7 P whenever there is a Dendrogram P."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Diagram with value equal to 13 then we can have at least 32 Visit with edge3 V such that there is an Unvalued with field8 Vor a Visit with edge3 D such that there is an Unvalued with field9 D.",
            "NL": "When a Diagram has a value of 13, we can have at least 32 Visit with edge3 V such that there is an Unvalued with field8 V or a Visit with edge3 D such that there is an Unvalued with field9 D."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Diameter W, then we can have exactly 31 Graph with field4 W, and with id4 T such that there is a Pointer T.",
            "NL": "We can always has a Graph with field4 W and id4 T exactly 31 Pointer T, whenever there is a Diameter W."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Difference with value L greater than 1, with id U, then we can have exactly 1 Alpha_Value with fake value P, with third point I such that there is a Difference with fake value P, with third point I, or a Alpha_Value with fake value P, with third point I such that there is an Difference with fake value I, with third point P.",
            "NL": "Whenever a Difference has a value L greater than 1, with id U, we can have exactly one Alpha_Value with fake value P, third point I, such that there is a Difference with fake value P, third point I, or a Alpha_Value with fake value P, with third point I, such that there is a Difference with fake value I, with third point P. "
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Distinct H then we can have Walk with value3 J, and with key3 H exactly 39 In J.",
            "NL": "We can always has an In with value3 J, and with key3 H exactly 39 In J, whenever there is a value3 J."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Distinct with value equal to 28 then we can have at least 31 Commence with node D such that there is a Less with field10 Dor a Commence with node S such that there is a Less with edge1 S.",
            "NL": "When a Distinct has a value of 28, we can have at least 31 Commence with node D such that there is a Less with field10 D or a Commence with node S such that there is a Less with edge1 S."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Dyed G then we can have NotFirst with vtx4 U, with vtx4 G exactly 1 Tree with vtx4 U, with vtx4 G.",
            "NL": "It is possible to have NotFirst with vtx4 U, with vtx4 G exactly 1 Tree with vtx4 U, with vtx4 G whenever there is a Dyed G."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Dyed O then we can have Spanning_Tree with vtx7 B, with vtx7 O exactly 1 Arc with vtx7 B, with vtx7 O.",
            "NL": "It is possible to have Spanning_Tree with vtx7 B, with vtx7 O exactly 1 Arc with vtx7 B, with vtx7 O whenever there is a Dyed O."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Edge with field10 A, and with value4 B, whenever there is an Tag with field10 A, and with value4 B, whenever there is not a NonInitial with layer value4 A, and with field10 Q, then we can have at least 15 Punishment with value8 A, and with node10 B, and with node7 Q.",
            "NL": "As long as there is an Edge with field10 A, and there is a Tag with field10 A, and with value4 B, there is no NonInitial with layer value4 A, and with field10 Q, then we can have at least 15 Punishment with value8 A, and with node10 B, and with node7 Q. "
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Edge_Label O then we can have Arrived with id2 E, with id2 O exactly 1 Valency with id2 E, with id2 O.",
            "NL": "It is possible to have Arrived with id2 E, with id2 O exactly 1 Valency with id2 E, with id2 O whenever there is an Edge_Label O."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Face with id7 Q, then we can have exactly 28 link with edge2 J, with edge6 U such that there is a Symbol with key7 J, with node2 U, or a Tally with edge2 J, with edge6 U such that there is an Symbol with key7 Q, with value3 J.",
            "NL": "We can have exactly 28 Tally nodes with edge2 J, with edge6 U such that there is a Symbol with key7 Q, with value3 J, or a Tally node with edge2 J, with edge6 U such that there is a Symbol with key7 Q, with value3 J whenever there is a Face node with id7 Q."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Flow_Network with value L greater than 1, with id U, then we can have exactly 1 Succeeding with third id L, with third vertex X such that there is a Flow_Network with third id L, with third vertex X, or a Succeeding with third id L, with third vertex X such that there is a Flow_Network with third id X, with third vertex L.",
            "NL": "Whenever a Flow_Network has a value L greater than 1, with id U, we can have exactly one Succeeding with third id L, third vertex X, such that there is a Flow_Network with third id L, third vertex X, or a Succeeding with third id L, with third vertex X, such that there is a Flow_Network with third id X, with third vertex L. "
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Following A, then we can have exactly 12 Probability_Value with node8 A, and with vtx2 J such that there is an Initial J.",
            "NL": "We can always has a Probability_Value with node8 A and vtx2 J exactly 12 Initial J, whenever there is a Following A."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Heaviness F then we can have Difference with id5 R, with id5 F exactly 1 Augmenting_Path with id5 R, with id5 F.",
            "NL": "It is possible to have Difference with id5 R, with id5 F exactly 1 Augmenting_Path with id5 R, with id5 F whenever there is a Heaviness F."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Hint U, then we can have exactly 21 Dormant with value7 U, and with edge Y such that there is a Short Y.",
            "NL": "We can always has a Dormant with value7 U and edge Y exactly 21 Short Y, whenever there is a Hint U."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a In_HamiltonianCycle K then we can have Edge with vtx4 Q, with vtx4 K exactly 1 Ending with vtx4 Q, with vtx4 K.",
            "NL": "It is possible to have Edge with vtx4 Q, with vtx4 K exactly 1 Ending with vtx4 Q, with vtx4 K whenever there is an In_HamiltonianCycle K."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Incidence_Matrix with value L greater than 1, with id U, then we can have exactly 1 Cliquesize with third point J, with fourth id D such that there is a Incidence_Matrix with third point J, with fourth id D, or a Cliquesize with third point J, with fourth id D such that there is an Incidence_Matrix with third point D, with fourth id J.",
            "NL": "Whenever a Incidence_Matrix has a value L greater than 1, with id U, we can have exactly one Cliquesize with third point J, fourth id D, such that there is an Incidence_Matrix with third point J, fourth id D, or a Cliquesize with third point J, with fourth id D, such that there is an Incidence_Matrix with third point D, with fourth id J. "
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Indication with edge O, whenever there is a Refused with edge A, then we can have between 2 and A Clique with edge G, and with id K such that there is an Out_Hamiltonian_Tour U.",
            "NL": "We can always has a Clique with edge G and edge O ranging between 2 and A with Out_Hamiltonian_Tour G, whenever we have Indication O and Refused A. "
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Jailed with field10 L, whenever there is a Selected_Color with field10 B, then we can have between 10 and B Eulerian_Path with field10 X, and with id K such that there is a Hue U.",
            "NL": "We can always has an Eulerian_Path with field10 X and field10 L ranging between 10 and B with Hue X, whenever we have Jailed L and Selected_Color B. "
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Last Y then we can have Maximum_Matching with key2 N, with key2 Y exactly 1 Engaged with key2 N, with key2 Y.",
            "NL": "It is possible to have Maximum_Matching with key2 N, with key2 Y exactly 1 Engaged with key2 N, with key2 Y whenever there is a Last Y."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Lead S, then we can have exactly 37 Check with vtx4 S, and with vtx6 K such that there is an In_Hamiltonian K.",
            "NL": "We can always has a Check with vtx4 S and vtx6 K exactly 37 In_Hamiltonian K, whenever there is a Lead S."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Less with edge7 I, and with node5 E, whenever there is an Project with edge7 I, and with node5 E, whenever there is not a Planar with layer node5 I, and with edge7 G, then we can have at least 11 Unlabeled with field I, and with value E, and with node9 G.",
            "NL": "As long as there is a Less with edge7 I, and there is a Project with edge7 I, and with node5 E, there is no Planar with layer node5 I, and with edge7 G, then we can have at least 11 Unlabeled with field I, and with value E, and with node9 G. "
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a LessThanExists with node1 G, and with id7 O, whenever there is a Statistical_Significance with node1 G, and with id7 O, whenever there is not a Triad with layer id7 G, and with node1 H, then we can have at least 28 Span with field9 G, and with edge4 O, and with id4 H.",
            "NL": "As long as there is a LessThanExists with node1 G, and there is a Statistical_Significance with node1 G, and with id7 O, there is no Triad with layer id7 G, and with node1 H, then we can have at least 28 Span with field9 G, and with edge4 O, and with id4 H. "
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Level_Vertex with id1 A, whenever there is a Tone with id1 M, then we can have between 47 and M NonGrouping with id1 R, and with id K such that there is a Triple U.",
            "NL": "We can always has a NonGrouping with id1 R and id1 A ranging between 47 and M with Triple R, whenever we have Level_Vertex A and Tone M. "
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a List T then we can have Attained with key2 G, and with value3 T exactly 49 Used_Edge G.",
            "NL": "We can always has an Used_Edge with key2 G, and with value3 T exactly 49 Used_Edge G, whenever there is a key2 G."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Location with node2 A, whenever there is a Spanning_Tree with node2 X, then we can have between 10 and X InDegree with node2 M, and with id K such that there is a Edge_Layer U.",
            "NL": "We can always has an InDegree with node2 M and node2 A ranging between 10 and X with Edge_Layer M, whenever we have Location A and Spanning_Tree X. "
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Mark Q then we can have Sole with vtx9 S, and with node8 Q exactly 1 Ultimate S.",
            "NL": "We can always has an Ultimate with vtx9 S, and with node8 Q exactly 1 Ultimate S, whenever there is a vtx9 S."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Matching V then we can have Oriented with key4 W, with key4 V exactly 1 NonInitial with key4 W, with key4 V.",
            "NL": "It is possible to have Oriented with key4 W, with key4 V exactly 1 NonInitial with key4 W, with key4 V whenever there is a Matching V."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Minus Q then we can have Thickness with field5 N, and with node4 Q exactly 1 Chromatic_Number N.",
            "NL": "We can always has a Chromatic_Number with field5 N, and with node4 Q exactly 1 Chromatic_Number N, whenever there is a field5 N."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a NonActive with id S, then we can have exactly 36 link with field2 U, with edge2 H such that there is a Lone with field10 U, with node2 U, or a Degree_Sequence with field2 U, with edge2 H such that there is an Lone with field10 S, with value8 U.",
            "NL": "We can have exactly 36 Degree_Sequence nodes with field2 U, with edge2 H such that there is a Lone with field10 S, with value8 U, or a Degree_Sequence node with field2 U, with edge2 H such that there is a Lone with field10 S, with value8 U whenever there is a NonActive node with id S."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a NonClustering with value equal to 4 then we can have at least 7 Maximum with id E such that there is an Position with edge Eor a Maximum with id O such that there is an Position with id1 O.",
            "NL": "When a NonClustering has a value of 4, we can have at least 7 Maximum with id E such that there is a Position with edge E or a Maximum with id O such that there is a Position with id1 O."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a NonCohesive with node4 M, then we can have exactly 2 link with node5 H, with field2 A such that there is a Punishment with value1 H, with node2 U, or a Flow_Network with node5 H, with field2 A such that there is a Punishment with value1 M, with value3 H.",
            "NL": "We can have exactly 2 Flow_Network nodes with node5 H, with field2 A such that there is a Punishment with value1 M, with value3 H, or a Flow_Network node with node5 H, with field2 A such that there is a Punishment with value1 M, with value3 H whenever there is a NonCohesive node with node4 M."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a NonForemost with value2 C, then we can have exactly 6 link with edge4 E, with field4 G such that there is a Degree with value E, with node2 U, or a Shaded with edge4 E, with field4 G such that there is a Degree with value C, with vtx1 E.",
            "NL": "We can have exactly 6 Shaded nodes with edge4 E, with field4 G such that there is a Degree with value C, with vtx1 E, or a Shaded node with edge4 E, with field4 G such that there is a Degree with value C, with vtx1 E whenever there is a NonForemost node with value2 C."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a NonPlanar C then we can have List with vtx8 B, with vtx8 C exactly 1 Lone with vtx8 B, with vtx8 C.",
            "NL": "It is possible to have List with vtx8 B, with vtx8 C exactly 1 Lone with vtx8 B, with vtx8 C whenever there is a NonPlanar C."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Offspring with value equal to 11 then we can have at least 23 Irrelevant with key1 G such that there is an Accomplishment with id7 Gor a Irrelevant with key1 C such that there is an Accomplishment with field8 C.",
            "NL": "When a Offspring has a value of 11, we can have at least 23 Irrelevant with key1 G such that there is an Accomplishment with id7 G or a Irrelevant with key1 C such that there is an Accomplishment with field8 C."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a OutDegree with edge3 N, whenever there is a NonCohesive with edge3 P, then we can have between 26 and P Includes with edge3 Z, and with id K such that there is an Employed_Edge U.",
            "NL": "We can always has an Includes with edge3 Z and edge3 N ranging between 26 and P with Employed_Edge Z, whenever we have OutDegree N and NonCohesive P. "
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Parent with field10 F, whenever there is a Punishment with field10 U, then we can have between 37 and U Start with field10 N, and with id K such that there is a Partition U.",
            "NL": "We can always has a Start with field10 N and field10 F ranging between 37 and U with Partition N, whenever we have Parent F and Punishment U. "
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Particle O then we can have Residual_Graph with field10 A, and with field7 O exactly 6 OutgoingPath A.",
            "NL": "We can always has an OutgoingPath with field10 A, and with field7 O exactly 6 OutgoingPath A, whenever there is a field10 A."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Perfect_Graph with value equal to 8 then we can have at least 32 Gravity with key7 H such that there is an Used_Edge with field3 Hor a Gravity with key7 X such that there is an Used_Edge with id3 X.",
            "NL": "When a Perfect_Graph has a value of 8, we can have at least 32 Gravity with key7 H such that there is an Used_Edge with field3 H or a Gravity with key7 X such that there is an Used_Edge with id3 X."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Predominant U, then we can have exactly 38 Capacity with node7 U, and with field1 X such that there is a Singleton X.",
            "NL": "We can always has a Capacity with node7 U and field1 X exactly 38 Singleton X, whenever there is a Predominant U."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Predominant V then we can have Complex with id2 K, and with value10 V exactly 21 Path K.",
            "NL": "We can always has a Path with id2 K, and with value10 V exactly 21 Path K, whenever there is an id2 K."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Punishment K then we can have Extra with vtx2 P, and with id7 K exactly 3 Incidence_Matrix P.",
            "NL": "We can always has an Incidence_Matrix with vtx2 P, and with id7 K exactly 3 Incidence_Matrix P, whenever there is a vtx2 P."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Punishment Q, then we can have exactly 23 Arc_Label with value7 Q, and with field5 M such that there is a Start M.",
            "NL": "We can always has an Arc_Label with value7 Q and field5 M exactly 23 Start M, whenever there is a Punishment Q."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Punishment with value equal to 38 then we can have at least 5 Member with vtx1 L such that there is a Painted with field1 Lor a Member with vtx1 Q such that there is a Painted with vtx7 Q.",
            "NL": "When a Punishment has a value of 38, we can have at least 5 Member with vtx1 L such that there is a Painted with field1 L or a Member with vtx1 Q such that there is a Painted with vtx7 Q."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Regular with edge4 N, whenever there is a Full with edge4 F, then we can have between 31 and F Arc_Label with edge4 T, and with id K such that there is a Investigate U.",
            "NL": "We can always has an Arc_Label with edge4 T and edge4 N ranging between 31 and F with Investigate T, whenever we have Regular N and Full F. "
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Relevant with key10 L, and with id1 V, whenever there is an Simple with key10 L, and with id1 V, whenever there is not a Match with layer id1 L, and with key10 R, then we can have at least 3 Minimum_Vertex_Cover with field6 L, and with value10 V, and with node1 R.",
            "NL": "As long as there is a Relevant with key10 L, and there is a Simple with key10 L, and with id1 V, there is no Match with layer id1 L, and with key10 R, then we can have at least 3 Minimum_Vertex_Cover with field6 L, and with value10 V, and with node1 R. "
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Sanction O, then we can have exactly 24 Out_Hamiltonian_Tour with field8 O, and with vtx7 F such that there is a Reached F.",
            "NL": "We can always has an Out_Hamiltonian_Tour with field8 O and vtx7 F exactly 24 Reached F, whenever there is a Sanction O."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Sequence W, then we can have exactly 1 Colored with id10 W, and with vtx N such that there is a Flow_Network N.",
            "NL": "We can always has a Colored with id10 W and vtx N exactly 1 Flow_Network N, whenever there is a Sequence W."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Shaded U, then we can have exactly 33 Load with vtx3 U, and with vtx4 V such that there is an Idle V.",
            "NL": "We can always has a Load with vtx3 U and vtx4 V exactly 33 Idle V, whenever there is a Shaded U."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Simple E then we can have Twosome with id7 T, with id7 E exactly 1 Parent_Edge with id7 T, with id7 E.",
            "NL": "It is possible to have Twosome with id7 T, with id7 E exactly 1 Parent_Edge with id7 T, with id7 E whenever there is a Simple E."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Singleton with field4 J, and with vtx8 Y, whenever there is an Twosome with field4 J, and with vtx8 Y, whenever there is not a Cross with layer vtx8 J, and with field4 E, then we can have at least 44 Diversity with value9 J, and with value5 Y, and with field1 E.",
            "NL": "As long as there is a Singleton with field4 J, and there is a Twosome with field4 J, and with vtx8 Y, there is no Cross with layer vtx8 J, and with field4 E, then we can have at least 44 Diversity with value9 J, and with value5 Y, and with field1 E. "
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Sole with value equal to 45 then we can have at least 41 Caught with vtx5 B such that there is an Insignificant with edge9 Bor a Caught with vtx5 C such that there is an Insignificant with key C.",
            "NL": "When a Sole has a value of 45, we can have at least 41 Caught with vtx5 B such that there is an Insignificant with edge9 B or a Caught with vtx5 C such that there is an Insignificant with key C."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Sorted with id8 M, then we can have exactly 38 link with vtx3 O, with edge7 Q such that there is a Outgroup with value6 O, with node2 U, or a Distinct with vtx3 O, with edge7 Q such that there is an Outgroup with value6 M, with vtx2 O.",
            "NL": "We can have exactly 38 Distinct nodes with vtx3 O, with edge7 Q such that there is an Outgroup with value6 M, with vtx2 O, or a Distinct node with vtx3 O, with edge7 Q such that there is an Outgroup with value6 M, with vtx2 O whenever there is a Sorted node with id8 M."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Statistical_Significance S, then we can have exactly 33 Undirected with node3 S, and with value I such that there is a Bucket I.",
            "NL": "We can always has an Undirected with node3 S and value I exactly 33 Bucket I, whenever there is a Statistical_Significance S."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Statistical_Significance with id4 P, whenever there is a Tinted with id4 O, then we can have between 25 and O Used_Edge with id4 N, and with id K such that there is a Secondary U.",
            "NL": "We can always has an Used_Edge with id4 N and id4 P ranging between 25 and O with Secondary N, whenever we have Statistical_Significance P and Tinted O. "
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Sub_Index with key9 Z, then we can have exactly 22 link with id5 N, with value5 J such that there is a Succeeding with field10 N, with node2 U, or a Reference with id5 N, with value5 J such that there is an Succeeding with field10 Z, with key3 N.",
            "NL": "We can have exactly 22 Reference nodes with id5 N, with value5 J such that there is a Succeeding with field10 Z, with key3 N, or a Reference node with id5 N, with value5 J such that there is a Succeeding with field10 Z, with key3 N whenever there is a Sub_Index node with key9 Z."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Subsequently with value equal to 16 then we can have at least 9 Begin with value4 W such that there is a Weight with node4 Wor a Begin with value4 K such that there is a Weight with node7 K.",
            "NL": "When a Subsequently has a value of 16, we can have at least 9 Begin with value4 W such that there is a Weight with node4 W or a Begin with value4 K such that there is a Weight with node7 K."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Tag I then we can have Enumeration with key5 V, with key5 I exactly 1 Has with key5 V, with key5 I.",
            "NL": "It is possible to have Enumeration with key5 V, with key5 I exactly 1 Has with key5 V, with key5 I whenever there is a Tag I."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Tint with value L greater than 1, with id U, then we can have exactly 1 Full with first id X, with first point C such that there is a Tint with first id X, with first point C, or a Full with first id X, with first point C such that there is a Tint with first id C, with first point X.",
            "NL": "Whenever a Tint has a value L greater than 1, with id U, we can have exactly one Full with first id X, first point C, such that there is a Tint with first id X, first point C, or a Full with first id X, with first point C, such that there is a Tint with first id C, with first point X. "
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Trapped with id7 Q, whenever there is a Difference with id7 A, then we can have between 39 and A Sanction with id7 C, and with id K such that there is a Cell U.",
            "NL": "We can always has a Sanction with id7 C and id7 Q ranging between 39 and A with Cell C, whenever we have Trapped Q and Difference A. "
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Trapped with value L greater than 1, with id U, then we can have exactly 1 Index with first point X, with fourth id F such that there is a Trapped with first point X, with fourth id F, or a Index with first point X, with fourth id F such that there is an Trapped with first point F, with fourth id X.",
            "NL": "Whenever a Trapped has a value L greater than 1, with id U, we can have exactly one Index with first point X, fourth id F, such that there is a Trapped with first point X, fourth id F, or a Index with first point X, with fourth id F, such that there is a Trapped with first point F, with fourth id X. "
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Triple with id3 E, and with node9 N, whenever there is a Colored with id3 E, and with node9 N, whenever there is not a Later with layer node9 E, and with id3 C, then we can have at least 46 Weight with id9 E, and with edge2 N, and with id10 C.",
            "NL": "As long as there is a Triple with id3 E, and there is a Colored with id3 E, and with node9 N, there is no Later with layer node9 E, and with id3 C, then we can have at least 46 Weight with id9 E, and with edge2 N, and with id10 C. "
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Triplet W then we can have Radius with vtx L, and with node8 W exactly 26 Predominant L.",
            "NL": "We can always has a Predominant with vtx L, and with node8 W exactly 26 Predominant L, whenever there is a vtx L."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Triumph with value5 E, and with edge10 H, whenever there is an Mark with value5 E, and with edge10 H, whenever there is not a Directed_Graph with layer edge10 E, and with value5 I, then we can have at least 43 Distinct with key9 E, and with value4 H, and with id3 I.",
            "NL": "As long as there is a Triumph with value5 E, and there is a Mark with value5 E, and with edge10 H, there is no Directed_Graph with layer edge10 E, and with value5 I, then we can have at least 43 Distinct with key9 E, and with value4 H, and with id3 I. "
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Trivial with node4 Y, whenever there is a Color with node4 V, then we can have between 35 and V Controlling with node4 D, and with id K such that there is an Undirected_Graph U.",
            "NL": "We can always has a Controlling with node4 D and node4 Y ranging between 35 and V with Undirected_Graph D, whenever we have Trivial Y and Color V. "
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Ultimate with vtx10 S, whenever there is a Perfect_Graph with vtx10 O, then we can have between 28 and O Dominant with vtx10 F, and with id K such that there is a Source_Data U.",
            "NL": "We can always has a Dominant with vtx10 F and vtx10 S ranging between 28 and O with Source_Data F, whenever we have Ultimate S and Perfect_Graph O. "
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Unimportant with edge10 N, and with id10 Z, whenever there is a Diagram with edge10 N, and with id10 Z, whenever there is not a In_Hamiltonian with layer id10 N, and with edge10 D, then we can have at least 27 Order with field N, and with edge1 Z, and with value9 D.",
            "NL": "As long as there is an Unimportant with edge10 N, and there is a Diagram with edge10 N, and with id10 Z, there is no In_Hamiltonian with layer id10 N, and with edge10 D, then we can have at least 27 Order with field N, and with edge1 Z, and with value9 D. "
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Valency L, then we can have exactly 44 Attained with value8 L, and with vtx2 S such that there is a Idle S.",
            "NL": "We can always has an Attained with value8 L and vtx2 S exactly 44 Idle S, whenever there is a Valency L."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Valency with value equal to 46 then we can have at least 22 Trapped with key7 B such that there is an Irrelevant with node1 Bor a Trapped with key7 E such that there is an Irrelevant with edge8 E.",
            "NL": "When a Valency has a value of 46, we can have at least 22 Trapped with key7 B such that there is an Irrelevant with node1 B or a Trapped with key7 E such that there is an Irrelevant with edge8 E."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Weighted with value equal to 43 then we can have at least 36 Variation with vtx B such that there is a Subsequent with key7 Bor a Variation with vtx F such that there is a Subsequent with edge8 F.",
            "NL": "When a Weighted has a value of 43, we can have at least 36 Variation with vtx B such that there is a Subsequent with key7 B or a Variation with vtx F such that there is a Subsequent with edge8 F."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is an Active Q then we can have Node with vtx8 D, and with node10 Q exactly 42 Sign D.",
            "NL": "We can always has a Sign with vtx8 D, and with node10 Q exactly 42 Sign D, whenever there is a vtx8 D."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is an Arc with edge3 W, whenever there is a Primary with edge3 L, then we can have between 45 and L Distinct with edge3 J, and with id K such that there is an In U.",
            "NL": "We can always has a Distinct with edge3 J and edge3 W ranging between 45 and L with In J, whenever we have Arc W and Primary L. "
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is an Arrowed with value L greater than 1, with id U, then we can have exactly 1 Hamgraph with second node A, with first vertex J such that there is an Arrowed with second node A, with first vertex J, or a Hamgraph with second node A, with first vertex J such that there is an Arrowed with second node J, with first vertex A.",
            "NL": "Whenever a Arrowed has a value L greater than 1, with id U, we can have exactly one Hamgraph with second node A, first vertex J, such that there is an Arrowed with second node A, first vertex J, or a Hamgraph with second node A, with first vertex J, such that there is an Arrowed with second node J, with first vertex A. "
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is an Attained with id1 U, whenever there is a Flow_Network with id1 W, then we can have between 17 and W Module with id1 P, and with id K such that there is a Participating U.",
            "NL": "We can always has a Module with id1 P and id1 U ranging between 17 and W with Participating P, whenever we have Attained U and Flow_Network W. "
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is an Attained with node10 S, whenever there is a Label with node10 X, then we can have between 2 and X Dormant with node10 W, and with id K such that there is a Tally U.",
            "NL": "We can always has a Dormant with node10 W and node10 S ranging between 2 and X with Tally W, whenever we have Attained S and Label X. "
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is an Identifier with field6 S, then we can have exactly 11 link with edge4 N, with key5 X such that there is a Caught with field8 N, with node2 U, or a Out_HamiltonianCycle with edge4 N, with key5 X such that there is a Caught with field8 S, with field3 N.",
            "NL": "We can have exactly 11 Out_HamiltonianCycle nodes with edge4 N, with key5 X such that there is a Caught with field8 S, with field3 N, or a Out_HamiltonianCycle node with edge4 N, with key5 X such that there is a Caught with field8 S, with field3 N whenever there is an Identifier node with field6 S."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is an Inactive with value equal to 27 then we can have at least 2 Clue with edge2 W such that there is a Three_Nodes with vtx4 Wor a Clue with edge2 Q such that there is a Three_Nodes with value2 Q.",
            "NL": "When a Inactive has a value of 27, we can have at least 2 Clue with edge2 W such that there is a Three_Nodes with vtx4 W or a Clue with edge2 Q such that there is a Three_Nodes with value2 Q."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is an Includes with key9 G, whenever there is a Calculation with key9 L, then we can have between 29 and L Outgroup with key9 M, and with id K such that there is an Outpath U.",
            "NL": "We can always has an Outgroup with key9 M and key9 G ranging between 29 and L with Outpath M, whenever we have Includes G and Calculation L. "
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is an InDegree T, then we can have exactly 19 Offspring with field T, and with edge F such that there is a Width F.",
            "NL": "We can always has an Offspring with field T and edge F exactly 19 Width F, whenever there is an InDegree T."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is an Independent_Set with node9 X, and with vtx5 G, whenever there is a Centrality with node9 X, and with vtx5 G, whenever there is not a Indication with layer vtx5 X, and with node9 T, then we can have at least 7 Unconnected with value3 X, and with value6 G, and with field4 T.",
            "NL": "As long as there is an Independent_Set with node9 X, and there is a Centrality with node9 X, and with vtx5 G, there is no Indication with layer vtx5 X, and with node9 T, then we can have at least 7 Unconnected with value3 X, and with value6 G, and with field4 T. "
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is an Unweighted P, then we can have exactly 16 Degree_Sequence with node3 P, and with id5 X such that there is a Eulerian_Path X.",
            "NL": "We can always has a Degree_Sequence with node3 P and id5 X exactly 16 Eulerian_Path X, whenever there is an Unweighted P."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every node can be a clique.",
            "NL": "It is possible for every node to be part of a clique."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every node can be assigned to exactly 1 color.",
            "NL": "There can be only one color assigned to each node."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every vtx U can be a dom.",
            "NL": "It is possible for every vertex to be part of a dom."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every vtx U can be partition exactly 1 part K.",
            "NL": "There is exactly one part K for every vertex U that can be partitioned."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a body with value equal to 1 then we can have at least 0 linked with value V such that there is an edge with node1 V or a linked with value U such that there is an edge with node2 U. ",
            "NL": "When a body has a value of 1, we can have at least 0 linked with value V such that there is an edge with node V or a linked with value U such that there is an edge with node U."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a levelvtx with value L greater than 1, with id U, then we can have exactly 1 parentedge with first id P, with second id U such that there is a uedge with first id P, with second id U, or a parentedge with first id P, with second id U such that there is an uedge with first id U, with second id P. ",
            "NL": "Whenever a levelvtx has a value L greater than 1, with id U, we can have exactly one parentedge with first id P, second id U, such that there is an uedge with first id P, second id U, or a parentedge with first id P, with second id U, such that there is an uedge with first id U, with second id P. "
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a linked with value L, then we can have exactly 2 link with id1 P, with id2 U such that there is a edge with node1 P, with node2 U, or a link with id1 P, with id2 U such that there is an edge with node1 U, with node2 P.",
            "NL": "We can have exactly two link nodes with id1 P, with id2 U such that there is an edge with node1 U, with node2 P, or a link node with id1 P, with id2 U such that there is an edge with node1 U, with node2 P whenever there is a linked node with value L."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a part K, whenever there is a vtxbound with value V, then we can have between 1 and V partition with value U, and with id K such that there is a vtx U.",
            "NL": "We can always has a partition with value U and value K ranging between 1 and V with vertex U, whenever we have parts K and vertex bound V."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a part with value K, whenever there is a vtxbound with value V, then we can have between 1 and V partition with value U, and with id K such that there is a vtx U. ",
            "NL": "We can always has a partition with value U and value K ranging between 1 and V with vertex U, whenever we have parts K and vtxbound V."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a pvalue with value L, and with id P, whenever there is an in_layer with value L, and with id N, whenever there is not a width with layer id L, and with value P, then we can have at least 0 gt with id1 L, and with id2 N, and with id3 P. ",
            "NL": "As long as there is a pvalue with value L, and there is an in_layer with value L, and with id N, there is no width with layer id L, and with value P, then we can have at least 0 GT with id1 L, and with id2 N, and with id3 P."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a var X then we can have in with value C, with id X exactly 1 pair with value C, with id X.",
            "NL": "It is possible to have IN with value C, with id X exactly 1 pair with value C, with id X whenever there is a var X."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a vtx U then we can have levelvtx with value L, and with id U exactly 1 level L. ",
            "NL": "We can always has a level vertex with value L, and with id U exactly 1 level L, whenever there is a vertex U."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a vtx U, then we can have exactly 1 partition with value U, and with id K such that there is a part K.",
            "NL": "We can always has a partition with value U and id K exactly 1 part K, whenever there is a vertex U."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every Afterward F can be a IncomingPath.",
            "NL": "Every Afterward can be included in an IncomingPath."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every Afterward F can be a IncomingPath.",
            "NL": "Every Afterward can join an IncomingPath."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every Afterward F can be a IncomingPath.",
            "NL": "Each Afterward can be a component of an IncomingPath."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every Afterward F can be a IncomingPath.",
            "NL": "Every Afterward can be part of an IncomingPath."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every Afterward F can be a IncomingPath.",
            "NL": "Every Afterward has the potential to be part of an IncomingPath."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every Breadth E can be an Information.",
            "NL": "Every Breadth could potentially be included in an Information."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every Breadth E can be an Information.",
            "NL": "Every Breadth can be part of an Information."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every Breadth E can be an Information.",
            "NL": "Every Breadth can be included in an Information."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every Breadth E can be an Information.",
            "NL": "Every Breadth can potentially be included in an Information."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every Breadth E can be an Information.",
            "NL": "Every Breadth can be incorporated into Information."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every edge10 can be a node.",
            "NL": "Every edge10 can be part of a node."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every edge10 can be a node.",
            "NL": "Every edge10 can be a part of a node."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every edge10 can be a node.",
            "NL": "Every edge10 can be incorporated into a node."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every edge10 can be a node.",
            "NL": "Every edge10 has the potential to be part of a node."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every edge10 can be a node.",
            "NL": "Every edge10 can be included in a node."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every edge10 can be Match to exactly 47 color.",
            "NL": "For each edge, there can only be a maximum of 47 colors."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every edge10 can be Match to exactly 47 color.",
            "NL": "There can only be 47 colors that match each edge10."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every edge10 can be Match to exactly 47 color.",
            "NL": "There can be a maximum of 47 colors matched to each edge10."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every edge10 can be Match to exactly 47 color.",
            "NL": "There can be only 47 matches of color to each edge10."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every edge10 can be Match to exactly 47 color.",
            "NL": "There can be a maximum of 47 colors matching to each edge10."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every Explore O can be an Edge.",
            "NL": "Every Edge has the potential for every Explore to be part of it."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every Explore O can be an Edge.",
            "NL": "Every Explore has the potential to be part of an Edge."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every Explore O can be an Edge.",
            "NL": "Every Explore has the potential to be part of a Edge."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every Explore O can be an Edge.",
            "NL": "Every Explore has the potential to be a part of an Edge."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every Explore O can be an Edge.",
            "NL": "Every Explore has the potential to join an Edge."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every field can be a field3.",
            "NL": "Every field has the potential to be part of a field3."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every field can be a field3.",
            "NL": "Every field has the potential to become part of a field3."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every field can be a field3.",
            "NL": "Every field has the potential to be a part of field3."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every field can be a field3.",
            "NL": "Every field has the potential to be part of field3."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every field can be a field3.",
            "NL": "Every field can be part of a field3."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every field can be Pigmented to exactly 4 color.",
            "NL": "Only 4 colors of pigment can be used in each field."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every field can be Pigmented to exactly 4 color.",
            "NL": "Only four colors of pigment can be used in each field."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every field can be Pigmented to exactly 4 color.",
            "NL": "There can only be four colors pigmented in each field."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every field can be Pigmented to exactly 4 color.",
            "NL": "Only four colors can be applied to each field."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every field can be Pigmented to exactly 4 color.",
            "NL": "Only 4 colors can be applied to each field."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every field6 Q can be Unit exaclty 8 Parent E.",
            "NL": "For every field6 Q that can be Unit, there are precisely 8 Parent E."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every field6 Q can be Unit exaclty 8 Parent E.",
            "NL": "For every Unit of field6 Q, there are precisely 8 Parent Es."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every field6 Q can be Unit exaclty 8 Parent E.",
            "NL": "For every field6 Q that can be Unit, there are exactly 8 Parent E."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every field6 Q can be Unit exaclty 8 Parent E.",
            "NL": "For every field6 Q, there are exactly 8 Parent E that can be Unit."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every field6 Q can be Unit exaclty 8 Parent E.",
            "NL": "For every Unit of field6 Q, there are precisely 8 Parent E."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every field6 W can be Adjacency_Matrix exaclty 46 Passive S.",
            "NL": "For every field6 W, there are precisely 46 Passive S that can be represented by an Adjacency_Matrix."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every field6 W can be Adjacency_Matrix exaclty 46 Passive S.",
            "NL": "For every field6 W, there are precisely 46 Passive S that can be represented in an Adjacency_Matrix."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every field6 W can be Adjacency_Matrix exaclty 46 Passive S.",
            "NL": "For every field6 W, there are precisely 46 Passive S that can be Adjacency_Matrixed."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every field6 W can be Adjacency_Matrix exaclty 46 Passive S.",
            "NL": "For each field6 W, there is precisely 46 Passive S that can be represented in an Adjacency_Matrix."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every field6 W can be Adjacency_Matrix exaclty 46 Passive S.",
            "NL": "For every field6 W, there are precisely 46 Passive Ss that can be found in the Adjacency_Matrix."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every field9 can be Planar_Graph to exactly 23 color.",
            "NL": "For each field9, the maximum number of colorable Planar_Graphs is 23."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every field9 can be Planar_Graph to exactly 23 color.",
            "NL": "For each field9, the maximum number of color Planar_Graphs is 23."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every field9 can be Planar_Graph to exactly 23 color.",
            "NL": "A maximum of 23 color Planar_Graphs can be assigned to each field9."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every field9 can be Planar_Graph to exactly 23 color.",
            "NL": "For each field9, the maximum number of color Planar_Graphs that can exist is 23."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every field9 can be Planar_Graph to exactly 23 color.",
            "NL": "The maximum number of color Planar_Graphs that can be allocated to each field9 is 23."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every Heaviness U can be a Last.",
            "NL": "Every Heaviness has the potential to be included in a Last."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every Heaviness U can be a Last.",
            "NL": "Every Heaviness can be a part of a Last."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every Heaviness U can be a Last.",
            "NL": "Every Heaviness can be included in a Last."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every Heaviness U can be a Last.",
            "NL": "Every Heaviness can be part of a Last."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every Heaviness U can be a Last.",
            "NL": "Every Heaviness could be part of a Last."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every id4 can be a node.",
            "NL": "Every ID4 can be included in a node."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every id4 can be a node.",
            "NL": "Every ID4 could be included in a node."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every id4 can be a node.",
            "NL": "Every ID4 can be incorporated into a node."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every id4 can be a node.",
            "NL": "Every ID4 could potentially be part of a node."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every id4 can be a node.",
            "NL": "Each individual ID4 can be included in a node."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every Index U can be a Dormant.",
            "NL": "Every Index can potentially be part of a Dormant."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every Index U can be a Dormant.",
            "NL": "Every Index could potentially be a part of a Dormant."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every Index U can be a Dormant.",
            "NL": "Every Index can potentially be a part of a Dormant."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every Index U can be a Dormant.",
            "NL": "Every Index has the potential to be part of a Dormant."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every Index U can be a Dormant.",
            "NL": "Every Index can potentially be included in a Dormant."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every Individual R can be an Element.",
            "NL": "Every Individual has the potential to be a part of a Element."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every Individual R can be an Element.",
            "NL": "Every Individual has the potential to be part of an Element."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every Individual R can be an Element.",
            "NL": "Every Individual has the potential to be part of a Element."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every Individual R can be an Element.",
            "NL": "Every Individual has the potential to be a part of an Element."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every Individual R can be an Element.",
            "NL": "Every Individual can have a role to play in an Element."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every key4 can be an id8.",
            "NL": "Every key4 has the potential to be part of an id8."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every key4 can be an id8.",
            "NL": "Every key4 has the potential to be part of a id8."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every key4 can be an id8.",
            "NL": "Every key4 can be included in an id8."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every key4 can be an id8.",
            "NL": "Every key4 has the potential to be included in an id8."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every key4 can be an id8.",
            "NL": "Every key4 can be incorporated into an id8."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every key5 can be Tinted to exactly 20 color.",
            "NL": "A maximum of 20 colors can be assigned to each key."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every key5 can be Tinted to exactly 20 color.",
            "NL": "Only 20 colors can be applied to each key."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every key5 can be Tinted to exactly 20 color.",
            "NL": "A maximum of 20 colors can be applied to each key."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every key5 can be Tinted to exactly 20 color.",
            "NL": "Only 20 colors can be assigned to each key."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every key5 can be Tinted to exactly 20 color.",
            "NL": "The maximum number of colors that can be applied to each key is twenty."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every key5 Y can be Project exaclty 35 Outbound J.",
            "NL": "For every key5 Y that can be Projected, there are exactly 35 Outbound Js."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every key5 Y can be Project exaclty 35 Outbound J.",
            "NL": "For every key5 Y that can be Project, there are exactly 35 Outbound J."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every key5 Y can be Project exaclty 35 Outbound J.",
            "NL": "For every key5 Y that can be Projected, there are precisely 35 Outbound Js."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every key5 Y can be Project exaclty 35 Outbound J.",
            "NL": "For every key5 Y that can be Project, there are precisely 35 Outbound J."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every key5 Y can be Project exaclty 35 Outbound J.",
            "NL": "For every key5 Y that can be Project, there are precisely 35 Outbound Js."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every key7 U can be Denied exaclty 49 Maximum_Matching J.",
            "NL": "For every key7 U, there are precisely 49 Maximum_Matching Js that can be denied."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every key7 U can be Denied exaclty 49 Maximum_Matching J.",
            "NL": "The number of Maximum_Matching J that can be Denied for each key7 U is precisely 49."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every key7 U can be Denied exaclty 49 Maximum_Matching J.",
            "NL": "For every key7 U that can be Denied, there are precisely 49 Maximum_Matching Js."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every key7 U can be Denied exaclty 49 Maximum_Matching J.",
            "NL": "For every key7 U, there are precisely 49 Maximum_Matching Js that can be rejected."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every key7 U can be Denied exaclty 49 Maximum_Matching J.",
            "NL": "For every key7 U, there are exactly 49 Maximum_Matching J that can be rejected."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every key9 L can be Idle exaclty 39 Unmatched Y.",
            "NL": "For every key9 L, there are precisely 39 Unmatched Ys that can be Idle."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every key9 L can be Idle exaclty 39 Unmatched Y.",
            "NL": "For every key9 L, there are precisely 39 Unmatched Y that can be Idle."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every key9 L can be Idle exaclty 39 Unmatched Y.",
            "NL": "For each key9 L, there are precisely 39 Unmatched Y that can remain inactive."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every key9 L can be Idle exaclty 39 Unmatched Y.",
            "NL": "For every key9 L that can be Idle, there are exactly 39 Unmatched Y."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every key9 L can be Idle exaclty 39 Unmatched Y.",
            "NL": "For every key9 L, there are exactly 39 Unmatched Y that can be Idle."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every Lone F can be a Foremost.",
            "NL": "Every person has the potential to be part of something great."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every Lone F can be a Foremost.",
            "NL": "Every individual has the potential to become a leader."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every Lone F can be a Foremost.",
            "NL": "Every individual can be a part of a leading group."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every Lone F can be a Foremost.",
            "NL": "Every one is able to be a part of a leading group."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every Lone F can be a Foremost.",
            "NL": "Every Lone has the potential to become part of a Foremost."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every node can be a clique.",
            "NL": "It is possible for each node to be included in a clique."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every node can be a clique.",
            "NL": "Every node has the potential to be a part of a clique."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every node can be a clique.",
            "NL": "Every node can potentially belong to a clique."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every node can be a clique.",
            "NL": "It's feasible for all nodes to be included in a clique."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every node can be a clique.",
            "NL": "The inclusion of every node in a clique is a possibility."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every node can be assigned to exactly 1 color.",
            "NL": "There can only be one color allocated to each node."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every node can be assigned to exactly 1 color.",
            "NL": "Only a single color can be attributed to each node."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every node can be assigned to exactly 1 color.",
            "NL": "Each node can have just one color assigned."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every node can be assigned to exactly 1 color.",
            "NL": "Each node is permitted to have only one color."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every node can be assigned to exactly 1 color.",
            "NL": "A single color is all that can be assigned to each node."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every node10 X can be Cut_Vertex exaclty 34 Incidence_Matrix O.",
            "NL": "For every node10 X, there are exactly 34 Incidence_Matrix O's that can be Cut_Vertex."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every node10 X can be Cut_Vertex exaclty 34 Incidence_Matrix O.",
            "NL": "For every node10 X, there are precisely 34 Incidence_Matrix O that can be Cut_Vertex."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every node10 X can be Cut_Vertex exaclty 34 Incidence_Matrix O.",
            "NL": "For each node10 X, there are exactly 34 Incidence_Matrix O Cut_Vertexes."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every node10 X can be Cut_Vertex exaclty 34 Incidence_Matrix O.",
            "NL": "For every node10 X, there are precisely 34 Incidence_Matrix O's that can be Cut_Vertex."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every node10 X can be Cut_Vertex exaclty 34 Incidence_Matrix O.",
            "NL": "For every node10 X, there are exactly 34 Incidence_Matrix O that can be Cut_Vertex."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every node2 can be Atom to exactly 30 color.",
            "NL": "Each node2 can have a maximum of 30 colors Atom."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every node2 can be Atom to exactly 30 color.",
            "NL": "Each node2 can only have 30 color Atoms."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every node2 can be Atom to exactly 30 color.",
            "NL": "Each node2 can only have 30 colors of Atom."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every node2 can be Atom to exactly 30 color.",
            "NL": "Each node2 is limited to a maximum of 30 color Atoms."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every node2 can be Atom to exactly 30 color.",
            "NL": "No more than 30 colors can be assigned to each node2."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every node2 can be Second to exactly 36 color.",
            "NL": "Each node2 can only have 36 colors."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every node2 can be Second to exactly 36 color.",
            "NL": "For each node2, there can only be 36 colors."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every node2 can be Second to exactly 36 color.",
            "NL": "At each node2, no more than 36 colors can exist."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every node2 can be Second to exactly 36 color.",
            "NL": "Each node2 can have a maximum of 36 colors."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every node2 can be Second to exactly 36 color.",
            "NL": "Each node2 can only have a maximum of 36 colors."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every node2 E can be Inactive exaclty 44 Tree O.",
            "NL": "For every node2 E that can be Inactive, there are precisely 44 Tree O."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every node2 E can be Inactive exaclty 44 Tree O.",
            "NL": "For every Inactive node2 E, there are precisely 44 Tree O."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every node2 E can be Inactive exaclty 44 Tree O.",
            "NL": "For every node2 E that can be Inactive, there are exactly 44 Tree O."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every node2 E can be Inactive exaclty 44 Tree O.",
            "NL": "For each node2 E that can be Inactive, there are precisely 44 Tree O."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every node2 E can be Inactive exaclty 44 Tree O.",
            "NL": "For every Inactive node2 E, there are exactly 44 Tree O."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every node3 can be Information to exactly 37 color.",
            "NL": "Each node3 can only contain 37 color information."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every node3 can be Information to exactly 37 color.",
            "NL": "Each node3 can only have 37 pieces of color information."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every node3 can be Information to exactly 37 color.",
            "NL": "Each node3 can only contain 37 pieces of color information."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every node3 can be Information to exactly 37 color.",
            "NL": "Each node3 can have a maximum of 37 color information."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every node3 can be Information to exactly 37 color.",
            "NL": "The maximum number of color Information that can be assigned to each node3 is 37."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every node4 can be Weighted_Graph to exactly 36 color.",
            "NL": "The maximum number of colors that can be assigned to each node4 of a Weighted Graph is 36."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every node4 can be Weighted_Graph to exactly 36 color.",
            "NL": "There can be a maximum of 36 colors assigned to each node4."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every node4 can be Weighted_Graph to exactly 36 color.",
            "NL": "There can be up to 36 colors assigned to each node in a Weighted Graph."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every node4 can be Weighted_Graph to exactly 36 color.",
            "NL": "For each node4, there can only be 36 colors in the Weighted Graph."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every node4 can be Weighted_Graph to exactly 36 color.",
            "NL": "Each node4 can only have 36 color Weighted_Graphs."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every node6 can be a id8.",
            "NL": "Every node6 has the potential to be incorporated into an id8."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every node6 can be a id8.",
            "NL": "Every node6 has the potential to be part of an id8."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every node6 can be a id8.",
            "NL": "Every node6 has the potential to become part of an id8."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every node6 can be a id8.",
            "NL": "Every node6 can be a part of an id8."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every node6 can be a id8.",
            "NL": "Every node6 can be part of an id8."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every node8 can be a node1.",
            "NL": "Every node1 has the potential to include a node8."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every node8 can be a node1.",
            "NL": "Every node1 can include every node8."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every node8 can be a node1.",
            "NL": "Every node1 can potentially include every node8."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every node8 can be a node1.",
            "NL": "Every node1 can contain a node8."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every node8 can be a node1.",
            "NL": "Every node1 is capable of being part of a node8."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every Nontrivial T can be an Irrelevant.",
            "NL": "Every Nontrivial can potentially be included in an Irrelevant."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every Nontrivial T can be an Irrelevant.",
            "NL": "Every Nontrivial element can potentially be included in an Irrelevant set."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every Nontrivial T can be an Irrelevant.",
            "NL": "Every Nontrivial could be included in an Irrelevant."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every Nontrivial T can be an Irrelevant.",
            "NL": "Every Nontrivial can potentially be associated with an Irrelevant."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every Nontrivial T can be an Irrelevant.",
            "NL": "Every Non-trivial thing can be included in an Irrelevant context."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every Pigmented Q can be a Graph.",
            "NL": "Every Pigmented can be included in a Graph."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every Pigmented Q can be a Graph.",
            "NL": "Every Pigmented individual can be included in a Graph."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every Pigmented Q can be a Graph.",
            "NL": "Every Pigmented individual has the potential to be included in a Graph."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every Pigmented Q can be a Graph.",
            "NL": "Every Pigmented has the potential to be included in a Graph."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every Pigmented Q can be a Graph.",
            "NL": "Every Pigmented can potentially be included in a Graph."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every Radius F can be a Nfirst.",
            "NL": "Every Radius can be part of a Nfirst."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every Radius F can be a Nfirst.",
            "NL": "Every Radius could be a part of a Nfirst."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every Radius F can be a Nfirst.",
            "NL": "Every Radius can be a part of a Nfirst."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every Radius F can be a Nfirst.",
            "NL": "Every Radius could be included in a Nfirst."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every Radius F can be a Nfirst.",
            "NL": "Every Radius can be included in a Nfirst."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every Selected_Color N can be a Incoming_Level.",
            "NL": "Every Selected_Color can be included in an Incoming_Level."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every Selected_Color N can be a Incoming_Level.",
            "NL": "Every Incoming_Level can contain a Selected_Color."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every Selected_Color N can be a Incoming_Level.",
            "NL": "Every Selected_Color has the potential to be included in an Incoming_Level."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every Selected_Color N can be a Incoming_Level.",
            "NL": "Every Incoming_Level can include a Selected_Color."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every Selected_Color N can be a Incoming_Level.",
            "NL": "Every Incoming_Level has the potential to include any Selected_Color."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every Size I can be a Major.",
            "NL": "Every Size can be included in a Major."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every Size I can be a Major.",
            "NL": "Every Size can be part of a Major."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every Size I can be a Major.",
            "NL": "Every Size is capable of being part of a Major."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every Size I can be a Major.",
            "NL": "Every Size is capable of being included in a Major."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every Size I can be a Major.",
            "NL": "Every Size can be a part of a Major."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every Trapped S can be a Container.",
            "NL": "Every Trapped has the potential to be included in a Container."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every Trapped S can be a Container.",
            "NL": "Every Trapped can be included in a Container."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every Trapped S can be a Container.",
            "NL": "Every Trapped individual can be included in a Container."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every Trapped S can be a Container.",
            "NL": "Every Trapped has the potential to become part of a Container."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every Trapped S can be a Container.",
            "NL": "Every Trapped individual has the potential to be included in a Container."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every Triumph M can be an Initiate.",
            "NL": "Every Triumph could potentially be part of an Initiate."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every Triumph M can be an Initiate.",
            "NL": "Every Triumph is capable of being included in an Initiate."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every Triumph M can be an Initiate.",
            "NL": "Every Triumph has the potential to be included in an Initiate."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every Triumph M can be an Initiate.",
            "NL": "Every Triumph can be included in an Initiate."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every Triumph M can be an Initiate.",
            "NL": "Every Triumph has the potential to be part of an Initiate."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every value can be InDegree to exactly 15 color.",
            "NL": "The maximum number of colors assigned to each value is 15."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every value can be InDegree to exactly 15 color.",
            "NL": "The maximum number of colors that can be associated with each value is 15."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every value can be InDegree to exactly 15 color.",
            "NL": "The maximum number of color InDegrees per value is 15."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every value can be InDegree to exactly 15 color.",
            "NL": "The maximum number of InDegree colors that can be assigned to each value is 15."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every value can be InDegree to exactly 15 color.",
            "NL": "The maximum number of color InDegrees that can be assigned to each value is 15."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every value U can be Element exaclty 43 Cycle K.",
            "NL": "For each value of U, there are precisely 43 Cycle Ks that can be Element."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every value U can be Element exaclty 43 Cycle K.",
            "NL": "For every value U, there are precisely 43 Cycle Ks that can be Element."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every value U can be Element exaclty 43 Cycle K.",
            "NL": "For every value U that can be Element, there are precisely 43 Cycle Ks."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every value U can be Element exaclty 43 Cycle K.",
            "NL": "For every U value, there are precisely 43 Cycle K Elements."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every value U can be Element exaclty 43 Cycle K.",
            "NL": "For every U that can be Element, there are precisely 43 Cycle Ks."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every value1 can be a node9.",
            "NL": "Every value1 can be part of a node9."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every value1 can be a node9.",
            "NL": "Every value1 can be incorporated into a node9."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every value1 can be a node9.",
            "NL": "Every value1 could be included in a node9."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every value1 can be a node9.",
            "NL": "Every value1 can be included in a node9."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every value1 can be a node9.",
            "NL": "Every value1 has the potential to be included in a node9."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every value1 can be a vtx2.",
            "NL": "Every value1 has the potential to be included in a vtx2."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every value1 can be a vtx2.",
            "NL": "Every value1 can be included in a vtx2."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every value1 can be a vtx2.",
            "NL": "Every value1 can be incorporated into a vtx2."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every value1 can be a vtx2.",
            "NL": "Every value1 has the potential to be incorporated into a vtx2."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every value1 can be a vtx2.",
            "NL": "Every value1 can potentially be included in a vtx2."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every value4 A can be Functioning exaclty 38 Tinted N.",
            "NL": "For every value4 A that can be Functioning, there are precisely 38 Tinted N."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every value4 A can be Functioning exaclty 38 Tinted N.",
            "NL": "For every value4 A that is Functioning, there are precisely 38 Tinted N."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every value4 A can be Functioning exaclty 38 Tinted N.",
            "NL": "For every Functioning A, there are precisely 38 Tinted Ns."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every value4 A can be Functioning exaclty 38 Tinted N.",
            "NL": "For every A that can be Functioning, there are exactly 38 Tinted Ns."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every value4 A can be Functioning exaclty 38 Tinted N.",
            "NL": "The ratio of Tinted N to Functioning A is 38 to 1."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every value7 L can be Data exaclty 7 Incidence_Matrix M.",
            "NL": "For every value7 L, there is an exact Incidence_Matrix M that can be Data."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every value7 L can be Data exaclty 7 Incidence_Matrix M.",
            "NL": "For every value7 L, there are exactly 7 Incidence_Matrix M that can be Data."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every value7 L can be Data exaclty 7 Incidence_Matrix M.",
            "NL": "For every value7 L, there is a corresponding Incidence_Matrix M with exactly 7 elements."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every value7 L can be Data exaclty 7 Incidence_Matrix M.",
            "NL": "For every value7 L, there are precisely 7 Incidence_Matrix M that can be Data."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every value7 L can be Data exaclty 7 Incidence_Matrix M.",
            "NL": "For every value7 L, there is a corresponding Incidence_Matrix M with 7 elements."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every vtx U can be a dom.",
            "NL": "Every vertex can potentially be included in a dom."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every vtx U can be a dom.",
            "NL": "Every vertex can potentially be part of a dom."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every vtx U can be a dom.",
            "NL": "Every vertex can be a part of a dom."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every vtx U can be a dom.",
            "NL": "Every vertex can be part of a dom."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every vtx U can be a dom.",
            "NL": "Every vertex can be included in a dom."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every vtx U can be partition exactly 1 part K.",
            "NL": "For every vertex U that can be partitioned, there is exactly one part K."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every vtx U can be partition exactly 1 part K.",
            "NL": "For every vertex U that can be partitioned, there is precisely one part K."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every vtx U can be partition exactly 1 part K.",
            "NL": "For each vertex U that can be partitioned, there is only one component K."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every vtx U can be partition exactly 1 part K.",
            "NL": "For every vertex U that can be partitioned, there is only one part K."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every vtx U can be partition exactly 1 part K.",
            "NL": "For each vertex U that can be partitioned, there is precisely one part K."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every vtx2 can be Width to exactly 28 color.",
            "NL": "The vtx2 can only have a maximum of 28 color Widths."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every vtx2 can be Width to exactly 28 color.",
            "NL": "The vtx2 can only have 28 color Widths."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every vtx2 can be Width to exactly 28 color.",
            "NL": "The vtx2 can only have a total of 28 different colors of width."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every vtx2 can be Width to exactly 28 color.",
            "NL": "The vtx2 can only have 28 distinct colors in its width."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every vtx2 can be Width to exactly 28 color.",
            "NL": "The vtx2 can only have 28 colors in its width."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every vtx2 I can be Below_Threshold exaclty 21 Cliquesize Y.",
            "NL": "For every vtx2 I, there are precisely 21 Cliquesize Y that can be Below_Threshold."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every vtx2 I can be Below_Threshold exaclty 21 Cliquesize Y.",
            "NL": "For every vtx2 I, there are exactly 21 Cliquesize Ys that are Below_Threshold."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every vtx2 I can be Below_Threshold exaclty 21 Cliquesize Y.",
            "NL": "For every vtx2 I, there are exactly 21 Cliquesize Y that can be Below_Threshold."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every vtx2 I can be Below_Threshold exaclty 21 Cliquesize Y.",
            "NL": "For every VTX2 I, there are precisely 21 Cliquesize Y which can be Below_Threshold."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every vtx2 I can be Below_Threshold exaclty 21 Cliquesize Y.",
            "NL": "For every vtx2 I, there are exactly 21 Cliquesize Y Below_Threshold."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every vtx4 Z can be Cycle_Basis exaclty 28 OutgoingRoute W.",
            "NL": "For every vtx4 Z, there are precisely 28 OutgoingRoute W that can be Cycle_Basis."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every vtx4 Z can be Cycle_Basis exaclty 28 OutgoingRoute W.",
            "NL": "For every vtx4 Z, there are precisely 28 OutgoingRoute Ws that can be Cycle_Basis."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every vtx4 Z can be Cycle_Basis exaclty 28 OutgoingRoute W.",
            "NL": "For every vtx4 Z, there are precisely 28 OutgoingRoute W which could be Cycle_Basis."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every vtx4 Z can be Cycle_Basis exaclty 28 OutgoingRoute W.",
            "NL": "For every vtx4 Z, there are exactly 28 OutgoingRoute W that can be Cycle_Basis."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Every vtx4 Z can be Cycle_Basis exaclty 28 OutgoingRoute W.",
            "NL": "For every vtx4 Z, there are precisely 28 OutgoingRoute Ws that can form a Cycle_Basis."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Bipartite_Graph with value L greater than 1, with id U, then we can have exactly 1 Index with third point U, with fourth id B such that there is a Bipartite_Graph with third point U, with fourth id B, or a Index with third point U, with fourth id B such that there is an Bipartite_Graph with third point B, with fourth id U.",
            "NL": "If a Bipartite_Graph has a value L greater than 1 and id U, then there must be either a Bipartite_Graph with third point U, fourth id B, or an Index with third point U and fourth id B, and a Bipartite_Graph with third point B and fourth id U."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Bipartite_Graph with value L greater than 1, with id U, then we can have exactly 1 Index with third point U, with fourth id B such that there is a Bipartite_Graph with third point U, with fourth id B, or a Index with third point U, with fourth id B such that there is an Bipartite_Graph with third point B, with fourth id U.",
            "NL": "When a Bipartite_Graph has a value of L greater than 1 and an id of U, there will be either one Index with third point U, fourth id B, and a Bipartite_Graph with third point U, fourth id B, or a Index with third point U, fourth id B, and a Bipartite_Graph with third point B, fourth id U."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Bipartite_Graph with value L greater than 1, with id U, then we can have exactly 1 Index with third point U, with fourth id B such that there is a Bipartite_Graph with third point U, with fourth id B, or a Index with third point U, with fourth id B such that there is an Bipartite_Graph with third point B, with fourth id U.",
            "NL": "If a Bipartite_Graph has a value L of more than 1 and an ID of U, then there can be only one Index with third point U, fourth id B, such that either a Bipartite_Graph with third point U, fourth id B exists or an Index with third point U, fourth id B exists that is associated with a Bipartite_Graph with third point B and fourth id U."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Bipartite_Graph with value L greater than 1, with id U, then we can have exactly 1 Index with third point U, with fourth id B such that there is a Bipartite_Graph with third point U, with fourth id B, or a Index with third point U, with fourth id B such that there is an Bipartite_Graph with third point B, with fourth id U.",
            "NL": "If a Bipartite_Graph has a value L greater than 1, where its third point is U and its fourth id is B, then there is either a Bipartite_Graph with third point U, fourth id B, or an Index with third point U, fourth id B, and a Bipartite_Graph with third point B, fourth id U."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Bipartite_Graph with value L greater than 1, with id U, then we can have exactly 1 Index with third point U, with fourth id B such that there is a Bipartite_Graph with third point U, with fourth id B, or a Index with third point U, with fourth id B such that there is an Bipartite_Graph with third point B, with fourth id U.",
            "NL": "If a Bipartite_Graph has a L value greater than one and a U ID, there will be an Index with third point U, fourth id B, and either a Bipartite_Graph with third point U, fourth id B or an Index with third point U, fourth id B, where there is a Bipartite_Graph with third point B, fourth id U."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a body with value equal to 1 then we can have at least 0 linked with value V such that there is an edge with node1 V or a linked with value U such that there is an edge with node2 U. ",
            "NL": "Given a body with a value of 1, we can link at least two nodes, V and U, to it such that there is an edge with each node."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a body with value equal to 1 then we can have at least 0 linked with value V such that there is an edge with node1 V or a linked with value U such that there is an edge with node2 U. ",
            "NL": "We can have at least 0 edges linked to either node V or node U when a body has a value of 1, with each node having a value of either V or U."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a body with value equal to 1 then we can have at least 0 linked with value V such that there is an edge with node1 V or a linked with value U such that there is an edge with node2 U. ",
            "NL": "If a body has a value of 1, then there must be at least one node (V) linked with a value of V, and another node (U) linked with a value of U, both of which have an edge connecting them."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a body with value equal to 1 then we can have at least 0 linked with value V such that there is an edge with node1 V or a linked with value U such that there is an edge with node2 U. ",
            "NL": "If a body has a value of 1, then there must be at least one node with value V connected by an edge or one node with value U connected by an edge."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a body with value equal to 1 then we can have at least 0 linked with value V such that there is an edge with node1 V or a linked with value U such that there is an edge with node2 U. ",
            "NL": "If a body has a value of 1, there must be at least one node (V) linked to it with a value of V, and another node (U) linked to it with a value of U, with an edge connecting the two."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Breadth with value equal to 29 then we can have at least 37 Complete with id3 D such that there is an Route with edge9 Dor a Complete with id3 P such that there is an Route with edge10 P.",
            "NL": "If the Breadth has a value of 29, there can be at least 37 Complete with id3 D that includes a Route with edge9 D or a Complete with id3 P with a Route that has edge10 P."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Breadth with value equal to 29 then we can have at least 37 Complete with id3 D such that there is an Route with edge9 Dor a Complete with id3 P such that there is an Route with edge10 P.",
            "NL": "If the Breadth is 29, we can find either a Complete with id3 D that has a Route with edge9 D or a Complete with id3 P that has a Route with edge10 P, with a minimum of 37 Complete."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Breadth with value equal to 29 then we can have at least 37 Complete with id3 D such that there is an Route with edge9 Dor a Complete with id3 P such that there is an Route with edge10 P.",
            "NL": "When a Breadth has a value of 29, we can have a Route with edge9 D or edge10 P that is completed with either id3 D or id3 P, resulting in at least 37 Completes."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Breadth with value equal to 29 then we can have at least 37 Complete with id3 D such that there is an Route with edge9 Dor a Complete with id3 P such that there is an Route with edge10 P.",
            "NL": "If a Breadth has a value of 29, we can find a Complete with id3 D and a Route with edge9 D, or a Complete with id3 P and a Route with edge10 P, with at least 37 being the minimum."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Breadth with value equal to 29 then we can have at least 37 Complete with id3 D such that there is an Route with edge9 Dor a Complete with id3 P such that there is an Route with edge10 P.",
            "NL": "If the Breadth has a value of 29, we can have a Complete with id3 D that contains a Route with edge9 D or a Complete with id3 P that includes a Route with edge10 P at least 37 times."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Capacity L then we can have Child with node8 O, with node8 L exactly 1 Offspring with node8 O, with node8 L.",
            "NL": "It is possible to have one Offspring with node8 O, with node8 L whenever there is a Capacity L, provided that the Child has node8 O, with node8 L."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Capacity L then we can have Child with node8 O, with node8 L exactly 1 Offspring with node8 O, with node8 L.",
            "NL": "It is possible to have one Offspring with node8 O and node8 L when Capacity L is present."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Capacity L then we can have Child with node8 O, with node8 L exactly 1 Offspring with node8 O, with node8 L.",
            "NL": "It is possible to have one Offspring with node8 O and node8 L whenever there is a Capacity L available."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Capacity L then we can have Child with node8 O, with node8 L exactly 1 Offspring with node8 O, with node8 L.",
            "NL": "It is possible to produce one Offspring with node8 O and node8 L if the Capacity L is present."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Capacity L then we can have Child with node8 O, with node8 L exactly 1 Offspring with node8 O, with node8 L.",
            "NL": "It is possible to produce one Offspring with node8 O and node8 L when a Capacity L is present."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Centrality R, then we can have exactly 29 Father_Edge with field7 R, and with edge7 H such that there is a Maximum_Matching H.",
            "NL": "Whenever there is a Centrality R, we can always have a Father_Edge with field7 R and edge7 H that has a maximum of 29 matchings."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Centrality R, then we can have exactly 29 Father_Edge with field7 R, and with edge7 H such that there is a Maximum_Matching H.",
            "NL": "Whenever there is a Centrality R, we can always have a Father_Edge with field7 R and edge7 H, up to a maximum of 29 Maximum_Matching H."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Centrality R, then we can have exactly 29 Father_Edge with field7 R, and with edge7 H such that there is a Maximum_Matching H.",
            "NL": "Whenever there is a Centrality R, we can always have a Father_Edge with field7 R and edge7 H exactly 29 Maximum_Matching H."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Centrality R, then we can have exactly 29 Father_Edge with field7 R, and with edge7 H such that there is a Maximum_Matching H.",
            "NL": "Whenever there is a Centrality R, we can always have a Father_Edge with field7 R and edge7 H with a maximum of 29 matchings."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Centrality R, then we can have exactly 29 Father_Edge with field7 R, and with edge7 H such that there is a Maximum_Matching H.",
            "NL": "Whenever there is a Centrality R, we can always have a Father_Edge with field7 R and edge7 H, with up to 29 Maximum_Matching H."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Centrality with id6 W, then we can have exactly 6 link with key10 D, with node8 I such that there is an Initiate with value D, with node2 U, or a Participating with key10 D, with node8 I such that there is an Initiate with value W, with key1 D.",
            "NL": "We can have up to 6 Participating nodes with key10 D and node8 I, with an Initiate of value W and key1 D, or a Participating node with key10 D and node8 I, with an Initiate of value W and key1 D, whenever there is a Centrality node with id6 W."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Centrality with id6 W, then we can have exactly 6 link with key10 D, with node8 I such that there is an Initiate with value D, with node2 U, or a Participating with key10 D, with node8 I such that there is an Initiate with value W, with key1 D.",
            "NL": "We can have either 6 Participating nodes with key10 D, node8 I and an Initiate with value W, key1 D, or a Participating node with key10 D, node8 I and an Initiate with value W, key1 D, provided that a Centrality node with id6 W is present."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Centrality with id6 W, then we can have exactly 6 link with key10 D, with node8 I such that there is an Initiate with value D, with node2 U, or a Participating with key10 D, with node8 I such that there is an Initiate with value W, with key1 D.",
            "NL": "Whenever there is a Centrality node with id6 W, we can have either an Initiate with value W and key1 D, or a Participating node with key10 D and node8 I, both of which have exactly 6 Participating nodes."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Centrality with id6 W, then we can have exactly 6 link with key10 D, with node8 I such that there is an Initiate with value D, with node2 U, or a Participating with key10 D, with node8 I such that there is an Initiate with value W, with key1 D.",
            "NL": "We can have either 6 Participating nodes with key10 D, node8 I, and an Initiate with value W and key1 D, or a Centrality node with id6 W and a Participating node with key10 D, node8 I, and an Initiate with value W and key1 D."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Centrality with id6 W, then we can have exactly 6 link with key10 D, with node8 I such that there is an Initiate with value D, with node2 U, or a Participating with key10 D, with node8 I such that there is an Initiate with value W, with key1 D.",
            "NL": "We can have a Centrality node with id6 W that is associated with either an Initiate with value W and key1 D, or a Participating node with key10 D and node8 I, with a maximum of 6 Participating nodes."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Chart Z, then we can have exactly 25 Clique with node10 Z, and with value7 X such that there is an Arc X.",
            "NL": "We can always form a Clique with node10 Z and value7 X of exactly 25 Arc X, whenever there is a Chart Z present."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Chart Z, then we can have exactly 25 Clique with node10 Z, and with value7 X such that there is an Arc X.",
            "NL": "We can always form a Clique with node10 Z and value7 X that has exactly 25 Arc X, whenever a Chart Z is present."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Chart Z, then we can have exactly 25 Clique with node10 Z, and with value7 X such that there is an Arc X.",
            "NL": "We can always form a Clique with node10 Z and value7 X of exactly 25 Arc X, whenever a Chart Z is present."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Chart Z, then we can have exactly 25 Clique with node10 Z, and with value7 X such that there is an Arc X.",
            "NL": "We can always form a Clique with node10 Z and value7 X having precisely 25 Arc X when there is a Chart Z."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Chart Z, then we can have exactly 25 Clique with node10 Z, and with value7 X such that there is an Arc X.",
            "NL": "We can always form a Clique with node10 Z and value7 X with exactly 25 Arc X, provided that there is a Chart Z available."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Chosencolour with node2 Q, whenever there is a Sign with node2 R, then we can have between 46 and R Shortest_Path with node2 T, and with id K such that there is an Enumeration U.",
            "NL": "Whenever we have chosen colour Q and sign R, we can always find a shortest path between node2 T and node2 Q with enumeration T."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Chosencolour with node2 Q, whenever there is a Sign with node2 R, then we can have between 46 and R Shortest_Path with node2 T, and with id K such that there is an Enumeration U.",
            "NL": "We can always find the Shortest_Path between node2 T and node2 Q, with Enumeration T, when we select Chosencolour Q and Sign R, that range between 46 and R."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Chosencolour with node2 Q, whenever there is a Sign with node2 R, then we can have between 46 and R Shortest_Path with node2 T, and with id K such that there is an Enumeration U.",
            "NL": "Whenever we have chosen the colour Q and sign R, we can always find a shortest path between node2 T and node2 Q ranging between 46 and R with enumeration T."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Chosencolour with node2 Q, whenever there is a Sign with node2 R, then we can have between 46 and R Shortest_Path with node2 T, and with id K such that there is an Enumeration U.",
            "NL": "Whenever we have chosen a colour Q and a sign R, we can always find a shortest path with node2 T and node2 Q ranging between 46 and R with enumeration T."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Chosencolour with node2 Q, whenever there is a Sign with node2 R, then we can have between 46 and R Shortest_Path with node2 T, and with id K such that there is an Enumeration U.",
            "NL": "We can always find a Shortest_Path between node2 T and node2 Q, with Enumeration T, if we have Chosencolour Q and Sign R, ranging from 46 to R."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Cliquesize with value equal to 40 then we can have at least 5 Visit with field4 H such that there is a Three_Nodes with id7 Hor a Visit with field4 U such that there is a Three_Nodes with node5 U.",
            "NL": "If the Cliquesize has a value of 40, we can have a minimum of 5 Visits with field4 H that contain Three_Nodes with id7 H, or a Visit with field4 U that has a Three_Nodes with node5 U."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Cliquesize with value equal to 40 then we can have at least 5 Visit with field4 H such that there is a Three_Nodes with id7 Hor a Visit with field4 U such that there is a Three_Nodes with node5 U.",
            "NL": "When a Cliquesize is equal to 40, we can have at least 5 Visits with field4 H in which there is a Three_Nodes with id7 H, or a Visit with field4 U that contains a Three_Nodes with node5 U."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Cliquesize with value equal to 40 then we can have at least 5 Visit with field4 H such that there is a Three_Nodes with id7 Hor a Visit with field4 U such that there is a Three_Nodes with node5 U.",
            "NL": "If Cliquesize is set to 40, we can have at least 5 Visits with field4 H containing a Three_Nodes with id7 H, or a Visit with field4 U that includes a Three_Nodes with node5 U."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Cliquesize with value equal to 40 then we can have at least 5 Visit with field4 H such that there is a Three_Nodes with id7 Hor a Visit with field4 U such that there is a Three_Nodes with node5 U.",
            "NL": "When the Cliquesize is 40, we can have a minimum of 5 Visits with field4 H that contain a Three_Nodes with id7 H, or a Visit with field4 U that contains a Three_Nodes with node5 U."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Cliquesize with value equal to 40 then we can have at least 5 Visit with field4 H such that there is a Three_Nodes with id7 Hor a Visit with field4 U such that there is a Three_Nodes with node5 U.",
            "NL": "When the Cliquesize is 40, we can have at least 5 Visits with field4 H that have a Three_Nodes with id7 H, or a Visit with field4 U that has a Three_Nodes with node5 U."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Cliquesize with value L greater than 1, with id U, then we can have exactly 1 Cut with fake value V, with first vertex U such that there is a Cliquesize with fake value V, with first vertex U, or a Cut with fake value V, with first vertex U such that there is a Cliquesize with fake value U, with first vertex V.",
            "NL": "If a Cliquesize has a value L greater than 1 and id U, then we are able to have a single Cut with fake value V, first vertex U, which could either be a Cliquesize with fake value V, first vertex U, or a Cut with fake value V, first vertex U, so that there is a Cliquesize with fake value U, first vertex V."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Cliquesize with value L greater than 1, with id U, then we can have exactly 1 Cut with fake value V, with first vertex U such that there is a Cliquesize with fake value V, with first vertex U, or a Cut with fake value V, with first vertex U such that there is a Cliquesize with fake value U, with first vertex V.",
            "NL": "If a Cliquesize has an L value greater than 1 and id U, then we can find one Cut with fake value V, first vertex U, for which there is either a Cliquesize with fake value V, first vertex U, or a Cut with fake value V, with first vertex U, and a Cliquesize with fake value U, first vertex V."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Cliquesize with value L greater than 1, with id U, then we can have exactly 1 Cut with fake value V, with first vertex U such that there is a Cliquesize with fake value V, with first vertex U, or a Cut with fake value V, with first vertex U such that there is a Cliquesize with fake value U, with first vertex V.",
            "NL": "When a Cliquesize has a value L greater than 1, with id U, it is possible to have one Cut with fake value V, first vertex U, where there is either a Cliquesize with fake value V, first vertex U, or a Cut with fake value V, with first vertex U, and a Cliquesize with fake value U, with first vertex V."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Cliquesize with value L greater than 1, with id U, then we can have exactly 1 Cut with fake value V, with first vertex U such that there is a Cliquesize with fake value V, with first vertex U, or a Cut with fake value V, with first vertex U such that there is a Cliquesize with fake value U, with first vertex V.",
            "NL": "When Cliquesize has a value L greater than 1 and id U, we can have a Cut with fake value V and first vertex U, or a Cut with fake value V and first vertex U, such that there is a Cliquesize with fake value U and first vertex V."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Cliquesize with value L greater than 1, with id U, then we can have exactly 1 Cut with fake value V, with first vertex U such that there is a Cliquesize with fake value V, with first vertex U, or a Cut with fake value V, with first vertex U such that there is a Cliquesize with fake value U, with first vertex V.",
            "NL": "When a Cliquesize has a value L greater than 1, with id U, there can only be one Cut with fake value V, first vertex U, if there is a Cliquesize with fake value V, first vertex U, or a Cut with fake value V, with first vertex U, and a Cliquesize with fake value U, with first vertex V."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Clue S then we can have Incorporates with value H, with value S exactly 1 Lone with value H, with value S.",
            "NL": "It is possible to have a Lone with value H and value S when there is a Clue S, plus an additional Incorporate with value H and value S."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Clue S then we can have Incorporates with value H, with value S exactly 1 Lone with value H, with value S.",
            "NL": "It is possible to have Incorporates with value H and exactly one Lone with value S when there is a Clue S present."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Clue S then we can have Incorporates with value H, with value S exactly 1 Lone with value H, with value S.",
            "NL": "A Clue S can result in one Lone with value H and one Incorporate with value S."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Clue S then we can have Incorporates with value H, with value S exactly 1 Lone with value H, with value S.",
            "NL": "It is possible to have Incorporates with value H and one Lone with value S when there is a Clue S."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Clue S then we can have Incorporates with value H, with value S exactly 1 Lone with value H, with value S.",
            "NL": "It is feasible to have a Lone with value H and value S when there is a Clue S, along with Incorporates with value H and value S only one time."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Clue with field5 E, whenever there is a Parent with field5 B, then we can have between 16 and B Labeled with field5 L, and with id K such that there is a Directed_Graph U.",
            "NL": "Whenever we have Clue E and Parent B, we can label field5 L and field5 E between 16 and B with Directed_Graph L."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Clue with field5 E, whenever there is a Parent with field5 B, then we can have between 16 and B Labeled with field5 L, and with id K such that there is a Directed_Graph U.",
            "NL": "Whenever we have Clue E and Parent B, we can always label field5 L and field5 E with Directed_Graph L, ranging between 16 and B."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Clue with field5 E, whenever there is a Parent with field5 B, then we can have between 16 and B Labeled with field5 L, and with id K such that there is a Directed_Graph U.",
            "NL": "Whenever we have Clue E and Parent B, we can always have a Labeled field5 L and field5 E ranging between 16 and B, with Directed_Graph L."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Clue with field5 E, whenever there is a Parent with field5 B, then we can have between 16 and B Labeled with field5 L, and with id K such that there is a Directed_Graph U.",
            "NL": "Whenever Clue E and Parent B are present, we can label Field5 L and Field5 E with Directed_Graph L, ranging from 16 to B."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Clue with field5 E, whenever there is a Parent with field5 B, then we can have between 16 and B Labeled with field5 L, and with id K such that there is a Directed_Graph U.",
            "NL": "Whenever we have Clue E and Parent B, we can always have a Labeled field5 L with Directed_Graph L ranging between 16 and B."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Commence with value L greater than 1, with id U, then we can have exactly 1 Trivial with second id U, with fourth id M such that there is a Commence with second id U, with fourth id M, or a Trivial with second id U, with fourth id M such that there is a Commence with second id M, with fourth id U.",
            "NL": "If a Commence has a value L greater than 1, with id U, then there will be a Trivial with second id U, fourth id M, and either a Commence with second id U, fourth id M or a Trivial with second id U, fourth id M, plus a Commence with second id M, fourth id U."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Commence with value L greater than 1, with id U, then we can have exactly 1 Trivial with second id U, with fourth id M such that there is a Commence with second id U, with fourth id M, or a Trivial with second id U, with fourth id M such that there is a Commence with second id M, with fourth id U.",
            "NL": "If a Commence has a value L greater than 1, and its id is U, then there must be either a Trivial with second id U, fourth id M, and a Commence with second id U, fourth id M, or a Trivial with second id U, and fourth id M, and a Commence with second id M, and fourth id U."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Commence with value L greater than 1, with id U, then we can have exactly 1 Trivial with second id U, with fourth id M such that there is a Commence with second id U, with fourth id M, or a Trivial with second id U, with fourth id M such that there is a Commence with second id M, with fourth id U.",
            "NL": "If a Commence has a value of L greater than 1, with id U, then we can have either a Trivial with second id U, fourth id M, or a Commence with second id U, fourth id M, such that there is a corresponding Commence with second id M, with fourth id U."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Commence with value L greater than 1, with id U, then we can have exactly 1 Trivial with second id U, with fourth id M such that there is a Commence with second id U, with fourth id M, or a Trivial with second id U, with fourth id M such that there is a Commence with second id M, with fourth id U.",
            "NL": "If a Commence has a value L greater than 1 and an id U, then there must be either a Trivial with a second id U and fourth id M, or a Trivial with a second id U and fourth id M, and a Commence with a second id M and fourth id U."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Commence with value L greater than 1, with id U, then we can have exactly 1 Trivial with second id U, with fourth id M such that there is a Commence with second id U, with fourth id M, or a Trivial with second id U, with fourth id M such that there is a Commence with second id M, with fourth id U.",
            "NL": "For any Commence with a value L greater than 1 and id U, we can find either a Trivial with second id U, fourth id M, and a Commence with second id U, fourth id M, or a Trivial with second id U and fourth id M, and a Commence with second id M, fourth id U."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Compartment U then we can have Tinted with vtx1 A, with vtx1 U exactly 1 NonGrouping with vtx1 A, with vtx1 U.",
            "NL": "It is possible to have Tinted with vtx1 A and exactly one NonGrouping with vtx1 U whenever there is a Compartment U and vtx1 U."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Compartment U then we can have Tinted with vtx1 A, with vtx1 U exactly 1 NonGrouping with vtx1 A, with vtx1 U.",
            "NL": "It is possible to tint vtx1 A and vtx1 U with exactly one NonGrouping whenever there is a Compartment U."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Compartment U then we can have Tinted with vtx1 A, with vtx1 U exactly 1 NonGrouping with vtx1 A, with vtx1 U.",
            "NL": "It is possible to have Tinted with vtx1 A and exactly one NonGrouping with vtx1 U whenever there is a Compartment U, and vtx1 U in both cases."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Compartment U then we can have Tinted with vtx1 A, with vtx1 U exactly 1 NonGrouping with vtx1 A, with vtx1 U.",
            "NL": "It is possible to have Tinted with vtx1 A and vtx1 U, with exactly one NonGrouping with vtx1 A and vtx1 U, whenever there is a Compartment U."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Compartment U then we can have Tinted with vtx1 A, with vtx1 U exactly 1 NonGrouping with vtx1 A, with vtx1 U.",
            "NL": "It is possible to Tint with vtx1 A and vtx1 U, with exactly one NonGrouping when there is a Compartment U."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Complete with value equal to 5 then we can have at least 14 Colored with edge3 D such that there is a Cycle_Basis with field3 Dor a Colored with edge3 L such that there is a Cycle_Basis with field4 L.",
            "NL": "When a Complete has a value of 5, we can have at least 14 Coloreds with either an edge3 D and a Cycle_Basis with field3 D, or an edge3 L and a Cycle_Basis with field4 L."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Complete with value equal to 5 then we can have at least 14 Colored with edge3 D such that there is a Cycle_Basis with field3 Dor a Colored with edge3 L such that there is a Cycle_Basis with field4 L.",
            "NL": "If the Completeness is 5, we can have at least 14 Coloreds with edge3 D that have a Cycle_Basis with field3 D, or a Colored with edge3 L that has a Cycle_Basis with field4 L."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Complete with value equal to 5 then we can have at least 14 Colored with edge3 D such that there is a Cycle_Basis with field3 Dor a Colored with edge3 L such that there is a Cycle_Basis with field4 L.",
            "NL": "If the Complete is set at 5, there could be a minimum of 14 Colored with edge3 D, resulting in a Cycle_Basis with field3 D, or a Colored with edge3 L, leading to a Cycle_Basis with field4 L."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Complete with value equal to 5 then we can have at least 14 Colored with edge3 D such that there is a Cycle_Basis with field3 Dor a Colored with edge3 L such that there is a Cycle_Basis with field4 L.",
            "NL": "When a Complete has a value of 5, we can have at least 14 Colored with either edge3 D and a Cycle_Basis with field3 D or edge3 L and a Cycle_Basis with field4 L."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Complete with value equal to 5 then we can have at least 14 Colored with edge3 D such that there is a Cycle_Basis with field3 Dor a Colored with edge3 L such that there is a Cycle_Basis with field4 L.",
            "NL": "When a Completion has a value of 5, we can have at least 14 Coloreds with edge3 D that form a Cycle_Basis with field3 D, or a Colored with edge3 L that forms a Cycle_Basis with field4 L."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Complex C then we can have Span with value5 E, and with edge6 C exactly 31 Information E.",
            "NL": "We can always access 31 Information E with a value5 E and edge6 C whenever it is available."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Complex C then we can have Span with value5 E, and with edge6 C exactly 31 Information E.",
            "NL": "We can always have 31 Information E with a value5 E and edge6 C whenever it is available."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Complex C then we can have Span with value5 E, and with edge6 C exactly 31 Information E.",
            "NL": "We can always access 31 pieces of Information E with value5 E and edge6 C whenever there is a value5 E."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Complex C then we can have Span with value5 E, and with edge6 C exactly 31 Information E.",
            "NL": "We can always access 31 Information E with value5 E and edge6 C when there is a value5 E."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Complex C then we can have Span with value5 E, and with edge6 C exactly 31 Information E.",
            "NL": "Whenever there is a value5 E, we can always have 31 Information E with edge6 C."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Complicated with value equal to 43 then we can have at least 16 Minimum_Vertex_Cover with node1 B such that there is an Out_HamiltonianCycle with value Bor a Minimum_Vertex_Cover with node1 G such that there is an Out_HamiltonianCycle with edge4 G.",
            "NL": "When a Complicated has a value of 43, we can have at least 16 Minimum_Vertex_Cover with node1 B and an Out_HamiltonianCycle with value B, or a Minimum_Vertex_Cover with node1 G and an Out_HamiltonianCycle with edge4 G."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Complicated with value equal to 43 then we can have at least 16 Minimum_Vertex_Cover with node1 B such that there is an Out_HamiltonianCycle with value Bor a Minimum_Vertex_Cover with node1 G such that there is an Out_HamiltonianCycle with edge4 G.",
            "NL": "If the Complicated has a value of 43, then we can have a Minimum_Vertex_Cover of at least 16 with node1 B, resulting in an Out_HamiltonianCycle with value B, or a Minimum_Vertex_Cover with node1 G, leading to an Out_HamiltonianCycle with edge4 G."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Complicated with value equal to 43 then we can have at least 16 Minimum_Vertex_Cover with node1 B such that there is an Out_HamiltonianCycle with value Bor a Minimum_Vertex_Cover with node1 G such that there is an Out_HamiltonianCycle with edge4 G.",
            "NL": "If a Complicated has a value of 43, we can have a Minimum_Vertex_Cover of at least 16 which includes node1 B, resulting in an Out_HamiltonianCycle with value B, or a Minimum_Vertex_Cover with node1 G that produces an Out_HamiltonianCycle with edge4 G."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Complicated with value equal to 43 then we can have at least 16 Minimum_Vertex_Cover with node1 B such that there is an Out_HamiltonianCycle with value Bor a Minimum_Vertex_Cover with node1 G such that there is an Out_HamiltonianCycle with edge4 G.",
            "NL": "When a Complicated has a value of 43, node1 B can yield at least 16 Minimum_Vertex_Cover with an Out_HamiltonianCycle of value B, and node1 G can yield a Minimum_Vertex_Cover with an Out_HamiltonianCycle of edge4 G."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Complicated with value equal to 43 then we can have at least 16 Minimum_Vertex_Cover with node1 B such that there is an Out_HamiltonianCycle with value Bor a Minimum_Vertex_Cover with node1 G such that there is an Out_HamiltonianCycle with edge4 G.",
            "NL": "When the Complicated has a value of 43, we can have at least 16 Minimum_Vertex_Cover with node1 B which results in an Out_HamiltonianCycle with value B, or a Minimum_Vertex_Cover with node1 G which results in an Out_HamiltonianCycle with edge4 G."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Cut with value equal to 22 then we can have at least 35 Index with id8 G such that there is a Symbol with field6 Gor a Index with id8 K such that there is a Symbol with id K.",
            "NL": "If the Cut has a value of 22, we can have at least 35 Indexes with id8 G where there is a Symbol with field6 G, or an Index with id8 K with a Symbol having id K."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Cut with value equal to 22 then we can have at least 35 Index with id8 G such that there is a Symbol with field6 Gor a Index with id8 K such that there is a Symbol with id K.",
            "NL": "If the Cut has a value of 22, we can have at least 35 Indexes with an id8 G that has a Symbol with a field6 G, or an Index with an id8 K with a Symbol with an id K."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Cut with value equal to 22 then we can have at least 35 Index with id8 G such that there is a Symbol with field6 Gor a Index with id8 K such that there is a Symbol with id K.",
            "NL": "If a Cut has a value of 22, we can have at least 35 Indexes with id8 G where there is a Symbol with field6 G, or an Index with id8 K that has a Symbol with id K."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Cut with value equal to 22 then we can have at least 35 Index with id8 G such that there is a Symbol with field6 Gor a Index with id8 K such that there is a Symbol with id K.",
            "NL": "If a Cut has a value of 22, it is possible to have at least 35 Indexes with id8 G, each of which has a Symbol with field6 G, or have at least one Index with id8 K that has a Symbol with id K."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Cut with value equal to 22 then we can have at least 35 Index with id8 G such that there is a Symbol with field6 Gor a Index with id8 K such that there is a Symbol with id K.",
            "NL": "If the Cut has a value of 22, there can be at least 35 Indexes with id8 G where there is a Symbol with field6 G, or a Index with id8 K and a Symbol with id K."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Data with key8 H, and with vtx10 O, whenever there is a Mark with key8 H, and with vtx10 O, whenever there is not a Denied with layer vtx10 H, and with key8 D, then we can have at least 33 Partition with node7 H, and with id7 O, and with value1 D.",
            "NL": "If there is a Data with key8 H, a Mark with key8 H and vtx10 O, and no Denied with layer vtx10 H and key8 D, then we can have a minimum of 33 Partitions with node7 H, id7 O, and value1 D."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Data with key8 H, and with vtx10 O, whenever there is a Mark with key8 H, and with vtx10 O, whenever there is not a Denied with layer vtx10 H, and with key8 D, then we can have at least 33 Partition with node7 H, and with id7 O, and with value1 D.",
            "NL": "If Data with key8 H, Mark with key8 H and vtx10 O, and Denied with layer vtx10 H, key8 D all exist, we can create a minimum of 33 Partition with node7 H, id7 O and value1 D."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Data with key8 H, and with vtx10 O, whenever there is a Mark with key8 H, and with vtx10 O, whenever there is not a Denied with layer vtx10 H, and with key8 D, then we can have at least 33 Partition with node7 H, and with id7 O, and with value1 D.",
            "NL": "Provided that a Data with key8 H, a Mark with key8 H and vtx10 O exist, there will be no Denied with layer vtx10 H and key8 D, and thus we can have at least 33 Partition with node7 H, id7 O and value1 D."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Data with key8 H, and with vtx10 O, whenever there is a Mark with key8 H, and with vtx10 O, whenever there is not a Denied with layer vtx10 H, and with key8 D, then we can have at least 33 Partition with node7 H, and with id7 O, and with value1 D.",
            "NL": "If Data with key8 H, Mark with key8 H and vtx10 O, and Denied with layer vtx10 H, key8 D exist, then we can have a minimum of 33 Partition with node7 H, id7 O and value1 D."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Data with key8 H, and with vtx10 O, whenever there is a Mark with key8 H, and with vtx10 O, whenever there is not a Denied with layer vtx10 H, and with key8 D, then we can have at least 33 Partition with node7 H, and with id7 O, and with value1 D.",
            "NL": "If Data with key8 H and Mark with key8 H and vtx10 O exist, and there is no Denied with layer vtx10 H and key8 D, then 33 Partition with node7 H, id7 O, and value1 D can be achieved."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Degree_Sequence with value8 Q, then we can have exactly 15 link with edge8 U, with value K such that there is a Unmatch with value9 U, with node2 U, or a Partition with edge8 U, with value K such that there is an Unmatch with value9 Q, with value3 U.",
            "NL": "Whenever there is a Degree_Sequence node with value8 Q, we can have either 15 Partition nodes with edge8 U, with value K and an Unmatch with value9 Q, with value3 U, or a Partition node with edge8 U, with value K and an Unmatch with value9 Q, with value3 U."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Degree_Sequence with value8 Q, then we can have exactly 15 link with edge8 U, with value K such that there is a Unmatch with value9 U, with node2 U, or a Partition with edge8 U, with value K such that there is an Unmatch with value9 Q, with value3 U.",
            "NL": "We can have 15 Partition nodes with edge8 U, value K, and an Unmatch with value9 Q, value3 U, or a Partition node with edge8 U, value K, and an Unmatch with value9 Q, value3 U, each time there is a Degree_Sequence node with value8 Q."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Degree_Sequence with value8 Q, then we can have exactly 15 link with edge8 U, with value K such that there is a Unmatch with value9 U, with node2 U, or a Partition with edge8 U, with value K such that there is an Unmatch with value9 Q, with value3 U.",
            "NL": "We can have either 15 Partition nodes with edge8 U and value K, which will result in an Unmatch with value9 Q and value3 U, or a Partition node with edge8 U and value K, which will lead to an Unmatch with value9 Q and value3 U, provided there is a Degree_Sequence node with value8 Q."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Degree_Sequence with value8 Q, then we can have exactly 15 link with edge8 U, with value K such that there is a Unmatch with value9 U, with node2 U, or a Partition with edge8 U, with value K such that there is an Unmatch with value9 Q, with value3 U.",
            "NL": "We can have a Degree_Sequence node with value8 Q that is accompanied by either 15 Partition nodes with edge8 U and value K where there is an Unmatch with value9 Q and value3 U, or a Partition node with edge8 U, value K, and an Unmatch with value9 Q and value3 U."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Degree_Sequence with value8 Q, then we can have exactly 15 link with edge8 U, with value K such that there is a Unmatch with value9 U, with node2 U, or a Partition with edge8 U, with value K such that there is an Unmatch with value9 Q, with value3 U.",
            "NL": "Whenever there is a Degree_Sequence node with value8 Q, we can have either 15 Partition nodes with edge8 U and value K, resulting in an Unmatch with value9 Q and value3 U, or a Partition node with edge8 U, value K, and an Unmatch with value9 Q and value3 U."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Directed_Graph P then we can have Mark with vtx F, and with field2 P exactly 4 Dynamic F.",
            "NL": "We can always have a Dynamic F with a vtx F, and exactly four Dynamic F with field2 P, whenever a vtx F is present."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Directed_Graph P then we can have Mark with vtx F, and with field2 P exactly 4 Dynamic F.",
            "NL": "We can always create a Dynamic F with vtx F, and with field2 P exactly 4 Dynamic F, whenever vtx F is present."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Directed_Graph P then we can have Mark with vtx F, and with field2 P exactly 4 Dynamic F.",
            "NL": "We can always have a Dynamic F with a vtx F and four Dynamic F with a field2 P whenever there is a vtx F."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Directed_Graph P then we can have Mark with vtx F, and with field2 P exactly 4 Dynamic F.",
            "NL": "We can always have a Dynamic F with a vtx F and with field2 P exactly 4 Dynamic F whenever vtx F is present."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Directed_Graph P then we can have Mark with vtx F, and with field2 P exactly 4 Dynamic F.",
            "NL": "We can always have a Dynamic with vtx F and field2 P set to 4 Dynamic F whenever vtx F is present."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Distinct with value L greater than 1, with id U, then we can have exactly 1 Coloring with first point F, with second id U such that there is a Distinct with first point F, with second id U, or a Coloring with first point F, with second id U such that there is an Distinct with first point U, with second id F.",
            "NL": "For any Distinct with a value L greater than 1 and id U, there is exactly one Coloring with first point F, second id U, for which there is either a Distinct with first point F, second id U, or a Coloring with first point F, second id U, and a Distinct with first point U, second id F."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Distinct with value L greater than 1, with id U, then we can have exactly 1 Coloring with first point F, with second id U such that there is a Distinct with first point F, with second id U, or a Coloring with first point F, with second id U such that there is an Distinct with first point U, with second id F.",
            "NL": "If the Distinct's value L is greater than 1 and its id is U, then we can find either a Distinct whose first point is F and second id is U, or a Coloring with first point F and second id U, where there is a Distinct with first point U and second id F."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Distinct with value L greater than 1, with id U, then we can have exactly 1 Coloring with first point F, with second id U such that there is a Distinct with first point F, with second id U, or a Coloring with first point F, with second id U such that there is an Distinct with first point U, with second id F.",
            "NL": "If a Distinct has a value of L greater than 1 and an id of U, there is always one Coloring with a first point of F, a second id of U, for which there is either a Distinct with a first point of F and a second id of U, or a Coloring with a first point of F and a second id of U, and a Distinct with a first point of U and a second id of F."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Distinct with value L greater than 1, with id U, then we can have exactly 1 Coloring with first point F, with second id U such that there is a Distinct with first point F, with second id U, or a Coloring with first point F, with second id U such that there is an Distinct with first point U, with second id F.",
            "NL": "When a Distinct has a value of L larger than 1, with an id of U, there is always one Coloring with a first point of F, second id of U, for which there is either a Distinct with first point F and second id U or a Coloring with first point F and second id U, for which there is a Distinct with first point U and second id F."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Distinct with value L greater than 1, with id U, then we can have exactly 1 Coloring with first point F, with second id U such that there is a Distinct with first point F, with second id U, or a Coloring with first point F, with second id U such that there is an Distinct with first point U, with second id F.",
            "NL": "If a Distinct has a value L greater than 1 and an id U, there can only be one Coloring with first point F and second id U, or a Coloring with first point F and second id U, for which there is a Distinct with first point U and second id F."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Diversity with value equal to 5 then we can have at least 18 Contains with node8 U such that there is a Solitary with node1 Uor a Contains with node8 O such that there is a Solitary with field4 O.",
            "NL": "If the Diversity value is 5, there must be at least 18 Contains with node8 U to have a Solitary with node1 U, or a Contains with node8 O to have a Solitary with field4 O."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Diversity with value equal to 5 then we can have at least 18 Contains with node8 U such that there is a Solitary with node1 Uor a Contains with node8 O such that there is a Solitary with field4 O.",
            "NL": "When the Diversity value is 5, we can have at least 18 Contains with node8 U and either a Solitary with node1 U or a Contains with node8 O and a Solitary with field4 O."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Diversity with value equal to 5 then we can have at least 18 Contains with node8 U such that there is a Solitary with node1 Uor a Contains with node8 O such that there is a Solitary with field4 O.",
            "NL": "If the Diversity is equal to 5, we can have a minimum of 18 Contains with node8 U, one of which has a Solitary with node1 U, or a Contains with node8 O, which also has a Solitary with field4 O."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Diversity with value equal to 5 then we can have at least 18 Contains with node8 U such that there is a Solitary with node1 Uor a Contains with node8 O such that there is a Solitary with field4 O.",
            "NL": "If Diversity is 5, we can have a minimum of 18 Contains with node8 U and a Solitary with node1 U, or a Contains with node8 O and a Solitary with field4 O."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Diversity with value equal to 5 then we can have at least 18 Contains with node8 U such that there is a Solitary with node1 Uor a Contains with node8 O such that there is a Solitary with field4 O.",
            "NL": "If Diversity is equal to 5, we can have a minimum of 18 Contains with node8 U, one of which will have a Solitary with node1 U or a Contains with node8 O, where there is a Solitary with field4 O."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Divide with value equal to 13 then we can have at least 32 Reference with value3 F such that there is an Inpath with edge For a Reference with value3 P such that there is an Inpath with vtx2 P.",
            "NL": "If a Divide is equal to 13, there will be at least 32 References with value3 F, which means there will be an Inpath with edge F, or a Reference with value3 P, with an Inpath having vtx2 P."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Divide with value equal to 13 then we can have at least 32 Reference with value3 F such that there is an Inpath with edge For a Reference with value3 P such that there is an Inpath with vtx2 P.",
            "NL": "If the Divide has a value of 13, we can find at least 32 References with a value of F that have an Inpath with an edge of F, or a Reference with a value of P that has an Inpath with a vtx2 of P."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Divide with value equal to 13 then we can have at least 32 Reference with value3 F such that there is an Inpath with edge For a Reference with value3 P such that there is an Inpath with vtx2 P.",
            "NL": "If the Division is 13, then there will be at least 32 References with a value of F which will result in an Inpath with an edge F or a Reference with a value of P with a vtx2 P."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Divide with value equal to 13 then we can have at least 32 Reference with value3 F such that there is an Inpath with edge For a Reference with value3 P such that there is an Inpath with vtx2 P.",
            "NL": "If the Divide has a value of 13, we can have at least 32 References with value3 F, with an Inpath including edge F, or a Reference with value3 P, with an Inpath including vtx2 P."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Divide with value equal to 13 then we can have at least 32 Reference with value3 F such that there is an Inpath with edge For a Reference with value3 P such that there is an Inpath with vtx2 P.",
            "NL": "If the Divide has a value of 13, at least 32 References with value3 F can be present, allowing for an Inpath with edge F or a Reference with value3 P, which would then have an Inpath with vtx2 P."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Dormant G then we can have Level_Vertex with edge4 M, with edge4 G exactly 1 Relevant with edge4 M, with edge4 G.",
            "NL": "It is possible for there to be a Level_Vertex with edge4 M, with edge4 G having precisely one Relevant connection with edge4 M, and edge4 G being Dormant whenever there is a G."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Dormant G then we can have Level_Vertex with edge4 M, with edge4 G exactly 1 Relevant with edge4 M, with edge4 G.",
            "NL": "It is possible for there to be a Level_Vertex connected to both M and G, with G being related to M when G is dormant."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Dormant G then we can have Level_Vertex with edge4 M, with edge4 G exactly 1 Relevant with edge4 M, with edge4 G.",
            "NL": "There is a potential for Level_Vertex to have a relationship of M with G of 1 when G is Dormant."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Dormant G then we can have Level_Vertex with edge4 M, with edge4 G exactly 1 Relevant with edge4 M, with edge4 G.",
            "NL": "Level_Vertex can be connected to both M and G, with G being dormant and exactly 1 Relevant with M, whenever G is present."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Dormant G then we can have Level_Vertex with edge4 M, with edge4 G exactly 1 Relevant with edge4 M, with edge4 G.",
            "NL": "A Level_Vertex with edge4 M can have exactly 1 Relevant edge4 G whenever there is a Dormant G."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Dormant with edge3 K, then we can have exactly 48 link with vtx6 F, with vtx2 R such that there is a Connection with field6 F, with node2 U, or a NonConsecutive with vtx6 F, with vtx2 R such that there is an Connection with field6 K, with edge1 F.",
            "NL": "We can have up to 48 NonConsecutive nodes with vtx6 F, vtx2 R, and a Connection with field6 K, edge1 F, or a NonConsecutive node with vtx6 F, vtx2 R, and a Connection with field6 K, edge1 F whenever there is a Dormant node with edge3 K."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Dormant with edge3 K, then we can have exactly 48 link with vtx6 F, with vtx2 R such that there is a Connection with field6 F, with node2 U, or a NonConsecutive with vtx6 F, with vtx2 R such that there is an Connection with field6 K, with edge1 F.",
            "NL": "We can have up to 48 NonConsecutive nodes with vtx6 F, vtx2 R, and a Connection with field6 K, edge1 F, or a NonConsecutive node with vtx6 F, vtx2 R, and a Connection with field6 K, edge1 F in existence when there is a Dormant node with edge3 K."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Dormant with edge3 K, then we can have exactly 48 link with vtx6 F, with vtx2 R such that there is a Connection with field6 F, with node2 U, or a NonConsecutive with vtx6 F, with vtx2 R such that there is an Connection with field6 K, with edge1 F.",
            "NL": "We can have a maximum of 48 NonConsecutive nodes with vtx6 F, vtx2 R, and field6 K, with edge1 F, or a NonConsecutive node with vtx6 F, vtx2 R, and field6 K, with edge1 F, provided that there is a Dormant node with edge3 K."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Dormant with edge3 K, then we can have exactly 48 link with vtx6 F, with vtx2 R such that there is a Connection with field6 F, with node2 U, or a NonConsecutive with vtx6 F, with vtx2 R such that there is an Connection with field6 K, with edge1 F.",
            "NL": "We can have up to 48 NonConsecutive nodes with vtx6 F and vtx2 R, and each node must have a Connection with field6 K and edge1 F, or a NonConsecutive node with vtx6 F, vtx2 R, a Connection with field6 K, and edge1 F if there is a Dormant node with edge3 K."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Dormant with edge3 K, then we can have exactly 48 link with vtx6 F, with vtx2 R such that there is a Connection with field6 F, with node2 U, or a NonConsecutive with vtx6 F, with vtx2 R such that there is an Connection with field6 K, with edge1 F.",
            "NL": "We can have up to 48 NonConsecutive nodes with vtx6 F, vtx2 R, and a Connection with field6 K, and edge1 F, or a NonConsecutive node with vtx6 F, vtx2 R, and a Connection with field6 K, and edge1 F provided a Dormant node with edge3 K is present."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Edge_Pair P then we can have NonForemost with id3 Y, and with node8 P exactly 37 Minimum_Vertex_Cover Y.",
            "NL": "Whenever there is an id3 Y, we can always obtain a Minimum_Vertex_Cover Y with node8 P, consisting of exactly 37 elements."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Edge_Pair P then we can have NonForemost with id3 Y, and with node8 P exactly 37 Minimum_Vertex_Cover Y.",
            "NL": "We can always obtain a Minimum_Vertex_Cover with id3 Y and node8 P of exactly 37 Minimum_Vertex_Cover Y whenever id3 Y is present."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Edge_Pair P then we can have NonForemost with id3 Y, and with node8 P exactly 37 Minimum_Vertex_Cover Y.",
            "NL": "We can always obtain a Minimum_Vertex_Cover Y with id3 Y and node8 P, of exactly 37 Minimum_Vertex_Cover Y, whenever id3 Y is present."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Edge_Pair P then we can have NonForemost with id3 Y, and with node8 P exactly 37 Minimum_Vertex_Cover Y.",
            "NL": "We can always obtain a Minimum_Vertex_Cover Y with node8 P of exactly 37 elements, whenever there is an id3 Y."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Edge_Pair P then we can have NonForemost with id3 Y, and with node8 P exactly 37 Minimum_Vertex_Cover Y.",
            "NL": "We can always find a Minimum_Vertex_Cover Y with node8 P consisting of exactly 37 Minimum_Vertex_Cover Y elements whenever an id3 Y is present."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Edge_Tag with value7 C, then we can have exactly 37 link with field5 Y, with id2 S such that there is a Penalty with key7 Y, with node2 U, or a Dual_Graph with field5 Y, with id2 S such that there is a Penalty with key7 C, with edge8 Y.",
            "NL": "We can have up to 37 Dual_Graph nodes with field5 Y, and id2 S, so that there is either a Penalty with key7 C, and edge8 Y, or a Dual_Graph node with field5 Y, and id2 S, that has a Penalty with key7 C, and edge8 Y, each time an Edge_Tag node with value7 C is present."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Edge_Tag with value7 C, then we can have exactly 37 link with field5 Y, with id2 S such that there is a Penalty with key7 Y, with node2 U, or a Dual_Graph with field5 Y, with id2 S such that there is a Penalty with key7 C, with edge8 Y.",
            "NL": "Whenever there is an Edge_Tag node with value7 C, we can have either a Dual_Graph node with field5 Y, id2 S, and a Penalty with key7 C and edge8 Y, or a Dual_Graph node with field5 Y, id2 S, and a Penalty with key7 C, and edge8 Y, for a total of exactly 37 nodes."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Edge_Tag with value7 C, then we can have exactly 37 link with field5 Y, with id2 S such that there is a Penalty with key7 Y, with node2 U, or a Dual_Graph with field5 Y, with id2 S such that there is a Penalty with key7 C, with edge8 Y.",
            "NL": "We can have up to 37 Dual_Graph nodes with field5 Y, and id2 S, that have a Penalty with key7 C, and edge8 Y, or a Dual_Graph node with field5 Y, and id2 S, that has a Penalty with key7 C, and edge8 Y, each time an Edge_Tag node with value7 C is present."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Edge_Tag with value7 C, then we can have exactly 37 link with field5 Y, with id2 S such that there is a Penalty with key7 Y, with node2 U, or a Dual_Graph with field5 Y, with id2 S such that there is a Penalty with key7 C, with edge8 Y.",
            "NL": "We can have up to 37 Dual_Graph nodes with field5 Y, id2 S, and a Penalty with key7 C and edge8 Y, or a Dual_Graph node with field5 Y, id2 S, and a Penalty with key7 C and edge8 Y, only if there is an Edge_Tag node with value7 C present."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Edge_Tag with value7 C, then we can have exactly 37 link with field5 Y, with id2 S such that there is a Penalty with key7 Y, with node2 U, or a Dual_Graph with field5 Y, with id2 S such that there is a Penalty with key7 C, with edge8 Y.",
            "NL": "We can have 37 Dual_Graph nodes with field5 Y, id2 S, and a Penalty with key7 C, edge8 Y, or a Dual_Graph node with field5 Y, id2 S with a Penalty with key7 C, edge8 Y when an Edge_Tag node with value7 C is present."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Father_Edge with field10 T, then we can have exactly 22 link with node10 D, with node1 R such that there is a Short with edge D, with node2 U, or a Center with node10 D, with node1 R such that there is an Short with edge T, with value5 D.",
            "NL": "We can have either 22 Center nodes with node10 D and node1 R, along with a Short edge with value5 D, or a Center node with node10 D and node1 R, with a Short edge having value5 D, provided there is a Father_Edge node with field10 T."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Father_Edge with field10 T, then we can have exactly 22 link with node10 D, with node1 R such that there is a Short with edge D, with node2 U, or a Center with node10 D, with node1 R such that there is an Short with edge T, with value5 D.",
            "NL": "We can have either 22 Center nodes with node10 D and node1 R, which have a Short with edge T and value5 D, or a Center node with node10 D and node1 R, which has a Short with edge T and value5 D, whenever there is a Father_Edge node with field10 T."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Father_Edge with field10 T, then we can have exactly 22 link with node10 D, with node1 R such that there is a Short with edge D, with node2 U, or a Center with node10 D, with node1 R such that there is an Short with edge T, with value5 D.",
            "NL": "We can have up to 22 Center nodes, each with node10 D and node1 R, that are connected by a Short with edge T and value5 D, or a Father_Edge node with field10 T, which would then have a Center node with node10 D, node1 R, and a Short with edge T and value5 D."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Father_Edge with field10 T, then we can have exactly 22 link with node10 D, with node1 R such that there is a Short with edge D, with node2 U, or a Center with node10 D, with node1 R such that there is an Short with edge T, with value5 D.",
            "NL": "We can have either 22 Center nodes with node10 D, node1 R and a Short with edge T, value5 D, or a Center node with node10 D, node1 R, a Short with edge T, and value5 D whenever there is a Father_Edge node with field10 T."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Father_Edge with field10 T, then we can have exactly 22 link with node10 D, with node1 R such that there is a Short with edge D, with node2 U, or a Center with node10 D, with node1 R such that there is an Short with edge T, with value5 D.",
            "NL": "We can have 22 Center nodes, each with node10 D and node1 R, that have a Short with edge T and value5 D, or a Center node with node10 D and node1 R, as long as there is a Father_Edge node with field10 T."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a First with vtx1 Y, then we can have exactly 43 link with node M, with id O such that there is a Load with key9 M, with node2 U, or a Earliest with node M, with id O such that there is an Load with key9 Y, with key8 M.",
            "NL": "We can guarantee that whenever there is a first node with vtx1 Y, there will be either a Load with key9 Y and key8 M, or a Earliest node with node M and id O, and no more than 43 Earliest nodes."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a First with vtx1 Y, then we can have exactly 43 link with node M, with id O such that there is a Load with key9 M, with node2 U, or a Earliest with node M, with id O such that there is an Load with key9 Y, with key8 M.",
            "NL": "We can have 43 Earliest nodes with node M and id O, each having a Load with key9 Y and key8 M, or a Earliest node with node M and id O, that has a Load with key9 Y and key8 M, when there is a first node with vtx1 Y."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a First with vtx1 Y, then we can have exactly 43 link with node M, with id O such that there is a Load with key9 M, with node2 U, or a Earliest with node M, with id O such that there is an Load with key9 Y, with key8 M.",
            "NL": "We can have up to 43 first nodes with vtx1 Y, node M, and id O, each with a Load containing key9 Y and key8 M, or a Earliest node with node M, id O, and a Load with key9 Y and key8 M."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a First with vtx1 Y, then we can have exactly 43 link with node M, with id O such that there is a Load with key9 M, with node2 U, or a Earliest with node M, with id O such that there is an Load with key9 Y, with key8 M.",
            "NL": "Whenever there is a first node with vtx1 Y, we can have either 43 Earliest nodes with node M and id O that have a Load with key9 Y and key8 M, or an Earliest node with node M and id O that has a Load with key9 Y and key8 M."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a First with vtx1 Y, then we can have exactly 43 link with node M, with id O such that there is a Load with key9 M, with node2 U, or a Earliest with node M, with id O such that there is an Load with key9 Y, with key8 M.",
            "NL": "We can have up to 43 first nodes with node M and id O, all of which have a Load with key9 Y and key8 M, or an Earliest node with node M and id O that has a Load with key9 Y and key8 M whenever there is a first node with vtx1 Y."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Flow with field3 X, then we can have exactly 44 link with field1 Y, with node1 E such that there is an Out_Hamiltonian_Tour with vtx1 Y, with node2 U, or a LessThanExists with field1 Y, with node1 E such that there is an Out_Hamiltonian_Tour with vtx1 X, with field7 Y.",
            "NL": "We can have up to 44 LessThanExists nodes with field1 Y, node1 E, and vtx1 X with field7 Y, or a LessThanExists node with field1 Y, node1 E, and vtx1 X with field7 Y in the event of a Flow node with field3 X existing."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Flow with field3 X, then we can have exactly 44 link with field1 Y, with node1 E such that there is an Out_Hamiltonian_Tour with vtx1 Y, with node2 U, or a LessThanExists with field1 Y, with node1 E such that there is an Out_Hamiltonian_Tour with vtx1 X, with field7 Y.",
            "NL": "We can have a maximum of 44 LessThanExists nodes with field1 Y, node1 E, and vtx1 X, with field7 Y, or a LessThanExists node with field1 Y, node1 E, and vtx1 X, with field7 Y if there is a Flow node with field3 X."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Flow with field3 X, then we can have exactly 44 link with field1 Y, with node1 E such that there is an Out_Hamiltonian_Tour with vtx1 Y, with node2 U, or a LessThanExists with field1 Y, with node1 E such that there is an Out_Hamiltonian_Tour with vtx1 X, with field7 Y.",
            "NL": "We can find a Flow node with field3 X, which would result in either 44 LessThanExists nodes with field1 Y, with node1 E having an Out_Hamiltonian_Tour with vtx1 X, with field7 Y, or a LessThanExists node with field1 Y, with node1 E possessing an Out_Hamiltonian_Tour with vtx1 X, with field7 Y."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Flow with field3 X, then we can have exactly 44 link with field1 Y, with node1 E such that there is an Out_Hamiltonian_Tour with vtx1 Y, with node2 U, or a LessThanExists with field1 Y, with node1 E such that there is an Out_Hamiltonian_Tour with vtx1 X, with field7 Y.",
            "NL": "We can have a maximum of 44 LessThanExists nodes with field1 Y, node1 E, an Out_Hamiltonian_Tour with vtx1 X, and field7 Y, or a LessThanExists node with field1 Y, node1 E, an Out_Hamiltonian_Tour with vtx1 X, and field7 Y, provided there is a Flow node with field3 X."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Flow with field3 X, then we can have exactly 44 link with field1 Y, with node1 E such that there is an Out_Hamiltonian_Tour with vtx1 Y, with node2 U, or a LessThanExists with field1 Y, with node1 E such that there is an Out_Hamiltonian_Tour with vtx1 X, with field7 Y.",
            "NL": "If there is a Flow node with field3 X, we can have 44 LessThanExists nodes with field1 Y, with node1 E such that there is an Out_Hamiltonian_Tour with vtx1 X, with field7 Y, or a LessThanExists node with field1 Y, with node1 E such that there is an Out_Hamiltonian_Tour with vtx1 X, with field7 Y."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Following with id1 A, and with edge8 Z, whenever there is an Ending with id1 A, and with edge8 Z, whenever there is not a Simple_Graph with layer edge8 A, and with id1 T, then we can have at least 9 Vertex with key7 A, and with vtx1 Z, and with id6 T.",
            "NL": "If there is not a Simple_Graph with edge8 A, id1 T, and layer id1 A, as well as edge8 Z, then we can have a minimum of 9 Vertex with key7 A, vtx1 Z, and id6 T."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Following with id1 A, and with edge8 Z, whenever there is an Ending with id1 A, and with edge8 Z, whenever there is not a Simple_Graph with layer edge8 A, and with id1 T, then we can have at least 9 Vertex with key7 A, and with vtx1 Z, and with id6 T.",
            "NL": "If no Simple_Graph exists with layer edge8 A, id1 T, and edge8 Z, then we can have at least 9 Vertex with key7 A, vtx1 Z, and id6 T, provided that there is a Following with id1 A and an Ending with id1 A."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Following with id1 A, and with edge8 Z, whenever there is an Ending with id1 A, and with edge8 Z, whenever there is not a Simple_Graph with layer edge8 A, and with id1 T, then we can have at least 9 Vertex with key7 A, and with vtx1 Z, and with id6 T.",
            "NL": "If there is no Simple_Graph with layer edge8 A, id1 T, and edge8 Z, then we can have at least 9 Vertex with key7 A, vtx1 Z, and id6 T, provided that there is a Following with id1 A and an Ending with id1 A."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Following with id1 A, and with edge8 Z, whenever there is an Ending with id1 A, and with edge8 Z, whenever there is not a Simple_Graph with layer edge8 A, and with id1 T, then we can have at least 9 Vertex with key7 A, and with vtx1 Z, and with id6 T.",
            "NL": "If there is not a Simple_Graph that has edge8 A, id1 T, and id1 A, and Ending with edge8 Z, then we can have at least 9 Vertex that have key7 A, vtx1 Z, and id6 T."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Following with id1 A, and with edge8 Z, whenever there is an Ending with id1 A, and with edge8 Z, whenever there is not a Simple_Graph with layer edge8 A, and with id1 T, then we can have at least 9 Vertex with key7 A, and with vtx1 Z, and with id6 T.",
            "NL": "If there is not a Simple_Graph with layer edge8 A, id1 T, and edge8 Z, we can have at least 9 Vertex with key7 A, vtx1 Z, and id6 T as long as there is a Following with id1 A and an Ending with id1 A."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Following with value equal to 6 then we can have at least 44 Following with node H such that there is an Distinct with value2 Hor a Following with node R such that there is an Distinct with id8 R.",
            "NL": "If the value of a Following is 6, then we can have a minimum of 44 Followings with node H, for which there is a Distinct with value2 H, or a Following with node R, for which there is a Distinct with id8 R."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Following with value equal to 6 then we can have at least 44 Following with node H such that there is an Distinct with value2 Hor a Following with node R such that there is an Distinct with id8 R.",
            "NL": "When the value of a Following is 6, we can have at least 44 Followings with node H that have a Distinct with value2 H, or a Following with node R that has a Distinct with id8 R."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Following with value equal to 6 then we can have at least 44 Following with node H such that there is an Distinct with value2 Hor a Following with node R such that there is an Distinct with id8 R.",
            "NL": "If the value of a Following is 6, we can have at least 44 Followings associated with node H, as long as there is a Distinct with value2 H or a Following with node R and a Distinct with id8 R."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Following with value equal to 6 then we can have at least 44 Following with node H such that there is an Distinct with value2 Hor a Following with node R such that there is an Distinct with id8 R.",
            "NL": "If the value of a Following is 6, we can have at least 44 Followings with node H, so that there is either a Distinct with value2 H or a Following with node R with a Distinct with id8 R."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Following with value equal to 6 then we can have at least 44 Following with node H such that there is an Distinct with value2 Hor a Following with node R such that there is an Distinct with id8 R.",
            "NL": "If the value of a Following is 6, we can have at least 44 Followings with node H, each of which has a Distinct with value2 H, or a Following with node R, with a Distinct with id8 R."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Forest with value equal to 4 then we can have at least 18 First with field E such that there is an Statistical_Significance with edge7 Eor a First with field Y such that there is an Statistical_Significance with id9 Y.",
            "NL": "If the value of a Forest is 4, then at least 18 Firsts with field E are possible, which would result in a Statistical_Significance with edge7 E, or a First with field Y that would have a Statistical_Significance with id9 Y."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Forest with value equal to 4 then we can have at least 18 First with field E such that there is an Statistical_Significance with edge7 Eor a First with field Y such that there is an Statistical_Significance with id9 Y.",
            "NL": "When the Forest has a value of 4, we can have at least 18 Firsts with either field E or field Y such that there is a Statistical_Significance with either edge7 E or id9 Y."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Forest with value equal to 4 then we can have at least 18 First with field E such that there is an Statistical_Significance with edge7 Eor a First with field Y such that there is an Statistical_Significance with id9 Y.",
            "NL": "When the Forest has a value of 4, we can have a minimum of 18 Firsts that have a Statistical_Significance with either edge7 E or id9 Y, depending on the field."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Forest with value equal to 4 then we can have at least 18 First with field E such that there is an Statistical_Significance with edge7 Eor a First with field Y such that there is an Statistical_Significance with id9 Y.",
            "NL": "When a Forest has a value of 4, we can have at least 18 Firsts with either field E and Statistical_Significance with edge7 E, or field Y and Statistical_Significance with id9 Y."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Forest with value equal to 4 then we can have at least 18 First with field E such that there is an Statistical_Significance with edge7 Eor a First with field Y such that there is an Statistical_Significance with id9 Y.",
            "NL": "When a Forest has a value of 4, we can have at least 18 Firsts with either field E having Statistical_Significance with edge7 E or field Y having Statistical_Significance with id9 Y."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Full with value L greater than 1, with id U, then we can have exactly 1 Pointer with fifth node C, with fifth id I such that there is a Full with fifth node C, with fifth id I, or a Pointer with fifth node C, with fifth id I such that there is a Full with fifth node I, with fifth id C.",
            "NL": "If Full has a value L greater than one and its id is U, then there will be one Pointer with fifth node C, fifth id I, either with a Full with fifth node C, fifth id I, or a Pointer with fifth node C, fifth id I, that has a Full with fifth node I, fifth id C."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Full with value L greater than 1, with id U, then we can have exactly 1 Pointer with fifth node C, with fifth id I such that there is a Full with fifth node C, with fifth id I, or a Pointer with fifth node C, with fifth id I such that there is a Full with fifth node I, with fifth id C.",
            "NL": "For every Full with value L greater than 1 and id U, there is either a Full with fifth node C and fifth id I or a Pointer with fifth node C and fifth id I, and a Full with fifth node I and fifth id C."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Full with value L greater than 1, with id U, then we can have exactly 1 Pointer with fifth node C, with fifth id I such that there is a Full with fifth node C, with fifth id I, or a Pointer with fifth node C, with fifth id I such that there is a Full with fifth node I, with fifth id C.",
            "NL": "If a Full has a value L greater than 1, with an id of U, then there must be either a Full with fifth node C, fifth id I, or a Pointer with fifth node C, fifth id I, and a Full with fifth node I, fifth id C."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Full with value L greater than 1, with id U, then we can have exactly 1 Pointer with fifth node C, with fifth id I such that there is a Full with fifth node C, with fifth id I, or a Pointer with fifth node C, with fifth id I such that there is a Full with fifth node I, with fifth id C.",
            "NL": "If there is a Full with a value L greater than 1, and an id U, we can have either a Full with fifth node C, fifth id I, or a Pointer with fifth node C, fifth id I, and a Full with fifth node I, fifth id C."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Full with value L greater than 1, with id U, then we can have exactly 1 Pointer with fifth node C, with fifth id I such that there is a Full with fifth node C, with fifth id I, or a Pointer with fifth node C, with fifth id I such that there is a Full with fifth node I, with fifth id C.",
            "NL": "Whenever there is a Full with a value L greater than 1 and an id U, we can find either a Full with fifth node C, fifth id I, or a Pointer with fifth node C, fifth id I, and a Full with fifth node I, fifth id C."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Gravity O, then we can have exactly 39 Edge_Match with id3 O, and with key10 K such that there is a Tint K.",
            "NL": "We can always perform an Edge_Match with id3 O and key10 K, with exactly 39 Tint K, in the presence of a Gravity O."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Gravity O, then we can have exactly 39 Edge_Match with id3 O, and with key10 K such that there is a Tint K.",
            "NL": "We can always have an Edge_Match with id3 O and key10 K, with exactly 39 Tint K, whenever Gravity O is present."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Gravity O, then we can have exactly 39 Edge_Match with id3 O, and with key10 K such that there is a Tint K.",
            "NL": "We can always perform an Edge_Match with id3 O and key10 K to exactly 39 Tint K when there is a Gravity O."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Gravity O, then we can have exactly 39 Edge_Match with id3 O, and with key10 K such that there is a Tint K.",
            "NL": "We can always perform an Edge_Match with id3 O and key10 K, set to 39 Tint K, in the presence of Gravity O."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Gravity O, then we can have exactly 39 Edge_Match with id3 O, and with key10 K such that there is a Tint K.",
            "NL": "We can always have an Edge_Match with id3 O and key10 K with 39 Tint K when Gravity O is present."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Hamiltonian_Cycle with key4 X, and with vtx3 E, whenever there is an Incoming_Level with key4 X, and with vtx3 E, whenever there is not a Edge_Pair with layer vtx3 X, and with key4 K, then we can have at least 36 Graph with id6 X, and with edge4 E, and with id5 K.",
            "NL": "If there is a Hamiltonian_Cycle with key4 X, an Incoming_Level with key4 X and vtx3 E, and no Edge_Pair with layer vtx3 X and key4 K, then we can have at least 36 Graphs with id6 X, edge4 E, and id5 K."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Hamiltonian_Cycle with key4 X, and with vtx3 E, whenever there is an Incoming_Level with key4 X, and with vtx3 E, whenever there is not a Edge_Pair with layer vtx3 X, and with key4 K, then we can have at least 36 Graph with id6 X, and with edge4 E, and with id5 K.",
            "NL": "If a Hamiltonian_Cycle with key4 X, an Incoming_Level with key4 X and vtx3 E exists, there will be no Edge_Pair with layer vtx3 X and key4 K, resulting in at least 36 Graphs with id6 X, edge4 E and id5 K."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Hamiltonian_Cycle with key4 X, and with vtx3 E, whenever there is an Incoming_Level with key4 X, and with vtx3 E, whenever there is not a Edge_Pair with layer vtx3 X, and with key4 K, then we can have at least 36 Graph with id6 X, and with edge4 E, and with id5 K.",
            "NL": "If there exists a Hamiltonian_Cycle with key4 X, an Incoming_Level with key4 X and vtx3 E, and no Edge_Pair with layer vtx3 X and key4 K, then we can have at least 36 Graphs with id6 X, edge4 E, and id5 K."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Hamiltonian_Cycle with key4 X, and with vtx3 E, whenever there is an Incoming_Level with key4 X, and with vtx3 E, whenever there is not a Edge_Pair with layer vtx3 X, and with key4 K, then we can have at least 36 Graph with id6 X, and with edge4 E, and with id5 K.",
            "NL": "If there is a Hamiltonian_Cycle with key4 X, an Incoming_Level with key4 X and vtx3 E, and no Edge_Pair with layer vtx3 X and key4 K, then we can have at least 36 Graphs with id6 X, edge4 E and id5 K."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Hamiltonian_Cycle with key4 X, and with vtx3 E, whenever there is an Incoming_Level with key4 X, and with vtx3 E, whenever there is not a Edge_Pair with layer vtx3 X, and with key4 K, then we can have at least 36 Graph with id6 X, and with edge4 E, and with id5 K.",
            "NL": "If there is a Hamiltonian_Cycle with key4 X, an Incoming_Level with key4 X and vtx3 E, and no Edge_Pair with layer vtx3 X and key4 K, then we can have a minimum of 36 Graphs with id6 X, edge4 E, and id5 K."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Hue G then we can have Inpath with key9 Q, with key9 G exactly 1 Wanting with key9 Q, with key9 G.",
            "NL": "It is possible to have Inpath with key9 Q and key9 G, with one instance of key9 Q and key9 G whenever there is a Hue G."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Hue G then we can have Inpath with key9 Q, with key9 G exactly 1 Wanting with key9 Q, with key9 G.",
            "NL": "It is possible to have Inpath with key9 Q and key9 G, one Wanting with key9 Q and key9 G whenever there is a Hue G."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Hue G then we can have Inpath with key9 Q, with key9 G exactly 1 Wanting with key9 Q, with key9 G.",
            "NL": "It is possible to have Inpath with key9 Q and key9 G, with exactly one Wanting with key9 Q and key9 G when there is a Hue G."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Hue G then we can have Inpath with key9 Q, with key9 G exactly 1 Wanting with key9 Q, with key9 G.",
            "NL": "It is possible to have Inpath with key9 Q and key9 G, with one of them being a Hue G, whenever there is a need for it."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Hue G then we can have Inpath with key9 Q, with key9 G exactly 1 Wanting with key9 Q, with key9 G.",
            "NL": "It is possible to have Inpath with key9 Q and key9 G, specifically 1 Wanting with key9 Q and key9 G whenever there is a Hue G."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a In_Layer with value6 O, whenever there is a Reckoning with value6 T, then we can have between 9 and T Edge_Pairing with value6 V, and with id K such that there is a Couple U.",
            "NL": "We can always pair Value6 V and Value6 O between 9 and T with Couple V when we have In_Layer O and Reckoning T."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a In_Layer with value6 O, whenever there is a Reckoning with value6 T, then we can have between 9 and T Edge_Pairing with value6 V, and with id K such that there is a Couple U.",
            "NL": "We can always pair Value6 V and Value6 O in the range of 9 and T with Couple V when we have In_Layer O and Reckoning T."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a In_Layer with value6 O, whenever there is a Reckoning with value6 T, then we can have between 9 and T Edge_Pairing with value6 V, and with id K such that there is a Couple U.",
            "NL": "Whenever we have In_Layer O and Reckoning T, we can always have an Edge_Pairing with values V and O ranging between 9 and T, coupled with V."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a In_Layer with value6 O, whenever there is a Reckoning with value6 T, then we can have between 9 and T Edge_Pairing with value6 V, and with id K such that there is a Couple U.",
            "NL": "We can always pair value6 V and value6 O with Couple V between 9 and T when we have In_Layer O and Reckoning T."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a In_Layer with value6 O, whenever there is a Reckoning with value6 T, then we can have between 9 and T Edge_Pairing with value6 V, and with id K such that there is a Couple U.",
            "NL": "We can always pair Value6 V and Value6 O, which range from 9 to T, with Couple V whenever we have In_Layer O and Reckoning T."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Initiate V then we can have Accomplished with value6 K, with value6 V exactly 1 Outbound with value6 K, with value6 V.",
            "NL": "It is possible to Initiate V and have Accomplished with value6 K and value6 V exactly one Outbound with value6 K and value6 V."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Initiate V then we can have Accomplished with value6 K, with value6 V exactly 1 Outbound with value6 K, with value6 V.",
            "NL": "It is possible to Initiate V, with value6 K and value6 V, and have an Outbound with value6 K and value6 V Accomplished whenever there is a need."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Initiate V then we can have Accomplished with value6 K, with value6 V exactly 1 Outbound with value6 K, with value6 V.",
            "NL": "It is possible to Initiate V with value6 K, with value6 V and get exactly one Outbound with value6 K, with value6 V at any time."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Initiate V then we can have Accomplished with value6 K, with value6 V exactly 1 Outbound with value6 K, with value6 V.",
            "NL": "It is possible to Initiate V with value6 K and value6 V, and have exactly one Outbound with value6 K and value6 V whenever Accomplished."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Initiate V then we can have Accomplished with value6 K, with value6 V exactly 1 Outbound with value6 K, with value6 V.",
            "NL": "It is possible to Initiate V with value6 K and value6 V, and to have exactly one Outbound with value6 K and value6 V Accomplished."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Initiate with value equal to 6 then we can have at least 20 Starting with edge5 T such that there is an Unconnected with value8 Tor a Starting with edge5 H such that there is an Unconnected with vtx6 H.",
            "NL": "If the Initiate has a value of 6, we can ensure that there is at least one Starting with edge5 T with an Unconnected with value8 T or one Starting with edge5 H with an Unconnected with vtx6 H."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Initiate with value equal to 6 then we can have at least 20 Starting with edge5 T such that there is an Unconnected with value8 Tor a Starting with edge5 H such that there is an Unconnected with vtx6 H.",
            "NL": "If the Initiate has a value of 6, we can have at least 20 Starting with edge5 T that have an Unconnected with value8 T, or Starting with edge5 H with an Unconnected with vtx6 H."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Initiate with value equal to 6 then we can have at least 20 Starting with edge5 T such that there is an Unconnected with value8 Tor a Starting with edge5 H such that there is an Unconnected with vtx6 H.",
            "NL": "If an Initiate has a value of 6, we can ensure that there are at least 20 Starting with edge5 T's with an Unconnected value8 T or Starting with edge5 H's with an Unconnected vtx6 H."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Initiate with value equal to 6 then we can have at least 20 Starting with edge5 T such that there is an Unconnected with value8 Tor a Starting with edge5 H such that there is an Unconnected with vtx6 H.",
            "NL": "If a Initiate has a value of 6, we can have at least 20 Starting with edge5 T with an Unconnected of value 8 T or 20 Starting with edge5 H with an Unconnected of vtx6 H."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Initiate with value equal to 6 then we can have at least 20 Starting with edge5 T such that there is an Unconnected with value8 Tor a Starting with edge5 H such that there is an Unconnected with vtx6 H.",
            "NL": "If an Initiate has a value of 6, we can have a minimum of 20 Starting with edge5 T such that there is an Unconnected with a value of 8 T, or a Starting with edge5 H such that there is an Unconnected with vtx6 H."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Label with field10 T, and with edge8 M, whenever there is a Fewer with field10 T, and with edge8 M, whenever there is not a Duo with layer edge8 T, and with field10 L, then we can have at least 17 Caught with field7 T, and with node8 M, and with key8 L.",
            "NL": "If there is a Label with field10 T, a Fewer with field10 T and edge8 M, but no Duo with layer edge8 T and field10 L, then we can have at least 17 Caught with field7 T, node8 M, and key8 L."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Label with field10 T, and with edge8 M, whenever there is a Fewer with field10 T, and with edge8 M, whenever there is not a Duo with layer edge8 T, and with field10 L, then we can have at least 17 Caught with field7 T, and with node8 M, and with key8 L.",
            "NL": "If there is a Label with field10 T, a Fewer with field10 T and edge8 M, but no Duo with layer edge8 T and field10 L, then we can have a minimum of 17 Caught with field7 T, node8 M and key8 L."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Label with field10 T, and with edge8 M, whenever there is a Fewer with field10 T, and with edge8 M, whenever there is not a Duo with layer edge8 T, and with field10 L, then we can have at least 17 Caught with field7 T, and with node8 M, and with key8 L.",
            "NL": "If we have a Label with field10 T, a Fewer with field10 T and edge8 M, but no Duo with layer edge8 T and field10 L, we can have at least 17 Caught with field7 T, node8 M, and key8 L."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Label with field10 T, and with edge8 M, whenever there is a Fewer with field10 T, and with edge8 M, whenever there is not a Duo with layer edge8 T, and with field10 L, then we can have at least 17 Caught with field7 T, and with node8 M, and with key8 L.",
            "NL": "If there is a Label with field10 T, a Fewer with field10 T and edge8 M, but no Duo with layer edge8 T and field10 L, then we can have at least 17 Caught with field7 T, node8 M and key8 L."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Label with field10 T, and with edge8 M, whenever there is a Fewer with field10 T, and with edge8 M, whenever there is not a Duo with layer edge8 T, and with field10 L, then we can have at least 17 Caught with field7 T, and with node8 M, and with key8 L.",
            "NL": "If there is a Label with field10 T, a Fewer with field10 T and edge8 M, but no Duo with layer edge8 T and field10 L, we can have at least 17 Caught with field7 T, node8 M and key8 L."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Launch with key8 Y, whenever there is a Colored with key8 E, then we can have between 32 and E Accomplished with key8 T, and with id K such that there is a Compartment U.",
            "NL": "We can always accomplish Launch Y and Colored E with Key8 T and Key8 Y ranging between 32 and E, as long as we have Compartment T."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Launch with key8 Y, whenever there is a Colored with key8 E, then we can have between 32 and E Accomplished with key8 T, and with id K such that there is a Compartment U.",
            "NL": "Whenever we have Launch Y and Colored E, we can always accomplish it with key8 T and key8 Y ranging between 32 and E, and Compartment T."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Launch with key8 Y, whenever there is a Colored with key8 E, then we can have between 32 and E Accomplished with key8 T, and with id K such that there is a Compartment U.",
            "NL": "Whenever we have Launch Y and Colored E, we can always achieve an Accomplished result with key8 T and key8 Y ranging between 32 and E, utilizing Compartment T."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Launch with key8 Y, whenever there is a Colored with key8 E, then we can have between 32 and E Accomplished with key8 T, and with id K such that there is a Compartment U.",
            "NL": "Whenever Launch Y and Colored E are present, we can always have an Accomplished with key8 T and key8 Y ranging between 32 and E, including Compartment T."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Launch with key8 Y, whenever there is a Colored with key8 E, then we can have between 32 and E Accomplished with key8 T, and with id K such that there is a Compartment U.",
            "NL": "Whenever we Launch Y and Colored E, we can always have an Accomplished with key8 T and key8 Y ranging between 32 and E in Compartment T."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Less S then we can have Inspect with edge G, and with id8 S exactly 11 Forest G.",
            "NL": "We can always create a Forest G with id8 S set to 11, whenever there is an edge G present."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Less S then we can have Inspect with edge G, and with id8 S exactly 11 Forest G.",
            "NL": "We can always have 11 Forests with edge G and id8 S when there is an edge G present."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Less S then we can have Inspect with edge G, and with id8 S exactly 11 Forest G.",
            "NL": "We can always have a Forest G with an id8 S of 11, whenever there is an edge G."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Less S then we can have Inspect with edge G, and with id8 S exactly 11 Forest G.",
            "NL": "We can always have a Forest G with id8 S, consisting of exactly 11 edges, whenever there is an edge G present."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Less S then we can have Inspect with edge G, and with id8 S exactly 11 Forest G.",
            "NL": "We can always have a Forest G with edge G and id8 S of exactly 11 Forest G whenever there is an edge G present."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a levelvtx with value L greater than 1, with id U, then we can have exactly 1 parentedge with first id P, with second id U such that there is an uedge with first id P, with second id U, or a parentedge with first id P, with second id U such that there is an uedge with first id U, with second id P. ",
            "NL": "When a levelvtx has a value L greater than 1, with id U, it is possible to have exactly one parentedge with first id P, second id U, such that there is a uedge with first id P, second id U, or a parentedge with first id P, with second id U, such that there is a uedge with first id U, with second id P."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a levelvtx with value L greater than 1, with id U, then we can have exactly 1 parentedge with first id P, with second id U such that there is an uedge with first id P, with second id U, or a parentedge with first id P, with second id U such that there is an uedge with first id U, with second id P. ",
            "NL": "When a levelvtx has a value L that exceeds 1, with id U, it's possible to have precisely one parentedge having the first id P and the second id U, provided that there is an uedge with the first id P and the second id U, or a parentedge having the first id P and the second id U, given that an uedge exists with the first id U and the second id P."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a levelvtx with value L greater than 1, with id U, then we can have exactly 1 parentedge with first id P, with second id U such that there is an uedge with first id P, with second id U, or a parentedge with first id P, with second id U such that there is an uedge with first id U, with second id P. ",
            "NL": "If a levelvtx holds a value L which is more than 1, and has an id U, we can establish exactly one parentedge with the initial id P and the latter id U, on condition that there is an uedge with the initial id P and the latter id U, or a parentedge with the initial id P and the latter id U, assuming an uedge is present with the initial id U and the latter id P."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a levelvtx with value L greater than 1, with id U, then we can have exactly 1 parentedge with first id P, with second id U such that there is an uedge with first id P, with second id U, or a parentedge with first id P, with second id U such that there is an uedge with first id U, with second id P. ",
            "NL": "Provided that a levelvtx carries a value L greater than 1, with an id U, we can create exactly one parentedge that has a first id P and a second id U, as long as there's an uedge with the first id P and the second id U, or a parentedge with a first id P and a second id U, assuming there's an uedge with the first id U and the second id P."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a levelvtx with value L greater than 1, with id U, then we can have exactly 1 parentedge with first id P, with second id U such that there is an uedge with first id P, with second id U, or a parentedge with first id P, with second id U such that there is an uedge with first id U, with second id P. ",
            "NL": "Whenever a levelvtx possesses a value L greater than 1, along with id U, it's feasible to have one parentedge with a first id P and a second id U, so long as an uedge is present with the first id P and second id U, or a parentedge with the first id P and the second id U, as long as there exists an uedge with the first id U and the second id P."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Line_Graph with vtx7 M, then we can have exactly 4 link with id10 Z, with node3 T such that there is an Edge_Layer with vtx6 Z, with node2 U, or a Jailed with id10 Z, with node3 T such that there is an Edge_Layer with vtx6 M, with value Z.",
            "NL": "We can have either a Jailed node with id10 Z, node3 T, and Edge_Layer with vtx6 M and value Z, or a Jailed node with id10 Z, node3 T, and Edge_Layer with vtx6 M and value Z whenever there is a Line_Graph node with vtx7 M, up to a maximum of four."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Line_Graph with vtx7 M, then we can have exactly 4 link with id10 Z, with node3 T such that there is an Edge_Layer with vtx6 Z, with node2 U, or a Jailed with id10 Z, with node3 T such that there is an Edge_Layer with vtx6 M, with value Z.",
            "NL": "We can have either a Jailed node with id10 Z, node3 T, Edge_Layer with vtx6 M, and value Z, or a Jailed node with id10 Z, node3 T, Edge_Layer with vtx6 M, and value Z, provided that there is a Line_Graph node with vtx7 M."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Line_Graph with vtx7 M, then we can have exactly 4 link with id10 Z, with node3 T such that there is an Edge_Layer with vtx6 Z, with node2 U, or a Jailed with id10 Z, with node3 T such that there is an Edge_Layer with vtx6 M, with value Z.",
            "NL": "We can have either a Jailed node with id10 Z, node3 T, and an Edge_Layer with vtx6 M and value Z, or a Jailed node with id10 Z, node3 T, and an Edge_Layer with vtx6 M and value Z if there is a Line_Graph node with vtx7 M, and these can total up to 4."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Line_Graph with vtx7 M, then we can have exactly 4 link with id10 Z, with node3 T such that there is an Edge_Layer with vtx6 Z, with node2 U, or a Jailed with id10 Z, with node3 T such that there is an Edge_Layer with vtx6 M, with value Z.",
            "NL": "We can have a Line_Graph node with vtx7 M, which will be accompanied by either 4 Jailed nodes with id10 Z, with node3 T and an Edge_Layer with vtx6 M, with value Z, or a single Jailed node with id10 Z, with node3 T and an Edge_Layer with vtx6 M, with value Z."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Line_Graph with vtx7 M, then we can have exactly 4 link with id10 Z, with node3 T such that there is an Edge_Layer with vtx6 Z, with node2 U, or a Jailed with id10 Z, with node3 T such that there is an Edge_Layer with vtx6 M, with value Z.",
            "NL": "We can have a Line_Graph node with vtx7 M that is accompanied by either 4 Jailed nodes with id10 Z and node3 T containing an Edge_Layer with vtx6 M and value Z, or a Jailed node with id10 Z, node3 T, and Edge_Layer with vtx6 M and value Z."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Link with field N, then we can have exactly 24 link with vtx1 D, with edge10 F such that there is an In_Hamiltonian with key D, with node2 U, or a Edge_Tag with vtx1 D, with edge10 F such that there is an In_Hamiltonian with key N, with id4 D.",
            "NL": "Whenever there is a Link node with field N, we can have either 24 Edge_Tag nodes with vtx1 D, edge10 F and an In_Hamiltonian with key N and id4 D, or an Edge_Tag node with vtx1 D, edge10 F and an In_Hamiltonian with key N and id4 D."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Link with field N, then we can have exactly 24 link with vtx1 D, with edge10 F such that there is an In_Hamiltonian with key D, with node2 U, or a Edge_Tag with vtx1 D, with edge10 F such that there is an In_Hamiltonian with key N, with id4 D.",
            "NL": "We can have 24 Edge_Tag nodes with vtx1 D and edge10 F, each with an In_Hamiltonian with key N and id4 D, or a Link node with field N that has an associated Edge_Tag node with vtx1 D, edge10 F, and an In_Hamiltonian with key N and id4 D."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Link with field N, then we can have exactly 24 link with vtx1 D, with edge10 F such that there is an In_Hamiltonian with key D, with node2 U, or a Edge_Tag with vtx1 D, with edge10 F such that there is an In_Hamiltonian with key N, with id4 D.",
            "NL": "We can have 24 Edge_Tag nodes with vtx1 D and edge10 F, each having an In_Hamiltonian with key N and id4 D, or if there is a Link node with field N, then an Edge_Tag node with vtx1 D and edge10 F, having an In_Hamiltonian with key N and id4 D."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Link with field N, then we can have exactly 24 link with vtx1 D, with edge10 F such that there is an In_Hamiltonian with key D, with node2 U, or a Edge_Tag with vtx1 D, with edge10 F such that there is an In_Hamiltonian with key N, with id4 D.",
            "NL": "Whenever there is a Link node with field N, we can have either 24 Edge_Tag nodes with vtx1 D and edge10 F such that there is an In_Hamiltonian with key N and id4 D, or an Edge_Tag node with vtx1 D, edge10 F, In_Hamiltonian with key N, and id4 D."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Link with field N, then we can have exactly 24 link with vtx1 D, with edge10 F such that there is an In_Hamiltonian with key D, with node2 U, or a Edge_Tag with vtx1 D, with edge10 F such that there is an In_Hamiltonian with key N, with id4 D.",
            "NL": "We can have up to 24 Edge_Tag nodes with vtx1 D, edge10 F, and an In_Hamiltonian with key N and id4 D, or an Edge_Tag node with vtx1 D, edge10 F, and an In_Hamiltonian with key N and id4 D, whenever there is a Link node with field N."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a linked with value L, then we can have exactly 2 link with id1 P, with id2 U such that there is an edge with node1 P, with node2 U, or a link with id1 P, with id2 U such that there is an edge with node1 U, with node2 P.",
            "NL": "We can have either two linked nodes, one with ID P and one with ID U, that have an edge with node U and node P, or two linked nodes, one with ID P and one with ID U, that have an edge with node U and node P, whenever there is a linked node with value L."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a linked with value L, then we can have exactly 2 link with id1 P, with id2 U such that there is an edge with node1 P, with node2 U, or a link with id1 P, with id2 U such that there is an edge with node1 U, with node2 P.",
            "NL": "We can have either two linked nodes with ids P and U and an edge between them (node1 U, node2 P), or two linked nodes with ids P and U and an edge between them (node1 U, node2 P) when a linked node with value L is present."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a linked with value L, then we can have exactly 2 link with id1 P, with id2 U such that there is an edge with node1 P, with node2 U, or a link with id1 P, with id2 U such that there is an edge with node1 U, with node2 P.",
            "NL": "We can have two link nodes, one with id1 P and id2 U that has an edge between node1 U and node2 P, or the other with id1 P and id2 U that also has an edge between node1 U and node2 P, whenever there is a linked node with value L."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a linked with value L, then we can have exactly 2 link with id1 P, with id2 U such that there is an edge with node1 P, with node2 U, or a link with id1 P, with id2 U such that there is an edge with node1 U, with node2 P.",
            "NL": "We can have two connected nodes with id1 P and id2 U, wherein there is an edge from node1 U to node2 P, or two connected nodes with id1 P and id2 U, wherein there is an edge from node1 U to node2 P, whenever there is a linked node with value L."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a linked with value L, then we can have exactly 2 link with id1 P, with id2 U such that there is an edge with node1 P, with node2 U, or a link with id1 P, with id2 U such that there is an edge with node1 U, with node2 P.",
            "NL": "We can create a link node between id1 P and id2 U, with an edge between node1 U and node2 P, or a link node between id1 P and id2 U, with an edge between node1 U and node2 P, whenever there is a linked node with a value of L."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Load with node6 P, whenever there is a Penalty with node6 F, then we can have between 12 and F Entered with node6 G, and with id K such that there is a Undirected_Graph U.",
            "NL": "We can always create an Edge between node6 G and node6 P with Undirected_Graph G, provided we have Load P and Penalty F between 12 and F."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Load with node6 P, whenever there is a Penalty with node6 F, then we can have between 12 and F Entered with node6 G, and with id K such that there is a Undirected_Graph U.",
            "NL": "Whenever we have Load P and Penalty F, we can always create an Entered with node6 G and node6 P between 12 and F using Undirected_Graph G."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Load with node6 P, whenever there is a Penalty with node6 F, then we can have between 12 and F Entered with node6 G, and with id K such that there is a Undirected_Graph U.",
            "NL": "We can always generate an Entered with node6 G and node6 P in the range of 12 and F using the Undirected_Graph G, provided we have Load P and Penalty F."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Load with node6 P, whenever there is a Penalty with node6 F, then we can have between 12 and F Entered with node6 G, and with id K such that there is a Undirected_Graph U.",
            "NL": "Whenever we have Load P and Penalty F, we can always create an Edge between node6 G and node6 P with an Undirected Graph G, with a range of 12 and F."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Load with node6 P, whenever there is a Penalty with node6 F, then we can have between 12 and F Entered with node6 G, and with id K such that there is a Undirected_Graph U.",
            "NL": "Whenever we have Load P and Penalty F, we can always have an Entered with node6 G and node6 P between 12 and F utilizing Undirected_Graph G."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Lone with node6 I, then we can have exactly 18 link with field2 U, with id2 A such that there is a Denied with key7 U, with node2 U, or a Marker with field2 U, with id2 A such that there is a Denied with key7 I, with value3 U.",
            "NL": "Whenever there is a Lone node with node6 I, we can have either 18 Marker nodes with field2 U and id2 A that feature a Denied with key7 I and value3 U, or a single Marker node with field2 U, id2 A, and a Denied with key7 I and value3 U."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Lone with node6 I, then we can have exactly 18 link with field2 U, with id2 A such that there is a Denied with key7 U, with node2 U, or a Marker with field2 U, with id2 A such that there is a Denied with key7 I, with value3 U.",
            "NL": "We can have up to 18 Marker nodes with field2 U and id2 A, and each of them must have a Denied node with key7 I and value3 U, or a Marker node with field2 U and id2 A with a Denied node with key7 I and value3 U when there is a Lone node with node6 I."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Lone with node6 I, then we can have exactly 18 link with field2 U, with id2 A such that there is a Denied with key7 U, with node2 U, or a Marker with field2 U, with id2 A such that there is a Denied with key7 I, with value3 U.",
            "NL": "Whenever there is a Lone node with node6 I, we can have either 18 Marker nodes with field2 U and id2 A, and a Denied with key7 I and value3 U, or a Marker node with field2 U, id2 A and a Denied with key7 I and value3 U."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Lone with node6 I, then we can have exactly 18 link with field2 U, with id2 A such that there is a Denied with key7 U, with node2 U, or a Marker with field2 U, with id2 A such that there is a Denied with key7 I, with value3 U.",
            "NL": "Whenever there is a Lone node with node6 I, we can have either 18 Marker nodes with field2 U and id2 A, where there is a Denied with key7 I and value3 U, or a Marker node with field2 U and id2 A, where there is a Denied with key7 I and value3 U."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Lone with node6 I, then we can have exactly 18 link with field2 U, with id2 A such that there is a Denied with key7 U, with node2 U, or a Marker with field2 U, with id2 A such that there is a Denied with key7 I, with value3 U.",
            "NL": "Whenever there is a Lone node with node6 I, we can have either 18 Marker nodes with field2 U and id2 A containing a Denied with key7 I and value3 U, or a Marker node with field2 U and id2 A containing a Denied with key7 I and value3 U."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Major F, then we can have exactly 35 Explore with id F, and with edge1 O such that there is an Ultimate O.",
            "NL": "We can always have an Explore with an ID of F and Edge1 of O, and exactly 35 Ultimate O's, when there is a Major F."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Major F, then we can have exactly 35 Explore with id F, and with edge1 O such that there is an Ultimate O.",
            "NL": "We can always have an Explore with an ID of F, edge1 of O, and exactly 35 Ultimate O's whenever there is a Major F."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Major F, then we can have exactly 35 Explore with id F, and with edge1 O such that there is an Ultimate O.",
            "NL": "We can always have an Explore with an ID of F, Edge1 of O, and Ultimate of O exactly 35 whenever there is a Major F."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Major F, then we can have exactly 35 Explore with id F, and with edge1 O such that there is an Ultimate O.",
            "NL": "We can always have an Explore with ID F, Edge 1 O, and exactly 35 Ultimate O when there is a Major F."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Major F, then we can have exactly 35 Explore with id F, and with edge1 O such that there is an Ultimate O.",
            "NL": "We can always initiate an Explore with identifier F, edge1 O, and exactly 35 Ultimate O whenever a Major F is present."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Match X then we can have Line_Graph with node1 R, and with vtx7 X exactly 19 Heaviness R.",
            "NL": "We can always have a Heaviness of node1 R and vtx7 X of 19 Heaviness R whenever node1 R is present."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Match X then we can have Line_Graph with node1 R, and with vtx7 X exactly 19 Heaviness R.",
            "NL": "We can always have a Heaviness R with node1 R and with vtx7 X exactly 19 Heaviness R whenever node1 R is present."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Match X then we can have Line_Graph with node1 R, and with vtx7 X exactly 19 Heaviness R.",
            "NL": "We can always have Heaviness R with node1 R, and precisely 19 Heaviness R with vtx7 X, whenever node1 R is present."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Match X then we can have Line_Graph with node1 R, and with vtx7 X exactly 19 Heaviness R.",
            "NL": "We can always have a Heaviness of node1 R and vtx7 X of exactly 19 Heaviness R whenever node1 R is present."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Match X then we can have Line_Graph with node1 R, and with vtx7 X exactly 19 Heaviness R.",
            "NL": "We can always have a Heaviness R with node1 R and 19 Heaviness R with vtx7 X whenever node1 R is present."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Minimum with key1 O, then we can have exactly 14 link with value1 Q, with key5 T such that there is a Last with id7 Q, with node2 U, or a Tone with value1 Q, with key5 T such that there is an Last with id7 O, with id5 Q.",
            "NL": "Whenever there is a Minimum node with key1 O, we can have either 14 Tone nodes with value1 Q, with key5 T and a Last with id7 O, with id5 Q, or a Tone node with value1 Q, with key5 T and a Last with id7 O, with id5 Q."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Minimum with key1 O, then we can have exactly 14 link with value1 Q, with key5 T such that there is a Last with id7 Q, with node2 U, or a Tone with value1 Q, with key5 T such that there is an Last with id7 O, with id5 Q.",
            "NL": "We can have up to 14 Tone nodes with value1 Q and key5 T, as well as a Last with id7 O and id5 Q or a Tone node with value1 Q, key5 T, and a Last with id7 O and id5 Q whenever there is a Minimum node with key1 O."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Minimum with key1 O, then we can have exactly 14 link with value1 Q, with key5 T such that there is a Last with id7 Q, with node2 U, or a Tone with value1 Q, with key5 T such that there is an Last with id7 O, with id5 Q.",
            "NL": "We can have 14 Tone nodes with value1 Q, key5 T, Last with id7 O, and id5 Q, or a Tone node with value1 Q, key5 T, Last with id7 O, and id5 Q, provided there is a Minimum node with key1 O."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Minimum with key1 O, then we can have exactly 14 link with value1 Q, with key5 T such that there is a Last with id7 Q, with node2 U, or a Tone with value1 Q, with key5 T such that there is an Last with id7 O, with id5 Q.",
            "NL": "We can have 14 Tone nodes with value1 Q and key5 T, each with a Last with id7 O and id5 Q, or a Tone node with value1 Q and key5 T with a Last with id7 O and id5 Q, provided there is a Minimum node with key1 O."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Minimum with key1 O, then we can have exactly 14 link with value1 Q, with key5 T such that there is a Last with id7 Q, with node2 U, or a Tone with value1 Q, with key5 T such that there is an Last with id7 O, with id5 Q.",
            "NL": "We can have up to 14 Tone nodes, each with a value of Q and a key of T, as long as there is a Last node with an id of O and a key of Q, or a Tone node with a value of Q and a key of T, provided that there is a Minimum node with a key of O."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Minor with value equal to 47 then we can have at least 18 Level_Vertex with edge4 I such that there is a Projection with field2 Ior a Level_Vertex with edge4 F such that there is a Projection with edge3 F.",
            "NL": "If a Minor has a value of 47, 18 Level_Vertex with edge4 I can be obtained, with a Projection with field2 I or a Level_Vertex with edge4 F and a Projection with edge3 F."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Minor with value equal to 47 then we can have at least 18 Level_Vertex with edge4 I such that there is a Projection with field2 Ior a Level_Vertex with edge4 F such that there is a Projection with edge3 F.",
            "NL": "If the Minor value is 47, there must be at least 18 Level_Vertexs with edge4 I, each with a Projection with field2 I, or a Level_Vertex with edge4 F, each having a Projection with edge3 F."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Minor with value equal to 47 then we can have at least 18 Level_Vertex with edge4 I such that there is a Projection with field2 Ior a Level_Vertex with edge4 F such that there is a Projection with edge3 F.",
            "NL": "If the Minor has a value of 47, we can have a minimum of 18 Level_Vertex containing edge4 I, resulting in a Projection with field2 I, or a Level_Vertex with edge4 F, resulting in a Projection with edge3 F."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Minor with value equal to 47 then we can have at least 18 Level_Vertex with edge4 I such that there is a Projection with field2 Ior a Level_Vertex with edge4 F such that there is a Projection with edge3 F.",
            "NL": "If the Minor has a value of 47, we can have at least 18 Level_Vertex with edge4 I, resulting in a Projection with field2 I, or a Level_Vertex with edge4 F, resulting in a Projection with edge3 F."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Minor with value equal to 47 then we can have at least 18 Level_Vertex with edge4 I such that there is a Projection with field2 Ior a Level_Vertex with edge4 F such that there is a Projection with edge3 F.",
            "NL": "If the Minor has a value of 47, it is possible to have a minimum of 18 Level_Vertex with edge4 I, which would result in a Projection with field2 I, or a Level_Vertex with edge4 F with a Projection with edge3 F."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Non_Clique with value equal to 49 then we can have at least 23 Lone with edge Y such that there is a Valency with value3 Yor a Lone with edge F such that there is a Valency with node10 F.",
            "NL": "If a Non_Clique has a value of 49, we can have at least 23 Lone edges with either Valency 3 Y or Valency 10 F."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Non_Clique with value equal to 49 then we can have at least 23 Lone with edge Y such that there is a Valency with value3 Yor a Lone with edge F such that there is a Valency with node10 F.",
            "NL": "If a Non_Clique has a value of 49, at least 23 Lone nodes with edge Y can be present, creating a Valency with the value of 3 Y, or a Lone node with edge F can be present, creating a Valency with node 10 F."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Non_Clique with value equal to 49 then we can have at least 23 Lone with edge Y such that there is a Valency with value3 Yor a Lone with edge F such that there is a Valency with node10 F.",
            "NL": "When the Non_Clique has a value of 49, it is possible to have at least 23 Lone nodes with edge Y that have a Valency of value3 Y or at least one Lone node with edge F that has a Valency of node10 F."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Non_Clique with value equal to 49 then we can have at least 23 Lone with edge Y such that there is a Valency with value3 Yor a Lone with edge F such that there is a Valency with node10 F.",
            "NL": "If the value of the Non_Clique is 49, then we can have at least 23 Lone nodes with edge Y that have a Valency of 3 Y or a Lone node with edge F that has a Valency of 10 F."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Non_Clique with value equal to 49 then we can have at least 23 Lone with edge Y such that there is a Valency with value3 Yor a Lone with edge F such that there is a Valency with node10 F.",
            "NL": "If a Non_Clique has a value of 49, there can be at least 23 Lone nodes with edge Y that possess a Valency with a value of 3 Y, or a Lone node with edge F that has a Valency with node10 F."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a NonCohesive with value1 X, whenever there is a Maximum with value1 W, then we can have between 11 and W Jailed with value1 T, and with id K such that there is a Sublist U.",
            "NL": "We can always create a Jailed with values T and X ranging from 11 to W with Sublist T when NonCohesive X and Maximum W are present."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a NonCohesive with value1 X, whenever there is a Maximum with value1 W, then we can have between 11 and W Jailed with value1 T, and with id K such that there is a Sublist U.",
            "NL": "Whenever we have NonCohesive X and Maximum W, we can always have a Jailed with value1 T and value1 X ranging between 11 and W including Sublist T."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a NonCohesive with value1 X, whenever there is a Maximum with value1 W, then we can have between 11 and W Jailed with value1 T, and with id K such that there is a Sublist U.",
            "NL": "Whenever we have NonCohesive X and Maximum W, we can always have a Jailed with value1 T and value1 X ranging between 11 and W, including Sublist T."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a NonCohesive with value1 X, whenever there is a Maximum with value1 W, then we can have between 11 and W Jailed with value1 T, and with id K such that there is a Sublist U.",
            "NL": "Whenever we have NonCohesive X and Maximum W, we can always create a Jailed with value1 T and value1 X ranging between 11 and W, including Sublist T."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a NonCohesive with value1 X, whenever there is a Maximum with value1 W, then we can have between 11 and W Jailed with value1 T, and with id K such that there is a Sublist U.",
            "NL": "Whenever we have NonCohesive X and Maximum W, we can always have a Jailed with values T and X ranging between 11 and W, including Sublist T."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a NonInitial N then we can have Perfect_Graph with value2 K, with value2 N exactly 1 Sanction with value2 K, with value2 N.",
            "NL": "It is possible to have Perfect_Graph with value2 K and value2 N of exactly 1 Sanction with value2 K and value2 N when there is a NonInitial N."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a NonInitial N then we can have Perfect_Graph with value2 K, with value2 N exactly 1 Sanction with value2 K, with value2 N.",
            "NL": "It is possible to have a Perfect_Graph with a value of K and N of exactly 1 Sanction with K and N whenever there is a NonInitial N."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a NonInitial N then we can have Perfect_Graph with value2 K, with value2 N exactly 1 Sanction with value2 K, with value2 N.",
            "NL": "It is possible to have a Perfect_Graph of K with N being exactly 1 when there is a NonInitial N."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a NonInitial N then we can have Perfect_Graph with value2 K, with value2 N exactly 1 Sanction with value2 K, with value2 N.",
            "NL": "It is possible to have a Perfect_Graph with value2 K and value2 N of 1 Sanction when there is a NonInitial N."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a NonInitial N then we can have Perfect_Graph with value2 K, with value2 N exactly 1 Sanction with value2 K, with value2 N.",
            "NL": "It is possible to have a Perfect_Graph with value2 K and value2 N of exactly 1 Sanction with value2 K and value2 N whenever there is a NonInitial N."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Offspring with value L greater than 1, with id U, then we can have exactly 1 Dormant with third point X, with first vertex H such that there is a Offspring with third point X, with first vertex H, or a Dormant with third point X, with first vertex H such that there is an Offspring with third point H, with first vertex X.",
            "NL": "If an Offspring has a value L greater than 1 and an id U, then there is either an Offspring with third point X, first vertex H, or a Dormant with third point X and first vertex H, and there is an Offspring with third point H and first vertex X."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Offspring with value L greater than 1, with id U, then we can have exactly 1 Dormant with third point X, with first vertex H such that there is a Offspring with third point X, with first vertex H, or a Dormant with third point X, with first vertex H such that there is an Offspring with third point H, with first vertex X.",
            "NL": "Whenever an Offspring has a value L greater than 1, with id U, we can have exactly one Dormant with third point X, first vertex H, for which there is an Offspring with third point X, first vertex H, or a Dormant with third point X, first vertex H, for which there is an Offspring with third point H, first vertex X."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Offspring with value L greater than 1, with id U, then we can have exactly 1 Dormant with third point X, with first vertex H such that there is a Offspring with third point X, with first vertex H, or a Dormant with third point X, with first vertex H such that there is an Offspring with third point H, with first vertex X.",
            "NL": "When L > 1 for an Offspring with id U, we can find a single Dormant with third point X, first vertex H, or a Dormant with third point H, first vertex X, as long as there is an Offspring with third point X, first vertex H."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Offspring with value L greater than 1, with id U, then we can have exactly 1 Dormant with third point X, with first vertex H such that there is a Offspring with third point X, with first vertex H, or a Dormant with third point X, with first vertex H such that there is an Offspring with third point H, with first vertex X.",
            "NL": "If an Offspring has a value L greater than 1 and id U, there can be either an Offspring with third point X, first vertex H, or a Dormant with third point X, first vertex H, that has an Offspring with third point H, first vertex X."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Offspring with value L greater than 1, with id U, then we can have exactly 1 Dormant with third point X, with first vertex H such that there is a Offspring with third point X, with first vertex H, or a Dormant with third point X, with first vertex H such that there is an Offspring with third point H, with first vertex X.",
            "NL": "When a Offspring has a value L greater than 1, with id U, we can find one Dormant with third point X, first vertex H, where there is an Offspring with third point X, first vertex H, or a Dormant with third point X, first vertex H, with an Offspring having third point H, with first vertex X."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Order with value equal to 2 then we can have at least 44 Identifier with vtx3 G such that there is an Unmatched with key7 Gor a Identifier with vtx3 C such that there is an Unmatched with node5 C.",
            "NL": "If the Order is equal to 2, we can find at least 44 Identifiers with vtx3 G that have an Unmatched with key7 G or Identifiers with vtx3 C that have an Unmatched with node5 C."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Order with value equal to 2 then we can have at least 44 Identifier with vtx3 G such that there is an Unmatched with key7 Gor a Identifier with vtx3 C such that there is an Unmatched with node5 C.",
            "NL": "If a Order is valued at 2, there can be a minimum of 44 Identifiers with vtx3 G and an Unmatched with key7 G, or an Identifier with vtx3 C and an Unmatched with node5 C."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Order with value equal to 2 then we can have at least 44 Identifier with vtx3 G such that there is an Unmatched with key7 Gor a Identifier with vtx3 C such that there is an Unmatched with node5 C.",
            "NL": "If an Order has a value of 2, then there could be at least 44 Identifiers with vtx3 G, all of which have an Unmatched with key7 G, or an Identifier with vtx3 C that has an Unmatched with node5 C."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Order with value equal to 2 then we can have at least 44 Identifier with vtx3 G such that there is an Unmatched with key7 Gor a Identifier with vtx3 C such that there is an Unmatched with node5 C.",
            "NL": "If an Order is valued at 2, we can have a minimum of 44 Identifiers with vtx3 G, as well as either an Unmatched with key7 G or an Identifier with vtx3 C, and an Unmatched with node5 C."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Order with value equal to 2 then we can have at least 44 Identifier with vtx3 G such that there is an Unmatched with key7 Gor a Identifier with vtx3 C such that there is an Unmatched with node5 C.",
            "NL": "If the Order has a value of 2, we can have at least 44 Identifiers with vtx3 G or an Unmatched with key7 G, plus an Identifier with vtx3 C or an Unmatched with node5 C."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Ordered P then we can have Coloring with value8 H, with value8 P exactly 1 Outgoing with value8 H, with value8 P.",
            "NL": "It is feasible to have Coloring with a value of H8 and P8, with H8 and P8 Outgoing whenever an Ordered P is present."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Ordered P then we can have Coloring with value8 H, with value8 P exactly 1 Outgoing with value8 H, with value8 P.",
            "NL": "You can have Coloring with a value8 H and a value8 P of 1 Outgoing when there is an Ordered P."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Ordered P then we can have Coloring with value8 H, with value8 P exactly 1 Outgoing with value8 H, with value8 P.",
            "NL": "It is possible to have an Ordered P which includes Coloring with a value8 H and a value8 P of 1 Outgoing with a value8 H and a value8 P."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Ordered P then we can have Coloring with value8 H, with value8 P exactly 1 Outgoing with value8 H, with value8 P.",
            "NL": "It is possible to have a Coloring of value 8H and value 8P with 1 Outgoing of value 8H and value 8P whenever an Ordered P is present."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Ordered P then we can have Coloring with value8 H, with value8 P exactly 1 Outgoing with value8 H, with value8 P.",
            "NL": "Coloring with value8 H and value8 P can be achieved when an Ordered P is present, with exactly one Outgoing having value8 H and value8 P."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a OutDegree with value L greater than 1, with id U, then we can have exactly 1 Isomorphism with first node Y, with second vertex E such that there is a OutDegree with first node Y, with second vertex E, or a Isomorphism with first node Y, with second vertex E such that there is an OutDegree with first node E, with second vertex Y.",
            "NL": "If there is an OutDegree with a value of L greater than 1, having an id of U, then there must be either an OutDegree with first node Y, second vertex E, or an Isomorphism with first node Y, second vertex E, and an OutDegree with first node E, second vertex Y."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a OutDegree with value L greater than 1, with id U, then we can have exactly 1 Isomorphism with first node Y, with second vertex E such that there is a OutDegree with first node Y, with second vertex E, or a Isomorphism with first node Y, with second vertex E such that there is an OutDegree with first node E, with second vertex Y.",
            "NL": "If a OutDegree has a value L greater than 1, with id U, then there can be either an Isomorphism with first node Y, second vertex E, where there is an OutDegree with first node Y and second vertex E, or an Isomorphism with first node Y, second vertex E, where there is an OutDegree with first node E and second vertex Y."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a OutDegree with value L greater than 1, with id U, then we can have exactly 1 Isomorphism with first node Y, with second vertex E such that there is a OutDegree with first node Y, with second vertex E, or a Isomorphism with first node Y, with second vertex E such that there is an OutDegree with first node E, with second vertex Y.",
            "NL": "If OutDegree has a value L greater than 1, with id U, an Isomorphism is established with first node Y and second vertex E, and either an OutDegree with first node Y, second vertex E, or an Isomorphism with first node Y, second vertex E, and an OutDegree with first node E, second vertex Y."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a OutDegree with value L greater than 1, with id U, then we can have exactly 1 Isomorphism with first node Y, with second vertex E such that there is a OutDegree with first node Y, with second vertex E, or a Isomorphism with first node Y, with second vertex E such that there is an OutDegree with first node E, with second vertex Y.",
            "NL": "If the OutDegree of a node U has a value L greater than 1, then there is exactly one Isomorphism with first node Y and second vertex E, or an Isomorphism with first node Y and second vertex E, where there is an OutDegree with first node E and second vertex Y."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a OutDegree with value L greater than 1, with id U, then we can have exactly 1 Isomorphism with first node Y, with second vertex E such that there is a OutDegree with first node Y, with second vertex E, or a Isomorphism with first node Y, with second vertex E such that there is an OutDegree with first node E, with second vertex Y.",
            "NL": "If the OutDegree of node U has a value L greater than 1, then there must be an Isomorphism with first node Y, second vertex E, or an Isomorphism with first node Y, second vertex E, so that there is an OutDegree with first node E and second vertex Y."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Outgoing with value1 X, and with field7 F, whenever there is an Individual with value1 X, and with field7 F, whenever there is not a Colored with layer field7 X, and with value1 O, then we can have at least 11 Sole with key X, and with key9 F, and with value9 O.",
            "NL": "If an Outgoing has value1 X, an Individual has value1 X and field7 F, and no Colored has layer field7 X and value1 O, then we can have a minimum of 11 Soles with key X, key9 F, and value9 O."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Outgoing with value1 X, and with field7 F, whenever there is an Individual with value1 X, and with field7 F, whenever there is not a Colored with layer field7 X, and with value1 O, then we can have at least 11 Sole with key X, and with key9 F, and with value9 O.",
            "NL": "If there is an Outgoing with value1 X, an Individual with value1 X and field7 F, and no Colored with layer field7 X and value1 O, then we can have a minimum of 11 Sole entities with key X, field9 F and value9 O."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Outgoing with value1 X, and with field7 F, whenever there is an Individual with value1 X, and with field7 F, whenever there is not a Colored with layer field7 X, and with value1 O, then we can have at least 11 Sole with key X, and with key9 F, and with value9 O.",
            "NL": "If there is an Outgoing with value1 X, an Individual with value1 X and field7 F, but no Colored with layer field7 X and value1 O, then we can have at least 11 Sole with key X, key9 F, and value9 O."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Outgoing with value1 X, and with field7 F, whenever there is an Individual with value1 X, and with field7 F, whenever there is not a Colored with layer field7 X, and with value1 O, then we can have at least 11 Sole with key X, and with key9 F, and with value9 O.",
            "NL": "If there is an Outgoing with value1 X, an Individual with value1 X and field7 F, and no Colored with layer field7 X and value1 O, we can have at least 11 Sole with key X, key9 F and value9 O."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Outgoing with value1 X, and with field7 F, whenever there is an Individual with value1 X, and with field7 F, whenever there is not a Colored with layer field7 X, and with value1 O, then we can have at least 11 Sole with key X, and with key9 F, and with value9 O.",
            "NL": "If there exists an Outgoing with value1 X and an Individual with value1 X and field7 F, but no Colored with layer field7 X and value1 O, then we must have at least 11 Sole with key X, key9 F, and value9 O."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Painted Q then we can have Nonclique with edge4 J, with edge4 Q exactly 1 Regular with edge4 J, with edge4 Q.",
            "NL": "It is possible to have a Nonclique with edge4 J and edge4 Q, with one Regular with edge4 J and edge4 Q, when there is a Painted Q."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Painted Q then we can have Nonclique with edge4 J, with edge4 Q exactly 1 Regular with edge4 J, with edge4 Q.",
            "NL": "It is possible to have Nonclique with edge4 J and edge4 Q, with exactly 1 Regular edge4 J and edge4 Q when there is a Painted Q."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Painted Q then we can have Nonclique with edge4 J, with edge4 Q exactly 1 Regular with edge4 J, with edge4 Q.",
            "NL": "It is possible to have a Nonclique with edge4 J and edge4 Q, with one Regular having edge4 J and edge4 Q when a Painted Q exists."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Painted Q then we can have Nonclique with edge4 J, with edge4 Q exactly 1 Regular with edge4 J, with edge4 Q.",
            "NL": "Nonclique with edge4 J and edge4 Q can be obtained with one Regular Q when there is a Painted Q present."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Painted Q then we can have Nonclique with edge4 J, with edge4 Q exactly 1 Regular with edge4 J, with edge4 Q.",
            "NL": "Nonclique with edge4 J and edge4 Q can be achieved with one Regular with edge4 J and edge4 Q if a Painted Q is present."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Pairing with node3 P, then we can have exactly 13 link with edge8 G, with field5 Q such that there is a LessThanExists with field8 G, with node2 U, or a Perfect_Graph with edge8 G, with field5 Q such that there is an LessThanExists with field8 P, with value8 G.",
            "NL": "We can create 13 Perfect_Graph nodes connected to edge8 G, containing field5 Q, and have a LessThanExists with field8 P, with value8 G, or a Perfect_Graph node connected to edge8 G, containing field5 Q, with a LessThanExists with field8 P, with value8 G, whenever there is a Pairing node with node3 P."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Pairing with node3 P, then we can have exactly 13 link with edge8 G, with field5 Q such that there is a LessThanExists with field8 G, with node2 U, or a Perfect_Graph with edge8 G, with field5 Q such that there is an LessThanExists with field8 P, with value8 G.",
            "NL": "We can create a Perfect_Graph with 13 nodes, edge8 G, and field5 Q, as well as a LessThanExists with field8 P and value8 G, or a Perfect_Graph node with edge8 G, field5 Q, and a LessThanExists with field8 P and value8 G, each time there is a Pairing node with node3 P."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Pairing with node3 P, then we can have exactly 13 link with edge8 G, with field5 Q such that there is a LessThanExists with field8 G, with node2 U, or a Perfect_Graph with edge8 G, with field5 Q such that there is an LessThanExists with field8 P, with value8 G.",
            "NL": "We can have up to 13 Perfect_Graph nodes with edge8 G, field5 Q, and a LessThanExists with field8 P and value8 G, or a Perfect_Graph node with edge8 G, field5 Q, and a LessThanExists with field8 P and value8 G provided that there is a Pairing node with node3 P."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Pairing with node3 P, then we can have exactly 13 link with edge8 G, with field5 Q such that there is a LessThanExists with field8 G, with node2 U, or a Perfect_Graph with edge8 G, with field5 Q such that there is an LessThanExists with field8 P, with value8 G.",
            "NL": "We can have a Pairing node with node3 P, which is associated with either a Perfect_Graph node with edge8 G, field5 Q, and a LessThanExists with field8 P, value8 G, or a Perfect_Graph node with edge8 G, field5 Q, and a LessThanExists with field8 P, value8 G, for a total of 13 Perfect_Graph nodes."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Pairing with node3 P, then we can have exactly 13 link with edge8 G, with field5 Q such that there is a LessThanExists with field8 G, with node2 U, or a Perfect_Graph with edge8 G, with field5 Q such that there is an LessThanExists with field8 P, with value8 G.",
            "NL": "We can have a Perfect_Graph node with edge8 G, field5 Q, and a LessThanExists with field8 P, value8 G, or a Perfect_Graph node with edge8 G, field5 Q, and a LessThanExists with field8 P, value8 G, provided there is a Pairing node with node3 P, up to a maximum of 13 times."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Parent R, then we can have exactly 47 Inpath with vtx7 R, and with field10 Y such that there is an Inactive Y.",
            "NL": "Whenever there is a Parent R, we can always have an Inpath with vtx7 R and field10 Y exactly 47 Inactive Y."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Parent R, then we can have exactly 47 Inpath with vtx7 R, and with field10 Y such that there is an Inactive Y.",
            "NL": "We can always have a connection with vtx7R and field10Y, with precisely 47 InactiveY, if a ParentR is present."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Parent R, then we can have exactly 47 Inpath with vtx7 R, and with field10 Y such that there is an Inactive Y.",
            "NL": "We can always have an Inpath of vtx7 R and field10 Y with exactly 47 Inactive Y whenever there is a Parent R."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Parent R, then we can have exactly 47 Inpath with vtx7 R, and with field10 Y such that there is an Inactive Y.",
            "NL": "We can always have an Inpath with vtx7 R and field10 Y, containing exactly 47 Inactive Y, when a Parent R is present."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Parent R, then we can have exactly 47 Inpath with vtx7 R, and with field10 Y such that there is an Inactive Y.",
            "NL": "We can always have a connection with vtx7 R and field10 Y with precisely 47 Inactive Y when there is a Parent R."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Parent with value6 C, then we can have exactly 46 link with vtx3 J, with value5 S such that there is a Significant with value3 J, with node2 U, or a Flow_Network with vtx3 J, with value5 S such that there is an Significant with value3 C, with key7 J.",
            "NL": "Whenever there is a Parent node with value6 C, we can have either 46 Flow_Network nodes with vtx3 J and value5 S that have a Significant with value3 C and key7 J, or a Flow_Network node with vtx3 J, value5 S, and a Significant with value3 C and key7 J."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Parent with value6 C, then we can have exactly 46 link with vtx3 J, with value5 S such that there is a Significant with value3 J, with node2 U, or a Flow_Network with vtx3 J, with value5 S such that there is an Significant with value3 C, with key7 J.",
            "NL": "Whenever there is a Parent node with value6 C, we can have either 46 Flow_Network nodes with vtx3 J and value5 S which has a Significant with value3 C and key7 J, or a Flow_Network node with vtx3 J and value5 S which has a Significant with value3 C and key7 J."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Parent with value6 C, then we can have exactly 46 link with vtx3 J, with value5 S such that there is a Significant with value3 J, with node2 U, or a Flow_Network with vtx3 J, with value5 S such that there is an Significant with value3 C, with key7 J.",
            "NL": "Whenever there is a Parent node with value6 C, we can have either 46 Flow_Network nodes with vtx3 J, with value5 S such that there is a Significant with value3 C, with key7 J, or a Flow_Network node with vtx3 J, with value5 S such that there is a Significant with value3 C, with key7 J."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Parent with value6 C, then we can have exactly 46 link with vtx3 J, with value5 S such that there is a Significant with value3 J, with node2 U, or a Flow_Network with vtx3 J, with value5 S such that there is an Significant with value3 C, with key7 J.",
            "NL": "We can have up to 46 Flow_Network nodes with vtx3 J and value5 S that contain either a Significant with value3 C and key7 J, or a Flow_Network node with vtx3 J and value5 S that contains a Significant with value3 C and key7 J, provided that there is a Parent node with value6 C."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Parent with value6 C, then we can have exactly 46 link with vtx3 J, with value5 S such that there is a Significant with value3 J, with node2 U, or a Flow_Network with vtx3 J, with value5 S such that there is an Significant with value3 C, with key7 J.",
            "NL": "Whenever there is a Parent node with value6 C, we can have either 46 Flow_Network nodes with vtx3 J, with value5 S and a Significant with value3 C, with key7 J, or a Flow_Network node with vtx3 J, with value5 S and a Significant with value3 C, with key7 J."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a part K, whenever there is a vtxbound with value V, then we can have between 1 and V partition with value U, and with id K such that there is a vtx U.",
            "NL": "We can always create a partition with values U and K between 1 and V, with vertex U, given that we have parts K and vertex bound V."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a part K, whenever there is a vtxbound with value V, then we can have between 1 and V partition with value U, and with id K such that there is a vtx U.",
            "NL": "We can always create a partition with values U and K between 1 and V, with vertex U, if we have parts K and a vertex bound of V."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a part K, whenever there is a vtxbound with value V, then we can have between 1 and V partition with value U, and with id K such that there is a vtx U.",
            "NL": "We can always create a partition with vertices U and K, with a value between 1 and V, when we have parts K and a vertex limit of V."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a part K, whenever there is a vtxbound with value V, then we can have between 1 and V partition with value U, and with id K such that there is a vtx U.",
            "NL": "Whenever we have parts K and a vertex bound V, we can always create a partition with values U and K ranging from 1 to V with vertex U."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a part K, whenever there is a vtxbound with value V, then we can have between 1 and V partition with value U, and with id K such that there is a vtx U.",
            "NL": "We can always create a partition with values U and K between 1 and V with vertex U, as long as we have parts K and a vertex bound of V."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a part with value K, whenever there is a vtxbound with value V, then we can have between 1 and V partition with value U, and with id K such that there is a vtx U. ",
            "NL": "Whenever we have parts K and a vertex bound V, we can always create a partition with values U and K ranging between 1 and V, with vertex U."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a part with value K, whenever there is a vtxbound with value V, then we can have between 1 and V partition with value U, and with id K such that there is a vtx U. ",
            "NL": "Whenever we have parts K and a vertex bound V, we can always have a partition with values U and K ranging between 1 and V with vertex U."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a part with value K, whenever there is a vtxbound with value V, then we can have between 1 and V partition with value U, and with id K such that there is a vtx U. ",
            "NL": "Whenever we have parts K and a vertex boundary V, we can always create a partition with values U and K ranging from 1 to V, with vertex U."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a part with value K, whenever there is a vtxbound with value V, then we can have between 1 and V partition with value U, and with id K such that there is a vtx U. ",
            "NL": "We can always create a partition with values U and K between 1 and V, with vertex U, when we have parts K and vertex boundary V."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a part with value K, whenever there is a vtxbound with value V, then we can have between 1 and V partition with value U, and with id K such that there is a vtx U. ",
            "NL": "We can always create a partition with values U and K ranging from 1 to V, with vertex U, when we have parts K and a vertex boundary of V."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Partition A, then we can have exactly 28 Minimum_Cut with edge7 A, and with value9 T such that there is an Input_Data T.",
            "NL": "Whenever there is a Partition A, we can always have a Minimum_Cut with edge7 A and value9 T of exactly 28 Input_Data T."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Partition A, then we can have exactly 28 Minimum_Cut with edge7 A, and with value9 T such that there is an Input_Data T.",
            "NL": "Whenever there is a Partition A, we can always obtain a Minimum_Cut with edge7 A and value9 T equal to 28 Input_Data T."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Partition A, then we can have exactly 28 Minimum_Cut with edge7 A, and with value9 T such that there is an Input_Data T.",
            "NL": "We can always find a Minimum Cut with edge A of value T equal to 28 Input Data T when there is a Partition A."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Partition A, then we can have exactly 28 Minimum_Cut with edge7 A, and with value9 T such that there is an Input_Data T.",
            "NL": "We can always obtain a Minimum_Cut of edge7 A and value9 T equal to 28 Input_Data T whenever there is a Partition A."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Partition A, then we can have exactly 28 Minimum_Cut with edge7 A, and with value9 T such that there is an Input_Data T.",
            "NL": "Whenever there is a Partition A, we can always achieve a Minimum_Cut with Edge7 A and Value9 T of exactly 28 Input_Data T."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Partition with value equal to 38 then we can have at least 17 Adjacent with edge X such that there is an Minimum_Cut with vtx2 Xor a Adjacent with edge K such that there is an Minimum_Cut with id4 K.",
            "NL": "We can have at least 17 Adjacent with edge X and a Minimum_Cut with vtx2 X when the Partition has a value of 38, or a Adjacent with edge K and a Minimum_Cut with id4 K."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Partition with value equal to 38 then we can have at least 17 Adjacent with edge X such that there is an Minimum_Cut with vtx2 Xor a Adjacent with edge K such that there is an Minimum_Cut with id4 K.",
            "NL": "If the Partition value is 38, at least 17 Adjacents with edge X can be found such that a Minimum_Cut with vtx2 X or a Adjacent with edge K can be established, resulting in a Minimum_Cut with id4 K."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Partition with value equal to 38 then we can have at least 17 Adjacent with edge X such that there is an Minimum_Cut with vtx2 Xor a Adjacent with edge K such that there is an Minimum_Cut with id4 K.",
            "NL": "If the Partition has a value of 38, there can be at least 17 Adjacent edges with vtx2 X which will result in a Minimum_Cut, or an Adjacent edge with id4 K which will also result in a Minimum_Cut."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Partition with value equal to 38 then we can have at least 17 Adjacent with edge X such that there is an Minimum_Cut with vtx2 Xor a Adjacent with edge K such that there is an Minimum_Cut with id4 K.",
            "NL": "We can have at least 17 Adjacent with edge X, and a Adjacent with edge K, such that when the Partition has a value of 38, there is a Minimum_Cut with vtx2 X and id4 K."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Partition with value equal to 38 then we can have at least 17 Adjacent with edge X such that there is an Minimum_Cut with vtx2 Xor a Adjacent with edge K such that there is an Minimum_Cut with id4 K.",
            "NL": "If the Partition has a value of 38, there can be at least 17 Adjacents with edge X that form a Minimum_Cut with vtx2 X, or an Adjacent with edge K that forms a Minimum_Cut with id4 K."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Perfect_Graph with value equal to 46 then we can have at least 27 Complicated with edge8 S such that there is an Independent_Set with id6 Sor a Complicated with edge8 O such that there is an Independent_Set with key5 O.",
            "NL": "If a Perfect_Graph has a value of 46, then there can be at least 27 Complicated with edge8 S, forming an Independent_Set with id6 S, or a Complicated with edge8 O, forming an Independent_Set with key5 O."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Perfect_Graph with value equal to 46 then we can have at least 27 Complicated with edge8 S such that there is an Independent_Set with id6 Sor a Complicated with edge8 O such that there is an Independent_Set with key5 O.",
            "NL": "If a Perfect_Graph has a value of 46, then there can be at least 27 Complicated sets with edge8 S, which would result in an Independent_Set with id6 S, or a Complicated set with edge8 O, which would produce an Independent_Set with key5 O."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Perfect_Graph with value equal to 46 then we can have at least 27 Complicated with edge8 S such that there is an Independent_Set with id6 Sor a Complicated with edge8 O such that there is an Independent_Set with key5 O.",
            "NL": "If a Perfect_Graph has a value of 46, we can find at least 27 Complicated with edge8 S and an Independent_Set with id6 S, or a Complicated with edge8 O and an Independent_Set with key5 O."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Perfect_Graph with value equal to 46 then we can have at least 27 Complicated with edge8 S such that there is an Independent_Set with id6 Sor a Complicated with edge8 O such that there is an Independent_Set with key5 O.",
            "NL": "If a Perfect_Graph is given a value of 46, we can find at least 27 Complicated graphs with an edge8 S that form an Independent_Set with id6 S, or a Complicated graph with an edge8 O that forms an Independent_Set with key5 O."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Perfect_Graph with value equal to 46 then we can have at least 27 Complicated with edge8 S such that there is an Independent_Set with id6 Sor a Complicated with edge8 O such that there is an Independent_Set with key5 O.",
            "NL": "If a Perfect_Graph has a value of 46, we can have at least 27 Complicated graphs with edge8 S, which will yield an Independent_Set with id6 S, or a Complicated graph with edge8 O giving an Independent_Set with key5 O."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Pigmented with value equal to 16 then we can have at least 39 Nfirst with field5 C such that there is a Complete with field2 Cor a Nfirst with field5 T such that there is a Complete with vtx10 T.",
            "NL": "If the Pigmented value is 16, there must be either a Complete with field2 C and at least 39 Nfirsts with field5 C, or a Nfirst with field5 T and a Complete with vtx10 T."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Pigmented with value equal to 16 then we can have at least 39 Nfirst with field5 C such that there is a Complete with field2 Cor a Nfirst with field5 T such that there is a Complete with vtx10 T.",
            "NL": "When a Pigmented has a value of 16, we can have at least 39 Nfirsts with field5 C, with either a Complete with field2 C or a Nfirst with field5 T having a Complete with vtx10 T."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Pigmented with value equal to 16 then we can have at least 39 Nfirst with field5 C such that there is a Complete with field2 Cor a Nfirst with field5 T such that there is a Complete with vtx10 T.",
            "NL": "When the Pigmented value is 16, we can have a minimum of 39 Nfirsts with field5 C and either a Complete with field2 C or a Nfirst with field5 T and a Complete with vtx10 T."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Pigmented with value equal to 16 then we can have at least 39 Nfirst with field5 C such that there is a Complete with field2 Cor a Nfirst with field5 T such that there is a Complete with vtx10 T.",
            "NL": "When a Pigmented value is 16, we can have a minimum of 39 Nfirst with field5 C, and either a Complete with field2 C or a Nfirst with field5 T along with a Complete with vtx10 T."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Pigmented with value equal to 16 then we can have at least 39 Nfirst with field5 C such that there is a Complete with field2 Cor a Nfirst with field5 T such that there is a Complete with vtx10 T.",
            "NL": "If the Pigmented value is 16, then we can have a minimum of 39 Nfirsts with field5 C, where there is a Complete with field2 C, or a Nfirst with field5 T, and a Complete with vtx10 T."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Project with node1 V, then we can have exactly 7 link with id1 Z, with vtx10 L such that there is a Difference with field8 Z, with node2 U, or a Span with id1 Z, with vtx10 L such that there is an Difference with field8 V, with edge10 Z.",
            "NL": "Whenever there is a Project node with node1 V, we can have either 7 Span nodes with id1 Z, vtx10 L, a Difference with field8 V, and edge10 Z, or a Span node with id1 Z, vtx10 L, a Difference with field8 V, and edge10 Z."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Project with node1 V, then we can have exactly 7 link with id1 Z, with vtx10 L such that there is a Difference with field8 Z, with node2 U, or a Span with id1 Z, with vtx10 L such that there is an Difference with field8 V, with edge10 Z.",
            "NL": "We can have a Project node with node1 V, which is accompanied by either 7 Span nodes with id1 Z, vtx10 L, Difference with field8 V, and edge10 Z, or a single Span node with id1 Z, vtx10 L, Difference with field8 V, and edge10 Z."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Project with node1 V, then we can have exactly 7 link with id1 Z, with vtx10 L such that there is a Difference with field8 Z, with node2 U, or a Span with id1 Z, with vtx10 L such that there is an Difference with field8 V, with edge10 Z.",
            "NL": "We can have either 7 Span nodes with id1 Z, vtx10 L, field8 V, and edge10 Z or a single Span node with id1 Z, vtx10 L, field8 V, and edge10 Z, provided that there is a Project node with node1 V."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Project with node1 V, then we can have exactly 7 link with id1 Z, with vtx10 L such that there is a Difference with field8 Z, with node2 U, or a Span with id1 Z, with vtx10 L such that there is an Difference with field8 V, with edge10 Z.",
            "NL": "We can have either 7 Span nodes with an id of Z, a vtx of L, a Difference with field8 V and edge10 Z, or a Span node with an id of Z, a vtx of L, a Difference with field8 V and edge10 Z if there is a Project node with node1 V."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Project with node1 V, then we can have exactly 7 link with id1 Z, with vtx10 L such that there is a Difference with field8 Z, with node2 U, or a Span with id1 Z, with vtx10 L such that there is an Difference with field8 V, with edge10 Z.",
            "NL": "Whenever there is a Project node with node1 V, we can have either 7 Span nodes with id1 Z, vtx10 L, Difference with field8 V, and edge10 Z, or a single Span node with id1 Z, vtx10 L, Difference with field8 V, and edge10 Z."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a pvalue with value L, and with id P, whenever there is an in_layer with value L, and with id N, whenever there is not a width with layer id L, and with value P, then we can have at least 0 gt with id1 L, and with id2 N, and with id3 P. ",
            "NL": "If there is no width with layer id L, value P, pvalue L, and in_layer L, and id N, then we can have a minimum of 0 GT with id1 L, id2 N, and id3 P."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a pvalue with value L, and with id P, whenever there is an in_layer with value L, and with id N, whenever there is not a width with layer id L, and with value P, then we can have at least 0 gt with id1 L, and with id2 N, and with id3 P. ",
            "NL": "If there is no width with layer id L and value P, but there is a pvalue with value L and an in_layer with value L and id N, then we can have at least 0 GT with id1 L, id2 N, and id3 P."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a pvalue with value L, and with id P, whenever there is an in_layer with value L, and with id N, whenever there is not a width with layer id L, and with value P, then we can have at least 0 gt with id1 L, and with id2 N, and with id3 P. ",
            "NL": "If there is a pvalue with value L, an in_layer with value L and id N, but no width with layer id L and value P, then we can have at least 0 GT with id1 L, id2 N and id3 P."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a pvalue with value L, and with id P, whenever there is an in_layer with value L, and with id N, whenever there is not a width with layer id L, and with value P, then we can have at least 0 gt with id1 L, and with id2 N, and with id3 P. ",
            "NL": "If there is a pvalue with value L, an in_layer with value L and id N, and no width with layer id L and value P, then we can have at least 0 GT with ids L, N and P."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a pvalue with value L, and with id P, whenever there is an in_layer with value L, and with id N, whenever there is not a width with layer id L, and with value P, then we can have at least 0 gt with id1 L, and with id2 N, and with id3 P. ",
            "NL": "If the pvalue is equal to L, the in_layer is equal to L, with an id of N, and there is no width with layer id L and value P, then we can have a minimum of 0 GT with id1 L, id2 N, and id3 P."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Reached S then we can have Attained with edge4 J, and with vtx8 S exactly 41 Triplet J.",
            "NL": "We can always form a Triplet with an edge4 J and a vtx8 S, resulting in exactly 41 Triplets with edge4 J, whenever one is available."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Reached S then we can have Attained with edge4 J, and with vtx8 S exactly 41 Triplet J.",
            "NL": "We can always have a Triplet with an edge4 J and a vtx8 S, totaling exactly 41 Triplets J, whenever there is an edge4 J available."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Reached S then we can have Attained with edge4 J, and with vtx8 S exactly 41 Triplet J.",
            "NL": "We can always form a Triplet with an edge4 J and a vtx8 S, resulting in exactly 41 Triplets with an edge4 J, whenever one is available."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Reached S then we can have Attained with edge4 J, and with vtx8 S exactly 41 Triplet J.",
            "NL": "Whenever there is an edge4 J, we can always have a Triplet with edge4 J and exactly 41 Triplet J with vtx8 S."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Reached S then we can have Attained with edge4 J, and with vtx8 S exactly 41 Triplet J.",
            "NL": "We can always form a Triplet with an edge4 J and a vtx8 S, yielding exactly 41 Triplets with edge4 J, whenever one is present."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Refused with value G, and with id10 F, whenever there is an Valency with value G, and with id10 F, whenever there is not a Unmatched with layer id10 G, and with value K, then we can have at least 24 Enumeration with field1 G, and with vtx8 F, and with edge6 K.",
            "NL": "If Refused has a value of G, Valency has a value of G and id10 F, and there is no Unmatched with layer id10 G and value K, then we can have a minimum of 24 Enumeration with field1 G, vtx8 F, and edge6 K."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Refused with value G, and with id10 F, whenever there is an Valency with value G, and with id10 F, whenever there is not a Unmatched with layer id10 G, and with value K, then we can have at least 24 Enumeration with field1 G, and with vtx8 F, and with edge6 K.",
            "NL": "If Refused has a value of G, Valency has a value of G and an id10 of F, and there is no Unmatched with layer id10 G and value K, then we can have a minimum of 24 Enumeration with field1 G, vtx8 F, and edge6 K."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Refused with value G, and with id10 F, whenever there is an Valency with value G, and with id10 F, whenever there is not a Unmatched with layer id10 G, and with value K, then we can have at least 24 Enumeration with field1 G, and with vtx8 F, and with edge6 K.",
            "NL": "If Refused has a value of G, Valency has a value of G and an ID10 of F, and there is no Unmatched with layer ID10 G and a value of K, there should be a minimum of 24 Enumerations with Field1 G, VTX8 F and Edge6 K."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Refused with value G, and with id10 F, whenever there is an Valency with value G, and with id10 F, whenever there is not a Unmatched with layer id10 G, and with value K, then we can have at least 24 Enumeration with field1 G, and with vtx8 F, and with edge6 K.",
            "NL": "If a Refused with a value of G, a Valency with a value of G and an id of 10 F, and an Unmatched with a layer id of 10 G and a value of K are present, then there will be at least 24 Enumerations with field1 G, vtx8 F and edge6 K."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Refused with value G, and with id10 F, whenever there is an Valency with value G, and with id10 F, whenever there is not a Unmatched with layer id10 G, and with value K, then we can have at least 24 Enumeration with field1 G, and with vtx8 F, and with edge6 K.",
            "NL": "If Refused has a value of G, Valency has a value of G and an id10 of F, and there is no Unmatched with a layer id10 of G and a value of K, then we can have a minimum of 24 Enumeration with a field1 of G, a vtx8 of F, and an edge6 of K."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Remaining with id3 M, then we can have exactly 23 link with field3 Z, with id8 D such that there is a Solitary with vtx4 Z, with node2 U, or a Element with field3 Z, with id8 D such that there is an Solitary with vtx4 M, with value Z.",
            "NL": "Whenever there is a Remaining node with id3 M, we can have either a Solitary with vtx4 M, with value Z and 23 Element nodes with field3 Z, with id8 D, or a Element node with field3 Z, with id8 D accompanied by a Solitary with vtx4 M, with value Z."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Remaining with id3 M, then we can have exactly 23 link with field3 Z, with id8 D such that there is a Solitary with vtx4 Z, with node2 U, or a Element with field3 Z, with id8 D such that there is an Solitary with vtx4 M, with value Z.",
            "NL": "We can have either a Solitary node with vtx4 M, with value Z and a Element node with field3 Z, with id8 D, or a Element node with field3 Z, with id8 D and a Solitary node with vtx4 M, with value Z, as long as there is a Remaining node with id3 M, for a total of exactly 23 Element nodes."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Remaining with id3 M, then we can have exactly 23 link with field3 Z, with id8 D such that there is a Solitary with vtx4 Z, with node2 U, or a Element with field3 Z, with id8 D such that there is an Solitary with vtx4 M, with value Z.",
            "NL": "Whenever there is a Remaining node with id3 M, we can have either 23 Element nodes with field3 Z, and id8 D with a Solitary with vtx4 M, and value Z, or an Element node with field3 Z, id8 D, and a Solitary with vtx4 M, and value Z."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Remaining with id3 M, then we can have exactly 23 link with field3 Z, with id8 D such that there is a Solitary with vtx4 Z, with node2 U, or a Element with field3 Z, with id8 D such that there is an Solitary with vtx4 M, with value Z.",
            "NL": "Whenever there is a Remaining node with id3 M, we can have either a Solitary with vtx4 M, with value Z, or a Element node with field3 Z, with id8 D and exactly 23 Element nodes with field3 Z, with id8 D."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Remaining with id3 M, then we can have exactly 23 link with field3 Z, with id8 D such that there is a Solitary with vtx4 Z, with node2 U, or a Element with field3 Z, with id8 D such that there is an Solitary with vtx4 M, with value Z.",
            "NL": "We can have up to 23 Element nodes with field3 Z, id8 D, and a Solitary with vtx4 M, value Z, or an Element node with field3 Z, id8 D, and a Solitary with vtx4 M, value Z whenever there is a Remaining node with id3 M."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Sanction with edge1 X, whenever there is a NonSubsequent with edge1 Y, then we can have between 49 and Y Sorted with edge1 P, and with id K such that there is a Breadth U.",
            "NL": "Whenever we have Sanction X and NonSubsequent Y, we can always have a Sorted with edge1 P and edge1 X ranging between 49 and Y with Breadth P."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Sanction with edge1 X, whenever there is a NonSubsequent with edge1 Y, then we can have between 49 and Y Sorted with edge1 P, and with id K such that there is a Breadth U.",
            "NL": "Whenever we have Sanction X and NonSubsequent Y, we can always have a Sorted with edge1 P and edge1 X ranging between 49 and Y, with Breadth P."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Sanction with edge1 X, whenever there is a NonSubsequent with edge1 Y, then we can have between 49 and Y Sorted with edge1 P, and with id K such that there is a Breadth U.",
            "NL": "We can always have a Sorted with an edge1 P and edge1 X between 49 and Y with Breadth P when we have Sanction X and NonSubsequent Y."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Sanction with edge1 X, whenever there is a NonSubsequent with edge1 Y, then we can have between 49 and Y Sorted with edge1 P, and with id K such that there is a Breadth U.",
            "NL": "Whenever we have Sanction X and NonSubsequent Y, we can always have a Sorted with edge1 P and edge1 X ranging between 49 and Y with a Breadth of P."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Sanction with edge1 X, whenever there is a NonSubsequent with edge1 Y, then we can have between 49 and Y Sorted with edge1 P, and with id K such that there is a Breadth U.",
            "NL": "Whenever Sanction X and NonSubsequent Y are present, we can always have a Sorted with edge1 P and edge1 X ranging from 49 to Y with a Breadth P."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Selected_Color with value L greater than 1, with id U, then we can have exactly 1 Dominant with first node L, with third point E such that there is a Selected_Color with first node L, with third point E, or a Dominant with first node L, with third point E such that there is a Selected_Color with first node E, with third point L.",
            "NL": "If a Selected_Color has a value of L greater than 1 and an id of U, there is only one Dominant with first node L and third point E, or a Selected_Color with first node L and third point E, or a Dominant with first node L and third point E, and a Selected_Color with first node E and third point L."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Selected_Color with value L greater than 1, with id U, then we can have exactly 1 Dominant with first node L, with third point E such that there is a Selected_Color with first node L, with third point E, or a Dominant with first node L, with third point E such that there is a Selected_Color with first node E, with third point L.",
            "NL": "If a Selected_Color has an id of U and a value of L greater than 1, then a Dominant with a first node of L and third point of E, or a Selected_Color with first node of L and third point of E, or a Dominant with first node of E and third point of L must be present for there to be exactly one Selected_Color."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Selected_Color with value L greater than 1, with id U, then we can have exactly 1 Dominant with first node L, with third point E such that there is a Selected_Color with first node L, with third point E, or a Dominant with first node L, with third point E such that there is a Selected_Color with first node E, with third point L.",
            "NL": "For any Selected_Color with a value L greater than 1 and id U, we can have either a Dominant with first node L, third point E and a Selected_Color with first node L, third point E, or a Dominant with first node L, third point E and a Selected_Color with first node E, third point L."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Selected_Color with value L greater than 1, with id U, then we can have exactly 1 Dominant with first node L, with third point E such that there is a Selected_Color with first node L, with third point E, or a Dominant with first node L, with third point E such that there is a Selected_Color with first node E, with third point L.",
            "NL": "If the Selected_Color has a value of L greater than 1 and an id of U, there can be one Dominant with first node L and third point E, or a Selected_Color with first node L, third point E, or a Dominant with first node L, third point E, and a Selected_Color with first node E and third point L."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Selected_Color with value L greater than 1, with id U, then we can have exactly 1 Dominant with first node L, with third point E such that there is a Selected_Color with first node L, with third point E, or a Dominant with first node L, with third point E such that there is a Selected_Color with first node E, with third point L.",
            "NL": "If a Selected_Color has a value L greater than 1 and an id U, then there must be either a Selected_Color with first node L, third point E, or a Dominant with first node L, third point E, and a Selected_Color with first node E, third point L."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Separate I then we can have Succeeding with id7 Q, with id7 I exactly 1 Contains with id7 Q, with id7 I.",
            "NL": "It is possible to achieve success with id7 Q and id7 I whenever there is a distinct I."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Separate I then we can have Succeeding with id7 Q, with id7 I exactly 1 Contains with id7 Q, with id7 I.",
            "NL": "It is possible to achieve success with id7 Q and id7 I, as long as there is a distinct I each time."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Separate I then we can have Succeeding with id7 Q, with id7 I exactly 1 Contains with id7 Q, with id7 I.",
            "NL": "It is possible to achieve success with id7 Q and id7 I, as long as there is a distinct separation between the two."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Separate I then we can have Succeeding with id7 Q, with id7 I exactly 1 Contains with id7 Q, with id7 I.",
            "NL": "It is possible to achieve success with id7 Q and id7 I if there is a distinct separation between them."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Separate I then we can have Succeeding with id7 Q, with id7 I exactly 1 Contains with id7 Q, with id7 I.",
            "NL": "It is possible to achieve success with id7 Q and id7 I, provided that there is a distinct I present."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Sequence K, then we can have exactly 1 Size_of_Clique with vtx1 K, and with value10 L such that there is a Fine L.",
            "NL": "We can always have a Size_of_Clique with vtx1 K and value10 L of exactly 1 Fine L whenever there is a Sequence K present."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Sequence K, then we can have exactly 1 Size_of_Clique with vtx1 K, and with value10 L such that there is a Fine L.",
            "NL": "Whenever there is a Sequence K, we can always have a Size_of_Clique with vtx1 K and value10 L set to exactly 1 Fine L."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Sequence K, then we can have exactly 1 Size_of_Clique with vtx1 K, and with value10 L such that there is a Fine L.",
            "NL": "Whenever there is a Sequence K, we can always have a Size_of_Clique with vtx1 K and value10 L exactly 1 Fine L."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Sequence K, then we can have exactly 1 Size_of_Clique with vtx1 K, and with value10 L such that there is a Fine L.",
            "NL": "We can always have a Size_of_Clique with vtx1 K and value10 L exactly 1 Fine L in a Sequence K."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Sequence K, then we can have exactly 1 Size_of_Clique with vtx1 K, and with value10 L such that there is a Fine L.",
            "NL": "We can always have a Size_of_Clique with vtx1 K and value10 L of exactly 1 Fine L in the event that a Sequence K exists."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Shade I, then we can have exactly 1 Marker with vtx5 I, and with vtx7 F such that there is a Identifier F.",
            "NL": "We can always have a Marker with vtx5 I and vtx7 F, along with exactly one Identifier F, whenever there is a Shade I present."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Shade I, then we can have exactly 1 Marker with vtx5 I, and with vtx7 F such that there is a Identifier F.",
            "NL": "We can always have a Marker with vtx5 I and vtx7 F, along with an Identifier F, whenever there is a Shade I present."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Shade I, then we can have exactly 1 Marker with vtx5 I, and with vtx7 F such that there is a Identifier F.",
            "NL": "Whenever there is a Shade I, we can always have a Marker with VTX5 I and VTX7 F, along with exactly one Identifier F."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Shade I, then we can have exactly 1 Marker with vtx5 I, and with vtx7 F such that there is a Identifier F.",
            "NL": "We can always have a Marker with vtx5 I and vtx7 F, both with an Identifier F, whenever there is a Shade I."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Shade I, then we can have exactly 1 Marker with vtx5 I, and with vtx7 F such that there is a Identifier F.",
            "NL": "We can always ensure that there is a Marker with vtx5 I and vtx7 F, plus exactly one Identifier F, when there is a Shade I present."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Sign G, then we can have exactly 31 Incidence with vtx4 G, and with vtx10 H such that there is a Divide H.",
            "NL": "If there is a Sign G, we can always have an Incidence with vtx4 G and vtx10 H that is divided by 31 H."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Sign G, then we can have exactly 31 Incidence with vtx4 G, and with vtx10 H such that there is a Divide H.",
            "NL": "We can always divide VTX4G and VTX10H by 31 whenever there is a SignG present."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Sign G, then we can have exactly 31 Incidence with vtx4 G, and with vtx10 H such that there is a Divide H.",
            "NL": "We can always divide vtx10 H by 31 whenever there is a Sign G and an Incidence with vtx4 G."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Sign G, then we can have exactly 31 Incidence with vtx4 G, and with vtx10 H such that there is a Divide H.",
            "NL": "We can always divide vtx10 H by 31 whenever there is a sign of vtx4 G."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Sign G, then we can have exactly 31 Incidence with vtx4 G, and with vtx10 H such that there is a Divide H.",
            "NL": "We can always divide vtx10 H by 31 when there is a Sign G, and have an Incident with vtx4 G and vtx10 H."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Sign with value equal to 28 then we can have at least 18 Active with id6 D such that there is a Following with node5 Dor a Active with id6 C such that there is a Following with node3 C.",
            "NL": "If the Sign has a value of 28, we can have a minimum of 18 Active with id6 D and either a Following with node5 D or an Active with id6 C with a Following with node3 C."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Sign with value equal to 28 then we can have at least 18 Active with id6 D such that there is a Following with node5 Dor a Active with id6 C such that there is a Following with node3 C.",
            "NL": "If the Sign is valued at 28, we can have a minimum of 18 Active with id6 D that have a Following with node5 D, or an Active with id6 C that has a Following with node3 C."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Sign with value equal to 28 then we can have at least 18 Active with id6 D such that there is a Following with node5 Dor a Active with id6 C such that there is a Following with node3 C.",
            "NL": "If the Sign has a value of 28, we can have a minimum of 18 Active with id6 D and either a Following with node5 D or an Active with id6 C and a Following with node3 C."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Sign with value equal to 28 then we can have at least 18 Active with id6 D such that there is a Following with node5 Dor a Active with id6 C such that there is a Following with node3 C.",
            "NL": "If the Sign has a value of 28, we can have a minimum of 18 Active with id6 D that has a Following with node5 D, or an Active with id6 C that has a Following with node3 C."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Sign with value equal to 28 then we can have at least 18 Active with id6 D such that there is a Following with node5 Dor a Active with id6 C such that there is a Following with node3 C.",
            "NL": "If the Sign has a value of 28, we can ensure that there are at least 18 Active with id6 D and a Following with node5 D, or an Active with id6 C and a Following with node3 C."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Solitary with node10 A, then we can have exactly 5 link with vtx10 F, with node B such that there is a LessThanExists with value7 F, with node2 U, or a Success with vtx10 F, with node B such that there is an LessThanExists with value7 A, with value2 F.",
            "NL": "We can have a Solitary node with node10 A, which will result in a Success node with vtx10 F and node B with a LessThanExists with value7 A, with value2 F, or a Success node with vtx10 F, node B and a LessThanExists with value7 A, with value2 F, as long as there are no more than 5 Success nodes."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Solitary with node10 A, then we can have exactly 5 link with vtx10 F, with node B such that there is a LessThanExists with value7 F, with node2 U, or a Success with vtx10 F, with node B such that there is an LessThanExists with value7 A, with value2 F.",
            "NL": "We can have a Solitary node with node10 A that triggers either a Success node with vtx10 F, node B, and LessThanExists with value7 A and value2 F, or just a Success node with vtx10 F, node B, and LessThanExists with value7 A and value2 F, up to a maximum of five."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Solitary with node10 A, then we can have exactly 5 link with vtx10 F, with node B such that there is a LessThanExists with value7 F, with node2 U, or a Success with vtx10 F, with node B such that there is an LessThanExists with value7 A, with value2 F.",
            "NL": "We can have either five Success nodes with vtx10 F and node B such that there is a LessThanExists with value7 A and value2 F, or a Success node with vtx10 F, node B, LessThanExists with value7 A, and value2 F, as long as there is a Solitary node with node10 A."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Solitary with node10 A, then we can have exactly 5 link with vtx10 F, with node B such that there is a LessThanExists with value7 F, with node2 U, or a Success with vtx10 F, with node B such that there is an LessThanExists with value7 A, with value2 F.",
            "NL": "We can set up a Solitary node with node10 A that triggers either a Success node with vtx10 F and node B, and LessThanExists with value7 A and value2 F, or a Success node with vtx10 F, node B, LessThanExists with value7 A, and value2 F, for a total of five Success nodes."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Solitary with node10 A, then we can have exactly 5 link with vtx10 F, with node B such that there is a LessThanExists with value7 F, with node2 U, or a Success with vtx10 F, with node B such that there is an LessThanExists with value7 A, with value2 F.",
            "NL": "We can have a Success node with vtx10 F, accompanied by node B and a LessThanExists with value7 A and value2 F, or alternatively a Success node with vtx10 F, node B, and a LessThanExists with value7 A and value2 F, provided that there is a Solitary node with node10 A."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Sorted T, then we can have exactly 5 Insignificant with key3 T, and with id8 W such that there is a Complex W.",
            "NL": "We can always have a key3 T and id8 W with exactly five Complex W when there is a Sorted T present."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Sorted T, then we can have exactly 5 Insignificant with key3 T, and with id8 W such that there is a Complex W.",
            "NL": "We can always have a Small Key3 T and ID8 W with exactly 5 Complex W whenever there is an Ordered T."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Sorted T, then we can have exactly 5 Insignificant with key3 T, and with id8 W such that there is a Complex W.",
            "NL": "We can always have a key3 T and id8 W with exactly 5 Complex W whenever there is a Sorted T available."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Sorted T, then we can have exactly 5 Insignificant with key3 T, and with id8 W such that there is a Complex W.",
            "NL": "We can always obtain a Sorted T with key3 T and id8 W, as well as exactly 5 Complex W, whenever necessary."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Sorted T, then we can have exactly 5 Insignificant with key3 T, and with id8 W such that there is a Complex W.",
            "NL": "We can always have a Small Key with T3 and W8 exactly 5 Complex W whenever there is an Organized Task."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Source_Data Q then we can have Offspring with vtx8 F, and with vtx10 Q exactly 18 Incoming_Level F.",
            "NL": "We can always have an Incoming_Level of F with vtx8, and an Incoming_Level of Q with vtx10 whenever there is a vtx8 F present."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Source_Data Q then we can have Offspring with vtx8 F, and with vtx10 Q exactly 18 Incoming_Level F.",
            "NL": "We can always have an Incoming_Level of F with vtx8, and with vtx10 an Incoming_Level of Q with exactly 18 Fs, whenever vtx8 is present."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Source_Data Q then we can have Offspring with vtx8 F, and with vtx10 Q exactly 18 Incoming_Level F.",
            "NL": "We can always have an Incoming_Level of vtx8 F and vtx10 Q of exactly 18 Incoming_Level F whenever there is a vtx8 F present."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Source_Data Q then we can have Offspring with vtx8 F, and with vtx10 Q exactly 18 Incoming_Level F.",
            "NL": "We can always have an Incoming_Level of F with vtx8 and an Incoming_Level of Q with vtx10 whenever there is a vtx8 F present."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Source_Data Q then we can have Offspring with vtx8 F, and with vtx10 Q exactly 18 Incoming_Level F.",
            "NL": "We can always have an Incoming_Level with vtx8 F, and with vtx10 Q exactly 18 Incoming_Level F, whenever vtx8 F is present."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Start V, then we can have exactly 20 Complete with field9 V, and with value10 A such that there is a NonForemost A.",
            "NL": "Whenever Start V is present, we can always have a Complete field with V and value A exactly 20 NonForemost A."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Start V, then we can have exactly 20 Complete with field9 V, and with value10 A such that there is a NonForemost A.",
            "NL": "We can always have a Complete V with field9 A and value10 V, plus exactly 20 NonForemost V, whenever there is a Start A."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Start V, then we can have exactly 20 Complete with field9 V, and with value10 A such that there is a NonForemost A.",
            "NL": "Whenever there is a Start V, we can always have a Complete field9 V and value10 A consisting of exactly 20 NonForemost A."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Start V, then we can have exactly 20 Complete with field9 V, and with value10 A such that there is a NonForemost A.",
            "NL": "We can always have a Complete field9 V and value10 A of exactly 20 NonForemost A whenever there is a Start V."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Start V, then we can have exactly 20 Complete with field9 V, and with value10 A such that there is a NonForemost A.",
            "NL": "We can always have a Complete with field9 V and value10 A of exactly 20 NonForemost A whenever there is a Start V."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Statistical_Significance D then we can have Marker with value2 E, with value2 D exactly 1 Alpha_Value with value2 E, with value2 D.",
            "NL": "It is feasible to have one Alpha_Value with a value of E and D when there is a Statistical_Significance of D, and a Marker with a value of E and D."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Statistical_Significance D then we can have Marker with value2 E, with value2 D exactly 1 Alpha_Value with value2 E, with value2 D.",
            "NL": "It is possible to have one Alpha_Value with a value of E and one with a value of D whenever there is a Statistical_Significance D for Marker."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Statistical_Significance D then we can have Marker with value2 E, with value2 D exactly 1 Alpha_Value with value2 E, with value2 D.",
            "NL": "It is possible to have one Alpha_Value with value2 E and value2 D when there is a Statistical_Significance D, and Marker with value2 E and value2 D."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Statistical_Significance D then we can have Marker with value2 E, with value2 D exactly 1 Alpha_Value with value2 E, with value2 D.",
            "NL": "It is possible to have one Alpha_Value with value2 E and value2 D whenever there is a Statistical_Significance D, along with Marker with value2 E and value2 D."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Statistical_Significance D then we can have Marker with value2 E, with value2 D exactly 1 Alpha_Value with value2 E, with value2 D.",
            "NL": "It is possible to have one Alpha_Value with value2 E and value2 D whenever there is a Statistical_Significance D, and Marker with value2 E and value2 D."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Subgraph D then we can have OutgoingRoute with edge1 S, with edge1 D exactly 1 Degree with edge1 S, with edge1 D.",
            "NL": "It is possible for an OutgoingRoute to have edge1 S and edge1 D with a maximum of 1 Degree apart, as long as there is a Subgraph D present."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Subgraph D then we can have OutgoingRoute with edge1 S, with edge1 D exactly 1 Degree with edge1 S, with edge1 D.",
            "NL": "It is possible to have an OutgoingRoute with edge1 S and edge1 D at a maximum of 1 Degree apart, provided that there is a Subgraph D present."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Subgraph D then we can have OutgoingRoute with edge1 S, with edge1 D exactly 1 Degree with edge1 S, with edge1 D.",
            "NL": "It is possible to have an OutgoingRoute with edge1 S, with edge1 D at a maximum of 1 Degree with edge1 S, and edge1 D when a Subgraph D is present."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Subgraph D then we can have OutgoingRoute with edge1 S, with edge1 D exactly 1 Degree with edge1 S, with edge1 D.",
            "NL": "It is possible for OutgoingRoute to have edge1 S and edge1 D with a difference in degree of exactly 1 between edge1 S and edge1 D whenever there is a Subgraph D."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Subgraph D then we can have OutgoingRoute with edge1 S, with edge1 D exactly 1 Degree with edge1 S, with edge1 D.",
            "NL": "It is possible to have an OutgoingRoute with edge1 S and edge1 D having an exact angle of 1 Degree, and a Subgraph D whenever present."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Subsequent with node7 F, whenever there is an Outpath with node7 J, then we can have between 6 and J Module with node7 M, and with id K such that there is a Node U.",
            "NL": "We can have a Module with Node M and Node F ranging from 6 to J whenever we have Subsequent F and Outpath J."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Subsequent with node7 F, whenever there is an Outpath with node7 J, then we can have between 6 and J Module with node7 M, and with id K such that there is a Node U.",
            "NL": "Whenever we have Subsequent F and Outpath J, we can always have a Module with Node7 M and Node7 F ranging between 6 and J with Node M."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Subsequent with node7 F, whenever there is an Outpath with node7 J, then we can have between 6 and J Module with node7 M, and with id K such that there is a Node U.",
            "NL": "We can always have a Module with node7 M and node7 F ranging between 6 and J with Node M whenever we have Subsequent F and an Outpath of J."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Subsequent with node7 F, whenever there is an Outpath with node7 J, then we can have between 6 and J Module with node7 M, and with id K such that there is a Node U.",
            "NL": "We can always have a Module with Node7M and Node7F ranging between 6 and J, with NodeM, provided we have Subsequent F and Outpath J."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Subsequent with node7 F, whenever there is an Outpath with node7 J, then we can have between 6 and J Module with node7 M, and with id K such that there is a Node U.",
            "NL": "We can always have a Module with Node M ranging from 6 to J, along with Node F and Subsequent F, whenever we have Outpath J."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Subsequent with value8 H, then we can have exactly 3 link with key2 G, with edge1 U such that there is a Start with id7 G, with node2 U, or a Capacity with key2 G, with edge1 U such that there is an Start with id7 H, with vtx7 G.",
            "NL": "We can set up either a Capacity node with key2 G, edge1 U, and a Start with id7 H, vtx7 G, or a Capacity node with key2 G, edge1 U, and a Start with id7 H, vtx7 G, provided that there is a Subsequent node with value8 H, up to a maximum of 3 Capacity nodes."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Subsequent with value8 H, then we can have exactly 3 link with key2 G, with edge1 U such that there is a Start with id7 G, with node2 U, or a Capacity with key2 G, with edge1 U such that there is an Start with id7 H, with vtx7 G.",
            "NL": "We can always have a Start with id7 H, with vtx7 G, or a Capacity node with key2 G and edge1 U, as long as there is a Subsequent node with value8 H, with a maximum of 3 Capacity nodes with key2 G and edge1 U."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Subsequent with value8 H, then we can have exactly 3 link with key2 G, with edge1 U such that there is a Start with id7 G, with node2 U, or a Capacity with key2 G, with edge1 U such that there is an Start with id7 H, with vtx7 G.",
            "NL": "We can have a Start node with id7 H, with vtx7 G and a Capacity node with key2 G and edge1 U, or alternatively a Capacity node with key2 G, edge1 U and a Start node with id7 H, with vtx7 G, provided that there is a Subsequent node with value8 H."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Subsequent with value8 H, then we can have exactly 3 link with key2 G, with edge1 U such that there is a Start with id7 G, with node2 U, or a Capacity with key2 G, with edge1 U such that there is an Start with id7 H, with vtx7 G.",
            "NL": "We can have either a Start node with id7 H, with vtx7 G and 3 Capacity nodes with key2 G, with edge1 U, or a Start node with id7 H, with vtx7 G and a Capacity node with key2 G, with edge1 U, whenever there is a Subsequent node with value8 H."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Subsequent with value8 H, then we can have exactly 3 link with key2 G, with edge1 U such that there is a Start with id7 G, with node2 U, or a Capacity with key2 G, with edge1 U such that there is an Start with id7 H, with vtx7 G.",
            "NL": "Whenever there is a Subsequent node with value8 H, we can have either a Start with id7 H and vtx7 G, or a Capacity node with key2 G and edge1 U, both of which have a maximum of 3 Capacity nodes."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Tag J, then we can have exactly 18 Entered with id5 J, and with vtx7 I such that there is a Edge_Level I.",
            "NL": "We can always create an Entry with id5 J and vtx7 I at exactly 18 Edge_Level I whenever there is a Tag J."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Tag J, then we can have exactly 18 Entered with id5 J, and with vtx7 I such that there is a Edge_Level I.",
            "NL": "We can always have an Entry with id5 J and vtx7 I with exactly 18 Edge_Level I, whenever there is a Tag J present."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Tag J, then we can have exactly 18 Entered with id5 J, and with vtx7 I such that there is a Edge_Level I.",
            "NL": "We can always have an Entry with id5 J and vtx7 I with exactly 18 Edge_Level I whenever there is a Tag J."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Tag J, then we can have exactly 18 Entered with id5 J, and with vtx7 I such that there is a Edge_Level I.",
            "NL": "Whenever there is a Tag J, we can always have an Entry with id5 J and vtx7 I at exactly 18 Edge_Level I."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Tag J, then we can have exactly 18 Entered with id5 J, and with vtx7 I such that there is a Edge_Level I.",
            "NL": "We can always have an Entry with id5 J and vtx7 I with exactly 18 Edge_Level I whenever there is a Tag J present."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Tone with id7 Y, then we can have exactly 29 link with node6 M, with key8 V such that there is a Marker with edge6 M, with node2 U, or a Periphery with node6 M, with key8 V such that there is a Marker with edge6 Y, with node4 M.",
            "NL": "We can have up to 29 Periphery nodes with node6 M, key8 V, and a Marker with edge6 Y, node4 M, as well as a Periphery node with node6 M, key8 V, and a Marker with edge6 Y, node4 M, whenever there is a Tone node with id7 Y."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Tone with id7 Y, then we can have exactly 29 link with node6 M, with key8 V such that there is a Marker with edge6 M, with node2 U, or a Periphery with node6 M, with key8 V such that there is a Marker with edge6 Y, with node4 M.",
            "NL": "Whenever there is a Tone node with id7 Y, we can have either 29 Periphery nodes with node6 M and key8 V, which has a Marker with edge6 Y and node4 M, or a Periphery node with node6 M and key8 V, which has a Marker with edge6 Y and node4 M."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Tone with id7 Y, then we can have exactly 29 link with node6 M, with key8 V such that there is a Marker with edge6 M, with node2 U, or a Periphery with node6 M, with key8 V such that there is a Marker with edge6 Y, with node4 M.",
            "NL": "We can have up to 29 Periphery nodes with node6 M, key8 V, and a Marker with edge6 Y, node4 M, OR a Periphery node with node6 M, key8 V, and a Marker with edge6 Y, node4 M, provided that there is a Tone node with id7 Y present."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Tone with id7 Y, then we can have exactly 29 link with node6 M, with key8 V such that there is a Marker with edge6 M, with node2 U, or a Periphery with node6 M, with key8 V such that there is a Marker with edge6 Y, with node4 M.",
            "NL": "We can have 29 Periphery nodes with node6 M and key8 V, along with a Marker with edge6 Y and node4 M, or a Periphery node with node6 M and key8 V which also has a Marker with edge6 Y and node4 M, provided that there is a Tone node with id7 Y present."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Tone with id7 Y, then we can have exactly 29 link with node6 M, with key8 V such that there is a Marker with edge6 M, with node2 U, or a Periphery with node6 M, with key8 V such that there is a Marker with edge6 Y, with node4 M.",
            "NL": "We can have 29 Periphery nodes with node6 M and key8 V, each having a Marker with edge6 Y and node4 M, or a Tone node with id7 Y, whenever there is one."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Trapped U then we can have Accomplished with field6 W, and with field10 U exactly 17 In_Hamiltonian W.",
            "NL": "We can always have an In_Hamiltonian with field6 W, and with field10 U exactly 17 In_Hamiltonian W, provided that there is a field6 W present."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Trapped U then we can have Accomplished with field6 W, and with field10 U exactly 17 In_Hamiltonian W.",
            "NL": "We can always have an In_Hamiltonian with field6 W and exactly 17 In_Hamiltonian W with field10 U, whenever there is a field6 W present."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Trapped U then we can have Accomplished with field6 W, and with field10 U exactly 17 In_Hamiltonian W.",
            "NL": "Whenever there is a field6 W, we can always have an In_Hamiltonian with field6 W and exactly 17 In_Hamiltonian W with field10 U."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Trapped U then we can have Accomplished with field6 W, and with field10 U exactly 17 In_Hamiltonian W.",
            "NL": "We can always have an In_Hamiltonian with field6 W and exactly 17 In_Hamiltonian W with field10 U, provided that there is a field6 W."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a Trapped U then we can have Accomplished with field6 W, and with field10 U exactly 17 In_Hamiltonian W.",
            "NL": "We can always have an In_Hamiltonian with field6 W, and 17 In_Hamiltonian W with field10 U, whenever there is a field6 W."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Tree with value equal to 27 then we can have at least 48 Edge_Pairing with node8 G such that there is a Data with value7 Gor a Edge_Pairing with node8 A such that there is a Data with vtx3 A.",
            "NL": "For a Tree with a value of 27, we can establish at least 48 Edge_Pairings with node8 G, each of which has a Data with value7 G, or an Edge_Pairing with node8 A, which has a Data with vtx3 A."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Tree with value equal to 27 then we can have at least 48 Edge_Pairing with node8 G such that there is a Data with value7 Gor a Edge_Pairing with node8 A such that there is a Data with vtx3 A.",
            "NL": "If a Tree has a value of 27, there can be at least 48 Edge_Pairings with node8 G that have a Data with value7 G or an Edge_Pairing with node8 A that has a Data with vtx3 A."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Tree with value equal to 27 then we can have at least 48 Edge_Pairing with node8 G such that there is a Data with value7 Gor a Edge_Pairing with node8 A such that there is a Data with vtx3 A.",
            "NL": "If Tree has a value of 27, we can have at least 48 Edge_Pairing involving node8 G, where there is a Data with value7 G, or an Edge_Pairing with node8 A, where there is a Data with vtx3 A."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Tree with value equal to 27 then we can have at least 48 Edge_Pairing with node8 G such that there is a Data with value7 Gor a Edge_Pairing with node8 A such that there is a Data with vtx3 A.",
            "NL": "We can have a minimum of 48 Edge_Pairings with node8 G when a Tree has a value of 27, and either there is a Data with value7 G or a Edge_Pairing with node8 A that contains a Data with vtx3 A."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Tree with value equal to 27 then we can have at least 48 Edge_Pairing with node8 G such that there is a Data with value7 Gor a Edge_Pairing with node8 A such that there is a Data with vtx3 A.",
            "NL": "We can have at least 48 Edge_Pairings with node8 G when a Tree has a value of 27, with either a Data with value7 G or a Edge_Pairing with node8 A and a Data with vtx3 A."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Triumph with key5 F, then we can have exactly 40 link with vtx2 N, with node O such that there is a Punishment with vtx1 N, with node2 U, or a Starting with vtx2 N, with node O such that there is a Punishment with vtx1 F, with node1 N.",
            "NL": "We can have up to 40 Starting nodes with vtx2 N, node O, and vtx1 F, node1 N, or a Starting node with vtx2 N, node O, and vtx1 F, node1 N for each Triumph node with key5 F."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Triumph with key5 F, then we can have exactly 40 link with vtx2 N, with node O such that there is a Punishment with vtx1 N, with node2 U, or a Starting with vtx2 N, with node O such that there is a Punishment with vtx1 F, with node1 N.",
            "NL": "We can have up to 40 Starting nodes with vtx2 N and node O, with either a Punishment with vtx1 F, node1 N, or a Triumph node with key5 F, whenever there is a Starting node with vtx2 N and node O."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Triumph with key5 F, then we can have exactly 40 link with vtx2 N, with node O such that there is a Punishment with vtx1 N, with node2 U, or a Starting with vtx2 N, with node O such that there is a Punishment with vtx1 F, with node1 N.",
            "NL": "We can have up to 40 Starting nodes with vtx2 N, each with node O and a Punishment with vtx1 F, node1 N, or a Starting node with vtx2 N, node O and a Punishment with vtx1 F, node1 N when a Triumph node with key5 F is present."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Triumph with key5 F, then we can have exactly 40 link with vtx2 N, with node O such that there is a Punishment with vtx1 N, with node2 U, or a Starting with vtx2 N, with node O such that there is a Punishment with vtx1 F, with node1 N.",
            "NL": "We can have up to 40 Starting nodes with vtx2 N and node O, and if there is a Triumph node with key5 F, then there will be either a Punishment with vtx1 F and node1 N, or a Starting node with vtx2 N and node O and a Punishment with vtx1 F and node1 N."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Triumph with key5 F, then we can have exactly 40 link with vtx2 N, with node O such that there is a Punishment with vtx1 N, with node2 U, or a Starting with vtx2 N, with node O such that there is a Punishment with vtx1 F, with node1 N.",
            "NL": "We can have up to 40 Starting nodes with vtx2 N and node O, which may be accompanied by a Punishment with vtx1 F, node1 N, or a Triumph node with key5 F that would also have a Punishment with vtx1 F, node1 N."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Unconnected with node9 U, whenever there is a NonFollowing with node9 L, then we can have between 48 and L IngoingPath with node9 S, and with id K such that there is a Sub_Index U.",
            "NL": "We can always create an IngoingPath with nodes 9S and 9U between 48 and L, including a Sub_Index S, when Unconnected U and NonFollowing L are present."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Unconnected with node9 U, whenever there is a NonFollowing with node9 L, then we can have between 48 and L IngoingPath with node9 S, and with id K such that there is a Sub_Index U.",
            "NL": "We can always establish an IngoingPath with node9 S and node9 U that lies between 48 and L, along with Sub_Index S, if Unconnected U and NonFollowing L are present."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Unconnected with node9 U, whenever there is a NonFollowing with node9 L, then we can have between 48 and L IngoingPath with node9 S, and with id K such that there is a Sub_Index U.",
            "NL": "Whenever we have Unconnected U and NonFollowing L, we can always have an IngoingPath with node9 S and node9 U between 48 and L with Sub_Index S."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Unconnected with node9 U, whenever there is a NonFollowing with node9 L, then we can have between 48 and L IngoingPath with node9 S, and with id K such that there is a Sub_Index U.",
            "NL": "Whenever we have Unconnected U and NonFollowing L, we can always have an IngoingPath between node9 S and node9 U, with Sub_Index S ranging between 48 and L."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Unconnected with node9 U, whenever there is a NonFollowing with node9 L, then we can have between 48 and L IngoingPath with node9 S, and with id K such that there is a Sub_Index U.",
            "NL": "We can always establish an IngoingPath between node9 S and node9 U, with Sub_Index S, provided that Unconnected U and NonFollowing L are present, and the range is between 48 and L."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Undirected_Graph with id2 Z, and with field H, whenever there is an Attained with id2 Z, and with field H, whenever there is not a Edge with layer field Z, and with id2 B, then we can have at least 6 Assign with field2 Z, and with value7 H, and with edge6 B.",
            "NL": "If there is an Undirected_Graph with id2 Z, an Attained with id2 Z and field H, but no Edge with layer field Z and id2 B, we can have a minimum of 6 Assigns with field2 Z, value7 H and edge6 B."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Undirected_Graph with id2 Z, and with field H, whenever there is an Attained with id2 Z, and with field H, whenever there is not a Edge with layer field Z, and with id2 B, then we can have at least 6 Assign with field2 Z, and with value7 H, and with edge6 B.",
            "NL": "If there is an Undirected_Graph with id2 Z, an Attained with id2 Z and field H, and no Edge with layer field Z and id2 B, we can have a minimum of 6 Assigns with field2 Z, value7 H, and edge6 B."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Undirected_Graph with id2 Z, and with field H, whenever there is an Attained with id2 Z, and with field H, whenever there is not a Edge with layer field Z, and with id2 B, then we can have at least 6 Assign with field2 Z, and with value7 H, and with edge6 B.",
            "NL": "If an Undirected_Graph with id2 Z and an Attained with id2 Z and field H exist, then no Edge with layer field Z and id2 B can be found, allowing us to have at least 6 Assigns with field2 Z, value7 H, and edge6 B."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Undirected_Graph with id2 Z, and with field H, whenever there is an Attained with id2 Z, and with field H, whenever there is not a Edge with layer field Z, and with id2 B, then we can have at least 6 Assign with field2 Z, and with value7 H, and with edge6 B.",
            "NL": "If an Undirected_Graph with id2 Z and an Attained with id2 Z, field H exist, and there is no Edge with layer field Z, id2 B, then we can have at least 6 Assigns with field2 Z, value7 H, and edge6 B."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Undirected_Graph with id2 Z, and with field H, whenever there is an Attained with id2 Z, and with field H, whenever there is not a Edge with layer field Z, and with id2 B, then we can have at least 6 Assign with field2 Z, and with value7 H, and with edge6 B.",
            "NL": "If there is an Undirected_Graph with id2 Z, an Attained with id2 Z and field H, and no Edge with layer field Z and id2 B, then we can have at least 6 Assigns with field2 Z, value7 H, and edge6 B."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Unimportant with id4 G, then we can have exactly 44 link with value7 F, with field1 B such that there is a Variation with vtx5 F, with node2 U, or a Periphery with value7 F, with field1 B such that there is an Variation with vtx5 G, with value9 F.",
            "NL": "Whenever there is an Unimportant node with id4 G, we can have either 44 Periphery nodes with value7 F, with field1 B and a Variation with vtx5 G, with value9 F, or a single Periphery node with value7 F, with field1 B and a Variation with vtx5 G, with value9 F."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Unimportant with id4 G, then we can have exactly 44 link with value7 F, with field1 B such that there is a Variation with vtx5 F, with node2 U, or a Periphery with value7 F, with field1 B such that there is an Variation with vtx5 G, with value9 F.",
            "NL": "Whenever there is an Unimportant node with id4 G, we can have either a Periphery node with value7 F, with field1 B and a Variation with vtx5 G, with value9 F, or a Periphery node with value7 F, with field1 B and a Variation with vtx5 G, with value9 F, for a total of 44 Periphery nodes."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Unimportant with id4 G, then we can have exactly 44 link with value7 F, with field1 B such that there is a Variation with vtx5 F, with node2 U, or a Periphery with value7 F, with field1 B such that there is an Variation with vtx5 G, with value9 F.",
            "NL": "We can have up to 44 Periphery nodes with value7 F and field1 B, each with a Variation with vtx5 G and value9 F, or a Periphery node with value7 F, field1 B, and a Variation with vtx5 G and value9 F if there is an Unimportant node with id4 G."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Unimportant with id4 G, then we can have exactly 44 link with value7 F, with field1 B such that there is a Variation with vtx5 F, with node2 U, or a Periphery with value7 F, with field1 B such that there is an Variation with vtx5 G, with value9 F.",
            "NL": "Whenever there is an Unimportant node with id4 G, we can have either 44 Periphery nodes with value7 F, with field1 B and a Variation with vtx5 G, with value9 F, or a Periphery node with value7 F, with field1 B and a Variation with vtx5 G, with value9 F."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a Unimportant with id4 G, then we can have exactly 44 link with value7 F, with field1 B such that there is a Variation with vtx5 F, with node2 U, or a Periphery with value7 F, with field1 B such that there is an Variation with vtx5 G, with value9 F.",
            "NL": "We can have either 44 Periphery nodes with value7 F and field1 B that have a Variation with vtx5 G and value9 F, or a Periphery node with value7 F and field1 B that has a Variation with vtx5 G and value9 F, provided there is an Unimportant node with id4 G."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a var X then we can have in with value C, with id X exactly 1 pair with value C, with id X.",
            "NL": "Whenever there is a var X, it is possible to have exactly one pair of IN with a value of C and an id of X."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a var X then we can have in with value C, with id X exactly 1 pair with value C, with id X.",
            "NL": "It is possible to have exactly one pair of value C and ID X whenever var X is present."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a var X then we can have in with value C, with id X exactly 1 pair with value C, with id X.",
            "NL": "Whenever there is a var X, it is possible to have exactly one pair with value C and id X."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a var X then we can have in with value C, with id X exactly 1 pair with value C, with id X.",
            "NL": "Whenever there is a var X, it is possible to have exactly one pair of IN with value C and id X."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a var X then we can have in with value C, with id X exactly 1 pair with value C, with id X.",
            "NL": "It is possible to have one pair of IN with value C and id X whenever there is a variable X."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a vtx U then we can have levelvtx with value L, and with id U exactly 1 level L. ",
            "NL": "We can always have a vertex at level L with value L and with id U, precisely 1 level above vertex U level."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a vtx U then we can have levelvtx with value L, and with id U exactly 1 level L. ",
            "NL": "A vertex U always enables us to have a level vertex with value L and id U at exactly 1 level L."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a vtx U then we can have levelvtx with value L, and with id U exactly 1 level L. ",
            "NL": "Given the existence of vertex U, we can invariably establish a level vertex with value L, and with id U on precisely 1 level L."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a vtx U then we can have levelvtx with value L, and with id U exactly 1 level L. ",
            "NL": "The presence of vertex U always allows for a level vertex with value L, and an id U positioned at exactly 1 level L."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is a vtx U then we can have levelvtx with value L, and with id U exactly 1 level L. ",
            "NL": "When a vertex U is present, it's always possible to generate a level vertex with a value of L, and an id U at precisely 1 level L."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a vtx U, then we can have exactly 1 partition with value U, and with id K such that there is a part K.",
            "NL": "We can always have a partition with value U and ID K, with exactly one part K, whenever there is a vertex U."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a vtx U, then we can have exactly 1 partition with value U, and with id K such that there is a part K.",
            "NL": "Whenever there is a vertex U, we can always have a partition with value U and id K, having exactly one part K."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a vtx U, then we can have exactly 1 partition with value U, and with id K such that there is a part K.",
            "NL": "We can always have a partition with the value of U and the ID of K, consisting of exactly one part K, when there is a vertex U."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a vtx U, then we can have exactly 1 partition with value U, and with id K such that there is a part K.",
            "NL": "Whenever there is a vertex U, we can always have exactly one partition with both value U and id K."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is a vtx U, then we can have exactly 1 partition with value U, and with id K such that there is a part K.",
            "NL": "Whenever there is a vertex U, we can always have a partition with value U and id K, with exactly one part K."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is an Accessed with field6 F, whenever there is an Ancestor with field6 U, then we can have between 43 and U Victory with field6 Z, and with id K such that there is a Link U.",
            "NL": "Whenever we have Accessed F and Ancestor U, we can always achieve Victory with field6 Z and field6 F ranging between 43 and U, combined with Link Z."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is an Accessed with field6 F, whenever there is an Ancestor with field6 U, then we can have between 43 and U Victory with field6 Z, and with id K such that there is a Link U.",
            "NL": "Whenever we have Accessed F and Ancestor U, Victory with field6 Z and field6 F ranging between 43 and U can always be achieved with Link Z."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is an Accessed with field6 F, whenever there is an Ancestor with field6 U, then we can have between 43 and U Victory with field6 Z, and with id K such that there is a Link U.",
            "NL": "Whenever we have Accessed F and Ancestor U, we can always achieve a Victory with field6 Z and field6 F ranging between 43 and U, with Link Z."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is an Accessed with field6 F, whenever there is an Ancestor with field6 U, then we can have between 43 and U Victory with field6 Z, and with id K such that there is a Link U.",
            "NL": "Whenever we have Accessed F and Ancestor U, we can always achieve Victory with field6 Z and field6 F ranging between 43 and U, along with Link Z."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is an Accessed with field6 F, whenever there is an Ancestor with field6 U, then we can have between 43 and U Victory with field6 Z, and with id K such that there is a Link U.",
            "NL": "We can always achieve success with field6 Z and field6 F ranging between 43 and U, along with Link Z, when we have Accessed F and Ancestor U."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is an Active with value L greater than 1, with id U, then we can have exactly 1 Associated with first point I, with third point H such that there is an Active with first point I, with third point H, or a Associated with first point I, with third point H such that there is an Active with first point H, with third point I.",
            "NL": "If an Active has a value L greater than 1 and an id of U, there will be precisely one Associated with first point I and third point H, or an Active with first point I and third point H, or an Associated with first point I and third point H, with an Active having first point H and third point I."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is an Active with value L greater than 1, with id U, then we can have exactly 1 Associated with first point I, with third point H such that there is an Active with first point I, with third point H, or a Associated with first point I, with third point H such that there is an Active with first point H, with third point I.",
            "NL": "When the Active has a value of L greater than 1 and an id of U, there will be either an Active with first point I, third point H, or an Associated with first point I, third point H, and an Active with first point H, third point I."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is an Active with value L greater than 1, with id U, then we can have exactly 1 Associated with first point I, with third point H such that there is an Active with first point I, with third point H, or a Associated with first point I, with third point H such that there is an Active with first point H, with third point I.",
            "NL": "If an Active has a value L greater than 1 and an id U, there will be one Associated with first point I, third point H, which is either an Active with first point I, third point H, or an Associated with first point I, third point H, and an Active with first point H, third point I."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is an Active with value L greater than 1, with id U, then we can have exactly 1 Associated with first point I, with third point H such that there is an Active with first point I, with third point H, or a Associated with first point I, with third point H such that there is an Active with first point H, with third point I.",
            "NL": "If an Active has a value L greater than 1 and id U, there will be either an Active with first point I, third point H, or an Associated with first point I and third point H, and the other way around with an Active having first point H, third point I."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is an Active with value L greater than 1, with id U, then we can have exactly 1 Associated with first point I, with third point H such that there is an Active with first point I, with third point H, or a Associated with first point I, with third point H such that there is an Active with first point H, with third point I.",
            "NL": "If an Active has a value of L greater than 1 and an id of U, then there will be one Associated with first point I, third point H or an Active with first point I, third point H, or an Associated with first point I, third point H, such that an Active with first point H, third point I is present."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is an Adjacency_Matrix with value equal to 7 then we can have at least 34 Centrality with id10 B such that there is a Tree with field9 Bor a Centrality with id10 Z such that there is a Tree with id4 Z.",
            "NL": "If the Adjacency_Matrix has a value of 7, we can have a minimum of 34 Centrality with id10 B and a Tree with field9 B, or a Centrality with id10 Z and a Tree with id4 Z."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is an Adjacency_Matrix with value equal to 7 then we can have at least 34 Centrality with id10 B such that there is a Tree with field9 Bor a Centrality with id10 Z such that there is a Tree with id4 Z.",
            "NL": "We can have at least 34 Centrality with id10 B when an Adjacency_Matrix has a value of 7, and there is either a Tree with field9 B or a Centrality with id10 Z associated with a Tree with id4 Z."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is an Adjacency_Matrix with value equal to 7 then we can have at least 34 Centrality with id10 B such that there is a Tree with field9 Bor a Centrality with id10 Z such that there is a Tree with id4 Z.",
            "NL": "If the Adjacency_Matrix has a value of 7, we can have at least 34 Centrality with id10 B, which would result in a Tree with field9 B, or we can have a Centrality with id10 Z, which would generate a Tree with id4 Z."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is an Adjacency_Matrix with value equal to 7 then we can have at least 34 Centrality with id10 B such that there is a Tree with field9 Bor a Centrality with id10 Z such that there is a Tree with id4 Z.",
            "NL": "When the Adjacency_Matrix has a value of 7, there can be at least 34 Centrality with id10 B, either in the form of a Tree with field9 B or a Centrality with id10 Z with a Tree with id4 Z."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is an Adjacency_Matrix with value equal to 7 then we can have at least 34 Centrality with id10 B such that there is a Tree with field9 Bor a Centrality with id10 Z such that there is a Tree with id4 Z.",
            "NL": "If the Adjacency_Matrix has a value of 7, we can have at least 34 Centrality with id10 B, and either a Tree with field9 B or a Centrality with id10 Z and a Tree with id4 Z."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is an Afterward G then we can have Allocate with value9 Q, with value9 G exactly 1 Irrelevant with value9 Q, with value9 G.",
            "NL": "Whenever an Afterward G occurs, it is possible to have Allocate with value9 Q and exactly one Irrelevant with value9 Q and value9 G."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is an Afterward G then we can have Allocate with value9 Q, with value9 G exactly 1 Irrelevant with value9 Q, with value9 G.",
            "NL": "Whenever there is an Afterward G, it is possible to have Allocate with value9 Q and exactly one Irrelevant with value9 Q and value9 G."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is an Afterward G then we can have Allocate with value9 Q, with value9 G exactly 1 Irrelevant with value9 Q, with value9 G.",
            "NL": "It is possible to have an Allocate with a value of Q and a value of G, as well as an Irrelevant with a value of Q and a value of G, whenever there is an Afterward G."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is an Afterward G then we can have Allocate with value9 Q, with value9 G exactly 1 Irrelevant with value9 Q, with value9 G.",
            "NL": "It is possible to have Allocate with value9 Q and value9 G of exactly 1 Irrelevant with value9 Q and value9 G each time an Afterward G occurs."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is an Afterward G then we can have Allocate with value9 Q, with value9 G exactly 1 Irrelevant with value9 Q, with value9 G.",
            "NL": "It is possible to always have one Irrelevant with value9 Q, and value9 G when there is an Afterward G present."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is an Associated A then we can have Graph_Coloring with field10 C, and with value10 A exactly 23 Cross C.",
            "NL": "We can always have 23 Cross C when there is a field10 C, with a value10 A of exactly 10."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is an Associated A then we can have Graph_Coloring with field10 C, and with value10 A exactly 23 Cross C.",
            "NL": "We can always have a Cross C with field 10C and a value of 10A, specifically 23 Cross C, whenever field 10C is present."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is an Associated A then we can have Graph_Coloring with field10 C, and with value10 A exactly 23 Cross C.",
            "NL": "We can always have 23 Cross C with field10 C and value10 A whenever there is a field10 C."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is an Associated A then we can have Graph_Coloring with field10 C, and with value10 A exactly 23 Cross C.",
            "NL": "We can always have a Cross with field10 C and a value10 A of precisely 23 Cross C whenever field10 C is present."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is an Associated A then we can have Graph_Coloring with field10 C, and with value10 A exactly 23 Cross C.",
            "NL": "We can always have a Cross C with a field10 C and a value10 A exactly 23 Cross C whenever field10 C is present."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is an Atom with vtx9 A, and with value I, whenever there is an Suggestion with vtx9 A, and with value I, whenever there is not a Unimportant with layer value A, and with vtx9 X, then we can have at least 40 Sublist with field8 A, and with node9 I, and with vtx8 X.",
            "NL": "If there is an Atom with vtx9 A, a Suggestion with vtx9 A and value I, and no Unimportant with layer value A and vtx9 X, then there will be a minimum of 40 Sublist with field8 A, node9 I, and vtx8 X."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is an Atom with vtx9 A, and with value I, whenever there is an Suggestion with vtx9 A, and with value I, whenever there is not a Unimportant with layer value A, and with vtx9 X, then we can have at least 40 Sublist with field8 A, and with node9 I, and with vtx8 X.",
            "NL": "If we have an Atom with vtx9 A, a Suggestion with vtx9 A and value I, and no Unimportant with layer value A and vtx9 X, then we can have at least 40 Sublists containing field8 A, node9 I, and vtx8 X."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is an Atom with vtx9 A, and with value I, whenever there is an Suggestion with vtx9 A, and with value I, whenever there is not a Unimportant with layer value A, and with vtx9 X, then we can have at least 40 Sublist with field8 A, and with node9 I, and with vtx8 X.",
            "NL": "If there is an Atom with vtx9 A and a Suggestion with vtx9 A and value I, then there will be no Unimportant with layer value A and vtx9 X, allowing us to have at least 40 Sublist with field8 A, node9 I, and vtx8 X."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is an Atom with vtx9 A, and with value I, whenever there is an Suggestion with vtx9 A, and with value I, whenever there is not a Unimportant with layer value A, and with vtx9 X, then we can have at least 40 Sublist with field8 A, and with node9 I, and with vtx8 X.",
            "NL": "If there is an Atom with vtx9 A, a Suggestion with vtx9 A and value I, and no Unimportant with layer value A and vtx9 X, then we can have at least 40 Sublist with field8 A, node9 I and vtx8 X."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is an Atom with vtx9 A, and with value I, whenever there is an Suggestion with vtx9 A, and with value I, whenever there is not a Unimportant with layer value A, and with vtx9 X, then we can have at least 40 Sublist with field8 A, and with node9 I, and with vtx8 X.",
            "NL": "If there exists an Atom with vtx9 A, a Suggestion with vtx9 A and a value of I, and no Unimportant with layer value A and vtx9 X, then we can have a minimum of 40 Sublist with field8 A, node9 I, and vtx8 X."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is an Edge_Label with value L greater than 1, with id U, then we can have exactly 1 Pairing with third id A, with fifth point C such that there is an Edge_Label with third id A, with fifth point C, or a Pairing with third id A, with fifth point C such that there is an Edge_Label with third id C, with fifth point A.",
            "NL": "If an Edge_Label has a value L greater than 1 and an id U, then there can only be one Pairing with a third id A and fifth point C, or an Edge_Label with third id C and fifth point A, or a Pairing with third id A and fifth point C, such that there is an Edge_Label with third id C and fifth point A."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is an Edge_Label with value L greater than 1, with id U, then we can have exactly 1 Pairing with third id A, with fifth point C such that there is an Edge_Label with third id A, with fifth point C, or a Pairing with third id A, with fifth point C such that there is an Edge_Label with third id C, with fifth point A.",
            "NL": "If an Edge_Label has a value L greater than 1, with id U, then there must be either an Edge_Label with third id A and fifth point C, or a Pairing with third id A and fifth point C, for which there is an Edge_Label with third id C and fifth point A."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is an Edge_Label with value L greater than 1, with id U, then we can have exactly 1 Pairing with third id A, with fifth point C such that there is an Edge_Label with third id A, with fifth point C, or a Pairing with third id A, with fifth point C such that there is an Edge_Label with third id C, with fifth point A.",
            "NL": "If an Edge_Label has a value L greater than 1, with id U, then there must be either an Edge_Label with third id A, fifth point C, or a Pairing with third id A, fifth point C, and an Edge_Label with third id C, fifth point A."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is an Edge_Label with value L greater than 1, with id U, then we can have exactly 1 Pairing with third id A, with fifth point C such that there is an Edge_Label with third id A, with fifth point C, or a Pairing with third id A, with fifth point C such that there is an Edge_Label with third id C, with fifth point A.",
            "NL": "If there is an Edge_Label with a value L greater than 1, and an id U, then we can only have one Pairing with third id A, fifth point C, where either there is an Edge_Label with third id A, fifth point C, or a Pairing with third id A, and fifth point C, and an Edge_Label with third id C, and fifth point A."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is an Edge_Label with value L greater than 1, with id U, then we can have exactly 1 Pairing with third id A, with fifth point C such that there is an Edge_Label with third id A, with fifth point C, or a Pairing with third id A, with fifth point C such that there is an Edge_Label with third id C, with fifth point A.",
            "NL": "For a given Edge_Label with value L greater than 1 and id U, there is always one Pairing with third id A, fifth point C, or an Edge_Label with third id C, fifth point A, such that there is a Pairing with third id A and fifth point C."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is an Incoming A then we can have Arc with vtx6 O, and with id7 A exactly 41 Sequence O.",
            "NL": "We can always have a Sequence of vtx6 O and id7 A of exactly 41 Sequence O whenever there is a vtx6 O."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is an Incoming A then we can have Arc with vtx6 O, and with id7 A exactly 41 Sequence O.",
            "NL": "We can always have a Sequence with vtx6 O and id7 A of exactly 41 Sequence O whenever vtx6 O is present."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is an Incoming A then we can have Arc with vtx6 O, and with id7 A exactly 41 Sequence O.",
            "NL": "Whenever there is a vtx6 O, we can always have a Sequence of O with id7 A of exactly 41."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is an Incoming A then we can have Arc with vtx6 O, and with id7 A exactly 41 Sequence O.",
            "NL": "We can always have a Sequence of vtx6 O and id7 A with exactly 41 Sequence O whenever vtx6 O is present."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is an Incoming A then we can have Arc with vtx6 O, and with id7 A exactly 41 Sequence O.",
            "NL": "We can always generate a Sequence with vtx6 O and id7 A of exactly 41 O's whenever there is a vtx6 O."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is an Index X then we can have Edge with value M, with value X exactly 1 Level with value M, with value X.",
            "NL": "Edge can have a value of M and have a Level with a value of X when the Index is X."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is an Index X then we can have Edge with value M, with value X exactly 1 Level with value M, with value X.",
            "NL": "Edge with value M and value X can be present whenever there is an Index X, with value M exactly one Level away."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is an Index X then we can have Edge with value M, with value X exactly 1 Level with value M, with value X.",
            "NL": "Edge with value M and value X can be achieved with an Index X, and the Level with value M and value X is exactly one."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is an Index X then we can have Edge with value M, with value X exactly 1 Level with value M, with value X.",
            "NL": "Edge can have a value of M, and there can be exactly one Level with a value of M and an Index of X whenever X is present."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is an Index X then we can have Edge with value M, with value X exactly 1 Level with value M, with value X.",
            "NL": "Edge with value M and value X can be present at Index X, with exactly one Level of value M and value X."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is an Initiate C then we can have Embedding with edge6 V, with edge6 C exactly 1 Arrowed with edge6 V, with edge6 C.",
            "NL": "Embedding with edge6 V and edge6 C can be initiated with 1 Arrowed whenever an Initiate C is present."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is an Initiate C then we can have Embedding with edge6 V, with edge6 C exactly 1 Arrowed with edge6 V, with edge6 C.",
            "NL": "It is possible to Initiate C with edge6 V and edge6 C Embedding, and have exactly 1 Arrowed with edge6 V and edge6 C whenever C is Initiated."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is an Initiate C then we can have Embedding with edge6 V, with edge6 C exactly 1 Arrowed with edge6 V, with edge6 C.",
            "NL": "Embedding with edge6 V can be done whenever there is an Initiate C, with edge6 C being exactly 1 Arrowed with edge6 V."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is an Initiate C then we can have Embedding with edge6 V, with edge6 C exactly 1 Arrowed with edge6 V, with edge6 C.",
            "NL": "Embedding with edge6 V and edge6 C can be initiated whenever there is an Initiate C, with edge6 V having exactly one Arrowed."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is an Initiate C then we can have Embedding with edge6 V, with edge6 C exactly 1 Arrowed with edge6 V, with edge6 C.",
            "NL": "Embedding with edge6 V and edge6 C can be initiated whenever there is an Initiate C, with edge6 V arrowed exactly once."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is an Inputted Q then we can have Nfirst with value10 A, with value10 Q exactly 1 Partition with value10 A, with value10 Q.",
            "NL": "It is possible to have an Inputted Q result in one Partition with a value of 10A and 10Q each, every time."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is an Inputted Q then we can have Nfirst with value10 A, with value10 Q exactly 1 Partition with value10 A, with value10 Q.",
            "NL": "It is possible to have a Partition with value 10A and value 10Q whenever there is an Inputted Q of value 10A and 10Q."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is an Inputted Q then we can have Nfirst with value10 A, with value10 Q exactly 1 Partition with value10 A, with value10 Q.",
            "NL": "It is possible to input a Q and have one Partition with a value of 10A and 10Q, every time."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is an Inputted Q then we can have Nfirst with value10 A, with value10 Q exactly 1 Partition with value10 A, with value10 Q.",
            "NL": "It is possible to input a Q and have a Partition of value 10A and 10Q, with a Nfirst of value 10A, whenever desired."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is an Inputted Q then we can have Nfirst with value10 A, with value10 Q exactly 1 Partition with value10 A, with value10 Q.",
            "NL": "It is possible to have a Partition of Nfirst with a value of 10A and 10Q whenever an Inputted Q is present."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is an Ordered with field8 U, then we can have exactly 13 link with key N, with id10 I such that there is a Graph with vtx4 N, with node2 U, or a Index with key N, with id10 I such that there is an Graph with vtx4 U, with node9 N.",
            "NL": "We can create a Graph with vtx4 U, with node9 N and an Ordered node with field8 U, which has an Index node with key N and id10 I."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is an Ordered with field8 U, then we can have exactly 13 link with key N, with id10 I such that there is a Graph with vtx4 N, with node2 U, or a Index with key N, with id10 I such that there is an Graph with vtx4 U, with node9 N.",
            "NL": "Whenever there is an Ordered node with field8 U, we can have either a Graph with vtx4 U, node9 N, and 13 Index nodes with key N and id10 I, or a Graph with vtx4 U, node9 N, and an Index node with key N and id10 I."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is an Ordered with field8 U, then we can have exactly 13 link with key N, with id10 I such that there is a Graph with vtx4 N, with node2 U, or a Index with key N, with id10 I such that there is an Graph with vtx4 U, with node9 N.",
            "NL": "Whenever there is an Ordered node with field8 U, we can have either a Graph with vtx4 U, with node9 N, or a Index node with key N, with id10 I, and in either case, there will be exactly 13 Index nodes with key N."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is an Ordered with field8 U, then we can have exactly 13 link with key N, with id10 I such that there is a Graph with vtx4 N, with node2 U, or a Index with key N, with id10 I such that there is an Graph with vtx4 U, with node9 N.",
            "NL": "Whenever there is an Ordered node with field8 U, we can have either a Graph with vtx4 U, with node9 N, or an Index node with key N and id10 I, both of which will result in a Graph with vtx4 U, with node9 N."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is an Ordered with field8 U, then we can have exactly 13 link with key N, with id10 I such that there is a Graph with vtx4 N, with node2 U, or a Index with key N, with id10 I such that there is an Graph with vtx4 U, with node9 N.",
            "NL": "We can create a Graph with vtx4 U, with node9 N, or an Index node with key N, with id10 I whenever an Ordered node with field8 U exists, and it will have exactly 13 Index nodes with key N, with id10 I."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is an Out_Hamiltonian A, then we can have exactly 32 Face with key7 A, and with node10 U such that there is a Center U.",
            "NL": "We can always make a Face with key7 A and node10 U at a distance of 32 Center U from an Out_Hamiltonian A."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is an Out_Hamiltonian A, then we can have exactly 32 Face with key7 A, and with node10 U such that there is a Center U.",
            "NL": "We can always have a Face with key7 A and node10 U of exactly 32 Center U whenever an Out_Hamiltonian A is present."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is an Out_Hamiltonian A, then we can have exactly 32 Face with key7 A, and with node10 U such that there is a Center U.",
            "NL": "Whenever there is an Out_Hamiltonian A, we can always have a Face with key7 A and node10 U, exactly 32 Center U."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is an Out_Hamiltonian A, then we can have exactly 32 Face with key7 A, and with node10 U such that there is a Center U.",
            "NL": "We can always have a Face with key7A and node10U, with 32 Center U, whenever an Out_Hamiltonian A is present."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is an Out_Hamiltonian A, then we can have exactly 32 Face with key7 A, and with node10 U such that there is a Center U.",
            "NL": "We can always construct an Out_Hamiltonian A with a Face consisting of key7 A and node10 U exactly 32 Center U."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is an Out_HamiltonianCycle G then we can have Load with edge2 T, with edge2 G exactly 1 Outbound with edge2 T, with edge2 G.",
            "NL": "It is possible to have an Outbound Hamiltonian Cycle with edge2 T and edge2 G whenever there is a Load with exactly one Outbound with edge2 T and edge2 G."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is an Out_HamiltonianCycle G then we can have Load with edge2 T, with edge2 G exactly 1 Outbound with edge2 T, with edge2 G.",
            "NL": "It is possible to have an Outbound Hamiltonian Cycle G with edge2 T and edge2 G where Load is exactly 1 whenever there is an Out_HamiltonianCycle G."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is an Out_HamiltonianCycle G then we can have Load with edge2 T, with edge2 G exactly 1 Outbound with edge2 T, with edge2 G.",
            "NL": "It is possible to have Load with edge2 T and edge2 G, with exactly one Outbound with edge2 T and edge2 G when an Out_HamiltonianCycle G exists."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is an Out_HamiltonianCycle G then we can have Load with edge2 T, with edge2 G exactly 1 Outbound with edge2 T, with edge2 G.",
            "NL": "It is possible to have Load with edge2 T and edge2 G equal to 1 Outbound with edge2 T and edge2 G whenever there is an Out_HamiltonianCycle G."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is an Out_HamiltonianCycle G then we can have Load with edge2 T, with edge2 G exactly 1 Outbound with edge2 T, with edge2 G.",
            "NL": "It is possible to have a Load with edge2 T and edge2 G that contains exactly one Outbound with edge2 T and edge2 G when there is an Out_HamiltonianCycle G."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is an Outgoing with value6 U, whenever there is a Penalty with value6 O, then we can have between 11 and O Dendrogram with value6 K, and with id K such that there is an Edge_Tag U.",
            "NL": "We can create a Dendrogram with values of K and U ranging from 11 to 0, with Edge_Tag K, any time we have an Outgoing U and Penalty O."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is an Outgoing with value6 U, whenever there is a Penalty with value6 O, then we can have between 11 and O Dendrogram with value6 K, and with id K such that there is an Edge_Tag U.",
            "NL": "Whenever we have an Outgoing U and a Penalty O, we can always generate a Dendrogram with values of K and U ranging from 11 to 0 and an Edge_Tag of K."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is an Outgoing with value6 U, whenever there is a Penalty with value6 O, then we can have between 11 and O Dendrogram with value6 K, and with id K such that there is an Edge_Tag U.",
            "NL": "Whenever Outgoing U and Penalty O are present, we can always create a Dendrogram with Edge_Tag K and values of 6 K and 6 U ranging from 11 to 0."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is an Outgoing with value6 U, whenever there is a Penalty with value6 O, then we can have between 11 and O Dendrogram with value6 K, and with id K such that there is an Edge_Tag U.",
            "NL": "Whenever we have an Outgoing U and a Penalty O, we can always construct a Dendrogram with value6 K and value6 U ranging between 11 and 0, and Edge_Tag K."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is an Outgoing with value6 U, whenever there is a Penalty with value6 O, then we can have between 11 and O Dendrogram with value6 K, and with id K such that there is an Edge_Tag U.",
            "NL": "We can always create a Dendrogram with Edge_Tag K, which has values of 6K and 6U ranging from 11 to 0, whenever we have an Outgoing U and a Penalty of 0."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is an OutgoingPath I then we can have Below_Threshold with key9 L, and with value5 I exactly 43 Painted L.",
            "NL": "We can always have 43 Painted L with key9 L and value5 I whenever one is available."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is an OutgoingPath I then we can have Below_Threshold with key9 L, and with value5 I exactly 43 Painted L.",
            "NL": "We can always obtain 43 Painted L with key9 L and value5 I, whenever one is available."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is an OutgoingPath I then we can have Below_Threshold with key9 L, and with value5 I exactly 43 Painted L.",
            "NL": "We can always have a Painted with key9 L and value5 I of exactly 43 Painted L whenever key9 L exists."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is an OutgoingPath I then we can have Below_Threshold with key9 L, and with value5 I exactly 43 Painted L.",
            "NL": "We can always have 43 Painted L with key9 L and value5 I whenever one is present."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "whenever there is an OutgoingPath I then we can have Below_Threshold with key9 L, and with value5 I exactly 43 Painted L.",
            "NL": "We can always have a Painted L with key9 L and value5 I of exactly 43 Painted L whenever there is a key9 L present."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is an Undirected with value L greater than 1, with id U, then we can have exactly 1 Cycle_Basis with first point D, with second point C such that there is an Undirected with first point D, with second point C, or a Cycle_Basis with first point D, with second point C such that there is an Undirected with first point C, with second point D.",
            "NL": "If the Undirected has an id U and a value L greater than 1, then there will be one Cycle_Basis with first point D and second point C, or an Undirected with first point D and second point C, or a Cycle_Basis with first point D and second point C, with an Undirected with first point C and second point D."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is an Undirected with value L greater than 1, with id U, then we can have exactly 1 Cycle_Basis with first point D, with second point C such that there is an Undirected with first point D, with second point C, or a Cycle_Basis with first point D, with second point C such that there is an Undirected with first point C, with second point D.",
            "NL": "When the value of an Undirected with id U is greater than 1, there is precisely one Cycle_Basis with first point D and second point C, or an Undirected with first point D and second point C, or a Cycle_Basis with first point D and second point C, with an Undirected with first point C and second point D."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is an Undirected with value L greater than 1, with id U, then we can have exactly 1 Cycle_Basis with first point D, with second point C such that there is an Undirected with first point D, with second point C, or a Cycle_Basis with first point D, with second point C such that there is an Undirected with first point C, with second point D.",
            "NL": "If the Undirected has a value L greater than 1 and an id U, there is one Cycle_Basis with a first point D and second point C, or an Undirected with a first point D and second point C, or a Cycle_Basis with a first point D and second point C, and an Undirected with a first point C and second point D."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is an Undirected with value L greater than 1, with id U, then we can have exactly 1 Cycle_Basis with first point D, with second point C such that there is an Undirected with first point D, with second point C, or a Cycle_Basis with first point D, with second point C such that there is an Undirected with first point C, with second point D.",
            "NL": "If an Undirected has an id U and a value L greater than 1, then there is exactly one Cycle_Basis (with first point D and second point C) or an Undirected (with first point D and second point C) and an Undirected (with first point C and second point D)."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is an Undirected with value L greater than 1, with id U, then we can have exactly 1 Cycle_Basis with first point D, with second point C such that there is an Undirected with first point D, with second point C, or a Cycle_Basis with first point D, with second point C such that there is an Undirected with first point C, with second point D.",
            "NL": "When the value of an Undirected (U) is greater than 1, there will be one Cycle_Basis with the first point (D) and second point (C) such that there is an Undirected with first point D and second point C, or a Cycle_Basis with first point C and second point D."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is an Unmatch with key5 E, and with edge Z, whenever there is an Triad with key5 E, and with edge Z, whenever there is not a Penalty with layer edge E, and with key5 F, then we can have at least 42 Child with field1 E, and with vtx5 Z, and with node3 F.",
            "NL": "If there is an Unmatch with key5 E, a Triad with key5 E and edge Z, and no Penalty with layer edge E and key5 F, then we can have at least 42 Child with field1 E, vtx5 Z and node3 F."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is an Unmatch with key5 E, and with edge Z, whenever there is an Triad with key5 E, and with edge Z, whenever there is not a Penalty with layer edge E, and with key5 F, then we can have at least 42 Child with field1 E, and with vtx5 Z, and with node3 F.",
            "NL": "If there is an Unmatch with key5 E, a Triad with key5 E and edge Z, and no Penalty with layer edge E and key5 F, then there will be a minimum of 42 Child with field1 E, vtx5 Z, and node3 F."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is an Unmatch with key5 E, and with edge Z, whenever there is an Triad with key5 E, and with edge Z, whenever there is not a Penalty with layer edge E, and with key5 F, then we can have at least 42 Child with field1 E, and with vtx5 Z, and with node3 F.",
            "NL": "If there is no Penalty with layer edge E, key5 F, and a Unmatch with key5 E and a Triad with key5 E and edge Z, we can have at least 42 Child with field1 E, vtx5 Z, and node3 F."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is an Unmatch with key5 E, and with edge Z, whenever there is an Triad with key5 E, and with edge Z, whenever there is not a Penalty with layer edge E, and with key5 F, then we can have at least 42 Child with field1 E, and with vtx5 Z, and with node3 F.",
            "NL": "If there is an Unmatch with key5 E, a Triad with key5 E and edge Z, and no Penalty with layer edge E and key5 F, then we can have a minimum of 42 Child with field1 E, vtx5 Z, and node3 F."
        },
        {
            "Category": "Quantified Choice Rules",
            "CNL": "Whenever there is an Unmatch with key5 E, and with edge Z, whenever there is an Triad with key5 E, and with edge Z, whenever there is not a Penalty with layer edge E, and with key5 F, then we can have at least 42 Child with field1 E, and with vtx5 Z, and with node3 F.",
            "NL": "If there is an Unmatch with key5 E, a Triad with key5 E and edge Z, and no Penalty with layer edge E and key5 F, we can expect a minimum of 42 Child with field1 E, vtx5 Z, and node3 F."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of edge2 that are key5 is maximized.",
            "NL": "Maximizing the number of key5 edge2 is of high priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of edge9 P that are Tally is minimized.",
            "NL": "It is preferred with a high priority that the number of edge9 P that are not in a Tally is minimized. "
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of field3 that are field1 is maximized.",
            "NL": "Maximizing the number of field1 field3 is of high priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of field7 that are vtx4 is maximized.",
            "NL": "Maximizing the number of vtx4 field7 is of high priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of field8 that are edge6 is maximized.",
            "NL": "Maximizing the number of edge6 field8 is of high priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of id10 that are value7 is maximized.",
            "NL": "Maximizing the number of value7 id10 is of high priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of key2 Y that are Complete is minimized.",
            "NL": "It is preferred with a high priority that the number of key2 Y that are not in a Complete is minimized. "
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of key3 L that are Short is minimized.",
            "NL": "It is preferred with a high priority that the number of key3 L that are not in a Short is minimized. "
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of key3 Q that are Directed is minimized.",
            "NL": "It is preferred with a high priority that the number of key3 Q that are not in a Directed is minimized. "
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of key4 P that are Influential is minimized.",
            "NL": "It is preferred with a high priority that the number of key4 P that are not in a Influential is minimized. "
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of key4 that are field2 is maximized.",
            "NL": "Maximizing the number of field2 key4 is of high priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of key4 that are field7 is maximized.",
            "NL": "Maximizing the number of field7 key4 is of high priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of key5 that are key is maximized.",
            "NL": "Maximizing the number of key key5 is of high priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of key8 that are vtx1 is maximized.",
            "NL": "Maximizing the number of vtx1 key8 is of high priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of node7 that are vtx5 is maximized.",
            "NL": "Maximizing the number of vtx5 node7 is of high priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of node7 that are vtx8 is maximized.",
            "NL": "Maximizing the number of vtx8 node7 is of high priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of value6 that are edge is maximized.",
            "NL": "Maximizing the number of edge value6 is of high priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of value8 that are id10 is maximized.",
            "NL": "Maximizing the number of id10 value8 is of high priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of vtx H that are Afterward is minimized.",
            "NL": "It is preferred with a high priority that the number of vtx H that are not in a Afterward is minimized. "
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of vtx3 that are edge10 is maximized.",
            "NL": "Maximizing the number of edge10 vtx3 is of high priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of vtx4 that are value9 is maximized.",
            "NL": "Maximizing the number of value9 vtx4 is of high priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of vtx4 that are vtx9 is maximized.",
            "NL": "Maximizing the number of vtx9 vtx4 is of high priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of vtx9 that are value2 is maximized.",
            "NL": "Maximizing the number of value2 vtx9 is of high priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with low priority that the number of vtx6 Q that are Achievement is minimized.",
            "NL": "It is preferred with a low priority that the number of vtx6 Q that are not in a Achievement is minimized. "
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with medium priority that the number of id10 Z that are Isomorphism is minimized.",
            "NL": "It is preferred with a medium priority that the number of id10 Z that are not in a Isomorphism is minimized. "
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with medium priority that the number of key2 V that are Load is minimized.",
            "NL": "It is preferred with a medium priority that the number of key2 V that are not in a Load is minimized. "
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with medium priority that the number of key3 F that are Breadth is minimized.",
            "NL": "It is preferred with a medium priority that the number of key3 F that are not in a Breadth is minimized. "
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with medium priority that the number of key8 M that are Additional is minimized.",
            "NL": "It is preferred with a medium priority that the number of key8 M that are not in a Additional is minimized. "
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with medium priority that the number of key9 W that are Intersect is minimized.",
            "NL": "It is preferred with a medium priority that the number of key9 W that are not in a Intersect is minimized. "
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with medium priority that the number of node2 H that are Eulerian_Circuit is minimized.",
            "NL": "It is preferred with a medium priority that the number of node2 H that are not in a Eulerian_Circuit is minimized. "
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with medium priority that the number of node2 Y that are Trail is minimized.",
            "NL": "It is preferred with a medium priority that the number of node2 Y that are not in a Trail is minimized. "
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with medium priority that the number of value9 Z that are Fine is minimized.",
            "NL": "It is preferred with a medium priority that the number of value9 Z that are not in a Fine is minimized. "
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Caught with edge7 J, with edge7 W, whenever there is a Reckoning with edge7 X, X is minimized.",
            "NL": "It is preferable, with high priority when there is a Caught with edge7 J, with edge7 W, there is a Reckoning with edge7 X, it is preferred that X is minimized. "
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Center with second id Y, whenever there is a Related with node G, G is minimized.",
            "NL": "With high priority, it is preferable that whenever there is a Center with second id Y, whenever there is a Related with node G, G is minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Circuit with value5 W, with value5 K, whenever there is a Enumeration with value5 Z, Z is minimized.",
            "NL": "It is preferable, with high priority when there is a Circuit with value5 W, with value5 K, there is an Enumeration with value5 Z, it is preferred that Z is minimized. "
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Compare with edge1 N, with field10 K, with vtx2 A, with value5 V, whenever there is a Point with value6 Y, Y is minimized. ",
            "NL": "As a matter of high priority, whenever there is a Compare between edge1 N, field10 K, vtx2 A, value5 V, whenever there is a Point with value6 Y, the Point must be minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Compartment with id10 U, with node2 D, whenever there is an In with value B, with key3 U, with id2 D, whenever there is a weight with value T, T is minimized.",
            "NL": "There is a preference, with a high priority, that whenever there is a Compartment with id10 U, with node2 D, whenever there is an In with value B, with key3 U, with id2 D, whenever there is a weight with value T, T is minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Engaged with edge4 I, with edge4 D, whenever there is a Denied with edge4 C, C is minimized.",
            "NL": "It is preferable, with high priority when there is an Engaged with edge4 I, with edge4 D, there is a Denied with edge4 C, it is preferred that C is minimized. "
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Fine with value10 V, with value10 E, whenever there is a Visit with value10 I, I is minimized.",
            "NL": "It is preferable, with high priority when there is a Fine with value10 V, with value10 E, there is a Visit with value10 I, it is preferred that I is minimized. "
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Functioning with value5 H, whenever there is a Remaining with value5 H, H is minimized.",
            "NL": "With high priority, it is preferable that whenever there is a Functioning with value5 H, whenever there is a Remaining with value5 H, H is minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Indication with fifth id P, whenever there is a Includes with value4 R, R is minimized.",
            "NL": "With high priority, it is preferable that whenever there is an Indication with fifth id P, whenever there is an Includes with value4 R, R is minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Indication with first point B, whenever there is a NonGroup with id1 U, U is minimized.",
            "NL": "With high priority, it is preferable that whenever there is an Indication with first point B, whenever there is a NonGroup with id1 U, U is minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Initial with id G, whenever there is a Statistical_Significance with id G, G is minimized.",
            "NL": "With high priority, it is preferable that whenever there is an Initial with id G, whenever there is a Statistical_Significance with id G, G is minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Lacking with edge6 J, J is minimized.",
            "NL": "There is a preference that whenever there is a Lacking with edge6 J, that it should be minimized with the lowest priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Maximum_Matching with field8 D, with edge1 G, whenever there is an Achieved with field8 E, with edge1 G, whenever there is a Edge_Tag with field8 E, with edge1 X, whenever there is a weight with field8 E, E is minimized.",
            "NL": "There is a preference, with high priority, that whenever there is a Maximum_Matching with field8 D, with edge1 G, there is an Achieved with field8 E, with edge1 G, there is an Edge_Tag with field8 E, with edge1 X, and whenever there is a weight with field8 E, E is minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Nfirst with field3 X, with node8 J, with id O, with edge1 Y, whenever there is a Predominant with id8 V, V is minimized. ",
            "NL": "As a matter of high priority, whenever there is a Nfirst between field3 X, node8 J, id O, edge1 Y, whenever there is a Predominant with id8 V, the Predominant must be minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Node with fifth id P, whenever there is a Pairing with value8 K, K is minimized.",
            "NL": "With high priority, it is preferable that whenever there is a Node with fifth id P, whenever there is a Pairing with value8 K, K is minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Offspring with key4 L, with id3 N, whenever there is an Inbound with edge10 F, with id L, with id6 N, whenever there is a weight with value O, O is minimized.",
            "NL": "There is a preference, with a high priority, that whenever there is an Offspring with key4 L, with id3 N, whenever there is an Inbound with edge10 F, with id L, with id6 N, whenever there is a weight with value O, O is minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Parent with id6 S, with id6 C, whenever there is a Linked with id6 I, I is minimized.",
            "NL": "It is preferable, with high priority when there is a Parent with id6 S, with id6 C, there is a Linked with id6 I, it is preferred that I is minimized. "
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Shaded with value10 Q, with value1 C, whenever there is an Incoming_Level with value10 Z, with value1 C, whenever there is a Triad with value10 Z, with value1 E, whenever there is a weight with value10 Z, Z is minimized.",
            "NL": "There is a preference, with high priority, that whenever there is a Shaded with value10 Q, with value1 C, there is an Incoming_Level with value10 Z, with value1 C, there is a Triad with value10 Z, with value1 E, and whenever there is a weight with value10 Z, Z is minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Subordinate with id7 S, S is minimized.",
            "NL": "There is a preference that whenever there is a Subordinate with id7 S, that it should be minimized with the lowest priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Succeeding with edge4 X, with edge4 S, whenever there is a Launch with edge4 X, whenever there is not a Trail with edge4 X, whenever there is a weight with edge4 S, S is minimized.",
            "NL": "The minimization of S is preferred, with high priority, whenever there is a Succeeding with edge4 X, with edge4 S, whenever there is a Launch with edge4 X, whenever there is no Trail with edge4 X, whenever there is a weight with edge4 S."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Tag with vtx10 J, J is minimized.",
            "NL": "There is a preference that whenever there is a Tag with vtx10 J, that it should be minimized with the lowest priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Trivial with key4 W, whenever there is a Out_HamiltonianCycle with key4 W, W is minimized.",
            "NL": "With high priority, it is preferable that whenever there is a Trivial with key4 W, whenever there is an Out_HamiltonianCycle with key4 W, W is minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Twosome with id2 B, whenever there is a Participating with id2 B, B is minimized.",
            "NL": "With high priority, it is preferable that whenever there is a Twosome with id2 B, whenever there is a Participating with id2 B, B is minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is an Accessed with field4 G, G is minimized.",
            "NL": "There is a preference that whenever there is an Accessed with field4 G, that it should be minimized with the lowest priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is an Alpha_Value with vtx9 O, with key7 Z, whenever there is a Size with vtx9 L, with key7 Z, whenever there is an Initiate with vtx9 L, with key7 E, whenever there is a weight with vtx9 L, L is minimized.",
            "NL": "There is a preference, with high priority, that whenever there is an Alpha_Value with vtx9 O, with key7 Z, there is a Size with vtx9 L, with key7 Z, there is an Initiate with vtx9 L, with key7 E, and whenever there is a weight with vtx9 L, L is minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is an Earliest with second vertex S, whenever there is a Victory with node7 O, O is minimized.",
            "NL": "With high priority, it is preferable that whenever there is an Earliest with second vertex S, whenever there is a Victory with node7 O, O is minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is an Edge_Pair with fourth node F, with fifth vertex R, whenever there is an Complete with fourth node F, with fifth vertex R, with second id I, I is minimized.",
            "NL": "It is preferred, though with high priority, that whenever there is an Edge_Pair between fourth node F and fifth vertex R, there is a Complete between fourth node F and fifth vertex R, with second id I, the value of I is minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is an Edge_Tag with key4 U, U is minimized.",
            "NL": "There is a preference that whenever there is an Edge_Tag with key4 U, that it should be minimized with the lowest priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is an Element with edge7 P, with edge7 K, whenever there is a Initiate with edge7 P, whenever there is not a Connection with edge7 P, whenever there is a weight with edge7 K, K is minimized.",
            "NL": "The minimization of K is preferred, with high priority, whenever there is an Element with edge7 P, with edge7 K, whenever there is an Initiate with edge7 P, whenever there is no Connection with edge7 P, whenever there is a weight with edge7 K."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is an In_Layer with fifth id R, with fourth vertex V, whenever there is a Diagram with fifth id R, with fourth vertex V, with first node X, X is minimized.",
            "NL": "It is preferred, though with high priority, that whenever there is an In_Layer between fifth id R and fourth vertex V, there is a Diagram between fifth id R and fourth vertex V, with first node X, the value of X is minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is an Incoming with id2 V, with value9 I, whenever there is a Planar_Graph with key2 T, with node3 V, with value I, whenever there is a weight with value K, K is minimized.",
            "NL": "There is a preference, with a high priority, that whenever there is an Incoming with id2 V, with value9 I, whenever there is a Planar_Graph with key2 T, with node3 V, with value I, whenever there is a weight with value K, K is minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is an Initial with field5 V, with field5 Q, whenever there is an Outpath with field5 V, whenever there is not a Flow with field5 V, whenever there is a weight with field5 Q, Q is minimized.",
            "NL": "The minimization of Q is preferred, with high priority, whenever there is an Initial with field5 V, with field5 Q, whenever there is an Outpath with field5 V, whenever there is no Flow with field5 V, whenever there is a weight with field5 Q."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is an NonGroup with second vertex U, with fifth point J, whenever there is a Directed with second vertex U, with fifth point J, with fifth vertex P, P is minimized.",
            "NL": "It is preferred, though with high priority, that whenever there is a NonGroup between second vertex U and fifth point J, there is a Directed between second vertex U and fifth point J, with fifth vertex P, the value of P is minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is an Used_Edge with key5 B, with key5 Y, whenever there is a Significant with key5 B, whenever there is not a Trail with key5 B, whenever there is a weight with key5 Y, Y is minimized.",
            "NL": "The minimization of Y is preferred, with high priority, whenever there is an Used_Edge with key5 B, with key5 Y, whenever there is a Significant with key5 B, whenever there is no Trail with key5 B, whenever there is a weight with key5 Y."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Accessed with edge6 N, with id3 Y, whenever there is a Dyed with edge6 S, with id3 Y, whenever there is an Eulerian_Graph with edge6 S, with id3 H, whenever there is a weight with edge6 S, S is minimized.",
            "NL": "There is a preference, with low priority, that whenever there is an Accessed with edge6 N, with id3 Y, there is a Dyed with edge6 S, with id3 Y, there is an Eulerian_Graph with edge6 S, with id3 H, and whenever there is a weight with edge6 S, S is minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Cliquesize with field10 K, with vtx M, whenever there is a Linked with value10 S, with node5 K, with vtx8 M, whenever there is a weight with value I, I is minimized.",
            "NL": "There is a preference, with a low priority, that whenever there is a Cliquesize with field10 K, with vtx M, whenever there is a Linked with value10 S, with node5 K, with vtx8 M, whenever there is a weight with value I, I is minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Comprises with vtx4 C, with field1 V, whenever there is a Node with vtx4 O, with field1 V, whenever there is a Planar with vtx4 O, with field1 L, whenever there is a weight with vtx4 O, O is minimized.",
            "NL": "There is a preference, with low priority, that whenever there is a Comprises with vtx4 C, with field1 V, there is a Node with vtx4 O, with field1 V, there is a Planar with vtx4 O, with field1 L, and whenever there is a weight with vtx4 O, O is minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Denied with edge3 C, with edge9 L, with vtx W, with vtx5 E, whenever there is a Loop with id7 R, R is minimized. ",
            "NL": "As a matter of low priority, whenever there is a Denied between edge3 C, edge9 L, vtx W, vtx5 E, whenever there is a Loop with id7 R, the Loop must be minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Disconnected with node9 I, with node9 T, whenever there is a NonActive with node9 N, N is minimized.",
            "NL": "It is preferable, with low priority when there is a Disconnected with node9 I, with node9 T, there is a NonActive with node9 N, it is preferred that N is minimized. "
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Duo with value10 I, whenever there is a Particle with value10 I, I is minimized.",
            "NL": "With low priority, it is preferable that whenever there is a Duo with value10 I, whenever there is a Particle with value10 I, I is minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Dynamic with node8 X, whenever there is a Fewer with node8 X, X is minimized.",
            "NL": "With low priority, it is preferable that whenever there is a Dynamic with node8 X, whenever there is a Fewer with node8 X, X is minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Extra with edge C, with edge5 F, whenever there is a Bucket with edge K, with edge5 F, whenever there is an Independent_Set with edge K, with edge5 Y, whenever there is a weight with edge K, K is minimized.",
            "NL": "There is a preference, with low priority, that whenever there is an Extra with edge C, with edge5 F, there is a Bucket with edge K, with edge5 F, there is an Independent_Set with edge K, with edge5 Y, and whenever there is a weight with edge K, K is minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Face with key10 M, with key10 T, whenever there is a Notnext with key10 O, O is minimized.",
            "NL": "It is preferable, with low priority when there is a Face with key10 M, with key10 T, there is a Notnext with key10 O, it is preferred that O is minimized. "
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Later with vtx3 A, with vtx M, with vtx9 X, with edge5 P, whenever there is a Trio with vtx10 S, S is minimized. ",
            "NL": "As a matter of low priority, whenever there is a Later between vtx3 A, vtx M, vtx9 X, edge5 P, whenever there is a Trio with vtx10 S, the Trio must be minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Level with node7 Y, Y is minimized.",
            "NL": "There is a preference that whenever there is a Level with node7 Y, that it should be minimized with the lowest priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Linked with field7 A, A is minimized.",
            "NL": "There is a preference that whenever there is a Linked with field7 A, that it should be minimized with the lowest priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Lone with value3 P, with value8 V, with node3 R, with id1 K, whenever there is a Contrast with id10 Z, Z is minimized. ",
            "NL": "As a matter of low priority, whenever there is a Lone between value3 P, value8 V, node3 R, id1 K, whenever there is a Contrast with id10 Z, the Contrast must be minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Mark with vtx4 C, with field5 N, whenever there is a Trapped with vtx4 J, with field5 N, whenever there is a Commence with vtx4 J, with field5 A, whenever there is a weight with vtx4 J, J is minimized.",
            "NL": "There is a preference, with low priority, that whenever there is a Mark with vtx4 C, with field5 N, there is a Trapped with vtx4 J, with field5 N, there is a Commence with vtx4 J, with field5 A, and whenever there is a weight with vtx4 J, J is minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Marker with value5 W, whenever there is a Has with value5 W, W is minimized.",
            "NL": "With low priority, it is preferable that whenever there is a Marker with value5 W, whenever there is a Has with value5 W, W is minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Planar_Graph with key2 M, with key2 P, whenever there is an OutDegree with key2 M, whenever there is not a Planar_Embedding with key2 M, whenever there is a weight with key2 P, P is minimized.",
            "NL": "The minimization of P is preferred, with low priority, whenever there is a Planar_Graph with key2 M, with key2 P, whenever there is an OutDegree with key2 M, whenever there is no Planar_Embedding with key2 M, whenever there is a weight with key2 P."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Reference with vtx Y, with vtx Z, whenever there is a NonConsecutive with vtx T, T is minimized.",
            "NL": "It is preferable, with low priority when there is a Reference with vtx Y, with vtx Z, there is a NonConsecutive with vtx T, it is preferred that T is minimized. "
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Simple with key8 V, whenever there is a Subposition with key8 V, V is minimized.",
            "NL": "With low priority, it is preferable that whenever there is a Simple with key8 V, whenever there is a Subposition with key8 V, V is minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Subsequent with vtx6 G, with id5 W, with key8 Q, with edge N, whenever there is a Base with field10 M, M is minimized. ",
            "NL": "As a matter of low priority, whenever there is a Subsequent between vtx6 G, id5 W, key8 Q, edge N, whenever there is a Base with field10 M, the Base must be minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Trapped with field5 W, with vtx10 K, whenever there is a Contains with key5 D, with node3 W, with vtx6 K, whenever there is a weight with value Z, Z is minimized.",
            "NL": "There is a preference, with a low priority, that whenever there is a Trapped with field5 W, with vtx10 K, whenever there is a Contains with key5 D, with node3 W, with vtx6 K, whenever there is a weight with value Z, Z is minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Trio with value5 S, whenever there is a Foremost with value5 S, S is minimized.",
            "NL": "With low priority, it is preferable that whenever there is a Trio with value5 S, whenever there is a Foremost with value5 S, S is minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Unit with second node V, whenever there is a Subposition with field3 L, L is minimized.",
            "NL": "With low priority, it is preferable that whenever there is an Unit with second node V, whenever there is a Subposition with field3 L, L is minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Wanting with field3 Y, with value8 V, with vtx1 W, with key3 J, whenever there is a Solitary with edge3 U, U is minimized. ",
            "NL": "As a matter of low priority, whenever there is a Wanting between field3 Y, value8 V, vtx1 W, key3 J, whenever there is a Solitary with edge3 U, the Solitary must be minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Wanting with id1 H, whenever there is a Complete with id1 H, H is minimized.",
            "NL": "With low priority, it is preferable that whenever there is a Wanting with id1 H, whenever there is a Complete with id1 H, H is minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Width with field2 W, with field3 K, whenever there is a Simple with field2 X, with field3 K, whenever there is a Bridge with field2 X, with field3 M, whenever there is a weight with field2 X, X is minimized.",
            "NL": "There is a preference, with low priority, that whenever there is a Width with field2 W, with field3 K, there is a Simple with field2 X, with field3 K, there is a Bridge with field2 X, with field3 M, and whenever there is a weight with field2 X, X is minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is an Accessed with node F, F is minimized.",
            "NL": "There is a preference that whenever there is an Accessed with node F, that it should be minimized with the lowest priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is an Adjacency_List with edge8 R, with value S, whenever there is a Parent with vtx4 G, with field R, with key4 S, whenever there is a weight with value I, I is minimized.",
            "NL": "There is a preference, with a low priority, that whenever there is an Adjacency_List with edge8 R, with value S, whenever there is a Parent with vtx4 G, with field R, with key4 S, whenever there is a weight with value I, I is minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is an Coloring with vtx7 D, D is minimized.",
            "NL": "There is a preference that whenever there is a Coloring with vtx7 D, that it should be minimized with the lowest priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is an Ending with node8 P, P is minimized.",
            "NL": "There is a preference that whenever there is an Ending with node8 P, that it should be minimized with the lowest priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is an Entered with id V, with id8 B, whenever there is a Regular with field7 C, with edge2 V, with field2 B, whenever there is a weight with value A, A is minimized.",
            "NL": "There is a preference, with a low priority, that whenever there is an Entered with id V, with id8 B, whenever there is a Regular with field7 C, with edge2 V, with field2 B, whenever there is a weight with value A, A is minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is an Following with value6 Z, Z is minimized.",
            "NL": "There is a preference that whenever there is a Following with value6 Z, that it should be minimized with the lowest priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is an Inactive with node2 X, with node2 A, whenever there is a Hamgraph with node2 N, N is minimized.",
            "NL": "It is preferable, with low priority when there is an Inactive with node2 X, with node2 A, there is a Hamgraph with node2 N, it is preferred that N is minimized. "
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is an Includes with vtx2 L, with vtx2 H, whenever there is a Tally with vtx2 N, N is minimized.",
            "NL": "It is preferable, with low priority when there is an Includes with vtx2 L, with vtx2 H, there is a Tally with vtx2 N, it is preferred that N is minimized. "
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is an Initiate with node8 W, with value10 Q, whenever there is a Maximum_Matching with node5 U, with value1 W, with node1 Q, whenever there is a weight with value L, L is minimized.",
            "NL": "There is a preference, with a low priority, that whenever there is an Initiate with node8 W, with value10 Q, whenever there is a Maximum_Matching with node5 U, with value1 W, with node1 Q, whenever there is a weight with value L, L is minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is an NonClustering with key9 A, A is minimized.",
            "NL": "There is a preference that whenever there is a NonClustering with key9 A, that it should be minimized with the lowest priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is an Out_Hamiltonian with edge6 G, with value4 W, whenever there is a Bridge with field7 J, with field G, with vtx W, whenever there is a weight with value A, A is minimized.",
            "NL": "There is a preference, with a low priority, that whenever there is an Out_Hamiltonian with edge6 G, with value4 W, whenever there is a Bridge with field7 J, with field G, with vtx W, whenever there is a weight with value A, A is minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is an Outgoing with value3 E, with value3 Z, whenever there is a Significant with value3 E, whenever there is not a Arc with value3 E, whenever there is a weight with value3 Z, Z is minimized.",
            "NL": "The minimization of Z is preferred, with low priority, whenever there is an Outgoing with value3 E, with value3 Z, whenever there is a Significant with value3 E, whenever there is no Arc with value3 E, whenever there is a weight with value3 Z."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is an Refused with field2 T, T is minimized.",
            "NL": "There is a preference that whenever there is a Refused with field2 T, that it should be minimized with the lowest priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Capacity with key5 S, with key5 H, whenever there is a Predominant with key5 S, whenever there is not a Simple_Graph with key5 S, whenever there is a weight with key5 H, H is minimized.",
            "NL": "The minimization of H is preferred, with medium priority, whenever there is a Capacity with key5 S, with key5 H, whenever there is a Predominant with key5 S, whenever there is no Simple_Graph with key5 S, whenever there is a weight with key5 H."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Circuit with second point H, with fake value K, whenever there is an Element with second point H, with fake value K, with fourth node X, X is minimized.",
            "NL": "It is preferred, though with medium priority, that whenever there is a Circuit between second point H and fake value K, there is an Element between second point H and fake value K, with fourth node X, the value of X is minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Clue with id6 K, with edge5 B, with node8 T, with edge1 L, whenever there is a Width with id4 W, W is minimized. ",
            "NL": "As a matter of medium priority, whenever there is a Clue between id6 K, edge5 B, node8 T, edge1 L, whenever there is a Width with id4 W, the Width must be minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Complete_Graph with id6 X, X is minimized.",
            "NL": "There is a preference that whenever there is a Complete_Graph with id6 X, that it should be minimized with the lowest priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Cycle with edge7 K, with id4 S, whenever there is a Edge_Paired with node8 D, with vtx K, with key7 S, whenever there is a weight with value Q, Q is minimized.",
            "NL": "There is a preference, with a medium priority, that whenever there is a Cycle with edge7 K, with id4 S, whenever there is an Edge_Paired with node8 D, with vtx K, with key7 S, whenever there is a weight with value Q, Q is minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Dendrogram with first node V, whenever there is a Diagram with id2 P, P is minimized.",
            "NL": "With medium priority, it is preferable that whenever there is a Dendrogram with first node V, whenever there is a Diagram with id2 P, P is minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Depth_Vertex with vtx2 C, with edge1 M, whenever there is a Line_Graph with id10 W, with id9 C, with field3 M, whenever there is a weight with value N, N is minimized.",
            "NL": "There is a preference, with a medium priority, that whenever there is a Depth_Vertex with vtx2 C, with edge1 M, whenever there is a Line_Graph with id10 W, with id9 C, with field3 M, whenever there is a weight with value N, N is minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Difference with value D, with value K, whenever there is a Loop with value D, whenever there is not a NonCohesive with value D, whenever there is a weight with value K, K is minimized.",
            "NL": "The minimization of K is preferred, with medium priority, whenever there is a Difference with value D, with value K, whenever there is a Loop with value D, whenever there is no NonCohesive with value D, whenever there is a weight with value K."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Dual_Graph with vtx5 P, with vtx5 H, whenever there is a Lead with vtx5 V, V is minimized.",
            "NL": "It is preferable, with medium priority when there is a Dual_Graph with vtx5 P, with vtx5 H, there is a Lead with vtx5 V, it is preferred that V is minimized. "
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Dyed with key3 B, with key3 T, whenever there is a Chromatic_Number with key3 L, L is minimized.",
            "NL": "It is preferable, with medium priority when there is a Dyed with key3 B, with key3 T, there is a Chromatic_Number with key3 L, it is preferred that L is minimized. "
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Edge_Match with field10 O, with field10 I, whenever there is a Elabel with field10 O, whenever there is not a Mass with field10 O, whenever there is a weight with field10 I, I is minimized.",
            "NL": "The minimization of I is preferred, with medium priority, whenever there is an Edge_Match with field10 O, with field10 I, whenever there is an Elabel with field10 O, whenever there is no Mass with field10 O, whenever there is a weight with field10 I."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Following with id7 F, with id4 Q, whenever there is an Attained with id7 I, with id4 Q, whenever there is a Dyed with id7 I, with id4 G, whenever there is a weight with id7 I, I is minimized.",
            "NL": "There is a preference, with medium priority, that whenever there is a Following with id7 F, with id4 Q, there is an Attained with id7 I, with id4 Q, there is a Dyed with id7 I, with id4 G, and whenever there is a weight with id7 I, I is minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Following with node7 K, with node7 O, whenever there is a Linked with node7 Y, Y is minimized.",
            "NL": "It is preferable, with medium priority when there is a Following with node7 K, with node7 O, there is a Linked with node7 Y, it is preferred that Y is minimized. "
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Functioning with fifth vertex A, whenever there is a Outgroup with vtx9 X, X is minimized.",
            "NL": "With medium priority, it is preferable that whenever there is a Functioning with fifth vertex A, whenever there is an Outgroup with vtx9 X, X is minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Identifier with id A, whenever there is a Center with id A, A is minimized.",
            "NL": "With medium priority, it is preferable that whenever there is an Identifier with id A, whenever there is a Center with id A, A is minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a In_HamiltonianCycle with field N, with field Q, whenever there is an Allocate with field N, whenever there is not a Adjacent with field N, whenever there is a weight with field Q, Q is minimized.",
            "NL": "The minimization of Q is preferred, with medium priority, whenever there is an In_HamiltonianCycle with field N, with field Q, whenever there is an Allocate with field N, whenever there is no Adjacent with field N, whenever there is a weight with field Q."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a In_Layer with node7 S, with node7 K, whenever there is a Edge_Level with node7 Z, Z is minimized.",
            "NL": "It is preferable, with medium priority when there is an In_Layer with node7 S, with node7 K, there is an Edge_Level with node7 Z, it is preferred that Z is minimized. "
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a IncomingPath with value10 J, with edge3 C, whenever there is an Inspect with value5 S, with key5 J, with value6 C, whenever there is a weight with value M, M is minimized.",
            "NL": "There is a preference, with a medium priority, that whenever there is an IncomingPath with value10 J, with edge3 C, whenever there is an Inspect with value5 S, with key5 J, with value6 C, whenever there is a weight with value M, M is minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Irrelevant with id8 R, with value1 F, whenever there is a Lead with field7 P, with id10 R, with edge10 F, whenever there is a weight with value W, W is minimized.",
            "NL": "There is a preference, with a medium priority, that whenever there is an Irrelevant with id8 R, with value1 F, whenever there is a Lead with field7 P, with id10 R, with edge10 F, whenever there is a weight with value W, W is minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Location with node4 A, with node4 N, whenever there is a Trapped with node4 W, W is minimized.",
            "NL": "It is preferable, with medium priority when there is a Location with node4 A, with node4 N, there is a Trapped with node4 W, it is preferred that W is minimized. "
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Nontrivial with value6 Q, with edge2 C, whenever there is a Reached with value6 O, with edge2 C, whenever there is a Degree_Sequence with value6 O, with edge2 U, whenever there is a weight with value6 O, O is minimized.",
            "NL": "There is a preference, with medium priority, that whenever there is a Nontrivial with value6 Q, with edge2 C, there is a Reached with value6 O, with edge2 C, there is a Degree_Sequence with value6 O, with edge2 U, and whenever there is a weight with value6 O, O is minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Planar_Embedding with fourth node N, with third vertex K, whenever there is a Jailed with fourth node N, with third vertex K, with second id M, M is minimized.",
            "NL": "It is preferred, though with medium priority, that whenever there is a Planar_Embedding between fourth node N and third vertex K, there is a Jailed between fourth node N and third vertex K, with second id M, the value of M is minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Planar_Graph with edge5 R, with field10 M, whenever there is a Minus with field9 P, with id R, with key4 M, whenever there is a weight with value E, E is minimized.",
            "NL": "There is a preference, with a medium priority, that whenever there is a Planar_Graph with edge5 R, with field10 M, whenever there is a Minus with field9 P, with id R, with key4 M, whenever there is a weight with value E, E is minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Primary with fifth point H, whenever there is a Independent_Set with field6 W, W is minimized.",
            "NL": "With medium priority, it is preferable that whenever there is a Primary with fifth point H, whenever there is an Independent_Set with field6 W, W is minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Probability_Value with id5 I, with value5 O, with key9 Q, with id1 J, whenever there is a Minimum_Vertex_Cover with value X, X is minimized. ",
            "NL": "As a matter of medium priority, whenever there is a Probability_Value between id5 I, value5 O, key9 Q, id1 J, whenever there is a Minimum_Vertex_Cover with value X, the Minimum_Vertex_Cover must be minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Regular with id2 F, with id2 G, whenever there is an Embedding with id2 M, M is minimized.",
            "NL": "It is preferable, with medium priority when there is a Regular with id2 F, with id2 G, there is an Embedding with id2 M, it is preferred that M is minimized. "
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Rest with edge9 R, with vtx10 V, with vtx7 W, with id1 D, whenever there is a Success with value10 X, X is minimized. ",
            "NL": "As a matter of medium priority, whenever there is a Rest between edge9 R, vtx10 V, vtx7 W, id1 D, whenever there is a Success with value10 X, the Success must be minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Short with vtx W, whenever there is a Indication with vtx W, W is minimized.",
            "NL": "With medium priority, it is preferable that whenever there is a Short with vtx W, whenever there is an Indication with vtx W, W is minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Simple with field4 A, with field4 L, whenever there is a Comprises with field4 W, W is minimized.",
            "NL": "It is preferable, with medium priority when there is a Simple with field4 A, with field4 L, there is a Comprises with field4 W, it is preferred that W is minimized. "
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Subposition with key4 W, with key4 U, whenever there is a Connection with key4 M, M is minimized.",
            "NL": "It is preferable, with medium priority when there is a Subposition with key4 W, with key4 U, there is a Connection with key4 M, it is preferred that M is minimized. "
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Subsequent with third point M, with second point W, whenever there is an Regular with third point M, with second point W, with third vertex N, N is minimized.",
            "NL": "It is preferred, though with medium priority, that whenever there is a Subsequent between third point M and second point W, there is a Regular between third point M and second point W, with third vertex N, the value of N is minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Succeeding with key4 N, with value5 I, with field9 P, with key2 Q, whenever there is a Input_Data with key5 K, K is minimized. ",
            "NL": "As a matter of medium priority, whenever there is a Succeeding between key4 N, value5 I, field9 P, key2 Q, whenever there is an Input_Data with key5 K, the Input_Data must be minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Unlabeled with vtx7 W, with vtx7 D, whenever there is a Connection with vtx7 W, whenever there is not a Nonclique with vtx7 W, whenever there is a weight with vtx7 D, D is minimized.",
            "NL": "The minimization of D is preferred, with medium priority, whenever there is an Unlabeled with vtx7 W, with vtx7 D, whenever there is a Connection with vtx7 W, whenever there is no Nonclique with vtx7 W, whenever there is a weight with vtx7 D."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Unpaired with vtx2 P, with vtx2 M, whenever there is a Last with vtx2 S, S is minimized.",
            "NL": "It is preferable, with medium priority when there is an Unpaired with vtx2 P, with vtx2 M, there is a Last with vtx2 S, it is preferred that S is minimized. "
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is an Adjacent with field8 V, with field5 M, whenever there is a Projection with key6 I, with vtx1 V, with vtx7 M, whenever there is a weight with value D, D is minimized.",
            "NL": "There is a preference, with a medium priority, that whenever there is an Adjacent with field8 V, with field5 M, whenever there is a Projection with key6 I, with vtx1 V, with vtx7 M, whenever there is a weight with value D, D is minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is an Basic with node10 D, D is minimized.",
            "NL": "There is a preference that whenever there is a Basic with node10 D, that it should be minimized with the lowest priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is an Dynamic with key4 N, N is minimized.",
            "NL": "There is a preference that whenever there is a Dynamic with key4 N, that it should be minimized with the lowest priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is an Earliest with field10 B, with id3 A, whenever there is a In with value2 H, with vtx9 B, with vtx6 A, whenever there is a weight with value N, N is minimized.",
            "NL": "There is a preference, with a medium priority, that whenever there is an Earliest with field10 B, with id3 A, whenever there is an In with value2 H, with vtx9 B, with vtx6 A, whenever there is a weight with value N, N is minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is an Employed_Edge with vtx4 F, with edge2 I, with edge1 M, with key2 R, whenever there is a Secondary with value1 O, O is minimized. ",
            "NL": "As a matter of medium priority, whenever there is an Employed_Edge between vtx4 F, edge2 I, edge1 M, key2 R, whenever there is a Secondary with value1 O, the Secondary must be minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is an Includes with fourth id F, with fifth id C, whenever there is an Concluding with fourth id F, with fifth id C, with third node N, N is minimized.",
            "NL": "It is preferred, though with medium priority, that whenever there is an Includes between fourth id F and fifth id C, there is a Concluding between fourth id F and fifth id C, with third node N, the value of N is minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is an Index with first node M, with third id N, whenever there is a Labeled with first node M, with third id N, with second node L, L is minimized.",
            "NL": "It is preferred, though with medium priority, that whenever there is an Index between first node M and third id N, there is a Labeled between first node M and third id N, with second node L, the value of L is minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is an Insignificant with first id Y, with first point B, whenever there is an Index with first id Y, with first point B, with second vertex D, D is minimized.",
            "NL": "It is preferred, though with medium priority, that whenever there is an Insignificant between first id Y and first point B, there is an Index between first id Y and first point B, with second vertex D, the value of D is minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is an LessThanExists with first vertex O, with fourth point A, whenever there is a Launch with first vertex O, with fourth point A, with third node B, B is minimized.",
            "NL": "It is preferred, though with medium priority, that whenever there is a LessThanExists between first vertex O and fourth point A, there is a Launch between first vertex O and fourth point A, with third node B, the value of B is minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is an Pointer with node4 L, L is minimized.",
            "NL": "There is a preference that whenever there is a Pointer with node4 L, that it should be minimized with the lowest priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is an Twosome with fifth id O, with fourth vertex U, whenever there is an Unweighted with fifth id O, with fourth vertex U, with second id L, L is minimized.",
            "NL": "It is preferred, though with medium priority, that whenever there is a Twosome between fifth id O and fourth vertex U, there is an Unweighted between fifth id O and fourth vertex U, with second id L, the value of L is minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": " It is preferred, with low priority, that whenever there is an inPath with first vtx X, with second vtx Y, whenever there is an edge with first vtx X, with second vtx Y, with third vtx C, C is minimized.",
            "NL": "It is preferred, though with low priority, that whenever there is an inPath between first vertex X and second vertex Y, there is an edge between first vertex X and second vertex Y, with third vertex C, the value of C is minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of nodes that are clique is maximized.",
            "NL": "Maximizing the number of clique nodes is of high priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with low priority that the number of nodes X that are nonclique is minimized.",
            "NL": "It is preferred with a low priority that the number of nodes X that are not in a clique is minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Acnt with value L, with id C, whenever there is a comp with value L, whenever there is not a assigned with value L, whenever there is a weight with value C, C is minimized.",
            "NL": "The minimization of C is preferred, with low priority, whenever there is an Acnt with value L, with id C, whenever there is a comp with value L, whenever there is no assignment with value L, whenever there is a weight with value C."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a clique with value X, whenever there is a weight with value V, V is minimized.",
            "NL": "With low priority, it is preferable that whenever there is a clique with value X, whenever there is a weight with value V, V is minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a crossing with id1 N1, with id2 N2, with id3 N3, with id4 N4, whenever there is a weight with value V, V is minimized.",
            "NL": "As a matter of low priority, whenever there is a crossing between id1 N1, id2 N2, id3 N3, id4 N4, whenever there is a weight with value V, the weight must be minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a diffpen with value P2, with id X, whenever there is a nextpen with field1 P1, with field2 P2, with field3 X, whenever there is a weight with value V, V is minimized.",
            "NL": "There is a preference, with a low priority, that whenever there is a diffpen with value P2, with id X, whenever there is a nextpen with field1 P1, with field2 P2, with field3 X, whenever there is a weight with value V, V is minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a member with value A, with id L, whenever there is an asgn with value X, with id L, whenever there is a next with value X, with id A, whenever there is a weight with value X, X is minimized.",
            "NL": "There is a preference, with low priority, that whenever there is a member with value A, with id L, there is an asgn with value X, with id L, there is a next with value X, with id A, and whenever there is a weight with value X, X is minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a minpen with value P, with id X, whenever there is a weight with value V, V is minimized. ",
            "NL": "It is preferable, with low priority when there is a minpen with value P, with id X, there is a weight with value V, it is preferred that V is minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a nonclique with first node X, whenever there is a weight with value V, V is minimized.",
            "NL": "With low priority, it is preferable that whenever there is a nonclique with first node X, whenever there is a weight with value V, V is minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is an abs with id X, X is minimized.",
            "NL": "There is a preference that whenever there is an abs with id X, that it should be minimized with the lowest priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": " It is preferred, with low priority, that whenever there is an inPath with first vtx X, with second vtx Y, whenever there is an edge with first vtx X, with second vtx Y, with third vtx C, C is minimized.",
            "NL": "It is preferable to have an edge between vertex X and vertex Y, with vertex C, in the event that there is an inPath between X and Y, though this is of low priority; the value of C should be kept to a minimum."
        },
        {
            "Category": "Weak Constraint",
            "CNL": " It is preferred, with low priority, that whenever there is an inPath with first vtx X, with second vtx Y, whenever there is an edge with first vtx X, with second vtx Y, with third vtx C, C is minimized.",
            "NL": "Whenever there is an inPath between first vertex X and second vertex Y, it is preferred, though with low priority, that an edge between first vertex X and second vertex Y with third vertex C be created, with the goal of minimizing C's value."
        },
        {
            "Category": "Weak Constraint",
            "CNL": " It is preferred, with low priority, that whenever there is an inPath with first vtx X, with second vtx Y, whenever there is an edge with first vtx X, with second vtx Y, with third vtx C, C is minimized.",
            "NL": "It is desirable, though not essential, that when there is a direct path between vertex X and vertex Y, an edge is created that connects the two vertices and has a minimum value of C."
        },
        {
            "Category": "Weak Constraint",
            "CNL": " It is preferred, with low priority, that whenever there is an inPath with first vtx X, with second vtx Y, whenever there is an edge with first vtx X, with second vtx Y, with third vtx C, C is minimized.",
            "NL": "It is desirable, though not essential, that when there is an inPath connecting vertex X to vertex Y, there should also be an edge between X and Y, with the value of vertex C being minimized as much as possible."
        },
        {
            "Category": "Weak Constraint",
            "CNL": " It is preferred, with low priority, that whenever there is an inPath with first vtx X, with second vtx Y, whenever there is an edge with first vtx X, with second vtx Y, with third vtx C, C is minimized.",
            "NL": "It is desirable that, given an inPath between vertices X and Y, there should be an edge between them, with vertex C, and the value of C should be as low as possible."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of edge4 Z that are In_Hamiltonian_Tour is minimized.",
            "NL": "It is highly important to minimize the amount of edge4 Z that are not included in an In_Hamiltonian_Tour."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of edge4 Z that are In_Hamiltonian_Tour is minimized.",
            "NL": "It is highly desirable to minimize the amount of edge4 Z that are not included in an In_Hamiltonian_Tour."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of edge4 Z that are In_Hamiltonian_Tour is minimized.",
            "NL": "It is highly preferable to minimize the amount of edge4 Z that are not included in an In_Hamiltonian_Tour."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of edge4 Z that are In_Hamiltonian_Tour is minimized.",
            "NL": "It is highly desirable to minimize the number of edge4 Zs that are not part of an In_Hamiltonian_Tour."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of edge4 Z that are In_Hamiltonian_Tour is minimized.",
            "NL": "It is highly desirable to minimize the number of edge4 Zs that are not included in an In_Hamiltonian_Tour."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of edge6 that are edge7 is maximized.",
            "NL": "Achieving the highest possible number of edge7 edge6 is of utmost importance."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of edge6 that are edge7 is maximized.",
            "NL": "Making the most of edge6 and edge7 is of utmost importance."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of edge6 that are edge7 is maximized.",
            "NL": "Giving priority to maximizing the number of edge6 edges is of utmost importance."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of edge6 that are edge7 is maximized.",
            "NL": "Achieving the highest possible amount of edge7 edge6 is a priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of edge6 that are edge7 is maximized.",
            "NL": "Maximizing the quantity of edge7 edge6 is of utmost importance."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of edge6 that are value9 is maximized.",
            "NL": "Making the most of value9 edge6 is a top priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of edge6 that are value9 is maximized.",
            "NL": "Prioritizing the maximization of value9 edge6 is essential."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of edge6 that are value9 is maximized.",
            "NL": "It is of high priority to maximize the value9 edge6."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of edge6 that are value9 is maximized.",
            "NL": "Making the most of value9 edge6 is of utmost importance."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of edge6 that are value9 is maximized.",
            "NL": "Giving priority to maximizing the number of value9 edge6 is essential."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of edge7 that are id10 is maximized.",
            "NL": "Having a high priority on maximizing the number of id10 edge7 is essential."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of edge7 that are id10 is maximized.",
            "NL": "Achieving the highest possible number of id10 edge7 is a top priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of edge7 that are id10 is maximized.",
            "NL": "Achieving the highest possible amount of id10 edge7 should be a top priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of edge7 that are id10 is maximized.",
            "NL": "Making sure the maximum number of id10 edge7s is reached is a top priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of edge7 that are id10 is maximized.",
            "NL": "Prioritizing the maximization of id10 edge7 is essential."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of field10 that are id4 is maximized.",
            "NL": "Giving the utmost importance to increasing the amount of id4 field10 is essential."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of field10 that are id4 is maximized.",
            "NL": "Giving priority to increasing the amount of id4 field10 is essential."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of field10 that are id4 is maximized.",
            "NL": "Maximizing field10 of the id4 is of utmost importance."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of field10 that are id4 is maximized.",
            "NL": "Making sure the id4 field10 count is as high as possible is a top priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of field10 that are id4 is maximized.",
            "NL": "It is of high importance to maximize the number of id4 field10."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of field2 that are key5 is maximized.",
            "NL": "Giving key5 field2 the highest level of attention is of utmost importance."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of field2 that are key5 is maximized.",
            "NL": "Giving the highest priority to increasing the amount of key5 field2 is essential."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of field2 that are key5 is maximized.",
            "NL": "Giving priority to maximizing the amount of key5 field2 is essential."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of field2 that are key5 is maximized.",
            "NL": "It is of utmost importance to maximize the amount of key5 field2."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of field2 that are key5 is maximized.",
            "NL": "Making the most of the key5 field2 is of utmost importance."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of id7 that are id is maximized.",
            "NL": "Giving priority to maximizing the amount of id id7 is essential."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of id7 that are id is maximized.",
            "NL": "Making sure id7 is at its maximum is a top priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of id7 that are id is maximized.",
            "NL": "Making sure that id7 is maximized is of utmost importance."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of id7 that are id is maximized.",
            "NL": "Achieving the highest possible quantity of id7 is a top priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of id7 that are id is maximized.",
            "NL": "Making sure that the highest possible amount of id id7 is attained is of great importance."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of id9 M that are Edge_Paired is minimized.",
            "NL": "It is of utmost importance to reduce the amount of id9 M that are not in a Edge_Paired."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of id9 M that are Edge_Paired is minimized.",
            "NL": "It is highly desirable to minimize the number of id9 M that are not in an Edge_Paired."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of id9 M that are Edge_Paired is minimized.",
            "NL": "It is highly desirable to reduce the amount of id9 M that are not Edge_Paired."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of id9 M that are Edge_Paired is minimized.",
            "NL": "It is highly recommended to minimize the amount of id9 M that are not in an Edge_Paired."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of id9 M that are Edge_Paired is minimized.",
            "NL": "It is highly recommended that the amount of id9 M not in an Edge_Paired is kept to a minimum."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of key5 that are value10 is maximized.",
            "NL": "Making the most of value10 key5 is a top priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of key5 that are value10 is maximized.",
            "NL": "Achieving the highest possible number of value10 key5 is a top priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of key5 that are value10 is maximized.",
            "NL": "Making sure that the highest number of value10 key5 is obtained is of great importance."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of key5 that are value10 is maximized.",
            "NL": "High priority is placed on maximizing the amount of value10 key5."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of key5 that are value10 is maximized.",
            "NL": "Achieving the highest possible amount of value10 key5 is a top priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of key9 that are vtx5 is maximized.",
            "NL": "Making sure there is a maximum amount of vtx5 key9 should be of the utmost importance."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of key9 that are vtx5 is maximized.",
            "NL": "Achieving a maximum amount of vtx5 key9 is of great importance."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of key9 that are vtx5 is maximized.",
            "NL": "Achieving the highest possible amount of vtx5 key9 is of utmost importance."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of key9 that are vtx5 is maximized.",
            "NL": "Making sure there is a maximum amount of vtx5 key9 is a top priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of key9 that are vtx5 is maximized.",
            "NL": "Achieving the highest possible number of vtx5 key9 is a top priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of key9 W that are Hierarchy is minimized.",
            "NL": "It is highly desirable to reduce the number of key9 Ws that are not part of a Hierarchy."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of key9 W that are Hierarchy is minimized.",
            "NL": "A high priority is given to minimizing the number of Key9Ws that are not in a Hierarchy."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of key9 W that are Hierarchy is minimized.",
            "NL": "It is highly desirable to minimize the number of key9 Ws that are not organized into a Hierarchy."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of key9 W that are Hierarchy is minimized.",
            "NL": "It is highly desirable to minimize the number of key9 W that are not organized in a Hierarchy."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of key9 W that are Hierarchy is minimized.",
            "NL": "It is highly recommended that the amount of key9 Ws not arranged in a Hierarchy is kept to a minimum."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of node1 that are edge1 is maximized.",
            "NL": "Giving priority to maximizing the amount of edge node1 is essential."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of node1 that are edge1 is maximized.",
            "NL": "Giving priority to maximizing the quantity of edge1 node1 is essential."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of node1 that are edge1 is maximized.",
            "NL": "Achieving a maximum quantity of edge1 node1 is a key priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of node1 that are edge1 is maximized.",
            "NL": "Prioritizing the maximization of edge1 node1 is of utmost importance."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of node1 that are edge1 is maximized.",
            "NL": "Maximizing the quantity of edge1 nodes1 is a top priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of node3 that are node is maximized.",
            "NL": "Making node3 as numerous as possible is of high priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of node3 that are node is maximized.",
            "NL": "Making sure that node3 has the highest possible number is a priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of node3 that are node is maximized.",
            "NL": "Making sure node3 reaches its maximum potential is of high priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of node3 that are node is maximized.",
            "NL": "Making sure node3 has the highest possible number is of utmost importance."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of node3 that are node is maximized.",
            "NL": "Making sure node3 reaches its highest potential is a top priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of node9 that are id is maximized.",
            "NL": "Making sure the maximum amount of id node9 is achieved should be a top priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of node9 that are id is maximized.",
            "NL": "Giving priority to maximizing the amount of id node9 is of utmost importance."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of node9 that are id is maximized.",
            "NL": "Prioritizing the maximization of the number of id node9 is of high importance."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of node9 that are id is maximized.",
            "NL": "Making sure the maximum amount of id nodes9 is achieved should be a top priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of node9 that are id is maximized.",
            "NL": "Making sure the amount of id node9 is as large as possible is of utmost importance."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of nodes that are clique is maximized.",
            "NL": "Making sure there is a maximum amount of clique nodes is of utmost importance."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of nodes that are clique is maximized.",
            "NL": "Making sure the greatest possible amount of clique nodes are present is of utmost importance."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of nodes that are clique is maximized.",
            "NL": "Making the greatest possible number of clique nodes is a top priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of nodes that are clique is maximized.",
            "NL": "Making the most of the clique nodes is of utmost importance."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of nodes that are clique is maximized.",
            "NL": "It is of utmost importance to maximize the amount of clique nodes."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of value10 that are node10 is maximized.",
            "NL": "Making sure that node10 has the highest possible value10 is of utmost importance."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of value10 that are node10 is maximized.",
            "NL": "Making sure node10 has a value of 10 is a top priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of value10 that are node10 is maximized.",
            "NL": "Maximizing the value of node10 should be given top priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of value10 that are node10 is maximized.",
            "NL": "Making sure that node10 value10 is maximized is of utmost importance."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of value10 that are node10 is maximized.",
            "NL": "Achieving the highest possible value of node10 is of utmost importance."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of value5 that are id10 is maximized.",
            "NL": "Making sure that the quantity of id10 value5 is at its peak is a top priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of value5 that are id10 is maximized.",
            "NL": "Achieving the highest possible count of id10 value5 is a top priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of value5 that are id10 is maximized.",
            "NL": "Achieving the highest possible number of id10 value5 is of utmost importance."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of value5 that are id10 is maximized.",
            "NL": "Giving priority to maximizing the number of id10 value5 is essential."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of value5 that are id10 is maximized.",
            "NL": "Having a high priority on increasing the quantity of id10 value5 is essential."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of vtx6 that are edge8 is maximized.",
            "NL": "Making the most of the edge8 vtx6 is of utmost importance."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of vtx6 that are edge8 is maximized.",
            "NL": "Achieving the highest possible number of edge8 vtx6 is a priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of vtx6 that are edge8 is maximized.",
            "NL": "Maximizing the quantity of edge8 vtx6 is of utmost importance."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of vtx6 that are edge8 is maximized.",
            "NL": "Achieving the highest possible number of edge8 vtx6 is of utmost importance."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with high priority that the number of vtx6 that are edge8 is maximized.",
            "NL": "Making the most of the edge8 vtx6 is a priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with low priority that the number of edge10 R that are Network is minimized.",
            "NL": "It is highly recommended to minimize the number of edge10 Rs that are not connected to a Network."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with low priority that the number of edge10 R that are Network is minimized.",
            "NL": "It is desirable to keep the number of edge10 R that are not connected to a Network to a minimum."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with low priority that the number of edge10 R that are Network is minimized.",
            "NL": "It is highly recommended that the amount of edge10 R that are not connected to a Network be kept to a minimum."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with low priority that the number of edge10 R that are Network is minimized.",
            "NL": "It is desirable to minimize the number of edge10 Rs that are not connected to a Network, but it is not a top priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with low priority that the number of edge10 R that are Network is minimized.",
            "NL": "It is preferable to minimize the number of edge10 R that are not part of a Network, given low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with low priority that the number of field9 E that are Pointer is minimized.",
            "NL": "It is preferable to minimize the amount of field9 E that are not associated with a Pointer, but this should be given a low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with low priority that the number of field9 E that are Pointer is minimized.",
            "NL": "It is desirable to keep the number of field9 E that are not in a Pointer to a minimum with a low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with low priority that the number of field9 E that are Pointer is minimized.",
            "NL": "It is preferable to minimize the number of Field9 Es that are not pointed to with a low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with low priority that the number of field9 E that are Pointer is minimized.",
            "NL": "It is preferable to keep the amount of field9 E that are not in a Pointer to a minimum and given a lower level of priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with low priority that the number of field9 E that are Pointer is minimized.",
            "NL": "It is preferable to minimize the number of field9 Es that are not in a Pointer, but this should be done with low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with low priority that the number of field9 R that are Out_HamiltonianCycle is minimized.",
            "NL": "It is desirable to keep the number of field9 Rs not in an Out_HamiltonianCycle to a minimum and given a low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with low priority that the number of field9 R that are Out_HamiltonianCycle is minimized.",
            "NL": "It is preferable to keep the number of field9 R that are not in an Out_HamiltonianCycle to a minimum and given a low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with low priority that the number of field9 R that are Out_HamiltonianCycle is minimized.",
            "NL": "It is desirable to minimize the number of field9 Rs that are not in an Out_HamiltonianCycle, but this should not be a top priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with low priority that the number of field9 R that are Out_HamiltonianCycle is minimized.",
            "NL": "It is desirable to keep the number of field9 Rs not in an Out_HamiltonianCycle to a minimum, but not at the expense of higher priority tasks."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with low priority that the number of field9 R that are Out_HamiltonianCycle is minimized.",
            "NL": "It is best to keep the number of field9 R that are not in a Out_HamiltonianCycle to a minimum, though this is not a top priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with low priority that the number of id4 O that are Father_Edge is minimized.",
            "NL": "It is desirable to keep the number of id4 O that are not in a Father_Edge to a minimum."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with low priority that the number of id4 O that are Father_Edge is minimized.",
            "NL": "It is preferable to minimize the number of id4 O that are not in a Father_Edge and should be given a low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with low priority that the number of id4 O that are Father_Edge is minimized.",
            "NL": "It is highly recommended that the number of id4 O that do not have a Father_Edge be kept to a minimum."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with low priority that the number of id4 O that are Father_Edge is minimized.",
            "NL": "It is desirable to keep the amount of id4 O that are not in a Father_Edge to a minimum."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with low priority that the number of id4 O that are Father_Edge is minimized.",
            "NL": "It is preferable to keep the number of id4 O that are not in a Father_Edge to a minimum."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with low priority that the number of key5 H that are Input_Data is minimized.",
            "NL": "It is preferable to minimize the number of key5 H that are not in the Input_Data, although it is not a priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with low priority that the number of key5 H that are Input_Data is minimized.",
            "NL": "It is desirable to keep the number of key5 Hs not present in Input_Data to a minimum, with a low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with low priority that the number of key5 H that are Input_Data is minimized.",
            "NL": "It is desirable to keep the number of key5 Hs not present in the Input_Data to a minimum, but this is not a top priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with low priority that the number of key5 H that are Input_Data is minimized.",
            "NL": "It is desirable to keep the number of key5 H not included in the Input_Data to a minimum and given a low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with low priority that the number of key5 H that are Input_Data is minimized.",
            "NL": "It is preferable to minimize the number of key5 H that are not in the Input_Data and should be given low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with low priority that the number of nodes X that are nonclique is minimized.",
            "NL": "It is preferable to minimize the number of nodes X that are not in a clique, but this should be done with a low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with low priority that the number of nodes X that are nonclique is minimized.",
            "NL": "It is desirable to minimize the number of nodes X that are not in a clique, but this should not be given a high priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with low priority that the number of nodes X that are nonclique is minimized.",
            "NL": "It is desirable to keep the number of nodes X that are not in a clique to a minimum, but with low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with low priority that the number of nodes X that are nonclique is minimized.",
            "NL": "It is desired that the amount of nodes X that are not part of a clique be kept to a minimum, although this is of low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with low priority that the number of nodes X that are nonclique is minimized.",
            "NL": "It is preferable to minimize the number of nodes X that are not part of a clique, given low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with low priority that the number of vtx10 L that are Link_Label is minimized.",
            "NL": "It is preferable to keep the number of vtx10 L that are not in a Link_Label to a minimum."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with low priority that the number of vtx10 L that are Link_Label is minimized.",
            "NL": "It is desirable to keep the amount of vtx10 L that are not in a Link_Label to a minimum."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with low priority that the number of vtx10 L that are Link_Label is minimized.",
            "NL": "It is preferable to keep the amount of vtx10 L that are not in a Link_Label to a minimum."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with low priority that the number of vtx10 L that are Link_Label is minimized.",
            "NL": "It is desirable to keep the amount of vtx10 Ls that are not in a Link_Label to a minimum."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with low priority that the number of vtx10 L that are Link_Label is minimized.",
            "NL": "It is preferable to minimize the number of vtx10 L that are not in a Link_Label, though it is of low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with medium priority that the number of edge6 Z that are Graph_Coloring is minimized.",
            "NL": "It is desired to minimize the number of edge6 Z that are not in a Graph_Coloring, with a medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with medium priority that the number of edge6 Z that are Graph_Coloring is minimized.",
            "NL": "It is preferable to minimize the number of edge6 Z that are not included in a Graph_Coloring, with medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with medium priority that the number of edge6 Z that are Graph_Coloring is minimized.",
            "NL": "It is desirable to minimize the number of edge6 Z that are not in a Graph_Coloring with medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with medium priority that the number of edge6 Z that are Graph_Coloring is minimized.",
            "NL": "It is preferable to minimize the number of edge6 Z that are not in a Graph_Coloring with a medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with medium priority that the number of edge6 Z that are Graph_Coloring is minimized.",
            "NL": "It is desirable to minimize the amount of edge6 Z that are not included in a Graph_Coloring, giving it a medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with medium priority that the number of edge7 K that are Clique is minimized.",
            "NL": "It is desirable to minimize the amount of edge7 K that are not part of a Clique, giving it a medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with medium priority that the number of edge7 K that are Clique is minimized.",
            "NL": "It is desirable to minimize the number of edge7 K that are not in a Clique, giving it a medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with medium priority that the number of edge7 K that are Clique is minimized.",
            "NL": "It is preferable to minimize the number of edge7 K that are not part of a Clique with medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with medium priority that the number of edge7 K that are Clique is minimized.",
            "NL": "It is desired to minimize the number of edge7 K that are not in a Clique, with a medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with medium priority that the number of edge7 K that are Clique is minimized.",
            "NL": "It is preferable to minimize the number of edge7 Ks that are not part of a Clique, giving it a medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with medium priority that the number of edge8 M that are Selected_Color is minimized.",
            "NL": "It is desirable to minimize the number of edge8 M that are not in a Selected_Color, with a medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with medium priority that the number of edge8 M that are Selected_Color is minimized.",
            "NL": "It is highly recommended to minimize the amount of edge8 M that are not in a Selected_Color."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with medium priority that the number of edge8 M that are Selected_Color is minimized.",
            "NL": "It is desirable to minimize the number of edge8 M that are not in a Selected_Color, and should be given medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with medium priority that the number of edge8 M that are Selected_Color is minimized.",
            "NL": "It is desirable to minimize the number of edge8 M that are not in a Selected_Color with a medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with medium priority that the number of edge8 M that are Selected_Color is minimized.",
            "NL": "It is desirable to minimize the number of edge8 M that are not in a Selected_Color, giving it a medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with medium priority that the number of key9 G that are Fine is minimized.",
            "NL": "It is highly recommended that the amount of key9 Gs not in Fine condition should be kept to a minimum."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with medium priority that the number of key9 G that are Fine is minimized.",
            "NL": "It is preferable to minimize the number of key9 Gs that are not in a Fine condition with medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with medium priority that the number of key9 G that are Fine is minimized.",
            "NL": "It is desirable to minimize the number of key9 Gs that are not in a Fine state, giving it a medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with medium priority that the number of key9 G that are Fine is minimized.",
            "NL": "It is highly recommended to reduce the number of key9 G that are not in a Fine state to the lowest possible amount."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with medium priority that the number of key9 G that are Fine is minimized.",
            "NL": "It is highly recommended to reduce the amount of key9 Gs that are not in a Fine state."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with medium priority that the number of node B that are Joined is minimized.",
            "NL": "It is desirable to minimize the number of node Bs that are not Joined with medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with medium priority that the number of node B that are Joined is minimized.",
            "NL": "It is preferable to minimize the number of node B that are not in a Joined state with medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with medium priority that the number of node B that are Joined is minimized.",
            "NL": "It is highly recommended to minimize the number of node Bs that are not in a Joined state."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with medium priority that the number of node B that are Joined is minimized.",
            "NL": "It is desirable to keep the number of node Bs that are not in a Joined state to a minimum."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with medium priority that the number of node B that are Joined is minimized.",
            "NL": "It is desired that the amount of node B that are not Connected be kept to a minimum, with medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with medium priority that the number of value3 E that are Distinct is minimized.",
            "NL": "It is preferable to minimize the amount of value3 E that are not Distinct with a medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with medium priority that the number of value3 E that are Distinct is minimized.",
            "NL": "It is preferable to minimize the number of value3 E that are not in a Distinct, with a medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with medium priority that the number of value3 E that are Distinct is minimized.",
            "NL": "It is desired that the amount of value3 E that are not Distinct be kept to a minimum."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with medium priority that the number of value3 E that are Distinct is minimized.",
            "NL": "It is preferable to reduce the number of value3 E that are not Distinct to a medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with medium priority that the number of value3 E that are Distinct is minimized.",
            "NL": "It is recommended that the amount of value3 E that are not Distinct be kept to a minimum."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with medium priority that the number of vtx10 K that are Employed_Edge is minimized.",
            "NL": "It is desirable to reduce the amount of vtx10 K that are not Employed_Edge to a medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with medium priority that the number of vtx10 K that are Employed_Edge is minimized.",
            "NL": "It is desirable to minimize the number of vtx10 K that are not Employed_Edge with a medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with medium priority that the number of vtx10 K that are Employed_Edge is minimized.",
            "NL": "It is preferable to minimize the number of VTX10Ks that are not employed in an Edge."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with medium priority that the number of vtx10 K that are Employed_Edge is minimized.",
            "NL": "It is desirable to minimize the number of vtx10 K that are not in an Employed_Edge, with a medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred with medium priority that the number of vtx10 K that are Employed_Edge is minimized.",
            "NL": "It is desirable to reduce the number of vtx10 K that are not in an Employed_Edge to a medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Achieved with key S, with key W, whenever there is a Allocate with key S, whenever there is not a Sign with key S, whenever there is a weight with key W, W is minimized.",
            "NL": "Whenever there is an Allocate with key S, or an Achieved with key S, or no Sign with key S and a weight with key W, the prioritization of W should be given high priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Achieved with key S, with key W, whenever there is a Allocate with key S, whenever there is not a Sign with key S, whenever there is a weight with key W, W is minimized.",
            "NL": "Whenever there is an Allocate with key S, or an Achieved with key S, or a Sign with key S, or a weight with key W, minimizing W should be given the highest priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Achieved with key S, with key W, whenever there is a Allocate with key S, whenever there is not a Sign with key S, whenever there is a weight with key W, W is minimized.",
            "NL": "Whenever there is an Allocate with key S, or an Achieved with key S, or no Sign with key S, or a weight with key W, minimizing W should be given top priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Achieved with key S, with key W, whenever there is a Allocate with key S, whenever there is not a Sign with key S, whenever there is a weight with key W, W is minimized.",
            "NL": "Whenever there is an Achieved with key S, Allocate with key S, or a weight with key W, minimizing W should be given top priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Achieved with key S, with key W, whenever there is a Allocate with key S, whenever there is not a Sign with key S, whenever there is a weight with key W, W is minimized.",
            "NL": "Whenever there is an Allocate with key S, an Achieved with key S, no Sign with key S, or a weight with key W, minimizing W should be given high priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Arrived with edge9 U, with edge9 J, whenever there is a Cell with edge9 E, E is minimized.",
            "NL": "When there is an Arrived with edge9 U and a Cell with edge9 J, it is highly recommended that the edge9 E be minimized as much as possible."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Arrived with edge9 U, with edge9 J, whenever there is a Cell with edge9 E, E is minimized.",
            "NL": "When there is an Arrived with edge9 U, and a Cell with edge9 J, it is highly preferred that edge9 E be minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Arrived with edge9 U, with edge9 J, whenever there is a Cell with edge9 E, E is minimized.",
            "NL": "When there is an Arrived with edge9 U, and a Cell with edge9 J, it is highly recommended to minimize edge9 E."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Arrived with edge9 U, with edge9 J, whenever there is a Cell with edge9 E, E is minimized.",
            "NL": "When there is an Arrived with edge9 U and a Cell with edge9 J, it is highly recommended to minimize the edge9 E as much as possible."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Arrived with edge9 U, with edge9 J, whenever there is a Cell with edge9 E, E is minimized.",
            "NL": "When there is an Arrived with edge9 U, and a Cell with edge9 J, it is highly recommended that edge9 E be minimized as much as possible."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Basic with field9 M, with vtx9 B, whenever there is a Inpath with node3 Q, with field7 M, with id2 B, whenever there is a weight with value P, P is minimized.",
            "NL": "Whenever there is a Basic with field9 M and vtx9 B, an Inpath with node3 Q, field7 M, and id2 B, and a weight with value P, it is of high priority to minimize P."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Basic with field9 M, with vtx9 B, whenever there is a Inpath with node3 Q, with field7 M, with id2 B, whenever there is a weight with value P, P is minimized.",
            "NL": "It is of utmost importance to minimize the value of P whenever there is a Basic with field9 M, vtx9 B, an Inpath with node3 Q, field7 M, and id2 B, and a weight with value P."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Basic with field9 M, with vtx9 B, whenever there is a Inpath with node3 Q, with field7 M, with id2 B, whenever there is a weight with value P, P is minimized.",
            "NL": "The highest priority preference is to minimize value P whenever there is a Basic with field9 M, vtx9 B, an Inpath with node3 Q, field7 M, and id2 B, and a weight with value P."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Basic with field9 M, with vtx9 B, whenever there is a Inpath with node3 Q, with field7 M, with id2 B, whenever there is a weight with value P, P is minimized.",
            "NL": "Whenever possible, it is preferred to prioritize minimizing the weight value of P whenever there is a Basic with field9 M, vtx9 B, an Inpath with node3 Q, field7 M, and id2 B."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Basic with field9 M, with vtx9 B, whenever there is a Inpath with node3 Q, with field7 M, with id2 B, whenever there is a weight with value P, P is minimized.",
            "NL": "Whenever possible, it is highly preferred to minimize the value of P when there is a Basic with field9 M and vtx9 B, an Inpath with node3 Q, field7 M and id2 B, and a weight with value P."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Below_Threshold with fourth node U, whenever there is a Out_HamiltonianCycle with node6 S, S is minimized.",
            "NL": "Whenever a Below_Threshold with fourth node U is present, it is preferable to prioritize minimizing Out_HamiltonianCycle with node6 S."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Below_Threshold with fourth node U, whenever there is a Out_HamiltonianCycle with node6 S, S is minimized.",
            "NL": "Whenever there is a Below_Threshold with fourth node U and an Out_HamiltonianCycle with node6 S, it is preferable to minimize S with high priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Below_Threshold with fourth node U, whenever there is a Out_HamiltonianCycle with node6 S, S is minimized.",
            "NL": "It is preferable to prioritize minimizing S whenever there is a Below_Threshold with fourth node U and an Out_HamiltonianCycle with node6 S."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Below_Threshold with fourth node U, whenever there is a Out_HamiltonianCycle with node6 S, S is minimized.",
            "NL": "It is preferable that node S is minimized whenever there is a Below_Threshold with fourth node U and an Out_HamiltonianCycle with node6 S, and this should be done with high priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Below_Threshold with fourth node U, whenever there is a Out_HamiltonianCycle with node6 S, S is minimized.",
            "NL": "When a Below_Threshold with fourth node U is present, it is preferable to prioritize minimizing Out_HamiltonianCycle with node6 S."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Bucket with key9 L, with id K, with id2 E, with edge10 D, whenever there is a Cut_Vertex with edge4 G, G is minimized. ",
            "NL": "When there is a Bucket between key9 L, id K, id2 E, edge10 D, and a Cut_Vertex with edge4 G, it is of utmost importance to minimize the Cut_Vertex."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Bucket with key9 L, with id K, with id2 E, with edge10 D, whenever there is a Cut_Vertex with edge4 G, G is minimized. ",
            "NL": "The Cut_Vertex must be minimized as a top priority when there is a Bucket between key9 L, id K, id2 E, edge10 D and a Cut_Vertex with edge4 G."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Bucket with key9 L, with id K, with id2 E, with edge10 D, whenever there is a Cut_Vertex with edge4 G, G is minimized. ",
            "NL": "Whenever there is a Bucket between key9 L, id K, id2 E, edge10 D, and a Cut_Vertex with edge4 G, minimizing the Cut_Vertex should be a top priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Bucket with key9 L, with id K, with id2 E, with edge10 D, whenever there is a Cut_Vertex with edge4 G, G is minimized. ",
            "NL": "When there is a Bucket between key9 L, id K, id2 E, and edge10 D, the Cut_Vertex with edge4 G should be minimized as a top priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Bucket with key9 L, with id K, with id2 E, with edge10 D, whenever there is a Cut_Vertex with edge4 G, G is minimized. ",
            "NL": "Whenever there is a Bucket between key9 L, id K, id2 E, edge10 D, and a Cut_Vertex with edge4 G, it is of utmost importance to minimize the Cut_Vertex."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Connection with node4 K, with node4 W, whenever there is a Isomorphism with node4 M, M is minimized.",
            "NL": "When there is a connection between node4 K and node4 W, it is highly preferable to minimize node4 M, as there is an isomorphism present."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Connection with node4 K, with node4 W, whenever there is a Isomorphism with node4 M, M is minimized.",
            "NL": "When a Connection is established between node4 K and node4 W, it is highly recommended that node4 M be minimized as much as possible, as an Isomorphism is present."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Connection with node4 K, with node4 W, whenever there is a Isomorphism with node4 M, M is minimized.",
            "NL": "When there is a connection between node4 K and node4 W, it is highly preferred that the isomorphism with node4 M is minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Connection with node4 K, with node4 W, whenever there is a Isomorphism with node4 M, M is minimized.",
            "NL": "When there is a connection between node4 K and node4 W, it is highly preferable to minimize node4 M, as there is an isomorphism with it."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Connection with node4 K, with node4 W, whenever there is a Isomorphism with node4 M, M is minimized.",
            "NL": "When there is a connection between node4 K and node4 W, it is highly recommended to minimize node4 M, as it is isomorphic with them."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Connection with second node B, whenever there is an Eulerian_Graph with id1 W, W is minimized.",
            "NL": "It is of the highest priority to minimize W when there is an Eulerian Graph with id1 W and a Connection with second node B."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Connection with second node B, whenever there is an Eulerian_Graph with id1 W, W is minimized.",
            "NL": "Whenever a Connection is made with second node B and an Eulerian_Graph with id1 W is present, it is preferable that W is minimized with high priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Connection with second node B, whenever there is an Eulerian_Graph with id1 W, W is minimized.",
            "NL": "Whenever a Connection with second node B is established and an Eulerian_Graph with id1 W is present, it is desirable to minimize W with the highest priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Connection with second node B, whenever there is an Eulerian_Graph with id1 W, W is minimized.",
            "NL": "It is preferable that W be minimized whenever there is a Connection with second node B and an Eulerian_Graph with id1 W, and that this be given high priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Connection with second node B, whenever there is an Eulerian_Graph with id1 W, W is minimized.",
            "NL": "It is highly recommended that W be minimized whenever there is a Connection with second node B and an Eulerian_Graph with id1 W."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Data with value5 V, with field4 Y, whenever there is a OutgoingPath with value5 X, with field4 Y, whenever there is an OutgoingRoute with value5 X, with field4 G, whenever there is a weight with value5 X, X is minimized.",
            "NL": "Whenever Data with value5 V and field4 Y exist, OutgoingPath with value5 X and field4 Y, and OutgoingRoute with value5 X and field4 G should be given high priority, and weight with value5 X should be minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Data with value5 V, with field4 Y, whenever there is a OutgoingPath with value5 X, with field4 Y, whenever there is an OutgoingRoute with value5 X, with field4 G, whenever there is a weight with value5 X, X is minimized.",
            "NL": "Whenever there is a Data with value5 V and field4 Y, an OutgoingPath with value5 X and field4 Y, as well as an OutgoingRoute with value5 X and field4 G must be given top priority. Additionally, if there is a weight with value5 X, it should be minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Data with value5 V, with field4 Y, whenever there is a OutgoingPath with value5 X, with field4 Y, whenever there is an OutgoingRoute with value5 X, with field4 G, whenever there is a weight with value5 X, X is minimized.",
            "NL": "Whenever there is a Data with value5 V and field4 Y, an OutgoingPath with value5 X and field4 Y, and an OutgoingRoute with value5 X and field4 G, is preferred with high priority, and the weight value5 X should be minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Data with value5 V, with field4 Y, whenever there is a OutgoingPath with value5 X, with field4 Y, whenever there is an OutgoingRoute with value5 X, with field4 G, whenever there is a weight with value5 X, X is minimized.",
            "NL": "Whenever there is a Data with value5 V and field4 Y, an OutgoingPath with value5 X and field4 Y, as well as an OutgoingRoute with value5 X and field4 G, should be prioritized, and the weight with value5 X should be minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Data with value5 V, with field4 Y, whenever there is a OutgoingPath with value5 X, with field4 Y, whenever there is an OutgoingRoute with value5 X, with field4 G, whenever there is a weight with value5 X, X is minimized.",
            "NL": "Whenever there is a Data with value5 V, with field4 Y, there is a preference to prioritize having an OutgoingPath with value5 X, with field4 Y, and an OutgoingRoute with value5 X, with field4 G. Additionally, whenever there is a weight with value5 X, it should be minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Diagram with node7 C, with node7 X, whenever there is a Later with node7 Q, Q is minimized.",
            "NL": "When it comes to Diagrams with both node7 C and node7 X, it is preferable to prioritize minimizing node7 Q."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Diagram with node7 C, with node7 X, whenever there is a Later with node7 Q, Q is minimized.",
            "NL": "When there is a Diagram with node7 C and node7 X, it is highly desirable to minimize node7 Q as much as possible."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Diagram with node7 C, with node7 X, whenever there is a Later with node7 Q, Q is minimized.",
            "NL": "It is best to minimize node7 Q if there is a Diagram with node7 C and node7 X, as this has a high priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Diagram with node7 C, with node7 X, whenever there is a Later with node7 Q, Q is minimized.",
            "NL": "When there is a Diagram with node7 C and node7 X, it is highly preferable that node7 Q is minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Diagram with node7 C, with node7 X, whenever there is a Later with node7 Q, Q is minimized.",
            "NL": "It is highly recommended that node7 Q be minimized if there is a Diagram with node7 C and node7 X, and a Later with node7 Q."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Diameter with value7 E, with value7 P, whenever there is a Suggestion with value7 S, S is minimized.",
            "NL": "When there is a Diameter of value7 E and a value7 P, it is highly recommended to minimize the Suggestion of value7 S."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Diameter with value7 E, with value7 P, whenever there is a Suggestion with value7 S, S is minimized.",
            "NL": "When there is a Diameter with value 7E and a Suggestion with value 7S, it is highly recommended that S is minimized as much as possible."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Diameter with value7 E, with value7 P, whenever there is a Suggestion with value7 S, S is minimized.",
            "NL": "When there is a Diameter with value7 E and a Suggestion with value7 S, it is highly recommended to minimize S as much as possible."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Diameter with value7 E, with value7 P, whenever there is a Suggestion with value7 S, S is minimized.",
            "NL": "When there is a Diameter of value7 E and a value7 P, it is highly important that the Suggestion of value7 S be minimized as much as possible."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Diameter with value7 E, with value7 P, whenever there is a Suggestion with value7 S, S is minimized.",
            "NL": "When there is a Diameter with a value of 7E and a value of 7P, it is highly recommended to minimize the Suggestion with a value of 7S."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Dominant with id2 Q, with id2 Y, whenever there is a Perfect_Graph with id2 Q, whenever there is not a Maximum_Flow with id2 Q, whenever there is a weight with id2 Y, Y is minimized.",
            "NL": "Whenever there is a Dominant with id2 Q, a Perfect_Graph with id2 Q, no Maximum_Flow with id2 Q, or a weight with id2 Y, minimizing Y should be given high priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Dominant with id2 Q, with id2 Y, whenever there is a Perfect_Graph with id2 Q, whenever there is not a Maximum_Flow with id2 Q, whenever there is a weight with id2 Y, Y is minimized.",
            "NL": "Whenever there is a Dominant with id2 Q, a Perfect_Graph with id2 Q, and no Maximum_Flow with id2 Q, it is highly important to reduce Y, and in such cases, a weight with id2 Y should be taken into consideration."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Dominant with id2 Q, with id2 Y, whenever there is a Perfect_Graph with id2 Q, whenever there is not a Maximum_Flow with id2 Q, whenever there is a weight with id2 Y, Y is minimized.",
            "NL": "Whenever a Dominant with id2 Q, a Perfect_Graph with id2 Q, and no Maximum_Flow with id2 Q are present, the reduction of Y should be given top priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Dominant with id2 Q, with id2 Y, whenever there is a Perfect_Graph with id2 Q, whenever there is not a Maximum_Flow with id2 Q, whenever there is a weight with id2 Y, Y is minimized.",
            "NL": "Whenever there is a Dominant with id2 Q, a Perfect_Graph with id2 Q, and no Maximum_Flow with id2 Q, it is preferred to have a high priority in minimizing Y, as well as a weight with id2 Y."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Dominant with id2 Q, with id2 Y, whenever there is a Perfect_Graph with id2 Q, whenever there is not a Maximum_Flow with id2 Q, whenever there is a weight with id2 Y, Y is minimized.",
            "NL": "Whenever there is a Dominant with id2 Q, a Perfect_Graph with id2 Q, or a weight with id2 Y, the reduction of Y should be given the highest priority. However, if there is a Maximum_Flow with id2 Q, then Y should not be minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Dominant with node9 T, whenever there is a Contains with node9 T, T is minimized.",
            "NL": "It is preferable that T be minimized whenever there is a Dominant or Contains with node9 T and high priority is given."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Dominant with node9 T, whenever there is a Contains with node9 T, T is minimized.",
            "NL": "It is preferable to minimize T whenever there is a Dominant or Contains with node9 T, and this should be done with high priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Dominant with node9 T, whenever there is a Contains with node9 T, T is minimized.",
            "NL": "Whenever possible, it is preferable to minimize T when there is a Dominant or Contains node9 T with high priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Dominant with node9 T, whenever there is a Contains with node9 T, T is minimized.",
            "NL": "It is preferable that T be minimized whenever there is a Dominant or Contains with node9 T, and this should be given high priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Dominant with node9 T, whenever there is a Contains with node9 T, T is minimized.",
            "NL": "When dealing with high priority, it is preferable to minimize T whenever there is a Dominant or Contains node9 T present."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Edge_Tag with edge8 Q, with edge8 C, whenever there is a Member with edge8 P, P is minimized.",
            "NL": "When there is an Edge_Tag with edge8 Q and edge8 C, it is highly preferable to minimize the Member with edge8 P."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Edge_Tag with edge8 Q, with edge8 C, whenever there is a Member with edge8 P, P is minimized.",
            "NL": "When there is an Edge_Tag with edge8 Q and edge8 C, it is highly desirable to minimize the Member with edge8 P."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Edge_Tag with edge8 Q, with edge8 C, whenever there is a Member with edge8 P, P is minimized.",
            "NL": "When given an Edge_Tag with edge8 Q and edge8 C, it is highly recommended to minimize edge8 P of the Member whenever possible."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Edge_Tag with edge8 Q, with edge8 C, whenever there is a Member with edge8 P, P is minimized.",
            "NL": "When there is an Edge_Tag with edge8 Q and edge8 C, it is highly recommended that the Member with edge8 P be minimized as much as possible."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Edge_Tag with edge8 Q, with edge8 C, whenever there is a Member with edge8 P, P is minimized.",
            "NL": "When there is an Edge_Tag with edge8 Q and edge8 C, it is highly preferred that the Member with edge8 P be minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Flow with fifth vertex K, with third node L, whenever there is an Root with fifth vertex K, with third node L, with second id E, E is minimized.",
            "NL": "Whenever there is a Flow between fifth vertex K and third node L, it is highly preferred that a Root with second id E be established, and the value of E is minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Flow with fifth vertex K, with third node L, whenever there is an Root with fifth vertex K, with third node L, with second id E, E is minimized.",
            "NL": "Whenever there is a Flow between fifth vertex K and third node L, it is preferred, and given high priority, that a Root with second id E is established between them, and the value of E is minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Flow with fifth vertex K, with third node L, whenever there is an Root with fifth vertex K, with third node L, with second id E, E is minimized.",
            "NL": "It is highly recommended that whenever there is a Flow between fifth vertex K and third node L, a Root between fifth vertex K and third node L with second id E should be established, and the value of E should be minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Flow with fifth vertex K, with third node L, whenever there is an Root with fifth vertex K, with third node L, with second id E, E is minimized.",
            "NL": "It is highly recommended that when there is a Flow between fifth vertex K and third node L, the Root between fifth vertex K and third node L, with second id E should have the lowest possible value."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Flow with fifth vertex K, with third node L, whenever there is an Root with fifth vertex K, with third node L, with second id E, E is minimized.",
            "NL": "Whenever there is a Flow between fifth vertex K and third node L, it is preferred, though of high priority, that there is a Root between them, with second id E, and the value of E is minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Hamiltonian_Cycle with value6 L, whenever there is an Used_Edge with value6 L, L is minimized.",
            "NL": "Whenever there is a Hamiltonian_Cycle with value 6L, it is preferable to minimize L as much as possible with high priority, and also when an Used_Edge is found with value 6L."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Hamiltonian_Cycle with value6 L, whenever there is an Used_Edge with value6 L, L is minimized.",
            "NL": "Whenever possible, it is best to minimize L when there is a Hamiltonian_Cycle with a value of 6L or an Used_Edge with a value of 6L and this should be done with high priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Hamiltonian_Cycle with value6 L, whenever there is an Used_Edge with value6 L, L is minimized.",
            "NL": "Whenever a Hamiltonian_Cycle with value 6L is found, it is preferable to minimize L by using an Used_Edge with value 6L as a top priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Hamiltonian_Cycle with value6 L, whenever there is an Used_Edge with value6 L, L is minimized.",
            "NL": "Whenever a Hamiltonian_Cycle with value 6L is present, it is preferable to minimize L whenever an Used_Edge with value 6L is encountered, given the high priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Hamiltonian_Cycle with value6 L, whenever there is an Used_Edge with value6 L, L is minimized.",
            "NL": "Whenever a Hamiltonian Cycle and an Used Edge have a value of 6L, it is preferable to minimize L with high priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Identifier with field8 B, with field8 N, whenever there is a List with field8 B, whenever there is not a Unpaired with field8 B, whenever there is a weight with field8 N, N is minimized.",
            "NL": "Whenever there is an Identifier with field8 B, a List with field8 B, and no Unpaired with field8 B, it is preferred to give high priority to minimizing N, which has field8 N."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Identifier with field8 B, with field8 N, whenever there is a List with field8 B, whenever there is not a Unpaired with field8 B, whenever there is a weight with field8 N, N is minimized.",
            "NL": "Whenever there is an Identifier with field8 B, a List with field8 B, and no Unpaired with field8 B, prioritizing the reduction of N in the weight field8 is preferred."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Identifier with field8 B, with field8 N, whenever there is a List with field8 B, whenever there is not a Unpaired with field8 B, whenever there is a weight with field8 N, N is minimized.",
            "NL": "Whenever there is an Identifier with field8 B, a List with field8 B, and no Unpaired with field8 B, and a weight with field8 N, it is highly preferred to minimize N."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Identifier with field8 B, with field8 N, whenever there is a List with field8 B, whenever there is not a Unpaired with field8 B, whenever there is a weight with field8 N, N is minimized.",
            "NL": "Whenever there is an Identifier with field8 B, a List with field8 B, and no Unpaired with field8 B, it is highly preferred to minimize field8 N, if there is a weight with field8 N."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Identifier with field8 B, with field8 N, whenever there is a List with field8 B, whenever there is not a Unpaired with field8 B, whenever there is a weight with field8 N, N is minimized.",
            "NL": "Whenever there is an Identifier with field8 B, a List with field8 B, and no Unpaired with field8 B, it is highly preferred to minimize field8 N, when a weight with field8 N is present."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Maximal with node9 Q, with node9 Y, whenever there is an Utilized_Edge with node9 Q, whenever there is not a Flow_Network with node9 Q, whenever there is a weight with node9 Y, Y is minimized.",
            "NL": "Whenever there is a Maximal with node9 Q, an Utilized_Edge with node9 Q, and no Flow_Network with node9 Q present, the priority should be placed on minimizing Y, with node9 Y's weight taken into account."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Maximal with node9 Q, with node9 Y, whenever there is an Utilized_Edge with node9 Q, whenever there is not a Flow_Network with node9 Q, whenever there is a weight with node9 Y, Y is minimized.",
            "NL": "Whenever there is a Maximal with node9 Q, an Utilized_Edge with node9 Q, or no Flow_Network with node9 Q, the priority should be placed on minimizing Y, along with its associated weight."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Maximal with node9 Q, with node9 Y, whenever there is an Utilized_Edge with node9 Q, whenever there is not a Flow_Network with node9 Q, whenever there is a weight with node9 Y, Y is minimized.",
            "NL": "Whenever there is a Maximal node9 Q, Utilized_Edge node9 Q, or no Flow_Network node9 Q, it is preferred to prioritize the minimization of node9 Y, with its weight taken into consideration."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Maximal with node9 Q, with node9 Y, whenever there is an Utilized_Edge with node9 Q, whenever there is not a Flow_Network with node9 Q, whenever there is a weight with node9 Y, Y is minimized.",
            "NL": "It is highly desirable to reduce Y whenever a Maximal is present with node9 Q, an Utilized_Edge is present with node9 Q, there is no Flow_Network with node9 Q, and a weight is present with node9 Y."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Maximal with node9 Q, with node9 Y, whenever there is an Utilized_Edge with node9 Q, whenever there is not a Flow_Network with node9 Q, whenever there is a weight with node9 Y, Y is minimized.",
            "NL": "Whenever there is a Maximal with node9 Q and an Utilized_Edge with node9 Q, but no Flow_Network with node9 Q, it is highly preferred to minimize node9 Y's weight."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Minus with field5 C, C is minimized.",
            "NL": "It is preferred that when there is a negative value in field5 C, it should be minimized with the lowest priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Minus with field5 C, C is minimized.",
            "NL": "When field5 C has a Minus, it should be given the lowest priority for minimizing."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Minus with field5 C, C is minimized.",
            "NL": "It is preferred that when field5 C has a negative value, it should be minimized with the least priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Minus with field5 C, C is minimized.",
            "NL": "It is preferred that field5 C Minuses be minimized with the least priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Minus with field5 C, C is minimized.",
            "NL": "It is preferred that any Minus associated with field5 C be minimized with the lowest priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Nfirst with value5 N, with field2 R, whenever there is an Edge_Label with value5 W, with field2 R, whenever there is a Vertex with value5 W, with field2 D, whenever there is a weight with value5 W, W is minimized.",
            "NL": "Whenever a Nfirst with a value of 5 N and field2 R is present, an Edge_Label with a value of 5 W and field2 R and a Vertex with a value of 5 W and field2 D should be given high priority. Additionally, when a weight with a value of 5 W is present, it should be minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Nfirst with value5 N, with field2 R, whenever there is an Edge_Label with value5 W, with field2 R, whenever there is a Vertex with value5 W, with field2 D, whenever there is a weight with value5 W, W is minimized.",
            "NL": "Whenever there is a Nfirst with value5 N, with field2 R, an Edge_Label with value5 W, with field2 R, and a Vertex with value5 W, with field2 D, it is highly preferred that the weight with value5 W be minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Nfirst with value5 N, with field2 R, whenever there is an Edge_Label with value5 W, with field2 R, whenever there is a Vertex with value5 W, with field2 D, whenever there is a weight with value5 W, W is minimized.",
            "NL": "Whenever there is a Nfirst with value5 N, with field2 R, there is an Edge_Label with value5 W, with field2 R, a Vertex with value5 W, with field2 D, and a weight with value5 W, it is highly preferred that W be minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Nfirst with value5 N, with field2 R, whenever there is an Edge_Label with value5 W, with field2 R, whenever there is a Vertex with value5 W, with field2 D, whenever there is a weight with value5 W, W is minimized.",
            "NL": "Whenever there is a Nfirst with value5 N and field2 R, there should be an Edge_Label with value 5W and field2 R, as well as a Vertex with value 5W and field2 D, and the weight should be minimized to value 5W."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Nfirst with value5 N, with field2 R, whenever there is an Edge_Label with value5 W, with field2 R, whenever there is a Vertex with value5 W, with field2 D, whenever there is a weight with value5 W, W is minimized.",
            "NL": "Whenever there is a Nfirst with value5 N and field2 R, an Edge_Label with value5 W and field2 R, and a Vertex with value5 W and field2 D, priority is given to minimizing the weight value of W."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a NonForemost with node7 Z, with node7 K, whenever there is a Commence with node7 F, F is minimized.",
            "NL": "When it comes to NonForemost with node7 Z and node7 K, it is preferable to prioritize minimizing node7 F in order to commence."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a NonForemost with node7 Z, with node7 K, whenever there is a Commence with node7 F, F is minimized.",
            "NL": "When there is a NonForemost with node7 Z and a Commence with node7 F, it is preferable to prioritize minimizing F."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a NonForemost with node7 Z, with node7 K, whenever there is a Commence with node7 F, F is minimized.",
            "NL": "When dealing with node7 Z and node7 K, it is highly recommended to minimize node7 F as much as possible."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a NonForemost with node7 Z, with node7 K, whenever there is a Commence with node7 F, F is minimized.",
            "NL": "When there is a NonForemost with node7 Z, it is highly preferable to minimize node7 F, which is associated with a Commence."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a NonForemost with node7 Z, with node7 K, whenever there is a Commence with node7 F, F is minimized.",
            "NL": "When there is a NonForemost with node7 Z and a Commence with node7 F, it is highly recommended to minimize F as much as possible."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a OutgoingPath with edge B, with edge W, whenever there is a Chosencolour with edge P, P is minimized.",
            "NL": "When there is an OutgoingPath with edges B and W, it is highly desirable to minimize the Chosencolour with edge P."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a OutgoingPath with edge B, with edge W, whenever there is a Chosencolour with edge P, P is minimized.",
            "NL": "When there is an OutgoingPath with edge B and edge W, it is highly preferable to minimize the Chosencolour with edge P."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a OutgoingPath with edge B, with edge W, whenever there is a Chosencolour with edge P, P is minimized.",
            "NL": "When there is an OutgoingPath with edge B and edge W, it is highly preferred that the Chosencolour with edge P is minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a OutgoingPath with edge B, with edge W, whenever there is a Chosencolour with edge P, P is minimized.",
            "NL": "When there is an OutgoingPath with edges B and W, it is highly recommended that the Chosencolour with edge P be minimized as much as possible."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a OutgoingPath with edge B, with edge W, whenever there is a Chosencolour with edge P, P is minimized.",
            "NL": "When there is an OutgoingPath with edge B and edge W, it is highly desirable to minimize the Chosencolour with edge P."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Parent with fake value V, whenever there is a Lead with edge4 K, K is minimized.",
            "NL": "Whenever there is a Parent with fake value V and a Lead with edge4 K, it is preferable to minimize K with high priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Parent with fake value V, whenever there is a Lead with edge4 K, K is minimized.",
            "NL": "When a Parent has a fake value V, it is preferable to minimize the Lead's edge4 K with high priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Parent with fake value V, whenever there is a Lead with edge4 K, K is minimized.",
            "NL": "When a Parent has a fake value V, it is essential to minimize the Lead with edge4 K as much as possible."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Parent with fake value V, whenever there is a Lead with edge4 K, K is minimized.",
            "NL": "When there is a Parent with fake value V, it is preferable that the Lead with edge4 K be minimized with high priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Parent with fake value V, whenever there is a Lead with edge4 K, K is minimized.",
            "NL": "Whenever there is a Parent with fake value V, it is preferable that K be minimized for any Lead with edge4 K, and this should be given high priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Predominant with key2 N, with node1 J, whenever there is an Intersect with edge7 I, with edge2 N, with value J, whenever there is a weight with value C, C is minimized.",
            "NL": "Whenever there is a Predominant with key2 N and node1 J, an Intersect with edge7 I, edge2 N, and value J, and a weight with value C, the preference is to prioritize minimizing C."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Predominant with key2 N, with node1 J, whenever there is an Intersect with edge7 I, with edge2 N, with value J, whenever there is a weight with value C, C is minimized.",
            "NL": "Whenever there is a Predominant with key2 N and node1 J, an Intersect with edge7 I, edge2 N, and value J, or a weight with value C, it is given high priority to minimize C."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Predominant with key2 N, with node1 J, whenever there is an Intersect with edge7 I, with edge2 N, with value J, whenever there is a weight with value C, C is minimized.",
            "NL": "Whenever there is a Predominant with key2 N and node1 J, and an Intersect with edge7 I, edge2 N, and value J, it is highly preferred that the weight value C is minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Predominant with key2 N, with node1 J, whenever there is an Intersect with edge7 I, with edge2 N, with value J, whenever there is a weight with value C, C is minimized.",
            "NL": "Whenever there is a Predominant with key2 N and node1 J, and an Intersect with edge7 I, edge2 N, and value J, it is preferred to minimize the weight value C with high priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Predominant with key2 N, with node1 J, whenever there is an Intersect with edge7 I, with edge2 N, with value J, whenever there is a weight with value C, C is minimized.",
            "NL": "Whenever there is a Predominant with key2 N and node1 J, an Intersect with edge7 I, edge2 N and value J, and a weight with value C, it is of high priority to minimize C."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Prevailing with key6 Q, with edge4 C, whenever there is a Color with key F, with key1 Q, with edge2 C, whenever there is a weight with value K, K is minimized.",
            "NL": "Whenever there is a Prevailing with key6 Q and edge4 C, or a Color with key F, key1 Q, and edge2 C, it is preferable to minimize the value of K in the weight."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Prevailing with key6 Q, with edge4 C, whenever there is a Color with key F, with key1 Q, with edge2 C, whenever there is a weight with value K, K is minimized.",
            "NL": "Whenever there is a Prevailing key6 Q with edge4 C, a Color key F with key1 Q and edge2 C, and a weight with value K, it is given the highest priority to minimize K."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Prevailing with key6 Q, with edge4 C, whenever there is a Color with key F, with key1 Q, with edge2 C, whenever there is a weight with value K, K is minimized.",
            "NL": "Whenever there is a Prevailing with key6 Q and edge4 C, or a Color with key F, key1 Q and edge2 C, it is preferable to minimize the weight with value K."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Prevailing with key6 Q, with edge4 C, whenever there is a Color with key F, with key1 Q, with edge2 C, whenever there is a weight with value K, K is minimized.",
            "NL": "Whenever there is a Prevailing key6 Q with edge4 C, Color key F with key1 Q and edge2 C, and a weight with value K, it is highly preferable to minimize K."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Prevailing with key6 Q, with edge4 C, whenever there is a Color with key F, with key1 Q, with edge2 C, whenever there is a weight with value K, K is minimized.",
            "NL": "It is highly preferred that, when key6 Q is Prevailing with edge4 C, and when key F is present with key1 Q and edge2 C, the value of K should be minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Punishment with edge4 C, with id5 G, with field P, with value7 S, whenever there is a Primary with vtx5 F, F is minimized. ",
            "NL": "Whenever there is a Punishment between edge4 C, id5 G, field P, and value7 S, it is of utmost importance that the Primary with vtx5 F be minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Punishment with edge4 C, with id5 G, with field P, with value7 S, whenever there is a Primary with vtx5 F, F is minimized. ",
            "NL": "Whenever there is a Punishment between edge4 C, id5 G, field P, and value7 S, it is of utmost importance that the Primary with vtx5 F is minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Punishment with edge4 C, with id5 G, with field P, with value7 S, whenever there is a Primary with vtx5 F, F is minimized. ",
            "NL": "Whenever there is a Punishment between edge4 C, id5 G, field P, value7 S, and a Primary with vtx5 F, it is of high priority that the Primary be minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Punishment with edge4 C, with id5 G, with field P, with value7 S, whenever there is a Primary with vtx5 F, F is minimized. ",
            "NL": "Whenever there is a Punishment between edge4 C, id5 G, field P, value7 S, it is of high priority that the Primary with vtx5 F be minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Punishment with edge4 C, with id5 G, with field P, with value7 S, whenever there is a Primary with vtx5 F, F is minimized. ",
            "NL": "When it comes to utmost importance, if there is a Punishment involving edge4 C, id5 G, field P, and value7 S, the Primary with vtx5 F must be reduced as much as possible."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Separate with field1 Q, with vtx3 I, whenever there is a Depth_Vertex with id3 B, with field8 Q, with vtx8 I, whenever there is a weight with value G, G is minimized.",
            "NL": "It is of high priority to minimize the value of G whenever a Separate with field1 Q and vtx3 I, a Depth_Vertex with id3 B and field8 Q and vtx8 I, and a weight with value G are present."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Separate with field1 Q, with vtx3 I, whenever there is a Depth_Vertex with id3 B, with field8 Q, with vtx8 I, whenever there is a weight with value G, G is minimized.",
            "NL": "A preference is given high priority that G is minimized whenever there is a Separate with field1 Q and vtx3 I, a Depth_Vertex with id3 B, field8 Q, and vtx8 I, and a weight with value G."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Separate with field1 Q, with vtx3 I, whenever there is a Depth_Vertex with id3 B, with field8 Q, with vtx8 I, whenever there is a weight with value G, G is minimized.",
            "NL": "When possible, it is strongly preferred to minimize G whenever there is a Separate with field1 Q and vtx3 I, a Depth_Vertex with id3 B and field8 Q and vtx8 I, and a weight with value G."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Separate with field1 Q, with vtx3 I, whenever there is a Depth_Vertex with id3 B, with field8 Q, with vtx8 I, whenever there is a weight with value G, G is minimized.",
            "NL": "A priority is placed on minimizing the value of G when there is a Separate with field1 Q and vtx3 I, a Depth_Vertex with id3 B and field8 Q and vtx8 I, and a weight with value G."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Separate with field1 Q, with vtx3 I, whenever there is a Depth_Vertex with id3 B, with field8 Q, with vtx8 I, whenever there is a weight with value G, G is minimized.",
            "NL": "It is highly preferred that, when there is a Separate with field1 Q and vtx3 I, and a Depth_Vertex with id3 B, field8 Q, and vtx8 I, the weight value G be minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Sign with field N, with vtx5 P, whenever there is an Associated with field H, with vtx5 P, whenever there is a Diagram with field H, with vtx5 J, whenever there is a weight with field H, H is minimized.",
            "NL": "Whenever there is a Sign with field N and vtx5 P, an Associated field H with vtx5 P, and a Diagram field H with vtx5 J, a high priority preference is given to minimizing the weight field H."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Sign with field N, with vtx5 P, whenever there is an Associated with field H, with vtx5 P, whenever there is a Diagram with field H, with vtx5 J, whenever there is a weight with field H, H is minimized.",
            "NL": "It is highly preferred that if there is a Sign with field N, vtx5 P, then there should be an Associated with field H, vtx5 P, and a Diagram with field H, vtx5 J, and if there is a weight with field H, H should be minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Sign with field N, with vtx5 P, whenever there is an Associated with field H, with vtx5 P, whenever there is a Diagram with field H, with vtx5 J, whenever there is a weight with field H, H is minimized.",
            "NL": "Whenever there is a Sign with field N, vtx5 P, there is an Associated field H, vtx5 P, and a Diagram with field H, vtx5 J, and the weight field H should be minimized with high priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Sign with field N, with vtx5 P, whenever there is an Associated with field H, with vtx5 P, whenever there is a Diagram with field H, with vtx5 J, whenever there is a weight with field H, H is minimized.",
            "NL": "Whenever there is a Sign with field N and vtx5 P, a high priority preference is that there be an Associated with field H with vtx5 P, a Diagram with field H and vtx5 J, and the weight field H is minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Sign with field N, with vtx5 P, whenever there is an Associated with field H, with vtx5 P, whenever there is a Diagram with field H, with vtx5 J, whenever there is a weight with field H, H is minimized.",
            "NL": "Whenever there is a Sign with field N and vtx5 P, it is given high priority to have an Associated field H with vtx5 P, a Diagram field H with vtx5 J, and when there is a weight field H, it should be minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Single with third point V, whenever there is a Disconnected with vtx3 J, J is minimized.",
            "NL": "When dealing with a high priority situation, it is best to minimize J when there is a Single with third point V or a Disconnected with vtx3 J."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Single with third point V, whenever there is a Disconnected with vtx3 J, J is minimized.",
            "NL": "It is best to minimize J whenever there is a Single with third point V and a Disconnected with vtx3 J, and this should be done with the highest priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Single with third point V, whenever there is a Disconnected with vtx3 J, J is minimized.",
            "NL": "It is highly desirable that J be minimized whenever there is a Single with third point V or a Disconnected with vtx3 J."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Single with third point V, whenever there is a Disconnected with vtx3 J, J is minimized.",
            "NL": "It is preferable to prioritize minimizing J whenever there is a Single with third point V and a Disconnected with vtx3 J."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Single with third point V, whenever there is a Disconnected with vtx3 J, J is minimized.",
            "NL": "Whenever there is a Single with third point V, it is best to prioritize minimizing J if there is a Disconnected with vtx3 J."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Triad with key2 Z, with value8 N, whenever there is a Initiate with key3 T, with node4 Z, with vtx7 N, whenever there is a weight with value B, B is minimized.",
            "NL": "Whenever there is a Triad with key2 Z and value8 N, an Initiate with key3 T, node4 Z, and vtx7 N, and a weight with value B, the priority is to minimize B."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Triad with key2 Z, with value8 N, whenever there is a Initiate with key3 T, with node4 Z, with vtx7 N, whenever there is a weight with value B, B is minimized.",
            "NL": "Whenever there is a Triad with key2 Z and value8 N, an Initiate with key3 T, node4 Z and vtx7 N, and a weight with value B, it is of high priority to minimize B."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Triad with key2 Z, with value8 N, whenever there is a Initiate with key3 T, with node4 Z, with vtx7 N, whenever there is a weight with value B, B is minimized.",
            "NL": "Whenever there is a Triad with key2 Z and value8 N, an Initiate with key3 T, node4 Z, and vtx7 N, and a weight with value B, it is of high priority to minimize B."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Triad with key2 Z, with value8 N, whenever there is a Initiate with key3 T, with node4 Z, with vtx7 N, whenever there is a weight with value B, B is minimized.",
            "NL": "Whenever a Triad with key2 Z and value8 N, an Initiate with key3 T, node4 Z, and vtx7 N, and a weight with value B are present, it is preferred that B be minimized with high priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Triad with key2 Z, with value8 N, whenever there is a Initiate with key3 T, with node4 Z, with vtx7 N, whenever there is a weight with value B, B is minimized.",
            "NL": "Whenever there is a Triad with key2 Z and value8 N, an Initiate with key3 T, node4 Z, and vtx7 N, or a weight with value B, the priority is to minimize B."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Unmatch with field7 Z, with id6 S, with field6 W, with id2 D, whenever there is a Simple_Graph with node8 L, L is minimized. ",
            "NL": "In the event of an Unmatch between field7 Z, id6 S, field6 W, and id2 D, minimizing the Simple_Graph with node8 L should be a top priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Unmatch with field7 Z, with id6 S, with field6 W, with id2 D, whenever there is a Simple_Graph with node8 L, L is minimized. ",
            "NL": "It is of utmost importance that when there is an Unmatch between field7 Z, id6 S, field6 W, id2 D, and a Simple_Graph with node8 L, the Simple_Graph should be minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Unmatch with field7 Z, with id6 S, with field6 W, with id2 D, whenever there is a Simple_Graph with node8 L, L is minimized. ",
            "NL": "Whenever there is an Unmatch between field7 Z, id6 S, field6 W, id2 D, and a Simple_Graph with node8 L is present, it is of utmost importance to minimize the Simple_Graph."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Unmatch with field7 Z, with id6 S, with field6 W, with id2 D, whenever there is a Simple_Graph with node8 L, L is minimized. ",
            "NL": "Whenever there is an Unmatch between field7 Z, id6 S, field6 S, id2 D and a Simple_Graph with node8 L is present, it is of utmost importance that the Simple_Graph be minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is a Unmatch with field7 Z, with id6 S, with field6 W, with id2 D, whenever there is a Simple_Graph with node8 L, L is minimized. ",
            "NL": "Whenever Unmatch between field7 Z, id6 S, field6 W, id2 D exists, it is of utmost importance that the Simple_Graph with node8 L be minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is an Allocate with key4 F, with edge3 D, whenever there is a Sign with field9 C, with field4 F, with field8 D, whenever there is a weight with value L, L is minimized.",
            "NL": "The highest priority is to minimize the value of L whenever there is an Allocate with key4 F and edge3 D, a Sign with field9 C, field4 F, and field8 D, and a weight with value L."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is an Allocate with key4 F, with edge3 D, whenever there is a Sign with field9 C, with field4 F, with field8 D, whenever there is a weight with value L, L is minimized.",
            "NL": "Whenever there is an Allocate with key4 F and edge3 D, and a Sign with field9 C, field4 F, and field8 D, the preference is to minimize the weight value of L with high priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is an Allocate with key4 F, with edge3 D, whenever there is a Sign with field9 C, with field4 F, with field8 D, whenever there is a weight with value L, L is minimized.",
            "NL": "It is highly preferable to minimize L whenever Allocate with key4 F and edge3 D, Sign with field9 C, field4 F, and field8 D, and weight with value L are present."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is an Allocate with key4 F, with edge3 D, whenever there is a Sign with field9 C, with field4 F, with field8 D, whenever there is a weight with value L, L is minimized.",
            "NL": "Given the high priority, it is preferred that when there is an Allocate with key4 F and edge3 D, and a Sign with field9 C, field4 F, and field8 D, the value of the weight be minimized as much as possible."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is an Allocate with key4 F, with edge3 D, whenever there is a Sign with field9 C, with field4 F, with field8 D, whenever there is a weight with value L, L is minimized.",
            "NL": "It is highly preferred that, when Allocating with key4 F and edge3 D, and when Signing with field9 C, field4 F, and field8 D, the value of L be minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is an Alpha_Value with value2 X, with key1 U, whenever there is a Degree with value2 L, with key1 U, whenever there is a Weighted_Graph with value2 L, with key1 I, whenever there is a weight with value2 L, L is minimized.",
            "NL": "Whenever an Alpha_Value with value2 X and key1 U is present, the Degree with value2 L and key1 U and the Weighted_Graph with value2 L and key1 I should be given high priority, and the Weight with value2 L should be minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is an Alpha_Value with value2 X, with key1 U, whenever there is a Degree with value2 L, with key1 U, whenever there is a Weighted_Graph with value2 L, with key1 I, whenever there is a weight with value2 L, L is minimized.",
            "NL": "Whenever an Alpha_Value with value2 X and key1 U is present, a Degree with value2 L and key1 U, and a Weighted_Graph with value2 L and key1 I should be given a high priority, and the weight with value2 L should be minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is an Alpha_Value with value2 X, with key1 U, whenever there is a Degree with value2 L, with key1 U, whenever there is a Weighted_Graph with value2 L, with key1 I, whenever there is a weight with value2 L, L is minimized.",
            "NL": "Whenever there is an Alpha_Value of X associated with U, there should be a Degree of L associated with U, a Weighted_Graph of L associated with I, and the Weight should be minimized to L."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is an Alpha_Value with value2 X, with key1 U, whenever there is a Degree with value2 L, with key1 U, whenever there is a Weighted_Graph with value2 L, with key1 I, whenever there is a weight with value2 L, L is minimized.",
            "NL": "Whenever an Alpha_Value with key1 U and value2 X is present, a Degree with key1 U and value2 L, a Weighted_Graph with key1 I and value2 L, and a Weight with value2 L should be prioritized, and the Weight should be minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is an Alpha_Value with value2 X, with key1 U, whenever there is a Degree with value2 L, with key1 U, whenever there is a Weighted_Graph with value2 L, with key1 I, whenever there is a weight with value2 L, L is minimized.",
            "NL": "Whenever there is an Alpha_Value with value2 X and key1 U, a Degree with value2 L and key1 U, and a Weighted_Graph with value2 L and key1 I, it is of high priority to minimize the value2 L of the Weight."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is an Atom with field8 Y, with value9 T, with key Z, with vtx5 I, whenever there is a Chart with node8 G, G is minimized. ",
            "NL": "It is of utmost importance that whenever there is an Atom between field8 Y, value9 T, key Z, vtx5 I, the Chart with node8 G should be minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is an Atom with field8 Y, with value9 T, with key Z, with vtx5 I, whenever there is a Chart with node8 G, G is minimized. ",
            "NL": "Whenever there is an Atom between field8 Y, value9 T, key Z, vtx5 I, and a Chart with node8 G, minimizing the Chart is of utmost importance."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is an Atom with field8 Y, with value9 T, with key Z, with vtx5 I, whenever there is a Chart with node8 G, G is minimized. ",
            "NL": "Whenever a Chart with node8 G is present, it is essential to minimize it; this is of utmost importance if there is an Atom between field8 Y, value9 T, key Z, vtx5 I."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is an Atom with field8 Y, with value9 T, with key Z, with vtx5 I, whenever there is a Chart with node8 G, G is minimized. ",
            "NL": "Whenever there is an Atom between field8 Y, value9 T, key Z, and vtx5 I, it is of the utmost importance that the Chart with node8 G be minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is an Atom with field8 Y, with value9 T, with key Z, with vtx5 I, whenever there is a Chart with node8 G, G is minimized. ",
            "NL": "The Chart with node8 G must be minimized as a top priority whenever there is an Atom between field8 Y, value9 T, key Z, vtx5 I."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is an Cell with fifth vertex K, with fake value R, whenever there is an Subposition with fifth vertex K, with fake value R, with third id P, P is minimized.",
            "NL": "Whenever there is a Cell between fifth vertex K and fake value R, it is highly desirable to have a Subposition between fifth vertex K and fake value R with third id P, and the value of P should be minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is an Cell with fifth vertex K, with fake value R, whenever there is an Subposition with fifth vertex K, with fake value R, with third id P, P is minimized.",
            "NL": "It is highly recommended that, whenever there is a Cell between fifth vertex K and fake value R, the Subposition between fifth vertex K and fake value R with third id P should have a minimized value of P."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is an Cell with fifth vertex K, with fake value R, whenever there is an Subposition with fifth vertex K, with fake value R, with third id P, P is minimized.",
            "NL": "Whenever there is a Cell between fifth vertex K and fake value R, it is preferable to have a Subposition between them with third id P, and the value of P should be kept to a minimum."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is an Cell with fifth vertex K, with fake value R, whenever there is an Subposition with fifth vertex K, with fake value R, with third id P, P is minimized.",
            "NL": "Whenever there is a Cell between fifth vertex K and fake value R, it is highly recommended to have a Subposition between them with third id P, and to minimize the value of P."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is an Cell with fifth vertex K, with fake value R, whenever there is an Subposition with fifth vertex K, with fake value R, with third id P, P is minimized.",
            "NL": "When there is a Cell between fifth vertex K and fake value R, it is highly recommended that there is a Subposition between fifth vertex K and fake value R, with third id P, and that the value of P is minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is an Circuit with id3 J, J is minimized.",
            "NL": "It is preferred that Circuit with id3 J be minimized with the lowest priority whenever it is present."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is an Circuit with id3 J, J is minimized.",
            "NL": "It is preferred that Circuit ID3 J be minimized with the lowest priority if it is present."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is an Circuit with id3 J, J is minimized.",
            "NL": "It is preferred that Circuit with ID3 J be minimized with the least priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is an Circuit with id3 J, J is minimized.",
            "NL": "It is preferred that Circuit id3 J should be minimized with the lowest priority whenever it is present."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is an Circuit with id3 J, J is minimized.",
            "NL": "It is preferred that Circuit id3 J should be minimized with the least amount of priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is an Concluding with edge5 S, S is minimized.",
            "NL": "It is preferable to minimize a Concluding with edge5 S with the lowest priority whenever one is present."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is an Concluding with edge5 S, S is minimized.",
            "NL": "It is preferred that when a Concluding with edge5 S is present, it should be minimized with the lowest priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is an Concluding with edge5 S, S is minimized.",
            "NL": "It is preferred that the Concluding with edge5 S be minimized with the lowest priority whenever it is present."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is an Concluding with edge5 S, S is minimized.",
            "NL": "It is preferred that when a Concluding with edge5 S is present, it should be minimized with the least priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is an Concluding with edge5 S, S is minimized.",
            "NL": "It is preferred that when a Concluding with Edge5 S situation arises, it should be given the lowest priority in terms of minimizing it."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is an Probability_Value with third vertex T, with fourth id L, whenever there is an Offspring with third vertex T, with fourth id L, with fifth point Z, Z is minimized.",
            "NL": "It is highly desirable that if there is a Probability_Value between third vertex T and fourth id L, then there should be an Offspring between third vertex T and fourth id L with fifth point Z, and the value of Z should be as low as possible."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is an Probability_Value with third vertex T, with fourth id L, whenever there is an Offspring with third vertex T, with fourth id L, with fifth point Z, Z is minimized.",
            "NL": "Whenever there is a Probability_Value between third vertex T and fourth id L, it is highly desirable to have an Offspring between third vertex T and fourth id L with fifth point Z, and to minimize the value of Z."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is an Probability_Value with third vertex T, with fourth id L, whenever there is an Offspring with third vertex T, with fourth id L, with fifth point Z, Z is minimized.",
            "NL": "It is highly desirable that, when there is a Probability_Value between third vertex T and fourth id L, there is an Offspring between third vertex T and fourth id L, and the fifth point Z is minimized as much as possible."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is an Probability_Value with third vertex T, with fourth id L, whenever there is an Offspring with third vertex T, with fourth id L, with fifth point Z, Z is minimized.",
            "NL": "Whenever there is a Probability_Value between third vertex T and fourth id L, it is preferred, and given high priority, that an Offspring between third vertex T and fourth id L is created with fifth point Z, and the value of Z is minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with high priority, that whenever there is an Probability_Value with third vertex T, with fourth id L, whenever there is an Offspring with third vertex T, with fourth id L, with fifth point Z, Z is minimized.",
            "NL": "It is highly desirable that, when there is a Probability_Value between third vertex T and fourth id L, an Offspring is created between third vertex T and fourth id L, and the value of fifth point Z is minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Acnt with value L, with id C, whenever there is a comp with value L, whenever there is not a assigned with value L, whenever there is a weight with value C, C is minimized.",
            "NL": "Whenever there is an Acnt with value L, a comp with value L, no assignment with value L, or a weight with value C, the minimization of C should be given low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Acnt with value L, with id C, whenever there is a comp with value L, whenever there is not a assigned with value L, whenever there is a weight with value C, C is minimized.",
            "NL": "Whenever there is an Acnt with value L and an id of C, a comp with value L, no assignment with value L, or a weight with value C, C should be minimized with low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Acnt with value L, with id C, whenever there is a comp with value L, whenever there is not a assigned with value L, whenever there is a weight with value C, C is minimized.",
            "NL": "Whenever there is an Acnt with value L and id C, a comp with value L, no assignment with value L, or a weight with value C, the minimizing of C should be given low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Acnt with value L, with id C, whenever there is a comp with value L, whenever there is not a assigned with value L, whenever there is a weight with value C, C is minimized.",
            "NL": "It is preferable to minimize C, giving it low priority, when there is an Acnt with a value of L, an ID of C, a comp with a value of L, no assignment with a value of L, or a weight with a value of C."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Acnt with value L, with id C, whenever there is a comp with value L, whenever there is not a assigned with value L, whenever there is a weight with value C, C is minimized.",
            "NL": "Whenever there is an Acnt with value L, a comp with value L, no assignment with value L, or a weight with value C, minimizing C should be given low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Breadth with node4 R, with node4 U, whenever there is a Hue with node4 G, G is minimized.",
            "NL": "When there is a Breadth with node4 R and a Hue with node4 G, it is preferable to minimize G, although it is of low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Breadth with node4 R, with node4 U, whenever there is a Hue with node4 G, G is minimized.",
            "NL": "When there is a Breadth with node4 R, it is preferable to have low priority, and when there is a Hue with node4 G, it is preferred to minimize G."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Breadth with node4 R, with node4 U, whenever there is a Hue with node4 G, G is minimized.",
            "NL": "When given the choice between Breadth with node4 R and Hue with node4 G, it is preferable to minimize G and give it low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Breadth with node4 R, with node4 U, whenever there is a Hue with node4 G, G is minimized.",
            "NL": "When there is a Breadth with node4 R, and a Hue with node4 G, it is preferable to minimize G, though this should be done with low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Breadth with node4 R, with node4 U, whenever there is a Hue with node4 G, G is minimized.",
            "NL": "When node4 R has a Breadth, it is preferable to minimize node4 G's Hue, however this should be done with low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Center with node2 X, X is minimized.",
            "NL": "It is preferred that node2 X in a Center be minimized with the lowest priority whenever possible."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Center with node2 X, X is minimized.",
            "NL": "It is preferred that node2 X in any Center should be minimized with the lowest priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Center with node2 X, X is minimized.",
            "NL": "It is preferred that node2 X of any Center should be minimized with the least priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Center with node2 X, X is minimized.",
            "NL": "It is preferable to minimize node2 X in the Center with the lowest priority whenever possible."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Center with node2 X, X is minimized.",
            "NL": "It is preferred that when there is a Center with node2 X, it should be given the least priority for minimizing."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a clique with value X, whenever there is a weight with value V, V is minimized.",
            "NL": "It is preferable to minimize the weight V whenever there is a clique with value X and the priority is low."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a clique with value X, whenever there is a weight with value V, V is minimized.",
            "NL": "Whenever there is a clique with value X and a weight with value V, it is preferable that V be minimized, given low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a clique with value X, whenever there is a weight with value V, V is minimized.",
            "NL": "Whenever there is a clique with value X, it is preferable to minimize the weight with value V, given its low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a clique with value X, whenever there is a weight with value V, V is minimized.",
            "NL": "When there is a clique with value X and a weight with value V, it is best to minimize V as much as possible, given the low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a clique with value X, whenever there is a weight with value V, V is minimized.",
            "NL": "Whenever there is a clique with value X and a weight with value V, it is preferable to minimize V, given its low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Color with field2 X, whenever there is a Cell with field2 X, X is minimized.",
            "NL": "Whenever there is a Color or Cell with field2 X, it is preferable to minimize X with low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Color with field2 X, whenever there is a Cell with field2 X, X is minimized.",
            "NL": "It is preferable that X be minimized whenever there is a Color or a Cell with field2 X, and that this be done with low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Color with field2 X, whenever there is a Cell with field2 X, X is minimized.",
            "NL": "It is preferable that X be minimized when there is a Color with field2 X or a Cell with field2 X, given the low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Color with field2 X, whenever there is a Cell with field2 X, X is minimized.",
            "NL": "When possible, it is best to minimize X if there is a Color with field2 X or a Cell with field2 X and the priority is low."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Color with field2 X, whenever there is a Cell with field2 X, X is minimized.",
            "NL": "It is preferable that X is minimized whenever there is a Color or a Cell with field2 X and low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Contrast with key3 D, with value5 L, with edge9 M, with value G, whenever there is a Walk with node1 H, H is minimized. ",
            "NL": "Whenever there is a contrast between key3 D, value5 L, edge9 M, and value G, the Walk with node1 H should be minimized as a lower priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Contrast with key3 D, with value5 L, with edge9 M, with value G, whenever there is a Walk with node1 H, H is minimized. ",
            "NL": "Whenever there is a Contrast between key3 D, value5 L, edge9 M, and value G, the Walk with node1 H should be kept to a minimum as a lower priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Contrast with key3 D, with value5 L, with edge9 M, with value G, whenever there is a Walk with node1 H, H is minimized. ",
            "NL": "When there is a Contrast between key3 D, value5 L, edge9 M, and value G, the Walk with node1 H should be minimized, though it is not of utmost importance."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Contrast with key3 D, with value5 L, with edge9 M, with value G, whenever there is a Walk with node1 H, H is minimized. ",
            "NL": "Whenever there is a contrast between key3D, value5L, edge9M, and valueG, the walk with node1H should be minimized as much as possible."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Contrast with key3 D, with value5 L, with edge9 M, with value G, whenever there is a Walk with node1 H, H is minimized. ",
            "NL": "Whenever there is a Contrast between key3 D, value5 L, edge9 M, value G, and a Walk with node1 H, the Walk should be minimized as a lower priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Controlling with id1 F, whenever there is a Trail with id1 F, F is minimized.",
            "NL": "It is preferable to minimize F in both a Controlling with id1 F and a Trail with id1 F, given the low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Controlling with id1 F, whenever there is a Trail with id1 F, F is minimized.",
            "NL": "Whenever there is a Controlling with id1 F or a Trail with id1 F, it is preferable to minimize F, given its low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Controlling with id1 F, whenever there is a Trail with id1 F, F is minimized.",
            "NL": "It is preferable to minimize F when there is a Controlling with id1 F or a Trail with id1 F, and it should be done with low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Controlling with id1 F, whenever there is a Trail with id1 F, F is minimized.",
            "NL": "It is preferable to minimize F when there is a Controlling with id1 F or a Trail with id1 F, and this should be given low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Controlling with id1 F, whenever there is a Trail with id1 F, F is minimized.",
            "NL": "It is preferable to minimize F whenever there is a Controlling with id1 F or a Trail with id1 F, and this should be given low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Couple with node4 Y, with value1 F, with edge3 C, with id5 G, whenever there is an Afterward with field D, D is minimized. ",
            "NL": "Whenever there is an Afterward with field D, it should be given a low priority and minimized whenever there is a Couple between node4 Y, value1 F, edge3 C, and id5 G."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Couple with node4 Y, with value1 F, with edge3 C, with id5 G, whenever there is an Afterward with field D, D is minimized. ",
            "NL": "When there is an Afterward with field D, it should be minimized as a lower priority than the Couple between node4 Y, value1 F, edge3 C, and id5 G."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Couple with node4 Y, with value1 F, with edge3 C, with id5 G, whenever there is an Afterward with field D, D is minimized. ",
            "NL": "When there is an Afterward with field D, it should be minimized as a low priority matter, especially when there is a Couple between node4 Y, value1 F, edge3 C, and id5 G."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Couple with node4 Y, with value1 F, with edge3 C, with id5 G, whenever there is an Afterward with field D, D is minimized. ",
            "NL": "Whenever there is an Afterward with field D, it must be minimized, taking into account the Couple between node4 Y, value1 F, edge3 C, and id5 G as a low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Couple with node4 Y, with value1 F, with edge3 C, with id5 G, whenever there is an Afterward with field D, D is minimized. ",
            "NL": "Whenever there is a Couple between node4 Y, value1 F, edge3 C, id5 G, and an Afterward with field D, the Afterward should be given minimal priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a crossing with id1 N1, with id2 N2, with id3 N3, with id4 N4, whenever there is a weight with value V, V is minimized.",
            "NL": "Whenever there is a crossing between id1 N1, id2 N2, id3 N3, and id4 N4, minimizing the weight with value V should be given low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a crossing with id1 N1, with id2 N2, with id3 N3, with id4 N4, whenever there is a weight with value V, V is minimized.",
            "NL": "Whenever there is a crossing between id1 N1, id2 N2, id3 N3, and id4 N4, minimizing the weight with value V should be given a low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a crossing with id1 N1, with id2 N2, with id3 N3, with id4 N4, whenever there is a weight with value V, V is minimized.",
            "NL": "If there is a weight of value V when crossing between id1 N1, id2 N2, id3 N3, and id4 N4, it is of low priority to minimize the weight."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a crossing with id1 N1, with id2 N2, with id3 N3, with id4 N4, whenever there is a weight with value V, V is minimized.",
            "NL": "When crossing between id1 N1, id2 N2, id3 N3, and id4 N4, minimizing the weight with value V should be given a low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a crossing with id1 N1, with id2 N2, with id3 N3, with id4 N4, whenever there is a weight with value V, V is minimized.",
            "NL": "Whenever there is a crossing between id1 N1, id2 N2, id3 N3, and id4 N4, minimizing the weight with value V should be of low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a diffpen with value P2, with id X, whenever there is a nextpen with field1 P1, with field2 P2, with field3 X, whenever there is a weight with value V, V is minimized.",
            "NL": "Whenever there is a diffpen with value P2 and id X, a nextpen with field1 P1, field2 P2, and field3 X, and a weight with value V, it is preferable to minimize V, though it is not a priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a diffpen with value P2, with id X, whenever there is a nextpen with field1 P1, with field2 P2, with field3 X, whenever there is a weight with value V, V is minimized.",
            "NL": "Whenever there is a diffpen with value P2 and ID X, a nextpen with field1 P1, field2 P2, and field3 X, and a weight with value V, it is preferred to minimize V, though it is of low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a diffpen with value P2, with id X, whenever there is a nextpen with field1 P1, with field2 P2, with field3 X, whenever there is a weight with value V, V is minimized.",
            "NL": "Whenever there is a diffpen with value P2 and id X, and a nextpen with field1 P1, field2 P2, and field3 X, it is preferred that the value V of the weight be minimized, though this is of low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a diffpen with value P2, with id X, whenever there is a nextpen with field1 P1, with field2 P2, with field3 X, whenever there is a weight with value V, V is minimized.",
            "NL": "When there is a diffpen with value P2 and id X, and there is a nextpen with field1 P1, field2 P2, and field3 X, the preference is to minimize the weight value V, although it is of low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a diffpen with value P2, with id X, whenever there is a nextpen with field1 P1, with field2 P2, with field3 X, whenever there is a weight with value V, V is minimized.",
            "NL": "Whenever there is a diffpen with value P2 and id X, a nextpen with field1 P1, field2 P2 and field3 X, and a weight with value V, it is preferable to minimize V, albeit with a low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Distinct with node2 S, with node2 H, whenever there is a Maximum with node2 R, R is minimized.",
            "NL": "When there is a Distinct with node2 S and node2 H, it is preferable to minimize node2 R with a low priority, as there is a Maximum with node2 R."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Distinct with node2 S, with node2 H, whenever there is a Maximum with node2 R, R is minimized.",
            "NL": "When there is a Distinct between node2 S and node2 H, it is preferable to minimize node2 R with low priority, as it has a Maximum value."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Distinct with node2 S, with node2 H, whenever there is a Maximum with node2 R, R is minimized.",
            "NL": "When there is a distinct node2 S with node2 H, it is preferable to minimize node2 R with low priority, as it has a maximum value."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Distinct with node2 S, with node2 H, whenever there is a Maximum with node2 R, R is minimized.",
            "NL": "When there is a distinct node2 S and node2 H, it is preferable to minimize node2 R with low priority, and to maximize it with high priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Distinct with node2 S, with node2 H, whenever there is a Maximum with node2 R, R is minimized.",
            "NL": "When there is a distinct with node2 S and node2 H, it is preferable to minimize node2 R with low priority, as there is a maximum with node2 R."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Edge_Tag with vtx X, with key A, with value2 S, with value8 M, whenever there is a Related with node6 V, V is minimized. ",
            "NL": "When there is an Edge_Tag between vtx X, key A, value2 S, and value8 M, the Related with node6 V must be minimized as a low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Edge_Tag with vtx X, with key A, with value2 S, with value8 M, whenever there is a Related with node6 V, V is minimized. ",
            "NL": "Whenever there is an Edge_Tag between vtx X, key A, value2 S, value8 M, and a Related with node6 V, the Related should be minimized as a lower priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Edge_Tag with vtx X, with key A, with value2 S, with value8 M, whenever there is a Related with node6 V, V is minimized. ",
            "NL": "Whenever there is an Edge_Tag between vtx X, key A, value2 S, value8 M, and a Related with node6 V, the Related must be minimized as a low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Edge_Tag with vtx X, with key A, with value2 S, with value8 M, whenever there is a Related with node6 V, V is minimized. ",
            "NL": "Whenever there is an Edge_Tag between vtx X, key A, value2 S, value8 M, and a Related with node6 V, the Related should be minimized as a lesser priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Edge_Tag with vtx X, with key A, with value2 S, with value8 M, whenever there is a Related with node6 V, V is minimized. ",
            "NL": "Whenever there is an Edge_Tag between vertex X, key A, value2 S, and value8 M, the Related with node6 V should be minimized as a lower priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Fine with key E, with edge9 M, whenever there is a Pairing with key D, with edge9 M, whenever there is a Maximum_Flow with key D, with edge9 J, whenever there is a weight with key D, D is minimized.",
            "NL": "Whenever there is a Fine with key E, with edge9 M, it is preferred (but given low priority) that there is a Pairing with key D, with edge9 M, a Maximum_Flow with key D, with edge9 J, and that the weight with key D is minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Fine with key E, with edge9 M, whenever there is a Pairing with key D, with edge9 M, whenever there is a Maximum_Flow with key D, with edge9 J, whenever there is a weight with key D, D is minimized.",
            "NL": "Whenever there is a Fine with key E and edge9 M, it is preferred, although not of utmost importance, that there be a Pairing with key D and edge9 M, a Maximum_Flow with key D and edge9 J, and that the weight with key D be minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Fine with key E, with edge9 M, whenever there is a Pairing with key D, with edge9 M, whenever there is a Maximum_Flow with key D, with edge9 J, whenever there is a weight with key D, D is minimized.",
            "NL": "Whenever there is a Fine with key E and edge9 M, there should be a Pairing with key D and edge9 M, a Maximum_Flow with key D and edge9 J, and D should be minimized if there is a weight with key D, though this is of low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Fine with key E, with edge9 M, whenever there is a Pairing with key D, with edge9 M, whenever there is a Maximum_Flow with key D, with edge9 J, whenever there is a weight with key D, D is minimized.",
            "NL": "Whenever there is a Fine with key E, edge9 M, the preference (although of low priority) is that there be a Pairing with key D, edge9 M, a Maximum_Flow with key D, edge9 J, and that the weight with key D be minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Fine with key E, with edge9 M, whenever there is a Pairing with key D, with edge9 M, whenever there is a Maximum_Flow with key D, with edge9 J, whenever there is a weight with key D, D is minimized.",
            "NL": "Whenever there is a Fine with key E and edge9 M, a Pairing with key D and edge9 M, and a Maximum_Flow with key D and edge9 J, there is a preference, albeit of low priority, to minimize the weight with key D."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Has with edge T, with value2 Q, whenever there is a Achieved with edge O, with value2 Q, whenever there is a Trivial with edge O, with value2 Z, whenever there is a weight with edge O, O is minimized.",
            "NL": "Whenever there is a Has with edge T, and its value2 is Q, an Achieved with edge O and value2 Q is preferred with low priority, while a Trivial with edge O and value2 Z is necessary. Additionally, the weight with edge O should be minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Has with edge T, with value2 Q, whenever there is a Achieved with edge O, with value2 Q, whenever there is a Trivial with edge O, with value2 Z, whenever there is a weight with edge O, O is minimized.",
            "NL": "Whenever there is a Has with edge T and value2 Q, an Achieved with edge O and value2 Q, and a Trivial with edge O and value2 Z should be present, and the weight with edge O should be minimized with low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Has with edge T, with value2 Q, whenever there is a Achieved with edge O, with value2 Q, whenever there is a Trivial with edge O, with value2 Z, whenever there is a weight with edge O, O is minimized.",
            "NL": "Whenever there is a Has with edge T, with value2 Q, it is preferred (albeit with low priority) that an Achieved with edge O, with value2 Q, and a Trivial with edge O, with value2 Z, be present, and that the weight with edge O be minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Has with edge T, with value2 Q, whenever there is a Achieved with edge O, with value2 Q, whenever there is a Trivial with edge O, with value2 Z, whenever there is a weight with edge O, O is minimized.",
            "NL": "Whenever there is a Has with edge T, possessing a value2 of Q, it is preferred (although not necessarily mandatory) that an Achieved with edge O, also having a value2 of Q, be present, and a Trivial with edge O and value2 of Z should be present. Additionally, when there is a weight with edge O, minimizing O is preferred."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Has with edge T, with value2 Q, whenever there is a Achieved with edge O, with value2 Q, whenever there is a Trivial with edge O, with value2 Z, whenever there is a weight with edge O, O is minimized.",
            "NL": "Whenever there is a Has with edge T, and its value2 is Q, there should be an Achieved with edge O, also with value2 Q, a Trivial with edge O and value2 Z, and the weight with edge O should be minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Has with id6 B, whenever there is a Foremost with id6 B, B is minimized.",
            "NL": "If possible, it is best to minimize B whenever there is either a Has with id6 B or a Foremost with id6 B, and this should be done with low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Has with id6 B, whenever there is a Foremost with id6 B, B is minimized.",
            "NL": "Whenever there is a Has with id6 B or a Foremost with id6 B, it is preferable to minimize B with low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Has with id6 B, whenever there is a Foremost with id6 B, B is minimized.",
            "NL": "It is preferable to minimize B whenever there is a Has with ID6 B or a Foremost with ID6 B, given low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Has with id6 B, whenever there is a Foremost with id6 B, B is minimized.",
            "NL": "When id6 B is present, it is best to minimize B whenever possible, regardless of the priority level."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Has with id6 B, whenever there is a Foremost with id6 B, B is minimized.",
            "NL": "Whenever there is a Has with id6 B and a Foremost with id6 B, it is preferable to minimize B with low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Important with key6 T, with vtx6 D, whenever there is a Longest_Path with key6 F, with vtx6 D, whenever there is a Sublist with key6 F, with vtx6 R, whenever there is a weight with key6 F, F is minimized.",
            "NL": "Low priority is given to the preference that, whenever there is an Important with key6 T and vtx6 D, the corresponding Longest_Path should have key6 F and vtx6 D, and the Sublist should have key6 F and vtx6 R; additionally, whenever there is a weight with key6 F, its value should be minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Important with key6 T, with vtx6 D, whenever there is a Longest_Path with key6 F, with vtx6 D, whenever there is a Sublist with key6 F, with vtx6 R, whenever there is a weight with key6 F, F is minimized.",
            "NL": "Whenever there is an Important with key6 T and vtx6 D, a Longest_Path with key6 F and vtx6 D, and a Sublist with key6 F and vtx6 R, preference is given to minimizing the weight with key6 F, although it is of low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Important with key6 T, with vtx6 D, whenever there is a Longest_Path with key6 F, with vtx6 D, whenever there is a Sublist with key6 F, with vtx6 R, whenever there is a weight with key6 F, F is minimized.",
            "NL": "Whenever there is an Important with key6 T and vtx6 D, a Longest_Path with key6 F and vtx6 D should be given low priority, and a Sublist with key6 F and vtx6 R should be given preference. Furthermore, if there is a weight with key6 F, F should be minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Important with key6 T, with vtx6 D, whenever there is a Longest_Path with key6 F, with vtx6 D, whenever there is a Sublist with key6 F, with vtx6 R, whenever there is a weight with key6 F, F is minimized.",
            "NL": "Whenever there is an Important with key6 T and vtx6 D, Longest_Path with key6 F and vtx6 D, or a Sublist with key6 F and vtx6 R, there is a preference with low priority for minimizing the weight with key6 F."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Important with key6 T, with vtx6 D, whenever there is a Longest_Path with key6 F, with vtx6 D, whenever there is a Sublist with key6 F, with vtx6 R, whenever there is a weight with key6 F, F is minimized.",
            "NL": "Whenever there is an Important with key6 T and vtx6 D, the preference is to have a Longest_Path with key6 F and vtx6 D; for a Sublist with key6 F and vtx6 R, the priority is low; and when there is a weight with key6 F, the goal is to minimize F."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Initiate with value2 J, with node8 Y, with vtx5 D, with field5 A, whenever there is a Clue with vtx7 N, N is minimized. ",
            "NL": "Whenever there is an Initiate between value2 J, node8 Y, vtx5 D, and field5 A, the Clue with vtx7 N must be minimized, taking low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Initiate with value2 J, with node8 Y, with vtx5 D, with field5 A, whenever there is a Clue with vtx7 N, N is minimized. ",
            "NL": "The Clue with vtx7 N must be minimized, but this is of low priority in comparison to the Initiate between value2 J, node8 Y, vtx5 D, and field5 A."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Initiate with value2 J, with node8 Y, with vtx5 D, with field5 A, whenever there is a Clue with vtx7 N, N is minimized. ",
            "NL": "Whenever there is an Initiate between value2 J, node8 Y, vtx5 D, and field5 A, the Clue with vtx7 N must be minimized as a low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Initiate with value2 J, with node8 Y, with vtx5 D, with field5 A, whenever there is a Clue with vtx7 N, N is minimized. ",
            "NL": "Whenever there is an Initiate between value2 J, node8 Y, vtx5 D, and field5 A, and a Clue with vtx7 N is present, the Clue should be given a low priority and minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Initiate with value2 J, with node8 Y, with vtx5 D, with field5 A, whenever there is a Clue with vtx7 N, N is minimized. ",
            "NL": "The Clue with vtx7 N must be minimized when there is an Initiate between value2 J, node8 Y, vtx5 D, and field5 A, as a low priority task."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a LessThanExists with second point Q, whenever there is a Outpath with vtx9 R, R is minimized.",
            "NL": "Whenever there is a LessThanExists with second point Q and an Outpath with vtx9 R, it is preferable to minimize R, taking into account its low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a LessThanExists with second point Q, whenever there is a Outpath with vtx9 R, R is minimized.",
            "NL": "Whenever there is a LessThanExists with second point Q and an Outpath with vtx9 R, it is preferable to minimize R with low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a LessThanExists with second point Q, whenever there is a Outpath with vtx9 R, R is minimized.",
            "NL": "It is preferred that R be minimized when there is a LessThanExists with second point Q and an Outpath with vtx9 R, given the low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a LessThanExists with second point Q, whenever there is a Outpath with vtx9 R, R is minimized.",
            "NL": "Whenever there is a LessThanExists with second point Q and an Outpath with vtx9 R, it is preferable that R be minimized, taking into account its low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a LessThanExists with second point Q, whenever there is a Outpath with vtx9 R, R is minimized.",
            "NL": "It is preferable to minimize R whenever there is an Outpath with vtx9 R and a LessThanExists with second point Q, and this should be done with low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Link_Label with edge A, with id7 F, whenever there is a Inbound with id8 T, with field A, with edge9 F, whenever there is a weight with value Z, Z is minimized.",
            "NL": "When Link_Label with edge A and id7 F, Inbound with id8 T and field A, and weight with value Z are present, it is preferred that Z be minimized with low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Link_Label with edge A, with id7 F, whenever there is a Inbound with id8 T, with field A, with edge9 F, whenever there is a weight with value Z, Z is minimized.",
            "NL": "Whenever there is a Link_Label with edge A and id7 F, an Inbound with id8 T and field A, and a weight with value Z, it is preferred that Z be minimized with low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Link_Label with edge A, with id7 F, whenever there is a Inbound with id8 T, with field A, with edge9 F, whenever there is a weight with value Z, Z is minimized.",
            "NL": "Whenever there is a Link_Label with edge A and id7 F, an Inbound with id8 T and field A, and a weight with value Z, it is preferred that Z be minimized with a low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Link_Label with edge A, with id7 F, whenever there is a Inbound with id8 T, with field A, with edge9 F, whenever there is a weight with value Z, Z is minimized.",
            "NL": "Whenever there is a Link_Label with edge A and id7 F, an Inbound with id8 T and field A, and a weight with value Z, it is preferable to minimize Z with low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Link_Label with edge A, with id7 F, whenever there is a Inbound with id8 T, with field A, with edge9 F, whenever there is a weight with value Z, Z is minimized.",
            "NL": "Whenever there is a Link_Label with edge A and id7 F, an Inbound with id8 T and field A, and a weight with value Z, the preference is to minimize Z with low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a member with value A, with id L, whenever there is a asgn with value X, with id L, whenever there is a next with value X, with id A, whenever there is a weight with value X, X is minimized.",
            "NL": "Whenever there is a member with value A and ID L, an assignment with value X and ID L, and a next with value X and ID A, preference is given to minimizing the weight with value X."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a member with value A, with id L, whenever there is a asgn with value X, with id L, whenever there is a next with value X, with id A, whenever there is a weight with value X, X is minimized.",
            "NL": "Whenever there is a member with value A and id L, an asgn with value X and id L, and a next with value X and id A, there is a low priority preference for minimizing the weight value X."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a member with value A, with id L, whenever there is a asgn with value X, with id L, whenever there is a next with value X, with id A, whenever there is a weight with value X, X is minimized.",
            "NL": "Whenever there is a member with a value of A and an ID of L, the associated value of X should also be present with the same ID of L, and the next value of X should have an ID of A. Additionally, if there is a weight with a value of X, it should be minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a member with value A, with id L, whenever there is a asgn with value X, with id L, whenever there is a next with value X, with id A, whenever there is a weight with value X, X is minimized.",
            "NL": "Whenever there is a member with value A, and its id is L, there should be an asgn with value X, also with id L, followed by a next with value X, and its id should be A. Additionally, if there is a weight with value X, it should be minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a member with value A, with id L, whenever there is a asgn with value X, with id L, whenever there is a next with value X, with id A, whenever there is a weight with value X, X is minimized.",
            "NL": "Whenever there is a member with value A and id L, there should be an assignment with value X and id L, followed by a next with value X and id A. Additionally, the weight with value X should be minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Minor with node5 J, with edge1 B, whenever there is a Incoming_Level with node5 E, with edge1 B, whenever there is a Caught with node5 E, with edge1 C, whenever there is a weight with node5 E, E is minimized.",
            "NL": "It is preferred, albeit not a priority, that when Minor is present with node5 J and edge1 B, Incoming_Level is present with node5 E and edge1 B; Caught is present with node5 E and edge1 C; and when there is a weight with node5 E, it is minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Minor with node5 J, with edge1 B, whenever there is a Incoming_Level with node5 E, with edge1 B, whenever there is a Caught with node5 E, with edge1 C, whenever there is a weight with node5 E, E is minimized.",
            "NL": "Whenever a Minor with node5 J and edge1 B is present, an Incoming_Level with node5 E and edge1 B should be given low priority, and when there is a Caught with node5 E and edge1 C, the weight of node5 E should be minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Minor with node5 J, with edge1 B, whenever there is a Incoming_Level with node5 E, with edge1 B, whenever there is a Caught with node5 E, with edge1 C, whenever there is a weight with node5 E, E is minimized.",
            "NL": "Whenever there is a Minor with node5 J, with edge1 B, there is an Incoming_Level with node5 E, with edge1 B, and a Caught with node5 E, with edge1 C; it is preferred, though of low priority, that the weight of node5 E is minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Minor with node5 J, with edge1 B, whenever there is a Incoming_Level with node5 E, with edge1 B, whenever there is a Caught with node5 E, with edge1 C, whenever there is a weight with node5 E, E is minimized.",
            "NL": "Whenever there is a Minor with node5 J and edge1 B, an Incoming_Level with node5 E and edge1 B, and a Caught with node5 E and edge1 C, the preference is to minimize E when there is a weight with node5 E, although it is of low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Minor with node5 J, with edge1 B, whenever there is a Incoming_Level with node5 E, with edge1 B, whenever there is a Caught with node5 E, with edge1 C, whenever there is a weight with node5 E, E is minimized.",
            "NL": "Whenever there is a Minor with node5 J, edge1 B, an Incoming_Level with node5 E, edge1 B, and a Caught with node5 E, edge1 C, there is a preference to minimize the weight of node5 E with low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a minpen with value P, with id X, whenever there is a weight with value V, V is minimized. ",
            "NL": "When there is a minimum penalty with a value of P and an ID of X, it is best to minimize the weight value V, though it is of low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a minpen with value P, with id X, whenever there is a weight with value V, V is minimized. ",
            "NL": "When there is a minimum penalty with value P and ID X, it is preferable to minimize the weight value V, but with low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a minpen with value P, with id X, whenever there is a weight with value V, V is minimized. ",
            "NL": "When there is a minimum penalty with value P and ID X, it is desirable to minimize the associated weight value V, although this is of low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a minpen with value P, with id X, whenever there is a weight with value V, V is minimized. ",
            "NL": "When there is a minimum penalty with value P and ID X, it is preferable to have a weight with value V that is minimized, while keeping it at a low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a minpen with value P, with id X, whenever there is a weight with value V, V is minimized. ",
            "NL": "When there is a minimum penalty with value P and ID X, it is preferable to minimize the associated weight value V, though it is of low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a nonclique with first node X, whenever there is a weight with value V, V is minimized.",
            "NL": "Whenever there is a nonclique with first node X and a weight with value V, it is preferable to minimize V as much as possible with low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a nonclique with first node X, whenever there is a weight with value V, V is minimized.",
            "NL": "When there is a nonclique with first node X and a weight with value V, it is preferable to minimize V with low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a nonclique with first node X, whenever there is a weight with value V, V is minimized.",
            "NL": "It is preferable to minimize the weight value V when there is a nonclique with first node X and low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a nonclique with first node X, whenever there is a weight with value V, V is minimized.",
            "NL": "Whenever there is a nonclique with the first node X and a weight of value V, it is best to minimize V with low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a nonclique with first node X, whenever there is a weight with value V, V is minimized.",
            "NL": "Whenever X is the first node in a nonclique, it is preferable for the weight value V to be minimized, given its low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Parent_Edge with value10 L, L is minimized.",
            "NL": "It is preferred that if a Parent_Edge has a value of 10L, it should be minimized with the lowest priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Parent_Edge with value10 L, L is minimized.",
            "NL": "It is preferable to minimize any Parent_Edge with value 10L with the lowest priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Parent_Edge with value10 L, L is minimized.",
            "NL": "It is preferred that when a Parent_Edge has a value of 10 L, it should be minimized with the lowest priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Parent_Edge with value10 L, L is minimized.",
            "NL": "It is preferred that when there is a Parent_Edge with a value of 10 L, it should be minimized with the lowest priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Parent_Edge with value10 L, L is minimized.",
            "NL": "It is preferred that when there is a Parent_Edge with a value of 10L, it should be minimized with the lowest priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Periphery with key4 E, whenever there is a Bucket with key4 E, E is minimized.",
            "NL": "It is best to minimize E when there is a Periphery or Bucket with key4 E, and the priority should be low."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Periphery with key4 E, whenever there is a Bucket with key4 E, E is minimized.",
            "NL": "Whenever there is a Periphery or Bucket with key4 E, it is best to minimize E with a low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Periphery with key4 E, whenever there is a Bucket with key4 E, E is minimized.",
            "NL": "It is preferable to minimize E whenever there is a Periphery or Bucket with key4 E and the priority is low."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Periphery with key4 E, whenever there is a Bucket with key4 E, E is minimized.",
            "NL": "It is best to minimize E when there is a Periphery or Bucket with key4 E given the low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Periphery with key4 E, whenever there is a Bucket with key4 E, E is minimized.",
            "NL": "It is preferable to minimize E when there is a Periphery or Bucket with key4 E and low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Pigmented with edge6 I, with node3 O, with node1 R, with field5 F, whenever there is a Perfect_Graph with key U, U is minimized. ",
            "NL": "Whenever there is a Perfect_Graph with key U, it must be minimized, as a matter of low priority, when there is a Pigmented between edge6 I, node3 O, node1 R, and field5 F."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Pigmented with edge6 I, with node3 O, with node1 R, with field5 F, whenever there is a Perfect_Graph with key U, U is minimized. ",
            "NL": "Whenever there is a Pigmented between edge6 I, node3 O, node1 R, field5 F, and a Perfect_Graph with key U is present, it is of low priority to minimize the Perfect_Graph."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Pigmented with edge6 I, with node3 O, with node1 R, with field5 F, whenever there is a Perfect_Graph with key U, U is minimized. ",
            "NL": "Whenever there is a Perfect_Graph with key U between edge6 I, node3 O, node1 R, and field5 F, it is of low priority to minimize the Perfect_Graph."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Pigmented with edge6 I, with node3 O, with node1 R, with field5 F, whenever there is a Perfect_Graph with key U, U is minimized. ",
            "NL": "Whenever there is a Pigmented between edge6 I, node3 O, node1 R, field5 F and a Perfect_Graph with key U, minimizing the Perfect_Graph should be given low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Pigmented with edge6 I, with node3 O, with node1 R, with field5 F, whenever there is a Perfect_Graph with key U, U is minimized. ",
            "NL": "Whenever there is a Perfect_Graph with key U, it is a low priority to minimize the Perfect_Graph between edge6 I, node3 O, node1 R, and field5 F."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Planar_Embedding with value N, whenever there is a Subsequent with value N, N is minimized.",
            "NL": "Whenever possible, it is best to reduce the value of N if both Planar_Embedding and Subsequent have a value of N."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Planar_Embedding with value N, whenever there is a Subsequent with value N, N is minimized.",
            "NL": "It is preferable to minimize N whenever there is a Planar_Embedding and Subsequent with the same value of N, and this should be done with low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Planar_Embedding with value N, whenever there is a Subsequent with value N, N is minimized.",
            "NL": "Whenever there is a Planar_Embedding and Subsequent with the same value of N, it is preferred that this value be minimized with low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Planar_Embedding with value N, whenever there is a Subsequent with value N, N is minimized.",
            "NL": "It is preferable to minimize N whenever there is a Planar_Embedding and a Subsequent with the same value N, given the low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Planar_Embedding with value N, whenever there is a Subsequent with value N, N is minimized.",
            "NL": "Whenever there is a Planar Embedding with value N and a Subsequent with value N, it is preferable to minimize N with low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Planar_Graph with value1 T, with value9 S, whenever there is a Pairing with value8 O, with key3 T, with vtx9 S, whenever there is a weight with value I, I is minimized.",
            "NL": "Whenever there is a Planar_Graph with value1 T and value9 S, a Pairing with value8 O, key3 T, and vtx9 S, and a weight with value I, it is preferred that I be minimized, though with a low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Planar_Graph with value1 T, with value9 S, whenever there is a Pairing with value8 O, with key3 T, with vtx9 S, whenever there is a weight with value I, I is minimized.",
            "NL": "It is preferred, though not a priority, that for a Planar_Graph with value1 T, value9 S, for a Pairing with value8 O, key3 T, vtx9 S, and for a weight with value I, I is minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Planar_Graph with value1 T, with value9 S, whenever there is a Pairing with value8 O, with key3 T, with vtx9 S, whenever there is a weight with value I, I is minimized.",
            "NL": "Whenever a Planar_Graph with value1 T and value9 S, a Pairing with value8 O, key3 T and vtx9 S, and a weight with value I are present, it is preferable to minimize I, although this is of low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Planar_Graph with value1 T, with value9 S, whenever there is a Pairing with value8 O, with key3 T, with vtx9 S, whenever there is a weight with value I, I is minimized.",
            "NL": "Whenever there is a Planar_Graph with value1 T and value9 S, a Pairing with value8 O, key3 T, and vtx9 S, and a weight with value I, the preference is to minimize I with low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Planar_Graph with value1 T, with value9 S, whenever there is a Pairing with value8 O, with key3 T, with vtx9 S, whenever there is a weight with value I, I is minimized.",
            "NL": "Whenever there is a Planar_Graph with value1 T and value9 S, a Pairing with value8 O, key3 T, and vtx9 S, and a weight with value I, it is preferred to minimize I, although it is of low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Related with value4 T, with node9 P, whenever there is a Hamgraph with value4 W, with node9 P, whenever there is a Marker with value4 W, with node9 K, whenever there is a weight with value4 W, W is minimized.",
            "NL": "Whenever there is a Related with value4 T, with node9 P, a Hamgraph with value4 W, with node9 P, and a Marker with value4 W, with node9 K, it is preferred, though not mandatory, that the weight with value4 W be minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Related with value4 T, with node9 P, whenever there is a Hamgraph with value4 W, with node9 P, whenever there is a Marker with value4 W, with node9 K, whenever there is a weight with value4 W, W is minimized.",
            "NL": "Whenever there is a Related with a value4 of T and a node9 of P, a Hamgraph with a value4 of W and a node9 of P should be given low priority, and a Marker with a value4 of W and a node9 of K should be present. Furthermore, whenever there is a weight with a value4 of W, it should be minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Related with value4 T, with node9 P, whenever there is a Hamgraph with value4 W, with node9 P, whenever there is a Marker with value4 W, with node9 K, whenever there is a weight with value4 W, W is minimized.",
            "NL": "Whenever there is a Related with value4 T and node9 P, a Hamgraph with value4 W and node9 P, and a Marker with value4 W and node9 K, it is preferred to minimize the weight with value4 W, though it is of low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Related with value4 T, with node9 P, whenever there is a Hamgraph with value4 W, with node9 P, whenever there is a Marker with value4 W, with node9 K, whenever there is a weight with value4 W, W is minimized.",
            "NL": "Whenever there is a Related with value4 T and node9 P, a Hamgraph with value4 W and node9 P, and a Marker with value4 W and node9 K, it is preferred to minimize the weight with value4 W, although this is of low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Related with value4 T, with node9 P, whenever there is a Hamgraph with value4 W, with node9 P, whenever there is a Marker with value4 W, with node9 K, whenever there is a weight with value4 W, W is minimized.",
            "NL": "Whenever there is a Related with value4 T and node9 P, a Hamgraph with value4 W and node9 P, and a Marker with value4 W and node9 K, it is preferred that the weight with value4 W be minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Sanction with id3 J, whenever there is a Cycle_Basis with id3 J, J is minimized.",
            "NL": "It is preferable to minimize J whenever there is a Sanction with id3 J or a Cycle_Basis with id3 J and the priority is low."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Sanction with id3 J, whenever there is a Cycle_Basis with id3 J, J is minimized.",
            "NL": "It is preferable to minimize J when there is a Sanction with id3 J or a Cycle_Basis with id3 J, and this should be done with low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Sanction with id3 J, whenever there is a Cycle_Basis with id3 J, J is minimized.",
            "NL": "It is preferable to minimize J when there is a Sanction with id3 J and a Cycle_Basis with id3 J, and this should be done with low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Sanction with id3 J, whenever there is a Cycle_Basis with id3 J, J is minimized.",
            "NL": "It is preferable that J is minimized whenever there is a Sanction with id3 J or a Cycle_Basis with id3 J, and this should be given low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Sanction with id3 J, whenever there is a Cycle_Basis with id3 J, J is minimized.",
            "NL": "It is preferable to minimize J whenever there is a Sanction with id3 J or a Cycle_Basis with id3 J, and this should be done with low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Significant with node7 S, with node7 M, whenever there is a NonSubsequent with node7 S, whenever there is not a Afterward with node7 S, whenever there is a weight with node7 M, M is minimized.",
            "NL": "Whenever node7 S has Significant, NonSubsequent, or no Afterward, the minimization of node7 M with low priority is preferred."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Significant with node7 S, with node7 M, whenever there is a NonSubsequent with node7 S, whenever there is not a Afterward with node7 S, whenever there is a weight with node7 M, M is minimized.",
            "NL": "Whenever there is a Significant, NonSubsequent, or Afterward with node7 S, the minimization of node7 M should be given low priority. Whenever there is a weight with node7 M, it should be taken into consideration."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Significant with node7 S, with node7 M, whenever there is a NonSubsequent with node7 S, whenever there is not a Afterward with node7 S, whenever there is a weight with node7 M, M is minimized.",
            "NL": "Whenever there is a Significant, NonSubsequent, or no Afterward with node7 S, the minimizing of node7 M should be given low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Significant with node7 S, with node7 M, whenever there is a NonSubsequent with node7 S, whenever there is not a Afterward with node7 S, whenever there is a weight with node7 M, M is minimized.",
            "NL": "Whenever there is a Significant, NonSubsequent, or Afterward with node7 S, the minimization of node7 M should be given low priority; however, if there is a weight with node7 M, this should be taken into consideration."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Significant with node7 S, with node7 M, whenever there is a NonSubsequent with node7 S, whenever there is not a Afterward with node7 S, whenever there is a weight with node7 M, M is minimized.",
            "NL": "Whenever there is a Significant node7 S, NonSubsequent node7 S, or no Afterward node7 S, minimizing node7 M should be given low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Subgraph with vtx4 I, I is minimized.",
            "NL": "It is preferred that Subgraph with vtx4 I be minimized with the lowest priority whenever possible."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Subgraph with vtx4 I, I is minimized.",
            "NL": "It is preferred that Subgraphs with vtx4 I be minimized with the lowest priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Subgraph with vtx4 I, I is minimized.",
            "NL": "It is preferred that Subgraph containing vertex 4 be minimized with the least priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Subgraph with vtx4 I, I is minimized.",
            "NL": "It is preferred that Subgraph with vtx4 I should be minimized with the least priority if present."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Subgraph with vtx4 I, I is minimized.",
            "NL": "It is preferred that Subgraph with vtx4 I be minimized with the lowest priority whenever it is present."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Subposition with id5 R, whenever there is a Network with id5 R, R is minimized.",
            "NL": "Whenever there is a Subposition with id5 R or a Network with id5 R, it is preferable to minimize R with low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Subposition with id5 R, whenever there is a Network with id5 R, R is minimized.",
            "NL": "Whenever there is a Subposition with id5 R or a Network with id5 R, it is best to reduce R to a minimum with low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Subposition with id5 R, whenever there is a Network with id5 R, R is minimized.",
            "NL": "It is preferable to minimize R whenever there is a Subposition with id5 R or a Network with id5 R, but with low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Subposition with id5 R, whenever there is a Network with id5 R, R is minimized.",
            "NL": "Whenever there is a Subposition with id5 R or a Network with id5 R, it is preferable to minimize R with a low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Subposition with id5 R, whenever there is a Network with id5 R, R is minimized.",
            "NL": "Whenever there is a Subposition or Network with id5 R, it is best to minimize R as much as possible, given its low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Subsequent with value5 W, with vtx6 Y, whenever there is a Unmatched with value5 G, with vtx6 Y, whenever there is a NotFirst with value5 G, with vtx6 V, whenever there is a weight with value5 G, G is minimized.",
            "NL": "Whenever there is a Subsequent with value5 W and vtx6 Y, an Unmatched with value5 G and vtx6 Y, and a NotFirst with value5 G and vtx6 V, it is preferred to minimize the value5 G of the weight."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Subsequent with value5 W, with vtx6 Y, whenever there is a Unmatched with value5 G, with vtx6 Y, whenever there is a NotFirst with value5 G, with vtx6 V, whenever there is a weight with value5 G, G is minimized.",
            "NL": "Whenever there is a Subsequent with value5 W and vtx6 Y, an Unmatched with value5 G and vtx6 Y, and a NotFirst with value5 G and vtx6 V, it is preferred (though not mandatory) that the weight value5 G is minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Subsequent with value5 W, with vtx6 Y, whenever there is a Unmatched with value5 G, with vtx6 Y, whenever there is a NotFirst with value5 G, with vtx6 V, whenever there is a weight with value5 G, G is minimized.",
            "NL": "Whenever there is a Subsequent with value5 W and vtx6 Y, an Unmatched with value5 G and vtx6 Y, and a NotFirst with value5 G and vtx6 V, preference is given to minimizing the weight value5 G with low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Subsequent with value5 W, with vtx6 Y, whenever there is a Unmatched with value5 G, with vtx6 Y, whenever there is a NotFirst with value5 G, with vtx6 V, whenever there is a weight with value5 G, G is minimized.",
            "NL": "It is preferred with low priority that when there is a Subsequent with value5 W and vtx6 Y, an Unmatched with value5 G and vtx6 Y, and a NotFirst with value5 G and vtx6 V, G is minimized when there is a weight with value5 G."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Subsequent with value5 W, with vtx6 Y, whenever there is a Unmatched with value5 G, with vtx6 Y, whenever there is a NotFirst with value5 G, with vtx6 V, whenever there is a weight with value5 G, G is minimized.",
            "NL": "Whenever there is a Subsequent with value5 W and vtx6 Y, an Unmatched with value5 G and vtx6 Y, and a NotFirst with value5 G and vtx6 V, there is a low priority preference that G should be minimized when a weight with value5 G is present."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Tone with vtx B, with value7 I, with field1 T, with node2 F, whenever there is a Nonclique with field9 X, X is minimized. ",
            "NL": "Whenever there is a Tone between VTX B, Value7 I, Field1 T, and Node2 F, and a Nonclique with Field9 X is present, it is of low priority to minimize the Nonclique."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Tone with vtx B, with value7 I, with field1 T, with node2 F, whenever there is a Nonclique with field9 X, X is minimized. ",
            "NL": "The Nonclique with field9 X must be minimized as a low priority when there is a Tone between vtx B, value7 I, field1 T, and node2 F."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Tone with vtx B, with value7 I, with field1 T, with node2 F, whenever there is a Nonclique with field9 X, X is minimized. ",
            "NL": "Whenever there is a Tone between VTX B, Value7 I, Field1 T, and Node2 F, it is of low priority to minimize the Nonclique with Field9 X."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Tone with vtx B, with value7 I, with field1 T, with node2 F, whenever there is a Nonclique with field9 X, X is minimized. ",
            "NL": "Whenever a Tone exists between vtx B, value7 I, field1 T, and node2 F, it is of low priority to minimize any Nonclique involving field9 X."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Tone with vtx B, with value7 I, with field1 T, with node2 F, whenever there is a Nonclique with field9 X, X is minimized. ",
            "NL": "Whenever there is a Tone between VTX B, Value7 I, Field1 T, and Node2 F, and a Nonclique with Field9 X is present, the Nonclique should be given the lowest priority and minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Vertex with id5 S, S is minimized.",
            "NL": "It is preferred that Vertex with id5 S be minimized with the lowest priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Vertex with id5 S, S is minimized.",
            "NL": "It is preferred that Vertex with id5 S is minimized with the lowest priority when present."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Vertex with id5 S, S is minimized.",
            "NL": "It is preferable to prioritize minimizing any Vertex with an id of 5S."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Vertex with id5 S, S is minimized.",
            "NL": "It is preferred that Vertex with id5 S be minimized with the least priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is a Vertex with id5 S, S is minimized.",
            "NL": "It is preferred that Vertex with id5 S be minimized with the lowest priority whenever it is present."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is an abs with id X, X is minimized.",
            "NL": "It is preferred that when there is an abs with id X, it should be minimized with the least priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is an abs with id X, X is minimized.",
            "NL": "Whenever there is an abs with id X, it should be minimized with the lowest priority as much as possible."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is an abs with id X, X is minimized.",
            "NL": "It is preferred that any abs with id X be minimized with the lowest priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is an abs with id X, X is minimized.",
            "NL": "A preference exists to minimize abs with id X with the lowest priority whenever it is present."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is an abs with id X, X is minimized.",
            "NL": "It is preferred that when there is an abs with id X, it should be minimized with the lowest priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is an Active with node5 Y, with edge4 I, whenever there is a Clique with node7 M, with field8 Y, with edge2 I, whenever there is a weight with value W, W is minimized.",
            "NL": "It is preferred, though not of utmost importance, that W, the weight value, be minimized whenever there is an Active with node5 Y and edge4 I, a Clique with node7 M, field8 Y, and edge2 I."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is an Active with node5 Y, with edge4 I, whenever there is a Clique with node7 M, with field8 Y, with edge2 I, whenever there is a weight with value W, W is minimized.",
            "NL": "It is preferred that W be minimized, with a low priority, when there is an Active with node5 Y and edge4 I, and a Clique with node7 M, field8 Y, and edge2 I."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is an Active with node5 Y, with edge4 I, whenever there is a Clique with node7 M, with field8 Y, with edge2 I, whenever there is a weight with value W, W is minimized.",
            "NL": "It is preferred, although not a top priority, that when an Active is present with node5 Y and edge4 I, and a Clique with node7 M, field8 Y, and edge2 I, the weight value W should be minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is an Active with node5 Y, with edge4 I, whenever there is a Clique with node7 M, with field8 Y, with edge2 I, whenever there is a weight with value W, W is minimized.",
            "NL": "Whenever there is an Active with node5 Y, edge4 I, a Clique with node7 M, field8 Y, and edge2 I, it is preferred that the value of the associated weight W be minimized, though this preference is of low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is an Active with node5 Y, with edge4 I, whenever there is a Clique with node7 M, with field8 Y, with edge2 I, whenever there is a weight with value W, W is minimized.",
            "NL": "Whenever there is an Active with node5 Y and edge4 I, a Clique with node7 M, field8 Y, and edge2 I, and a weight with value W, it is preferred to minimize W with low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is an Attained with vtx5 V, with key L, whenever there is a Breadth with vtx5 M, with key L, whenever there is an Used_Edge with vtx5 M, with key X, whenever there is a weight with vtx5 M, M is minimized.",
            "NL": "Whenever there is an Attained with vtx5 V and key L, a Breadth with vtx5 M and key L, and an Used_Edge with vtx5 M and key X, it is preferred that M be minimized, though not of the highest priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is an Attained with vtx5 V, with key L, whenever there is a Breadth with vtx5 M, with key L, whenever there is an Used_Edge with vtx5 M, with key X, whenever there is a weight with vtx5 M, M is minimized.",
            "NL": "Whenever there is an Attained with vtx5 V and key L, a Breadth with vtx5 M and key L, and an Used_Edge with vtx5 M and key X, there is a preference (although of low priority) to minimize M when there is a weight with vtx5 M."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is an Attained with vtx5 V, with key L, whenever there is a Breadth with vtx5 M, with key L, whenever there is an Used_Edge with vtx5 M, with key X, whenever there is a weight with vtx5 M, M is minimized.",
            "NL": "Whenever there is an Attained with vtx5 V, with key L, a Breadth with vtx5 M, with key L, and an Used_Edge with vtx5 M, with key X, it is preferred to minimize M in the weight with vtx5 M, though this has low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is an Attained with vtx5 V, with key L, whenever there is a Breadth with vtx5 M, with key L, whenever there is an Used_Edge with vtx5 M, with key X, whenever there is a weight with vtx5 M, M is minimized.",
            "NL": "When there is an Attained with vtx5 V, with key L, there is a preference to have a Breadth with vtx5 M, with key L, an Used_Edge with vtx5 M, with key X, and to minimize M when there is a weight with vtx5 M, though it is of low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is an Attained with vtx5 V, with key L, whenever there is a Breadth with vtx5 M, with key L, whenever there is an Used_Edge with vtx5 M, with key X, whenever there is a weight with vtx5 M, M is minimized.",
            "NL": "Whenever there is an Attained with vtx5 V and key L, a Breadth with vtx5 M and key L, and an Used_Edge with vtx5 M and key X, there is a preference to minimize the weight with vtx5 M, though it is given a low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is an Edge with key2 L, with field V, with vtx I, with edge6 P, whenever there is an Idle with field2 C, C is minimized. ",
            "NL": "Whenever there is an Edge between key2 L, field V, vtx I, and edge6 P, and an Idle with field2 C, minimizing the Idle should be a low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is an Edge with key2 L, with field V, with vtx I, with edge6 P, whenever there is an Idle with field2 C, C is minimized. ",
            "NL": "Whenever there is an Edge between key2 L, field V, vtx I, edge6 P, and an Idle with field2 C, the Idle should be minimized as a lower priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is an Edge with key2 L, with field V, with vtx I, with edge6 P, whenever there is an Idle with field2 C, C is minimized. ",
            "NL": "Whenever there is an Edge between key2 L, field V, vtx I, edge6 P, and a corresponding Idle with field2 C, the Idle should be reduced to a minimum."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is an Edge with key2 L, with field V, with vtx I, with edge6 P, whenever there is an Idle with field2 C, C is minimized. ",
            "NL": "When Edge exists between key2 L, field V, vtx I, and edge6 P, it is of low priority to minimize Idle with field2 C."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is an Edge with key2 L, with field V, with vtx I, with edge6 P, whenever there is an Idle with field2 C, C is minimized. ",
            "NL": "Whenever there is an Edge between key2 L, field V, vtx I, and edge6 P, minimizing the Idle with field2 C should be a low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is an In_HamiltonianCycle with field6 S, with edge8 Y, whenever there is a Non_Clique with field6 J, with edge8 Y, whenever there is a Member with field6 J, with edge8 X, whenever there is a weight with field6 J, J is minimized.",
            "NL": "Whenever there is an In_HamiltonianCycle with field6 S, and edge8 Y, a Non_Clique with field6 J, edge8 Y, and a Member with field6 J, edge8 X should be preferred, though it is of low priority, and if there is a weight with field6 J, the J should be minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is an In_HamiltonianCycle with field6 S, with edge8 Y, whenever there is a Non_Clique with field6 J, with edge8 Y, whenever there is a Member with field6 J, with edge8 X, whenever there is a weight with field6 J, J is minimized.",
            "NL": "Whenever an In_HamiltonianCycle is found with field6 S and edge8 Y, a Non_Clique with field6 J and edge8 Y, and a Member with field6 J and edge8 X should be present, and the weight with field6 J should be minimized with low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is an In_HamiltonianCycle with field6 S, with edge8 Y, whenever there is a Non_Clique with field6 J, with edge8 Y, whenever there is a Member with field6 J, with edge8 X, whenever there is a weight with field6 J, J is minimized.",
            "NL": "Whenever there is an In_HamiltonianCycle with field6 S and edge8 Y, a Non_Clique with field6 J and edge8 Y, and a Member with field6 J and edge8 X should be present, and field6 J should be minimized when there is a weight present. This is of low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is an In_HamiltonianCycle with field6 S, with edge8 Y, whenever there is a Non_Clique with field6 J, with edge8 Y, whenever there is a Member with field6 J, with edge8 X, whenever there is a weight with field6 J, J is minimized.",
            "NL": "Whenever there is an In_HamiltonianCycle with field6 S and edge8 Y, a Non_Clique with field6 J and edge8 Y, and a Member with field6 J and edge8 X should be present, and field6 J should be minimized in the case of a weight. This is a low priority preference."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is an In_HamiltonianCycle with field6 S, with edge8 Y, whenever there is a Non_Clique with field6 J, with edge8 Y, whenever there is a Member with field6 J, with edge8 X, whenever there is a weight with field6 J, J is minimized.",
            "NL": "Whenever there is an In_HamiltonianCycle with field6 S and edge8 Y, a Non_Clique with field6 J and edge8 Y, and a Member with field6 J and edge8 X should be given preference with low priority, and if there is a weight with field6 J, the value of J should be minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is an Individual with id L, L is minimized.",
            "NL": "It is preferred that when an individual with id L is present, they should be given the lowest priority and minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is an Individual with id L, L is minimized.",
            "NL": "It is preferred that when there is an Individual with ID L, it should be given the lowest priority for minimizing."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is an Individual with id L, L is minimized.",
            "NL": "It is preferred that if an individual with ID L is present, they should be given the lowest priority for minimizing."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is an Individual with id L, L is minimized.",
            "NL": "It is preferred that when an Individual with id L is present, they should be given the least priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is an Individual with id L, L is minimized.",
            "NL": "It is preferred that when an Individual with id L is present, it should be given the lowest priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is an Out with id10 J, with id10 E, whenever there is a Commence with id10 J, whenever there is not a Inpath with id10 J, whenever there is a weight with id10 E, E is minimized.",
            "NL": "When id10 J is Out, E should be minimized with low priority; when id10 J is Commencing, when there is no Inpath with id10 J, and when there is a weight with id10 E, E should also be minimized with low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is an Out with id10 J, with id10 E, whenever there is a Commence with id10 J, whenever there is not a Inpath with id10 J, whenever there is a weight with id10 E, E is minimized.",
            "NL": "Whenever there is an Out with id10 J, a Commence with id10 J, or no Inpath with id10 J, minimizing E should be the priority with id10 E."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is an Out with id10 J, with id10 E, whenever there is a Commence with id10 J, whenever there is not a Inpath with id10 J, whenever there is a weight with id10 E, E is minimized.",
            "NL": "When there is an Out with id10 J, a Commence with id10 J, no Inpath with id10 J, or a weight with id10 E, then minimizing E should be given low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is an Out with id10 J, with id10 E, whenever there is a Commence with id10 J, whenever there is not a Inpath with id10 J, whenever there is a weight with id10 E, E is minimized.",
            "NL": "Whenever there is an Out with id10 J, a Commence with id10 J, or no Inpath with id10 J, minimizing E should be given low priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is an Out with id10 J, with id10 E, whenever there is a Commence with id10 J, whenever there is not a Inpath with id10 J, whenever there is a weight with id10 E, E is minimized.",
            "NL": "Whenever there is an Out with id10 J, a Commence with id10 J, and no Inpath with id10 J, it is preferred to minimize E with low priority, when there is a weight with id10 E."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is an Unimportant with id4 Y, Y is minimized.",
            "NL": "It is preferred that Unimportant with id4 Y be minimized with the least priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is an Unimportant with id4 Y, Y is minimized.",
            "NL": "It is preferred that Unimportant with id4 Y be given the least amount of priority when minimizing."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is an Unimportant with id4 Y, Y is minimized.",
            "NL": "It is preferred that Unimportant with id4 Y be minimized with the least amount of priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is an Unimportant with id4 Y, Y is minimized.",
            "NL": "It is preferred that whenever Unimportant with id4 Y arises, it should be given the least priority and minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with low priority, that whenever there is an Unimportant with id4 Y, Y is minimized.",
            "NL": "It is preferred that when there is an Unimportant task with ID4 Y, it should be given the lowest priority in terms of its importance."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Allocate with value10 R, with value10 D, whenever there is a Concluding with value10 R, whenever there is not a Edge_Match with value10 R, whenever there is a weight with value10 D, D is minimized.",
            "NL": "It is preferable to minimize D, with medium priority, when there is an Allocation with value 10R, Concluding with value 10R, and no Edge_Match with value 10R, and a weight with value 10D."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Allocate with value10 R, with value10 D, whenever there is a Concluding with value10 R, whenever there is not a Edge_Match with value10 R, whenever there is a weight with value10 D, D is minimized.",
            "NL": "It is preferable to minimize D, with medium priority, when there is an Allocate with a value of 10R, a Conclude with a value of 10R, no Edge_Match with a value of 10R, and a weight with a value of 10D."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Allocate with value10 R, with value10 D, whenever there is a Concluding with value10 R, whenever there is not a Edge_Match with value10 R, whenever there is a weight with value10 D, D is minimized.",
            "NL": "It is preferred to minimize D with medium priority when Allocate has a value of 10R, Conclude has a value of 10R, there is no Edge_Match with a value of 10R, and there is a weight with a value of 10D."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Allocate with value10 R, with value10 D, whenever there is a Concluding with value10 R, whenever there is not a Edge_Match with value10 R, whenever there is a weight with value10 D, D is minimized.",
            "NL": "It is preferable to minimize D, with medium priority, when there is an Allocate with value10 R, Conclude with value10 R, and no Edge_Match with value10 R, and when there is a weight with value10 D."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Allocate with value10 R, with value10 D, whenever there is a Concluding with value10 R, whenever there is not a Edge_Match with value10 R, whenever there is a weight with value10 D, D is minimized.",
            "NL": "Whenever there is an Allocate with value10 R, a Concluding with value10 R, and no Edge_Match with value10 R, the reduction of D should be prioritized at a medium level with value10 D."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Begin with field4 X, with node8 K, with key4 W, with id2 L, whenever there is a Member with vtx8 U, U is minimized. ",
            "NL": "The Member with vtx8 U must be minimized whenever there is a Begin between field4 X, node8 K, key4 W, and id2 L as a matter of medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Begin with field4 X, with node8 K, with key4 W, with id2 L, whenever there is a Member with vtx8 U, U is minimized. ",
            "NL": "Whenever there is a Member with vtx8 U between field4 X, node8 K, key4 W, and id2 L, the Member must be minimized as a medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Begin with field4 X, with node8 K, with key4 W, with id2 L, whenever there is a Member with vtx8 U, U is minimized. ",
            "NL": "Whenever there is a Member with vtx8 U, it is of medium priority to minimize them whenever there is a Begin between field4 X, node8 K, key4 W, and id2 L."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Begin with field4 X, with node8 K, with key4 W, with id2 L, whenever there is a Member with vtx8 U, U is minimized. ",
            "NL": "If there is a Member with vtx8 U present, it is of medium priority to minimize the Member whenever there is a Begin between field4 X, node8 K, key4 W, and id2 L."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Begin with field4 X, with node8 K, with key4 W, with id2 L, whenever there is a Member with vtx8 U, U is minimized. ",
            "NL": "Whenever there is a Member with vtx8 U between field4 X, node8 K, key4 W, and id2 L, it is of medium priority that the Member be minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Clique with key9 Q, with key9 T, whenever there is a Root with key9 Q, whenever there is not a Module with key9 Q, whenever there is a weight with key9 T, T is minimized.",
            "NL": "Whenever there is a Clique with key9 Q, a Root with key9 Q, or a weight with key9 T, the minimization of T should be given medium priority; however, if there is no Module with key9 Q, this should not be done."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Clique with key9 Q, with key9 T, whenever there is a Root with key9 Q, whenever there is not a Module with key9 Q, whenever there is a weight with key9 T, T is minimized.",
            "NL": "It is preferable to minimize T, with medium priority, when there is a Clique with key9 Q, a Root with key9 Q, no Module with key9 Q, and a weight with key9 T."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Clique with key9 Q, with key9 T, whenever there is a Root with key9 Q, whenever there is not a Module with key9 Q, whenever there is a weight with key9 T, T is minimized.",
            "NL": "Whenever there is a Clique with key9 Q, a Root with key9 Q, or no Module with key9 Q, minimizing T should be given medium priority; if there is a weight with key9 T, then T should be minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Clique with key9 Q, with key9 T, whenever there is a Root with key9 Q, whenever there is not a Module with key9 Q, whenever there is a weight with key9 T, T is minimized.",
            "NL": "Whenever there is a Clique with key9 Q, a Root with key9 Q, or no Module with key9 Q, minimizing T should be given medium priority. Additionally, when there is a weight with key9 T, T should also be minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Clique with key9 Q, with key9 T, whenever there is a Root with key9 Q, whenever there is not a Module with key9 Q, whenever there is a weight with key9 T, T is minimized.",
            "NL": "Whenever there is a Clique with key9 Q, a Root with key9 Q, and no Module with key9 Q, the minimizing of T should be given medium priority. If there is a weight with key9 T, the same should be done."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Comprises with node7 D, whenever there is a Adjacent with node7 D, D is minimized.",
            "NL": "It is preferable to minimize D when there is a Comprises or Adjacent with node7 D and the priority is medium."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Comprises with node7 D, whenever there is a Adjacent with node7 D, D is minimized.",
            "NL": "It is preferable to minimize node7 D whenever there is a Comprises or Adjacent with it, and this should be done with medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Comprises with node7 D, whenever there is a Adjacent with node7 D, D is minimized.",
            "NL": "It is preferable to minimize D whenever there is a Comprises with node7 D or an Adjacent with node7 D, with medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Comprises with node7 D, whenever there is a Adjacent with node7 D, D is minimized.",
            "NL": "Whenever node7 D is part of a Comprises or Adjacent, it is preferable to minimize D with medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Comprises with node7 D, whenever there is a Adjacent with node7 D, D is minimized.",
            "NL": "It is preferable to minimize node7 D whenever there is a Comprises or an Adjacent with it and it should be done with medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Cross with second vertex O, whenever there is a Three_Nodes with vtx J, J is minimized.",
            "NL": "It is preferable to minimize vertex J in a Three_Nodes whenever there is a Cross with second vertex O, and to give this task medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Cross with second vertex O, whenever there is a Three_Nodes with vtx J, J is minimized.",
            "NL": "It is preferable that when there is a Cross with second vertex O, the Three_Nodes with vtx J is minimized, given medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Cross with second vertex O, whenever there is a Three_Nodes with vtx J, J is minimized.",
            "NL": "It is preferable that whenever there is a Cross with second vertex O and a Three_Nodes with vtx J, J is minimized at medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Cross with second vertex O, whenever there is a Three_Nodes with vtx J, J is minimized.",
            "NL": "It is preferable to minimize vertex J whenever there is a Three_Nodes with vtx J and a Cross with second vertex O, with medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Cross with second vertex O, whenever there is a Three_Nodes with vtx J, J is minimized.",
            "NL": "It is preferable that when there is a Cross with second vertex O, the Three_Nodes with vtx J is minimized, with medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Directed_Graph with node4 Y, with node4 L, whenever there is a Colored with node4 Y, whenever there is not a Cliquesize with node4 Y, whenever there is a weight with node4 L, L is minimized.",
            "NL": "It is preferable to minimize L, with medium priority, in situations when there is a Directed_Graph containing node4 Y, node4 L, a Colored containing node4 Y, no Cliquesize containing node4 Y, and a weight containing node4 L."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Directed_Graph with node4 Y, with node4 L, whenever there is a Colored with node4 Y, whenever there is not a Cliquesize with node4 Y, whenever there is a weight with node4 L, L is minimized.",
            "NL": "Whenever there is a Directed_Graph with node4 Y, a Colored with node4 Y, and a weight with node4 L, the minimizing of L should be given medium priority, but not if there is a Cliquesize with node4 Y."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Directed_Graph with node4 Y, with node4 L, whenever there is a Colored with node4 Y, whenever there is not a Cliquesize with node4 Y, whenever there is a weight with node4 L, L is minimized.",
            "NL": "Whenever there is a Directed_Graph with node4 Y and node4 L, a Colored with node4 Y, no Cliquesize with node4 Y, or a weight with node4 L, the minimizing of L should be given medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Directed_Graph with node4 Y, with node4 L, whenever there is a Colored with node4 Y, whenever there is not a Cliquesize with node4 Y, whenever there is a weight with node4 L, L is minimized.",
            "NL": "Whenever there is a Directed_Graph, Colored, or weight with node4 Y, minimizing L should be given medium priority, and when there is no Cliquesize with node4 Y, L should be minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Directed_Graph with node4 Y, with node4 L, whenever there is a Colored with node4 Y, whenever there is not a Cliquesize with node4 Y, whenever there is a weight with node4 L, L is minimized.",
            "NL": "Whenever there is a Directed_Graph with node4 Y, a Colored with node4 Y, and no Cliquesize with node4 Y, it is preferred to minimize node4 L with medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Diversity with third id K, with second vertex C, whenever there is a Start with third id K, with second vertex C, with first id S, S is minimized.",
            "NL": "It is desirable, though not of utmost importance, that when there is a disparity between third id K and second vertex C, a Start between third id K and second vertex C, with first id S, should be made with the smallest value of S."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Diversity with third id K, with second vertex C, whenever there is a Start with third id K, with second vertex C, with first id S, S is minimized.",
            "NL": "It is preferred, with medium priority, that when there is a difference between third id K and second vertex C, there is a Start between them with first id S, and the value of S is kept to a minimum."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Diversity with third id K, with second vertex C, whenever there is a Start with third id K, with second vertex C, with first id S, S is minimized.",
            "NL": "It is preferable, though not of utmost importance, that when there is a difference between Third ID K and Second Vertex C, a Start between them with First ID S should be made, with the value of S being kept to a minimum."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Diversity with third id K, with second vertex C, whenever there is a Start with third id K, with second vertex C, with first id S, S is minimized.",
            "NL": "When there is a difference between third id K and second vertex C, it is desirable to have a Start between them with first id S, and the value of S should be minimized as much as possible."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Diversity with third id K, with second vertex C, whenever there is a Start with third id K, with second vertex C, with first id S, S is minimized.",
            "NL": "It is desirable, albeit with medium importance, that when a discrepancy exists between third id K and second vertex C, a Start should be initiated between third id K and second vertex C, and the value of first id S should be kept to a minimum."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Edge_Tag with fifth vertex H, whenever there is a Minimum_Cut with node10 R, R is minimized.",
            "NL": "It is preferable to minimize node10 R whenever there is an Edge_Tag with fifth vertex H and a Minimum_Cut with node10 R, with medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Edge_Tag with fifth vertex H, whenever there is a Minimum_Cut with node10 R, R is minimized.",
            "NL": "It is preferable to minimize node10 R whenever there is a Minimum_Cut with node10 R and an Edge_Tag with fifth vertex H, with medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Edge_Tag with fifth vertex H, whenever there is a Minimum_Cut with node10 R, R is minimized.",
            "NL": "It is preferable to minimize R whenever there is an Edge_Tag with fifth vertex H and a Minimum_Cut with node10 R, with medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Edge_Tag with fifth vertex H, whenever there is a Minimum_Cut with node10 R, R is minimized.",
            "NL": "It is desirable to minimize R, node10, when there is a Minimum_Cut with node10 R and an Edge_Tag with fifth vertex H at medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Edge_Tag with fifth vertex H, whenever there is a Minimum_Cut with node10 R, R is minimized.",
            "NL": "It is preferable that, when there is an Edge_Tag with fifth vertex H and a Minimum_Cut with node10 R, R is minimized at medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Ending with vtx2 Z, whenever there is a Reference with vtx2 Z, Z is minimized.",
            "NL": "Whenever possible, it is best to minimize Z when there is an Ending with vtx2 Z and a Reference with vtx2 Z at medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Ending with vtx2 Z, whenever there is a Reference with vtx2 Z, Z is minimized.",
            "NL": "Whenever there is an Ending with vtx2 Z or a Reference with vtx2 Z, it is preferable to minimize Z with medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Ending with vtx2 Z, whenever there is a Reference with vtx2 Z, Z is minimized.",
            "NL": "It is preferable to minimize Z when there is an Ending with vtx2 Z and a Reference with vtx2 Z, and this should be done with medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Ending with vtx2 Z, whenever there is a Reference with vtx2 Z, Z is minimized.",
            "NL": "It is preferable to minimize Z when there is an Ending with vtx2 Z and a Reference with vtx2 Z, given medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Ending with vtx2 Z, whenever there is a Reference with vtx2 Z, Z is minimized.",
            "NL": "It is preferable to minimize Z whenever there is an Ending with vtx2 Z or a Reference with vtx2 Z, and the priority should be considered medium."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Eulerian_Circuit with node9 Y, with node9 H, whenever there is a Heaviness with node9 A, A is minimized.",
            "NL": "When there is an Eulerian Circuit with node9 Y and node9 H, it is preferable to minimize node9 A with medium priority, as it will result in a Heaviness."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Eulerian_Circuit with node9 Y, with node9 H, whenever there is a Heaviness with node9 A, A is minimized.",
            "NL": "It is best to minimize node A when there is an Eulerian Circuit with node 9Y and node 9H, and node 9A has a Heaviness with medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Eulerian_Circuit with node9 Y, with node9 H, whenever there is a Heaviness with node9 A, A is minimized.",
            "NL": "When there is an Eulerian Circuit with node9 Y and node9 H, it is preferable to minimize node9 A with medium priority, as this would result in a Heaviness."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Eulerian_Circuit with node9 Y, with node9 H, whenever there is a Heaviness with node9 A, A is minimized.",
            "NL": "When there is an Eulerian Circuit with node9 Y and node9 H, it is preferable to minimize node9 A with medium priority, as there is a Heaviness associated with it."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Eulerian_Circuit with node9 Y, with node9 H, whenever there is a Heaviness with node9 A, A is minimized.",
            "NL": "When there is an Eulerian Circuit with Node 9 Y and Node 9 H, it is preferable to minimize Node 9 A with medium priority, as it has a heaviness."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Forest with value2 G, with value2 T, whenever there is an Incoming with value2 N, N is minimized.",
            "NL": "When there is a Forest with value2 G and value2 T, it is preferable to minimize the Incoming with value2 N, giving it medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Forest with value2 G, with value2 T, whenever there is an Incoming with value2 N, N is minimized.",
            "NL": "When there is a Forest with values G and T, it is preferable to minimize the Incoming with value N, taking medium priority into consideration."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Forest with value2 G, with value2 T, whenever there is an Incoming with value2 N, N is minimized.",
            "NL": "When there is a Forest with value2 G and value2 T, it is preferable to minimize value2 N of the Incoming with medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Forest with value2 G, with value2 T, whenever there is an Incoming with value2 N, N is minimized.",
            "NL": "When there is a Forest with values G and T, it is preferable to minimize the Incoming with value N, given that it has medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Forest with value2 G, with value2 T, whenever there is an Incoming with value2 N, N is minimized.",
            "NL": "When there is a Forest with value2 G and value2 T, it is desirable to minimize value2 N in the Incoming with medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Full with node D, with node9 J, whenever there is a Location with node P, with node9 J, whenever there is a Incoming with node P, with node9 B, whenever there is a weight with node P, P is minimized.",
            "NL": "Medium priority is given to having a Full node D and a Location node P with node9 J, and an Incoming node P with node9 B, while trying to minimize the weight of node P."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Full with node D, with node9 J, whenever there is a Location with node P, with node9 J, whenever there is a Incoming with node P, with node9 B, whenever there is a weight with node P, P is minimized.",
            "NL": "Wherever there is a Full node D with node9 J, a Location node P with node9 J, and an Incoming node P with node9 B, the priority should be to minimize the weight node P."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Full with node D, with node9 J, whenever there is a Location with node P, with node9 J, whenever there is a Incoming with node P, with node9 B, whenever there is a weight with node P, P is minimized.",
            "NL": "It is preferred, at a moderate level of importance, that when there is a Full with node D and node9 J, there is a Location with node P and node9 J, an Incoming with node P and node9 B, and when there is a weight with node P, it should be minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Full with node D, with node9 J, whenever there is a Location with node P, with node9 J, whenever there is a Incoming with node P, with node9 B, whenever there is a weight with node P, P is minimized.",
            "NL": "Whenever there is a Full with node D and node9 J, it is preferable to have a Location with node P and node9 J, an Incoming with node P and node9 B, and if there is a weight with node P, it should be minimized with medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Full with node D, with node9 J, whenever there is a Location with node P, with node9 J, whenever there is a Incoming with node P, with node9 B, whenever there is a weight with node P, P is minimized.",
            "NL": "Whenever there is a Full with node D and node9 J, a Location with node P and node9 J, and an Incoming with node P and node9 B, a preference of medium priority is that the weight of node P is minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Input_Data with fourth node M, whenever there is a Penalty with node6 W, W is minimized.",
            "NL": "It is preferable that, when there is an Input_Data with the fourth node M and a Penalty with node6 W, W is minimized with medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Input_Data with fourth node M, whenever there is a Penalty with node6 W, W is minimized.",
            "NL": "It is preferable that, when there is an Input_Data with fourth node M and a Penalty with node6 W, W is minimized, prioritizing medium."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Input_Data with fourth node M, whenever there is a Penalty with node6 W, W is minimized.",
            "NL": "Whenever there is an Input_Data with fourth node M and a Penalty with node6 W, it is preferable to minimize W with medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Input_Data with fourth node M, whenever there is a Penalty with node6 W, W is minimized.",
            "NL": "When dealing with medium priority, it is best to minimize the Penalty with node6 W if there is an Input_Data with fourth node M present."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Input_Data with fourth node M, whenever there is a Penalty with node6 W, W is minimized.",
            "NL": "It is preferable to minimize Penalty with node6 W when there is an Input_Data with fourth node M, and to do so with medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Input_Data with value1 M, with id10 S, whenever there is a Signal with value1 G, with id10 S, whenever there is an Euler_Trail with value1 G, with id10 B, whenever there is a weight with value1 G, G is minimized.",
            "NL": "When Input_Data has a value of M and an id of 10 S, Signal with a value of G and an id of 10 S, and Euler_Trail with a value of G and an id of 10 B should be present, and the weight with a value of G should be minimized, with medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Input_Data with value1 M, with id10 S, whenever there is a Signal with value1 G, with id10 S, whenever there is an Euler_Trail with value1 G, with id10 B, whenever there is a weight with value1 G, G is minimized.",
            "NL": "Whenever there is an Input_Data with value1 M, with id10 S, there should be a Signal with value1 G, with id10 S, an Euler_Trail with value1 G, with id10 B, and a weight with value1 G, all with medium priority, and the weight should be minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Input_Data with value1 M, with id10 S, whenever there is a Signal with value1 G, with id10 S, whenever there is an Euler_Trail with value1 G, with id10 B, whenever there is a weight with value1 G, G is minimized.",
            "NL": "Whenever there is an Input_Data with the value1 M and id10 S, there should be a Signal with the value1 G and id10 S, an Euler_Trail with the value1 G and id10 B, and the weight with the value1 G should be minimized, all with medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Input_Data with value1 M, with id10 S, whenever there is a Signal with value1 G, with id10 S, whenever there is an Euler_Trail with value1 G, with id10 B, whenever there is a weight with value1 G, G is minimized.",
            "NL": "Whenever there is an Input_Data with value1 M, and id10 S, it is preferred with medium priority that a Signal with value1 G, and id10 S, an Euler_Trail with value1 G, and id10 B, and a weight with value1 G exist, and G is minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Input_Data with value1 M, with id10 S, whenever there is a Signal with value1 G, with id10 S, whenever there is an Euler_Trail with value1 G, with id10 B, whenever there is a weight with value1 G, G is minimized.",
            "NL": "Whenever there is an Input_Data with value1 M and id10 S, it is preferred (medium priority) to have a Signal with value1 G, id10 S, an Euler_Trail with value1 G, id10 B, and if there is a weight with value1 G, to minimize G."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Link with edge10 X, X is minimized.",
            "NL": "It is preferred that the edge10 X Link be minimized with the lowest priority whenever possible."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Link with edge10 X, X is minimized.",
            "NL": "It is preferred that when there is a Link with edge10 X, it should be minimized with the lowest priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Link with edge10 X, X is minimized.",
            "NL": "It is preferable to minimize the Link with edge10 X with the lowest priority whenever it is present."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Link with edge10 X, X is minimized.",
            "NL": "It is preferred that whenever there is a Link with edge10 X, it should be minimized with the least amount of priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Link with edge10 X, X is minimized.",
            "NL": "It is preferred that when there is a Link with edge10 X, it be minimized with the lowest priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Marker with node10 Q, with node10 S, whenever there is a Cliquesize with node10 Q, whenever there is not a Maximum_Flow with node10 Q, whenever there is a weight with node10 S, S is minimized.",
            "NL": "Whenever there is a Marker with node10 Q, a Cliquesize with node10 Q, and no Maximum_Flow with node10 Q, it is preferred to minimize S with medium priority, and when there is a weight with node10 S."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Marker with node10 Q, with node10 S, whenever there is a Cliquesize with node10 Q, whenever there is not a Maximum_Flow with node10 Q, whenever there is a weight with node10 S, S is minimized.",
            "NL": "It is preferred to minimize S with medium priority when there is a Marker with node10 Q, a Cliquesize with node10 Q, and no Maximum_Flow with node10 Q, and a weight with node10 S."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Marker with node10 Q, with node10 S, whenever there is a Cliquesize with node10 Q, whenever there is not a Maximum_Flow with node10 Q, whenever there is a weight with node10 S, S is minimized.",
            "NL": "Whenever there is a Marker with node10 Q, a Cliquesize with node10 Q, and no Maximum_Flow with node10 Q, it is preferred to minimize S with medium priority, and there is a weight with node10 S."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Marker with node10 Q, with node10 S, whenever there is a Cliquesize with node10 Q, whenever there is not a Maximum_Flow with node10 Q, whenever there is a weight with node10 S, S is minimized.",
            "NL": "It is preferable to minimize S, with medium priority, if there is a Marker with node 10 Q, Cliquesize with node 10 Q, no Maximum_Flow with node 10 Q, or a weight with node 10 S."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Marker with node10 Q, with node10 S, whenever there is a Cliquesize with node10 Q, whenever there is not a Maximum_Flow with node10 Q, whenever there is a weight with node10 S, S is minimized.",
            "NL": "Whenever there is a Marker with node10 Q, Cliquesize with node10 Q, or weight with node10 S, it is preferable to minimize S, though with medium priority, unless there is a Maximum_Flow with node10 Q."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Maximum_Matching with edge10 W, with edge10 F, whenever there is a Jailed with edge10 P, P is minimized.",
            "NL": "When there is a Maximum_Matching with edge10 W and edge10 F, it is preferable to minimize edge10 P with medium priority, and if necessary, a Jailed with edge10 P should be used."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Maximum_Matching with edge10 W, with edge10 F, whenever there is a Jailed with edge10 P, P is minimized.",
            "NL": "When there is a Maximum_Matching with edge10 W and edge10 F, it is preferable to minimize edge10 P with medium priority, and if necessary, have a Jailed with edge10 P."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Maximum_Matching with edge10 W, with edge10 F, whenever there is a Jailed with edge10 P, P is minimized.",
            "NL": "When there is a Maximum_Matching with edge10 W and edge10 F, it is preferable to minimize edge10 P with medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Maximum_Matching with edge10 W, with edge10 F, whenever there is a Jailed with edge10 P, P is minimized.",
            "NL": "When there is a Maximum_Matching with edge10 W and edge10 F, it is preferable to minimize edge10 P with medium priority, as it would result in a Jailed."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Maximum_Matching with edge10 W, with edge10 F, whenever there is a Jailed with edge10 P, P is minimized.",
            "NL": "It is preferable to minimize edge10 P when there is a Maximum_Matching with edge10 W and edge10 F, and a Jailed with edge10 P, and this should be done with medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a NonOriented with node5 U, with node5 M, whenever there is a Link with node5 U, whenever there is not a Independent_Set with node5 U, whenever there is a weight with node5 M, M is minimized.",
            "NL": "Whenever there is a NonOriented with node5 U, Link with node5 U, or weight with node5 M, it is preferable to minimize M with medium priority, but only if there is no Independent_Set with node5 U."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a NonOriented with node5 U, with node5 M, whenever there is a Link with node5 U, whenever there is not a Independent_Set with node5 U, whenever there is a weight with node5 M, M is minimized.",
            "NL": "Whenever there is a NonOriented with node5 U, a Link with node5 U, and no Independent_Set with node5 U, it is preferred to minimize node5 M with medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a NonOriented with node5 U, with node5 M, whenever there is a Link with node5 U, whenever there is not a Independent_Set with node5 U, whenever there is a weight with node5 M, M is minimized.",
            "NL": "Whenever there is a NonOriented with node5 U, a Link with node5 U, and no Independent_Set with node5 U, it is preferable to minimize node5 M, with medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a NonOriented with node5 U, with node5 M, whenever there is a Link with node5 U, whenever there is not a Independent_Set with node5 U, whenever there is a weight with node5 M, M is minimized.",
            "NL": "Whenever there is a NonOriented with node5 U, a Link with node5 U, and no Independent_Set with node5 U, it is preferred to minimize M with medium priority, and if there is a weight with node5 M, this should also be taken into account."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a NonOriented with node5 U, with node5 M, whenever there is a Link with node5 U, whenever there is not a Independent_Set with node5 U, whenever there is a weight with node5 M, M is minimized.",
            "NL": "Whenever there is a NonOriented with node5 U, a Link with node5 U, and no Independent_Set with node5 U, it is preferred to minimize node5 M, with medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Outbound with key5 V, whenever there is a Suggestion with key5 V, V is minimized.",
            "NL": "It is preferable to minimize V whenever there is an Outbound or Suggestion with key5 V, and this should be done with medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Outbound with key5 V, whenever there is a Suggestion with key5 V, V is minimized.",
            "NL": "It is best to reduce V as much as possible when there is an Outbound with key5 V, or if there is a Suggestion with key5 V, and this should be done with medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Outbound with key5 V, whenever there is a Suggestion with key5 V, V is minimized.",
            "NL": "It is preferable that whenever there is an Outbound or a Suggestion with key5 V, V is minimized, giving medium priority to this task."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Outbound with key5 V, whenever there is a Suggestion with key5 V, V is minimized.",
            "NL": "It is preferable to minimize V whenever there is an Outbound or Suggestion with key5 V and that it be given medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Outbound with key5 V, whenever there is a Suggestion with key5 V, V is minimized.",
            "NL": "It is preferable to minimize V whenever there is an Outbound or Suggestion with key5 V and the priority is set to medium."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a OutgoingPath with first vertex T, whenever there is a Starting with id V, V is minimized.",
            "NL": "Whenever there is an OutgoingPath with a first vertex of T and a Starting with id of V, it is preferable to minimize V with medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a OutgoingPath with first vertex T, whenever there is a Starting with id V, V is minimized.",
            "NL": "It is preferable that, when there is an OutgoingPath with first vertex T and a Starting with id V, V is minimized at a medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a OutgoingPath with first vertex T, whenever there is a Starting with id V, V is minimized.",
            "NL": "It is preferable to minimize V whenever there is an OutgoingPath with first vertex T and a Starting with id V, and to give this task medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a OutgoingPath with first vertex T, whenever there is a Starting with id V, V is minimized.",
            "NL": "Whenever there is an OutgoingPath with first vertex T and a Starting with id V, it is preferable to minimize V with medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a OutgoingPath with first vertex T, whenever there is a Starting with id V, V is minimized.",
            "NL": "When there is an OutgoingPath with first vertex T and Starting with id V, it is preferable to minimize V with medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Parentedge with vtx3 B, with node4 Y, whenever there is a Span with vtx2 F, with id6 B, with node7 Y, whenever there is a weight with value N, N is minimized.",
            "NL": "Whenever there is a Parentedge with vtx3 B and node4 Y, a Span with vtx2 F, id6 B, and node7 Y, and a weight with a value of N, it is preferred that N be minimized with medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Parentedge with vtx3 B, with node4 Y, whenever there is a Span with vtx2 F, with id6 B, with node7 Y, whenever there is a weight with value N, N is minimized.",
            "NL": "Whenever there is a Parentedge with vtx3 B and node4 Y, a Span with vtx2 F, id6 B, and node7 Y, and a weight with a value of N, it is preferred to minimize N with medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Parentedge with vtx3 B, with node4 Y, whenever there is a Span with vtx2 F, with id6 B, with node7 Y, whenever there is a weight with value N, N is minimized.",
            "NL": "It is preferred, at a moderate level, that when a Parentedge with vtx3 B and node4 Y is present, and when a Span with vtx2 F, id6 B, and node7 Y exists, the value of N in the corresponding weight should be minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Parentedge with vtx3 B, with node4 Y, whenever there is a Span with vtx2 F, with id6 B, with node7 Y, whenever there is a weight with value N, N is minimized.",
            "NL": "Whenever there is a Parentedge with vtx3 B, node4 Y, a Span with vtx2 F, id6 B, node7 Y, and a weight with value N, it is preferred that N is minimized with medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Parentedge with vtx3 B, with node4 Y, whenever there is a Span with vtx2 F, with id6 B, with node7 Y, whenever there is a weight with value N, N is minimized.",
            "NL": "It is preferred, with medium priority, to minimize the value of N whenever there is a Parentedge with vtx3 B and node4 Y, a Span with vtx2 F, id6 B, and node7 Y, and a weight with value N."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Path with value9 F, with vtx7 I, with value3 Q, with field7 S, whenever there is a Foremost with node1 O, O is minimized. ",
            "NL": "Whenever there is a Path between value9 F, vtx7 I, value3 Q, and field7 S, as a matter of medium priority, the Foremost with node1 O must be minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Path with value9 F, with vtx7 I, with value3 Q, with field7 S, whenever there is a Foremost with node1 O, O is minimized. ",
            "NL": "The Foremost with node1 O must be minimized whenever there is a Path between value9 F, vtx7 I, value3 Q, and field7 S of medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Path with value9 F, with vtx7 I, with value3 Q, with field7 S, whenever there is a Foremost with node1 O, O is minimized. ",
            "NL": "Whenever there is a Path between value9 F, vtx7 I, value3 Q, and field7 S, and concurrently a Foremost with node1 O exists, the Foremost should be minimized with medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Path with value9 F, with vtx7 I, with value3 Q, with field7 S, whenever there is a Foremost with node1 O, O is minimized. ",
            "NL": "Whenever there is a Path between value9 F, vtx7 I, value3 Q, and field7 S, and a Foremost with node1 O, the Foremost must be minimized as a priority of medium importance."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Path with value9 F, with vtx7 I, with value3 Q, with field7 S, whenever there is a Foremost with node1 O, O is minimized. ",
            "NL": "Whenever there is a Path between value9 F, vtx7 I, value3 Q, field7 S and a Foremost with node1 O, minimizing the Foremost should be given medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Planar with node8 E, with vtx7 M, with field6 S, with value4 V, whenever there is a Single with id5 X, X is minimized. ",
            "NL": "Whenever there is a Single with id5 X, it should be minimized as a matter of medium priority, alongside a Planar between node8 E, vtx7 M, field6 S, and value4 V."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Planar with node8 E, with vtx7 M, with field6 S, with value4 V, whenever there is a Single with id5 X, X is minimized. ",
            "NL": "Whenever there is a Planar between node8 E, vtx7 M, field6 S, value4 V, and a Single with id5 X, the Single should be minimized as a medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Planar with node8 E, with vtx7 M, with field6 S, with value4 V, whenever there is a Single with id5 X, X is minimized. ",
            "NL": "Whenever there is a Planar between node8 E, vtx7 M, field6 S, value4 V, and a Single with id5 X, the Single must be minimized as a matter of medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Planar with node8 E, with vtx7 M, with field6 S, with value4 V, whenever there is a Single with id5 X, X is minimized. ",
            "NL": "Whenever there is a Single with id5 X, it must be minimized as a matter of medium priority, in the presence of a Planar between node8 E, vtx7 M, field6 S, and value4 V."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Planar with node8 E, with vtx7 M, with field6 S, with value4 V, whenever there is a Single with id5 X, X is minimized. ",
            "NL": "Whenever there is a Planar between node8 E, vtx7 M, field6 S, value4 V, and a Single with id5 X, it is of medium priority to minimize the Single."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Planar_Embedding with second point S, whenever there is a Inputted with value8 X, X is minimized.",
            "NL": "It is preferable that whenever there is a Planar_Embedding with second point S and an Inputted with value8 X, X is minimized with medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Planar_Embedding with second point S, whenever there is a Inputted with value8 X, X is minimized.",
            "NL": "It is preferable to minimize X whenever there is a Planar_Embedding with second point S and an Inputted with value8 X, with medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Planar_Embedding with second point S, whenever there is a Inputted with value8 X, X is minimized.",
            "NL": "It is preferable that, when a Planar_Embedding with second point S is present and an Inputted with value8 X is inputted, X is minimized with medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Planar_Embedding with second point S, whenever there is a Inputted with value8 X, X is minimized.",
            "NL": "Whenever a Planar_Embedding with second point S is given with medium priority, it is preferable to minimize Inputted value8 X."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Planar_Embedding with second point S, whenever there is a Inputted with value8 X, X is minimized.",
            "NL": "It is preferable to minimize X whenever there is a Planar_Embedding with second point S and Inputted with value 8 X, with medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Predominant with node1 N, with node2 J, whenever there is a Diagram with key6 C, with edge6 N, with edge7 J, whenever there is a weight with value Q, Q is minimized.",
            "NL": "Whenever there is a Predominant with node1 N and node2 J, a Diagram with key6 C, edge6 N, and edge7 J, and a weight with value Q, it is preferred that Q be minimized with medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Predominant with node1 N, with node2 J, whenever there is a Diagram with key6 C, with edge6 N, with edge7 J, whenever there is a weight with value Q, Q is minimized.",
            "NL": "The preference is of medium priority that Q should be minimized when there is a Predominant with node1 N and node2 J, a Diagram with key6 C, edge6 N, and edge7 J, and a weight with value Q."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Predominant with node1 N, with node2 J, whenever there is a Diagram with key6 C, with edge6 N, with edge7 J, whenever there is a weight with value Q, Q is minimized.",
            "NL": "It is preferred that, given a Predominant with node1 N and node2 J, a Diagram with key6 C, edge6 N, and edge7 J, and a weight with value Q, Q is minimized with medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Predominant with node1 N, with node2 J, whenever there is a Diagram with key6 C, with edge6 N, with edge7 J, whenever there is a weight with value Q, Q is minimized.",
            "NL": "It is preferred, of medium importance, that Q is minimized when there is a Predominant with node1 N and node2 J, a Diagram with key6 C, edge6 N, and edge7 J, and a weight with value Q."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Predominant with node1 N, with node2 J, whenever there is a Diagram with key6 C, with edge6 N, with edge7 J, whenever there is a weight with value Q, Q is minimized.",
            "NL": "It is preferred, with medium priority, that Q is minimized when there is a Predominant with node1 N and node2 J, a Diagram with key6 C, edge6 N, and edge7 J, and a weight with value Q."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Punishment with key7 P, with key U, whenever there is a Line_Graph with node6 X, with node1 P, with key9 U, whenever there is a weight with value W, W is minimized.",
            "NL": "Whenever there is a Punishment with key7 P and key U, a Line_Graph with node6 X and node1 P, and a weight with value W, it is preferred that W be minimized with medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Punishment with key7 P, with key U, whenever there is a Line_Graph with node6 X, with node1 P, with key9 U, whenever there is a weight with value W, W is minimized.",
            "NL": "It is preferred that when Punishment with key7 P and key U, Line_Graph with node6 X and node1 P, and key9 U are present, the weight value W should be minimized as much as possible."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Punishment with key7 P, with key U, whenever there is a Line_Graph with node6 X, with node1 P, with key9 U, whenever there is a weight with value W, W is minimized.",
            "NL": "Whenever there is a Punishment with key7 P and key U, a Line_Graph with node6 X and node1 P and key9 U, and a weight with value W, it is preferred to minimize W with medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Punishment with key7 P, with key U, whenever there is a Line_Graph with node6 X, with node1 P, with key9 U, whenever there is a weight with value W, W is minimized.",
            "NL": "Whenever there is a Punishment with key7 P and key U, a Line_Graph with node6 X and node1 P, and a weight with value W, it is preferred to minimize W with medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Punishment with key7 P, with key U, whenever there is a Line_Graph with node6 X, with node1 P, with key9 U, whenever there is a weight with value W, W is minimized.",
            "NL": "It is preferred, with medium priority, that the value of W should be minimized whenever there is a Punishment with key7 P and key U, a Line_Graph with node6 X and node1 P, and a weight with key9 U."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Radius with edge8 J, with key1 D, whenever there is a Shade with edge8 E, with key1 D, whenever there is an Edge_Label with edge8 E, with key1 M, whenever there is a weight with edge8 E, E is minimized.",
            "NL": "When there is a Radius with edge8 J and key1 D, a Shade with edge8 E and key1 D, and an Edge_Label with edge8 E and key1 M, it is preferred, but of medium priority, that E be minimized when a weight with edge8 E is present."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Radius with edge8 J, with key1 D, whenever there is a Shade with edge8 E, with key1 D, whenever there is an Edge_Label with edge8 E, with key1 M, whenever there is a weight with edge8 E, E is minimized.",
            "NL": "Whenever there is a Radius with edge8 J, key1 D, a Shade with edge8 E, key1 D, and an Edge_Label with edge8 E, key1 M, it is preferred, of medium priority, to minimize E when there is a weight with edge8 E."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Radius with edge8 J, with key1 D, whenever there is a Shade with edge8 E, with key1 D, whenever there is an Edge_Label with edge8 E, with key1 M, whenever there is a weight with edge8 E, E is minimized.",
            "NL": "Whenever there is a Radius with edge8 J, key1 D, a Shade with edge8 E, key1 D, and an Edge_Label with edge8 E, key1 M, it is preferred to minimize E when there is a weight with edge8 E, and this preference has medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Radius with edge8 J, with key1 D, whenever there is a Shade with edge8 E, with key1 D, whenever there is an Edge_Label with edge8 E, with key1 M, whenever there is a weight with edge8 E, E is minimized.",
            "NL": "Whenever there is a Radius with edge8 J, key1 D, a Shade with edge8 E, key1 D, and an Edge_Label with edge8 E, key1 M, it is preferred to have E minimized with medium priority in the weight with edge8 E."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Radius with edge8 J, with key1 D, whenever there is a Shade with edge8 E, with key1 D, whenever there is an Edge_Label with edge8 E, with key1 M, whenever there is a weight with edge8 E, E is minimized.",
            "NL": "Whenever there is a Radius with edge8 J and key1 D, a Shade with edge8 E and key1 D, and an Edge_Label with edge8 E and key1 M, there is a medium priority preference that the weight with edge8 E is minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Remaining with node7 C, with node7 B, whenever there is a Pair_of_Nodes with node7 R, R is minimized.",
            "NL": "When there is a Remaining Pair_of_Nodes with node7 B and node7 C, it is preferable to minimize node7 R with medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Remaining with node7 C, with node7 B, whenever there is a Pair_of_Nodes with node7 R, R is minimized.",
            "NL": "When there is a Pair_of_Nodes with node7 R and node7 B, it is preferable to prioritize minimizing R with medium priority when remaining with node7 C."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Remaining with node7 C, with node7 B, whenever there is a Pair_of_Nodes with node7 R, R is minimized.",
            "NL": "It is preferable to minimize node7 R when there is a remaining Pair_of_Nodes with node7 B and node7 C, with medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Remaining with node7 C, with node7 B, whenever there is a Pair_of_Nodes with node7 R, R is minimized.",
            "NL": "When there is a Pair_of_Nodes with node7 R, it is preferable to minimize R with medium priority, while remaining with node7 C and node7 B."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Remaining with node7 C, with node7 B, whenever there is a Pair_of_Nodes with node7 R, R is minimized.",
            "NL": "When given the choice between node7 C and node7 B, it is preferable to prioritize minimizing node7 R, as it forms a pair of nodes with node7 R."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Route with field2 K, with id6 W, with field6 J, with key7 O, whenever there is a First with value1 M, M is minimized. ",
            "NL": "Whenever there is a Route between field2 K, id6 W, field6 J, key7 O, and a First with value1 M, minimizing the First should be given medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Route with field2 K, with id6 W, with field6 J, with key7 O, whenever there is a First with value1 M, M is minimized. ",
            "NL": "The First must be minimized whenever there is a Route between field2 K, id6 W, field6 J, key7 O and a First with value1 M, and this is of medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Route with field2 K, with id6 W, with field6 J, with key7 O, whenever there is a First with value1 M, M is minimized. ",
            "NL": "When there is a First with value1 M between field2 K, id6 W, field6 J, and key7 O, it is of medium priority to minimize the First."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Route with field2 K, with id6 W, with field6 J, with key7 O, whenever there is a First with value1 M, M is minimized. ",
            "NL": "Whenever there is a Route between field2 K, id6 W, field6 J, key7 O with value1 M, the First must be minimized as a matter of medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Route with field2 K, with id6 W, with field6 J, with key7 O, whenever there is a First with value1 M, M is minimized. ",
            "NL": "If there is a Route between field2 K, id6 W, field6 J, key7 O and a First with value1 M, it is of medium priority to minimize the First."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Shaded with field4 T, with edge8 W, whenever there is a Penalty with field4 H, with edge8 W, whenever there is a Project with field4 H, with edge8 G, whenever there is a weight with field4 H, H is minimized.",
            "NL": "Whenever there is a Shaded field4 T with edge8 W, a Penalty field4 H with edge8 W, and a Project field4 H with edge8 G, there is a preference of medium priority to minimize H in the weight field4 H."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Shaded with field4 T, with edge8 W, whenever there is a Penalty with field4 H, with edge8 W, whenever there is a Project with field4 H, with edge8 G, whenever there is a weight with field4 H, H is minimized.",
            "NL": "Whenever there is a Shaded with field4 T and edge8 W, there is a Penalty with field4 H and edge8 W, and a Project with field4 H and edge8 G. Additionally, when there is a weight with field4 H, it is preferred to minimize H."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Shaded with field4 T, with edge8 W, whenever there is a Penalty with field4 H, with edge8 W, whenever there is a Project with field4 H, with edge8 G, whenever there is a weight with field4 H, H is minimized.",
            "NL": "When Shaded has field4 T and edge8 W, Penalty has field4 H and edge8 W, Project has field4 H and edge8 G, and weight has field4 H, H is to be minimized with medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Shaded with field4 T, with edge8 W, whenever there is a Penalty with field4 H, with edge8 W, whenever there is a Project with field4 H, with edge8 G, whenever there is a weight with field4 H, H is minimized.",
            "NL": "When there is a Shaded field4 T with edge8 W, there is a Penalty field4 H with edge8 W; when there is a Project field4 H with edge8 G, there is a weight field4 H with edge8 G, and H is minimized with medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Shaded with field4 T, with edge8 W, whenever there is a Penalty with field4 H, with edge8 W, whenever there is a Project with field4 H, with edge8 G, whenever there is a weight with field4 H, H is minimized.",
            "NL": "Whenever there is a Shaded with field4 T, with edge8 W, a Penalty with field4 H, with edge8 W, and a Project with field4 H, with edge8 G, it is preferred, with medium priority, that the weight with field4 H be minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Subsequent with node8 Z, with vtx5 I, whenever there is a NonInitial with field10 R, with key10 Z, with edge4 I, whenever there is a weight with value J, J is minimized.",
            "NL": "Whenever there is a Subsequent with node8 Z, vtx5 I, NonInitial with field10 R, key10 Z, edge4 I, and a weight with value J, it is preferred to minimize J with medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Subsequent with node8 Z, with vtx5 I, whenever there is a NonInitial with field10 R, with key10 Z, with edge4 I, whenever there is a weight with value J, J is minimized.",
            "NL": "Whenever there is a Subsequent with node8 Z and vtx5 I, a NonInitial with field10 R, key10 Z, and edge4 I, and a weight with value J, it is preferred to minimize J with medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Subsequent with node8 Z, with vtx5 I, whenever there is a NonInitial with field10 R, with key10 Z, with edge4 I, whenever there is a weight with value J, J is minimized.",
            "NL": "Whenever there is a Subsequent with node8 Z, vtx5 I, a NonInitial with field10 R, key10 Z, and edge4 I, it is preferred that the weight value J is minimized to a medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Subsequent with node8 Z, with vtx5 I, whenever there is a NonInitial with field10 R, with key10 Z, with edge4 I, whenever there is a weight with value J, J is minimized.",
            "NL": "Whenever there is a Subsequent with node8 Z and vtx5 I, a NonInitial with field10 R, key10 Z, and edge4 I, and a weight with value J, it is preferable to minimize J with a medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Subsequent with node8 Z, with vtx5 I, whenever there is a NonInitial with field10 R, with key10 Z, with edge4 I, whenever there is a weight with value J, J is minimized.",
            "NL": "Whenever there is a Subsequent with node8 Z and vtx5 I, a NonInitial with field10 R, key10 Z, and edge4 I, and a weight with value J, it is preferable to minimize J with medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Subsequently with node6 T, with key9 K, whenever there is a Cycle with node6 X, with key9 K, whenever there is a Next with node6 X, with key9 Z, whenever there is a weight with node6 X, X is minimized.",
            "NL": "Whenever there is a Subsequently with node6 T, having key9 K, a Cycle with node6 X, also having key9 K, should follow with a Next with node6 X, having key9 Z, and X should be minimized in the case of a weight with node6 X, with medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Subsequently with node6 T, with key9 K, whenever there is a Cycle with node6 X, with key9 K, whenever there is a Next with node6 X, with key9 Z, whenever there is a weight with node6 X, X is minimized.",
            "NL": "Whenever node6 T and key9 K are present, Cycle with node6 X and key9 K should be prioritized with medium priority, and Next with node6 X and key9 Z should follow, while minimizing the weight of node6 X."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Subsequently with node6 T, with key9 K, whenever there is a Cycle with node6 X, with key9 K, whenever there is a Next with node6 X, with key9 Z, whenever there is a weight with node6 X, X is minimized.",
            "NL": "Whenever there is a Subsequently with node6 T, key9 K, there should be a Cycle with node6 X, key9 K, followed by a Next with node6 X, key9 Z, and the weight of node6 X should be minimized with medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Subsequently with node6 T, with key9 K, whenever there is a Cycle with node6 X, with key9 K, whenever there is a Next with node6 X, with key9 Z, whenever there is a weight with node6 X, X is minimized.",
            "NL": "Whenever there is a Subsequently with node6 T and key9 K, a Cycle with node6 X and key9 K, and a Next with node6 X and key9 Z, it is preferred that the weight of node6 X be minimized, and given medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Subsequently with node6 T, with key9 K, whenever there is a Cycle with node6 X, with key9 K, whenever there is a Next with node6 X, with key9 Z, whenever there is a weight with node6 X, X is minimized.",
            "NL": "Whenever there is a Subsequently node6 T with key9 K, a Cycle node6 X with key9 K, and a Next node6 X with key9 Z, the preference is to minimize the weight node6 X, with a medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Triple with vtx10 L, with value10 E, whenever there is a Initiate with vtx7 A, with node6 L, with id8 E, whenever there is a weight with value K, K is minimized.",
            "NL": "Whenever a Triple with vtx10 L and value10 E is present, and an Initiate with vtx7 A, node6 L, and id8 E is present, preference should be given to minimize the weight value K."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Triple with vtx10 L, with value10 E, whenever there is a Initiate with vtx7 A, with node6 L, with id8 E, whenever there is a weight with value K, K is minimized.",
            "NL": "It is preferable, having a moderate priority, to minimize the weight value K whenever there is a Triple with vtx10 L and value10 E, an Initiate with vtx7 A, node6 L and id8 E."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Triple with vtx10 L, with value10 E, whenever there is a Initiate with vtx7 A, with node6 L, with id8 E, whenever there is a weight with value K, K is minimized.",
            "NL": "It is preferred to minimize the weight value K whenever there is a Triple with vtx10 L and value10 E, an Initiate with vtx7 A, node6 L, and id8 E, all of which have medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Triple with vtx10 L, with value10 E, whenever there is a Initiate with vtx7 A, with node6 L, with id8 E, whenever there is a weight with value K, K is minimized.",
            "NL": "Whenever there is a Triple with vtx10 L, value10 E, an Initiate with vtx7 A, node6 L, and id8 E, preference should be given to minimizing the weight value K."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Triple with vtx10 L, with value10 E, whenever there is a Initiate with vtx7 A, with node6 L, with id8 E, whenever there is a weight with value K, K is minimized.",
            "NL": "Whenever there is a Triple with vtx10 L and value10 E, an Initiate with vtx7 A, node6 L, and id8 E, or a weight with value K, it is preferred that K is minimized with medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Unweighted with edge5 O, whenever there is a Short with edge5 O, O is minimized.",
            "NL": "It is preferable to minimize O when there is an Unweighted with edge5 O and a Short with edge5 O at medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Unweighted with edge5 O, whenever there is a Short with edge5 O, O is minimized.",
            "NL": "It is preferable to minimize O when there is an Unweighted with edge5 O or a Short with edge5 O, and this should be done with medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Unweighted with edge5 O, whenever there is a Short with edge5 O, O is minimized.",
            "NL": "It is preferable to minimize O when there is an Unweighted with edge5 O, and when there is a Short with edge5 O, with medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Unweighted with edge5 O, whenever there is a Short with edge5 O, O is minimized.",
            "NL": "It is best to minimize O if there is an Unweighted edge5 O or a Short edge5 O with medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Unweighted with edge5 O, whenever there is a Short with edge5 O, O is minimized.",
            "NL": "It is preferable to minimize O whenever there is an Unweighted with edge5 O or a Short with edge5 O, with medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Victory with key2 O, with value5 H, with node8 V, with value4 D, whenever there is a Symbol with value10 S, S is minimized. ",
            "NL": "If there is a Victory between key2 O, value5 H, node8 V, and value4 D, and a Symbol with value10 S is present, the Symbol should be minimized as a medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Victory with key2 O, with value5 H, with node8 V, with value4 D, whenever there is a Symbol with value10 S, S is minimized. ",
            "NL": "When Victory is present between key2 O, value5 H, node8 V, and value4 D, the Symbol with value10 S should be minimized as a medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Victory with key2 O, with value5 H, with node8 V, with value4 D, whenever there is a Symbol with value10 S, S is minimized. ",
            "NL": "Whenever there is a Victory between key2 O, value5 H, node8 V, and value4 D, the Symbol with value10 S must be minimized as a matter of medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Victory with key2 O, with value5 H, with node8 V, with value4 D, whenever there is a Symbol with value10 S, S is minimized. ",
            "NL": "Whenever there is a Victory between key2 O, value5 H, node8 V, and value4 D, Symbol with value10 S must be minimized as a matter of medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Victory with key2 O, with value5 H, with node8 V, with value4 D, whenever there is a Symbol with value10 S, S is minimized. ",
            "NL": "If there is a Victory between key2 O, value5 H, node8 V, and value4 D, and a Symbol with value10 S, the Symbol should be minimized as a medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Width with vtx8 W, with vtx8 Y, whenever there is a Variation with vtx8 W, whenever there is not a Embedding with vtx8 W, whenever there is a weight with vtx8 Y, Y is minimized.",
            "NL": "Whenever there is a Width with vtx8 W, Variation with vtx8 W, or no Embedding with vtx8 W, it is preferred to minimize Y with medium priority, and whenever there is a weight with vtx8 Y, the same is true."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Width with vtx8 W, with vtx8 Y, whenever there is a Variation with vtx8 W, whenever there is not a Embedding with vtx8 W, whenever there is a weight with vtx8 Y, Y is minimized.",
            "NL": "Whenever there is a Width with vtx8 W, Variation with vtx8 W, or Weight with vtx8 Y, minimizing Y should be prioritized at a medium level. If there is no Embedding with vtx8 W, then Y should still be minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Width with vtx8 W, with vtx8 Y, whenever there is a Variation with vtx8 W, whenever there is not a Embedding with vtx8 W, whenever there is a weight with vtx8 Y, Y is minimized.",
            "NL": "Whenever there is a Width with vtx8 W, Variation with vtx8 W, or no Embedding with vtx8 W, it is preferred to minimize Y with medium priority; when there is a weight with vtx8 Y, this should be done as well."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Width with vtx8 W, with vtx8 Y, whenever there is a Variation with vtx8 W, whenever there is not a Embedding with vtx8 W, whenever there is a weight with vtx8 Y, Y is minimized.",
            "NL": "Whenever there is a Width with vtx8 W, a Variation with vtx8 W, or no Embedding with vtx8 W, it is preferred to minimize Y with medium priority, and whenever there is a Weight with vtx8 Y, the same applies."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is a Width with vtx8 W, with vtx8 Y, whenever there is a Variation with vtx8 W, whenever there is not a Embedding with vtx8 W, whenever there is a weight with vtx8 Y, Y is minimized.",
            "NL": "It is preferred to minimize Y, with medium priority, when there is a Width of vtx8 W, a Variation with vtx8 W, no Embedding with vtx8 W, or a Weight with vtx8 Y."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is an Ancestor with key P, with key Q, whenever there is a Sequence with key M, M is minimized.",
            "NL": "When there is an Ancestor with key P, it is preferable to prioritize minimizing the Sequence with key M that has key Q, with medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is an Ancestor with key P, with key Q, whenever there is a Sequence with key M, M is minimized.",
            "NL": "When there is an Ancestor with key P and key Q, it is preferable to minimize the Sequence with key M, although this should be done with medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is an Ancestor with key P, with key Q, whenever there is a Sequence with key M, M is minimized.",
            "NL": "When there is an Ancestor with key P and key Q, it is preferable to minimize Sequence with key M, with medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is an Ancestor with key P, with key Q, whenever there is a Sequence with key M, M is minimized.",
            "NL": "When there is an Ancestor with key P and key Q, it is preferable to minimize the Sequence with key M, given that it has medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is an Ancestor with key P, with key Q, whenever there is a Sequence with key M, M is minimized.",
            "NL": "When there is an Ancestor with key P and key Q, it is preferred that the Sequence with key M be minimized, with medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is an Associated with id10 P, whenever there is a Edge_Match with id10 P, P is minimized.",
            "NL": "Whenever there is an Associated with id10 P or an Edge_Match with id10 P, it is preferable to minimize P with medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is an Associated with id10 P, whenever there is a Edge_Match with id10 P, P is minimized.",
            "NL": "It is preferable to minimize P when there is an Associated with id10 P or an Edge_Match with id10 P, with a medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is an Associated with id10 P, whenever there is a Edge_Match with id10 P, P is minimized.",
            "NL": "It is preferable to minimize P whenever there is an Associated with id10 P or an Edge_Match with id10 P, and this should be given medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is an Associated with id10 P, whenever there is a Edge_Match with id10 P, P is minimized.",
            "NL": "It is preferable that when there is an Associated with id10 P and an Edge_Match with id10 P, P is minimized with medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is an Associated with id10 P, whenever there is a Edge_Match with id10 P, P is minimized.",
            "NL": "It is preferable that whenever there is an Associated with id10 P or an Edge_Match with id10 P, P is minimized with medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is an Circuit with id9 R, R is minimized.",
            "NL": "It is preferred that Circuit ID9R be minimized with the lowest priority when present."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is an Circuit with id9 R, R is minimized.",
            "NL": "It is preferred that Circuit id9 R be minimized with the lowest priority whenever it is present."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is an Circuit with id9 R, R is minimized.",
            "NL": "It is preferred that Circuit id9 R be minimized with the least priority whenever present."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is an Circuit with id9 R, R is minimized.",
            "NL": "It is preferred that Circuit id9 R be minimized with the least amount of priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is an Circuit with id9 R, R is minimized.",
            "NL": "It is preferred that Circuit id9 R be minimized with the lowest priority when it is present."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is an Edge_Layer with node6 G, G is minimized.",
            "NL": "It is preferred that node6 G of the Edge_Layer be minimized with the lowest priority whenever possible."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is an Edge_Layer with node6 G, G is minimized.",
            "NL": "It is preferred that Edge_Layer with node6 G should be minimized as much as possible with the lowest priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is an Edge_Layer with node6 G, G is minimized.",
            "NL": "It is preferable to minimize the Edge_Layer with node6 G, assigning it the lowest priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is an Edge_Layer with node6 G, G is minimized.",
            "NL": "It is preferred that Edge_Layer with node6 G be minimized with the lowest priority whenever possible."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is an Edge_Layer with node6 G, G is minimized.",
            "NL": "It is preferred that node6 G in an Edge_Layer be minimized with the lowest priority whenever possible."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is an External_Group with node3 I, with node3 E, whenever there is a Spanning_Tree with node3 P, P is minimized.",
            "NL": "When there is an External_Group with node3 I, node3 E, and a Spanning_Tree with node3 P, it is preferable to minimize P with medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is an External_Group with node3 I, with node3 E, whenever there is a Spanning_Tree with node3 P, P is minimized.",
            "NL": "When there is an External_Group with node3 I and node3 E, it is preferable to have a Spanning_Tree with node3 P, and it is best to minimize P with medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is an External_Group with node3 I, with node3 E, whenever there is a Spanning_Tree with node3 P, P is minimized.",
            "NL": "When there is an External_Group with node3 I and node3 E, it is preferable to minimize the Spanning_Tree with node3 P, with medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is an External_Group with node3 I, with node3 E, whenever there is a Spanning_Tree with node3 P, P is minimized.",
            "NL": "When there is an External_Group with node3 I and node3 E, it is preferable to minimize node3 P in the Spanning_Tree with medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is an External_Group with node3 I, with node3 E, whenever there is a Spanning_Tree with node3 P, P is minimized.",
            "NL": "When there is an External_Group with node3 I and node3 E, it is preferable to minimize node3 P in a Spanning_Tree with medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is an InDegree with field10 T, whenever there is an In with field10 T, T is minimized.",
            "NL": "It is preferable that whenever there is an InDegree with field10 T, T is minimized, giving it medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is an InDegree with field10 T, whenever there is an In with field10 T, T is minimized.",
            "NL": "It is preferable to minimize T when there is an InDegree with field10 T and the priority is set to medium."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is an InDegree with field10 T, whenever there is an In with field10 T, T is minimized.",
            "NL": "It is preferable that whenever there is an InDegree with field10 T, the T is minimized with medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is an InDegree with field10 T, whenever there is an In with field10 T, T is minimized.",
            "NL": "It is preferable to minimize T when there is an In with field10 T and the priority is medium."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is an InDegree with field10 T, whenever there is an In with field10 T, T is minimized.",
            "NL": "It is best to minimize T whenever there is an InDegree with field10 T and it is of medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is an Initial with field5 P, P is minimized.",
            "NL": "It is preferred that when field5 P is present, it should be minimized with the least importance."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is an Initial with field5 P, P is minimized.",
            "NL": "It is preferred that when field5 P is present, it should be minimized with the least priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is an Initial with field5 P, P is minimized.",
            "NL": "It is preferred that field5 P be minimized with the least priority when present."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is an Initial with field5 P, P is minimized.",
            "NL": "It is preferred that when field5 P has an Initial, it should be given the least priority when minimizing."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is an Initial with field5 P, P is minimized.",
            "NL": "It is preferred that field5 P should be minimized with the lowest priority whenever it is initially present."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is an Matching with fourth node I, with third node H, whenever there is an Eulerian_Circuit with fourth node I, with third node H, with fourth id C, C is minimized.",
            "NL": "It is preferable, though not of utmost importance, that when there is a Matching between fourth node I and third node H, an Eulerian_Circuit between fourth node I and third node H with fourth id C is created with the C value being minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is an Matching with fourth node I, with third node H, whenever there is an Eulerian_Circuit with fourth node I, with third node H, with fourth id C, C is minimized.",
            "NL": "When a Matching is found between fourth node I and third node H, it is preferred to have an Eulerian_Circuit between them, with fourth id C, and to minimize the value of C."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is an Matching with fourth node I, with third node H, whenever there is an Eulerian_Circuit with fourth node I, with third node H, with fourth id C, C is minimized.",
            "NL": "It is preferable, though with moderate importance, to minimize the value of fourth id C when there is a Matching between fourth node I and third node H, and an Eulerian_Circuit is present between them."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is an Matching with fourth node I, with third node H, whenever there is an Eulerian_Circuit with fourth node I, with third node H, with fourth id C, C is minimized.",
            "NL": "It is preferred, with medium priority, that when a Matching exists between fourth node I and third node H, the corresponding Eulerian_Circuit has a minimal value for fourth id C."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is an Matching with fourth node I, with third node H, whenever there is an Eulerian_Circuit with fourth node I, with third node H, with fourth id C, C is minimized.",
            "NL": "Wherever there is a Matching between fourth node I and third node H, it is desirable (though not essential) to have an Eulerian_Circuit between the two nodes, with fourth id C, in which the value of C is minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is an NonActive with fifth point C, with second id E, whenever there is an Ordered with fifth point C, with second id E, with fourth node W, W is minimized.",
            "NL": "It is preferable, although with moderate priority, that when there is a NonActive between fifth point C and second id E, there should also be an Ordered between fifth point C and second id E with fourth node W, and the value of W should be minimized."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is an NonActive with fifth point C, with second id E, whenever there is an Ordered with fifth point C, with second id E, with fourth node W, W is minimized.",
            "NL": "It is preferable, albeit with medium priority, to minimize the value of fourth node W when there is an Ordered between fifth point C and second id E, given that there is a NonActive between them."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is an NonActive with fifth point C, with second id E, whenever there is an Ordered with fifth point C, with second id E, with fourth node W, W is minimized.",
            "NL": "It is desirable, though not essential, that when there is a NonActive between fifth point C and second id E, an Ordered with fourth node W is also present, with the lowest possible value for W."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is an NonActive with fifth point C, with second id E, whenever there is an Ordered with fifth point C, with second id E, with fourth node W, W is minimized.",
            "NL": "It is moderately important that when there is an inactive connection between fifth point C and second id E, an Ordered connection is established with fourth node W, and the value of W should be as low as possible."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is an NonActive with fifth point C, with second id E, whenever there is an Ordered with fifth point C, with second id E, with fourth node W, W is minimized.",
            "NL": "It is preferable, though of moderate importance, to have an Ordered with fourth node W between fifth point C and second id E when there is a NonActive, with the least possible value of W."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is an Order with node2 O, with node2 C, whenever there is an Undirected_Graph with node2 S, S is minimized.",
            "NL": "When there is an Order with node2 O and node2 C, it is preferable to minimize node2 S in an Undirected_Graph with medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is an Order with node2 O, with node2 C, whenever there is an Undirected_Graph with node2 S, S is minimized.",
            "NL": "When given an Order with node2 O and node2 C, it is desirable to minimize node2 S in an Undirected_Graph with medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is an Order with node2 O, with node2 C, whenever there is an Undirected_Graph with node2 S, S is minimized.",
            "NL": "When there is an Order with node2 O and node2 C, it is desirable to minimize node2 S in the Undirected_Graph with medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is an Order with node2 O, with node2 C, whenever there is an Undirected_Graph with node2 S, S is minimized.",
            "NL": "When there is an Order with node2 O and node2 C, it is preferable to minimize node2 S in the Undirected_Graph with medium priority."
        },
        {
            "Category": "Weak Constraint",
            "CNL": "It is preferred, with medium priority, that whenever there is an Order with node2 O, with node2 C, whenever there is an Undirected_Graph with node2 S, S is minimized.",
            "NL": "When there is an Order with node2 O and node2 C, it is preferable to minimize node2 S in an Undirected_Graph, with medium priority."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A node goes from 1 to 40. ",
            "NL": "Assume that there are forty nodes in a path."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A id goes from 1 to 20. ",
            "NL": "Assume that there are twenty ids in a graph."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A node goes from 1 to 30.",
            "NL": "Assume that there are thirty node in a graph."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A node goes from 1 to 30.",
            "NL": "Assume that there are number 30 nodes in a graph."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A node goes from 1 to 30.",
            "NL": "Let's assume that the graph contains exactly number 30 nodes."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A node goes from 1 to 30.",
            "NL": "We can presume that there is a total of number 30 nodes in the graph."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A node goes from 1 to 30.",
            "NL": "Considering the graph, there exists a fixed count of number 30 nodes."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A node goes from 1 to 30.",
            "NL": "It is safe to assume that the graph has precisely number 30 nodes."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A edge goes from 1 to 16.",
            "NL": "Assume that there are sixteen edges in a graph."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A edge goes from 1 to 16.",
            "NL": "Assume that there are number 16 edges in a graph."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A edge goes from 1 to 16.",
            "NL": "Let's assume that the graph contains exactly number 16 edges."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A edge goes from 1 to 16.",
            "NL": "We can presume that there is a total of number 16 edges in the graph."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A edge goes from 1 to 16.",
            "NL": "Considering the graph, there exists a fixed count of number 16 edges."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A edge goes from 1 to 16.",
            "NL": "It is safe to assume that the graph has precisely number 16 edges."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A vtx goes from 1 to 100.",
            "NL": "Assume that there are hundred vtxs in a graph."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A vtx goes from 1 to 100.",
            "NL": "Let's assume that the graph contains exactly number 100 vtxs."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A vtx goes from 1 to 100.",
            "NL": "Let's assume that the graph contains exactly number 100 vtxs."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A vtx goes from 1 to 100.",
            "NL": "Considering the graph, there exists a fixed count of number 100 vtxs."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A vtx goes from 1 to 100.",
            "NL": "We can presume that there is a total of number 100 vtxs in the graph."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A vtx goes from 1 to 100.",
            "NL": "It is safe to assume that the graph has precisely number 100 vtxs."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A node goes from 1 to 150.",
            "NL": "Assume that there are hundred-fifty nodes in a graph."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A node goes from 1 to 150.",
            "NL": "Let's assume that the graph contains exactly number 150 nodes."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A node goes from 1 to 150.",
            "NL": "Let's assume that the graph contains exactly number 150 nodes."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A node goes from 1 to 150.",
            "NL": "Considering the graph, there exists a fixed count of number 150 nodes."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A node goes from 1 to 150.",
            "NL": "We can presume that there is a total of number 150 nodes in the graph."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A node goes from 1 to 150.",
            "NL": "It is safe to assume that the graph has precisely number 150 nodes."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A field goes from 52 to 60.",
            "NL": "Assume that there are 52 to 60 field in a graph."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A field goes from 52 to 60.",
            "NL": "Consider the range of 52 to 60 fields in the graph."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A field goes from 52 to 60.",
            "NL": "The graph have a variation of 52 to 60 fields."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A field goes from 52 to 60.",
            "NL": "It is presumed that there exists a range of 52 to 60 fields in the graph."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A field goes from 52 to 60.",
            "NL": "Assume the graph falls within the bracket of 52 to 60 fields."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A field goes from 52 to 60.",
            "NL": "The graph is estimated to have a scope of 52 to 60 fields."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A vertex goes from 56 to 77.",
            "NL": "Assume that there are 56 to 77 vertex in a graph."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A vertex goes from 56 to 77.",
            "NL": "Consider the range of 56 to 77 vertex  in the graph."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A vertex goes from 56 to 77.",
            "NL": "The graph have a variation of 56 to 77 vertexs."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A vertex goes from 56 to 77.",
            "NL": "It is presumed that there exists a range of 56 to 77 vertexs  in the graph."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A vertex goes from 56 to 77.",
            "NL": "Assume the graph falls within the bracket of 56 to 77 vertex."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A vertex goes from 56 to 77.",
            "NL": "The graph is estimated to have a scope of 56 to 77 vertex."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A edge goes from 65 to 67.",
            "NL": "Assume that there are 65 to 67 edge in a graph."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A edge goes from 65 to 67.",
            "NL": "Consider the range of 65 to 67 edge  in the graph."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A edge goes from 65 to 67.",
            "NL": "The graph have a variation of 65 to 67 edge."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A edge goes from 65 to 67.",
            "NL": "It is presumed that there exists a range of 65 to 67 edge in the graph."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A edge goes from 65 to 67.",
            "NL": "Assume the graph falls within the bracket of 65 to 67 edge."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A edge goes from 65 to 67.",
            "NL": "The graph is estimated to have a scope of 65 to 67 edge."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A link goes from 11 to 95.",
            "NL": "Assume that there are 11 to 95 link in a graph."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A link goes from 11 to 95.",
            "NL": "Consider the range of 11 to 95 link in the graph."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A link goes from 11 to 95.",
            "NL": "The graph have a variation of 11 to 95 link."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A link goes from 11 to 95.",
            "NL": "It is presumed that there exists a range of 11 to 95 link in the graph."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A link goes from 11 to 95.",
            "NL": "Assume the graph falls within the bracket of 11 to 95 link."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A link goes from 11 to 95.",
            "NL": "The graph is estimated to have a scope of 11 to 95 link."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A value goes from 26 to 28.",
            "NL": "Assume that there are 26 to 28 value in a graph."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A value goes from 26 to 28.",
            "NL": "Consider the range of 26 to 28 value  in the graph."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A value goes from 26 to 28.",
            "NL": "The graph have a variation of 26 to 28 value."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A value goes from 26 to 28.",
            "NL": "It is presumed that there exists a range of 26 to 28 value in the graph."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A value goes from 26 to 28.",
            "NL": "Assume the graph falls within the bracket of 26 to 28 value."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A value goes from 26 to 28.",
            "NL": "The graph is estimated to have a scope of 26 to 28 value."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A edge goes from 41 to 61.",
            "NL": "Assume that there are 41 to 61 edge in a graph."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A edge goes from 41 to 61.",
            "NL": "Consider the range of 41 to 61 edge  in the graph."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A edge goes from 41 to 61.",
            "NL": "The graph have a variation of 41 to 61 edge."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A edge goes from 41 to 61.",
            "NL": "It is presumed that there exists a range of 41 to 61 edge in the graph."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A edge goes from 41 to 61.",
            "NL": "Assume the graph falls within the bracket of 41 to 61 edge."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A edge goes from 41 to 61.",
            "NL": "The graph is estimated to have a scope of 41 to 61 edge."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A value goes from 98 to 100.",
            "NL": "Assume that there are 98 to 100 value in a graph."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A value goes from 98 to 100.",
            "NL": "Consider the range of 98 to 100 value in the graph."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A value goes from 98 to 100.",
            "NL": "The graph have a variation of 98 to 100 value."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A value goes from 98 to 100.",
            "NL": "It is presumed that there exists a range of 98 to 100 value in the graph."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A value goes from 98 to 100.",
            "NL": "Assume the graph falls within the bracket of 98 to 100 value."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A value goes from 98 to 100.",
            "NL": "The graph is estimated to have a scope of 98 to 100 value."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A point goes from 25 to 64.",
            "NL": "Assume that there are 25 to 64 point in a graph."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A point goes from 25 to 64.",
            "NL": "Consider the range of 25 to 64 point in the graph."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A point goes from 25 to 64.",
            "NL": "The graph have a variation of 25 to 64 point."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A point goes from 25 to 64.",
            "NL": "It is presumed that there exists a range of 25 to 64 point in the graph."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A point goes from 25 to 64.",
            "NL": "Assume the graph falls within the bracket of 25 to 64 point."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A point goes from 25 to 64.",
            "NL": "The graph is estimated to have a scope of 25 to 64 point."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A key goes from 50 to 79.",
            "NL": "Assume that there are 50 to 79 key in a graph."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A key goes from 50 to 79.",
            "NL": "Consider the range of 50 to 79 key  in the graph."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A key goes from 50 to 79.",
            "NL": "The graph have a variation of 50 to 79 key."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A key goes from 50 to 79.",
            "NL": "It is presumed that there exists a range of 50 to 79 key in the graph."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A key goes from 50 to 79.",
            "NL": "Assume the graph falls within the bracket of 50 to 79 key."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A key goes from 50 to 79.",
            "NL": "The graph is estimated to have a scope of 50 to 79 key."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A value goes from 65 to 70.",
            "NL": "Assume that there are 65 to 70 value in a graph."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A value goes from 65 to 70.",
            "NL": "Consider the range of 65 to 70 value in the graph."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A value goes from 65 to 70.",
            "NL": "The graph have a variation of 65 to 70 value."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A value goes from 65 to 70.",
            "NL": "It is presumed that there exists a range of 65 to 70 value in the graph."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A value goes from 65 to 70.",
            "NL": "Assume the graph falls within the bracket of 65 to 70 value."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A value goes from 65 to 70.",
            "NL": "The graph is estimated to have a scope of 65 to 70 value."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A edge goes from 21 to 53.",
            "NL": "Assume that there are 21 to 53 edge in a graph."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A edge goes from 21 to 53.",
            "NL": "Consider the range of 21 to 53 edge in the graph."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A edge goes from 21 to 53.",
            "NL": "The graph have a variation of 21 to 53 edge."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A edge goes from 21 to 53.",
            "NL": "It is presumed that there exists a range of 21 to 53 edge in the graph."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A edge goes from 21 to 53.",
            "NL": "Assume the graph falls within the bracket of 21 to 53 edge."
        },
        {
            "Category": "Definition Const/Compound",
            "CNL": "A edge goes from 21 to 53.",
            "NL": "The graph is estimated to have a scope of 21 to 53 edge."
        }
    ],
    "version": 1.0
}